; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\parserInternals.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__A40A425D_stat@h DB 01H
__457DD326_basetsd@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__3A8479ED_parserinternals@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlCheckVersion
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_xmlParserInputRead
PUBLIC	_xmlParserInputGrow
PUBLIC	_xmlSubstituteEntitiesDefault
PUBLIC	_xmlKeepBlanksDefault
PUBLIC	_xmlPedanticParserDefault
PUBLIC	_xmlLineNumbersDefault
PUBLIC	_xmlNewParserCtxt
PUBLIC	_xmlInitParserCtxt
PUBLIC	_xmlClearParserCtxt
PUBLIC	_xmlFreeParserCtxt
PUBLIC	_xmlNewIOInputStream
PUBLIC	_xmlParserFindNodeInfo
PUBLIC	_xmlInitNodeInfoSeq
PUBLIC	_xmlClearNodeInfoSeq
PUBLIC	_xmlParserFindNodeInfoIndex
PUBLIC	_xmlParserAddNodeInfo
PUBLIC	_xmlIsLetter
PUBLIC	_xmlSwitchEncoding
PUBLIC	_xmlSwitchToEncoding
PUBLIC	_xmlSwitchInputEncoding
PUBLIC	___xmlErrEncoding
PUBLIC	_xmlNewStringInputStream
PUBLIC	_xmlNewEntityInputStream
PUBLIC	_xmlFreeInputStream
PUBLIC	_xmlNewInputFromFile
PUBLIC	_xmlNewInputStream
PUBLIC	_xmlStringCurrentChar
PUBLIC	_xmlCurrentChar
PUBLIC	_xmlCopyCharMultiByte
PUBLIC	_xmlCopyChar
PUBLIC	_xmlNextChar
PUBLIC	_xmlParserInputShrink
PUBLIC	_xmlErrMemory
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0DL@NPLHMNMP@Fatal?3?5program?5compiled?5against@ ; `string'
PUBLIC	??_C@_0DM@MEIIIPCN@Warning?3?5program?5compiled?5again@ ; `string'
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ ; `string'
PUBLIC	??_C@_0CA@FAKJAFPJ@Parser?5input?5data?5memory?5error?6@ ; `string'
PUBLIC	??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@ ; `string'
PUBLIC	??_C@_0DA@ICAIJAPJ@Input?5is?5not?5proper?5UTF?98?0?5indi@ ; `string'
PUBLIC	??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@ ; `string'
PUBLIC	??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@ ; `string'
PUBLIC	??_C@_0BP@OHGFBCJB@Char?50x0?5out?5of?5allowed?5range?6@ ; `string'
PUBLIC	??_C@_0DI@DIALIMHD@Internal?5error?0?5xmlCopyCharMult@ ; `string'
PUBLIC	??_C@_0BC@NFNLFCFA@encoding?5unknown?6@		; `string'
PUBLIC	??_C@_0BD@IJIIAAMB@USC4?5little?5endian@	; `string'
PUBLIC	??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BA@ELDAKMNC@USC4?5big?5endian@		; `string'
PUBLIC	??_C@_06JJAKJGEC@EBCDIC@			; `string'
PUBLIC	??_C@_09GAABMJEL@UCS4?52143@			; `string'
PUBLIC	??_C@_09HFGPODGD@UCS4?53412@			; `string'
PUBLIC	??_C@_04MDAFHLBC@UCS2@				; `string'
PUBLIC	??_C@_0M@LMIFKILO@ISO?92022?9JP@		; `string'
PUBLIC	??_C@_09LOKLFMHN@Shift_JIS@			; `string'
PUBLIC	??_C@_06KCFOODCD@EUC?9JP@			; `string'
PUBLIC	??_C@_08NBDJLNFA@UTF?916LE@			; `string'
PUBLIC	??_C@_06KNDPGIKI@UTF?916@			; `string'
PUBLIC	??_C@_08NLKHJAFK@UTF?916BE@			; `string'
PUBLIC	??_C@_05EGJIMALK@UTF?98@			; `string'
PUBLIC	??_C@_0CD@JHGPNEDB@switching?5encoding?3?5encoder?5err@ ; `string'
PUBLIC	??_C@_0BP@PLPBPMGM@switching?5encoding?5?3?5no?5input?6@ ; `string'
PUBLIC	??_C@_0CA@IBCMCMEC@xmlSwitchToEncoding?5?3?5no?5input?6@ ; `string'
PUBLIC	??_C@_0CG@CPFGJCJF@couldn?8t?5allocate?5a?5new?5input?5s@ ; `string'
PUBLIC	??_C@_0BE@PIBHFBFO@new?5input?5from?5I?1O?6@	; `string'
PUBLIC	??_C@_0CH@MELJCKLM@xmlNewEntityInputStream?5entity?5@ ; `string'
PUBLIC	??_C@_0BL@NEFEMIEI@new?5input?5from?5entity?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BI@JKMDPIMC@Cannot?5parse?5entity?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CG@GPBALEIB@Internal?5entity?5?$CFs?5without?5cont@ ; `string'
PUBLIC	??_C@_0DA@IHKPCFAE@Internal?5parameter?5entity?5?$CFs?5wi@ ; `string'
PUBLIC	??_C@_0CI@JMHJJLAK@Predefined?5entity?5?$CFs?5without?5co@ ; `string'
PUBLIC	??_C@_0CH@LBBEPMHA@xmlNewStringInputStream?5string?5@ ; `string'
PUBLIC	??_C@_0BI@JLKHFHIO@new?5fixed?5input?3?5?$CF?430s?6@ ; `string'
PUBLIC	??_C@_0BJ@HHNDNGAE@new?5input?5from?5file?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DA@OFJNACAP@failed?5to?5load?5external?5entity?3@ ; `string'
PUBLIC	??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@ ; `string'
PUBLIC	??_C@_0BJ@CKGPPCDK@Got?5NULL?5parser?5context?6@ ; `string'
PUBLIC	??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@ ; `string'
PUBLIC	??_C@_0CA@PHAEKKDI@cannot?5allocate?5parser?5context?6@ ; `string'
PUBLIC	??_C@_0BL@OCEPNLLN@failed?5to?5allocate?5buffer?6@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	___xmlLoaderErr:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufEnd:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlBufShrink:PROC
EXTRN	_xmlDictCreate:PROC
EXTRN	_xmlDictSetLimit:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashDefaultDeallocator:PROC
EXTRN	_xmlParserValidityError:PROC
EXTRN	_xmlParserValidityWarning:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlGetCharEncodingHandler:PROC
EXTRN	_xmlCharEncCloseFunc:PROC
EXTRN	_xmlParserInputBufferCreateFilename:PROC
EXTRN	_xmlParserInputBufferRead:PROC
EXTRN	_xmlParserInputBufferGrow:PROC
EXTRN	_xmlFreeParserInputBuffer:PROC
EXTRN	_xmlParserGetDirectory:PROC
EXTRN	_xmlCheckHTTPInput:PROC
EXTRN	_xmlInitParser:PROC
EXTRN	_xmlStopParser:PROC
EXTRN	_xmlLoadExternalEntity:PROC
EXTRN	_xmlCtxtReset:PROC
EXTRN	_xmlSAX2IgnorableWhitespace:PROC
EXTRN	_xmlSAXVersion:PROC
EXTRN	_xmlDefaultSAXHandlerInit:PROC
EXTRN	___xmlDefaultSAXHandler:PROC
EXTRN	___xmlDoValidityCheckingDefaultValue:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	___xmlGetWarningsDefaultValue:PROC
EXTRN	___xmlIndentTreeOutput:PROC
EXTRN	___xmlKeepBlanksDefaultValue:PROC
EXTRN	___xmlLineNumbersDefaultValue:PROC
EXTRN	___xmlLoadExtDtdDefaultValue:PROC
EXTRN	___xmlParserDebugEntities:PROC
EXTRN	___xmlPedanticParserDefaultValue:PROC
EXTRN	___xmlSubstituteEntitiesDefaultValue:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_inputPop:PROC
EXTRN	_xmlCanonicPath:PROC
EXTRN	_xmlCatalogFreeLocal:PROC
EXTRN	_xmlBufCreate:PROC
EXTRN	_xmlBufIsEmpty:PROC
EXTRN	_xmlBufResetInput:PROC
EXTRN	_xmlCharEncFirstLineInput:PROC
EXTRN	_xmlCharEncInput:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BL@OCEPNLLN@failed?5to?5allocate?5buffer?6@
CONST	SEGMENT
??_C@_0BL@OCEPNLLN@failed?5to?5allocate?5buffer?6@ DB 'failed to allocate'
	DB	' buffer', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PHAEKKDI@cannot?5allocate?5parser?5context?6@
CONST	SEGMENT
??_C@_0CA@PHAEKKDI@cannot?5allocate?5parser?5context?6@ DB 'cannot alloca'
	DB	'te parser context', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
CONST	SEGMENT
??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@ DB 'cannot initial'
	DB	'ize parser context', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CKGPPCDK@Got?5NULL?5parser?5context?6@
CONST	SEGMENT
??_C@_0BJ@CKGPPCDK@Got?5NULL?5parser?5context?6@ DB 'Got NULL parser cont'
	DB	'ext', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@
CONST	SEGMENT
??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@ DB 'failed to lo'
	DB	'ad external entity "%s"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OFJNACAP@failed?5to?5load?5external?5entity?3@
CONST	SEGMENT
??_C@_0DA@OFJNACAP@failed?5to?5load?5external?5entity?3@ DB 'failed to lo'
	DB	'ad external entity: NULL filename ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HHNDNGAE@new?5input?5from?5file?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@HHNDNGAE@new?5input?5from?5file?3?5?$CFs?6@ DB 'new input from '
	DB	'file: %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JLKHFHIO@new?5fixed?5input?3?5?$CF?430s?6@
CONST	SEGMENT
??_C@_0BI@JLKHFHIO@new?5fixed?5input?3?5?$CF?430s?6@ DB 'new fixed input:'
	DB	' %.30s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LBBEPMHA@xmlNewStringInputStream?5string?5@
CONST	SEGMENT
??_C@_0CH@LBBEPMHA@xmlNewStringInputStream?5string?5@ DB 'xmlNewStringInp'
	DB	'utStream string = NULL', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JMHJJLAK@Predefined?5entity?5?$CFs?5without?5co@
CONST	SEGMENT
??_C@_0CI@JMHJJLAK@Predefined?5entity?5?$CFs?5without?5co@ DB 'Predefined'
	DB	' entity %s without content !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@IHKPCFAE@Internal?5parameter?5entity?5?$CFs?5wi@
CONST	SEGMENT
??_C@_0DA@IHKPCFAE@Internal?5parameter?5entity?5?$CFs?5wi@ DB 'Internal p'
	DB	'arameter entity %s without content !', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GPBALEIB@Internal?5entity?5?$CFs?5without?5cont@
CONST	SEGMENT
??_C@_0CG@GPBALEIB@Internal?5entity?5?$CFs?5without?5cont@ DB 'Internal e'
	DB	'ntity %s without content !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JKMDPIMC@Cannot?5parse?5entity?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@JKMDPIMC@Cannot?5parse?5entity?5?$CFs?6@ DB 'Cannot parse entit'
	DB	'y %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NEFEMIEI@new?5input?5from?5entity?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@NEFEMIEI@new?5input?5from?5entity?3?5?$CFs?6@ DB 'new input fro'
	DB	'm entity: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MELJCKLM@xmlNewEntityInputStream?5entity?5@
CONST	SEGMENT
??_C@_0CH@MELJCKLM@xmlNewEntityInputStream?5entity?5@ DB 'xmlNewEntityInp'
	DB	'utStream entity = NULL', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PIBHFBFO@new?5input?5from?5I?1O?6@
CONST	SEGMENT
??_C@_0BE@PIBHFBFO@new?5input?5from?5I?1O?6@ DB 'new input from I/O', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CPFGJCJF@couldn?8t?5allocate?5a?5new?5input?5s@
CONST	SEGMENT
??_C@_0CG@CPFGJCJF@couldn?8t?5allocate?5a?5new?5input?5s@ DB 'couldn''t a'
	DB	'llocate a new input stream', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IBCMCMEC@xmlSwitchToEncoding?5?3?5no?5input?6@
CONST	SEGMENT
??_C@_0CA@IBCMCMEC@xmlSwitchToEncoding?5?3?5no?5input?6@ DB 'xmlSwitchToE'
	DB	'ncoding : no input', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PLPBPMGM@switching?5encoding?5?3?5no?5input?6@
CONST	SEGMENT
??_C@_0BP@PLPBPMGM@switching?5encoding?5?3?5no?5input?6@ DB 'switching en'
	DB	'coding : no input', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JHGPNEDB@switching?5encoding?3?5encoder?5err@
CONST	SEGMENT
??_C@_0CD@JHGPNEDB@switching?5encoding?3?5encoder?5err@ DB 'switching enc'
	DB	'oding: encoder error', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EGJIMALK@UTF?98@
CONST	SEGMENT
??_C@_05EGJIMALK@UTF?98@ DB 'UTF-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLKHJAFK@UTF?916BE@
CONST	SEGMENT
??_C@_08NLKHJAFK@UTF?916BE@ DB 'UTF-16BE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KNDPGIKI@UTF?916@
CONST	SEGMENT
??_C@_06KNDPGIKI@UTF?916@ DB 'UTF-16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NBDJLNFA@UTF?916LE@
CONST	SEGMENT
??_C@_08NBDJLNFA@UTF?916LE@ DB 'UTF-16LE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KCFOODCD@EUC?9JP@
CONST	SEGMENT
??_C@_06KCFOODCD@EUC?9JP@ DB 'EUC-JP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LOKLFMHN@Shift_JIS@
CONST	SEGMENT
??_C@_09LOKLFMHN@Shift_JIS@ DB 'Shift_JIS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMIFKILO@ISO?92022?9JP@
CONST	SEGMENT
??_C@_0M@LMIFKILO@ISO?92022?9JP@ DB 'ISO-2022-JP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MDAFHLBC@UCS2@
CONST	SEGMENT
??_C@_04MDAFHLBC@UCS2@ DB 'UCS2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HFGPODGD@UCS4?53412@
CONST	SEGMENT
??_C@_09HFGPODGD@UCS4?53412@ DB 'UCS4 3412', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GAABMJEL@UCS4?52143@
CONST	SEGMENT
??_C@_09GAABMJEL@UCS4?52143@ DB 'UCS4 2143', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJAKJGEC@EBCDIC@
CONST	SEGMENT
??_C@_06JJAKJGEC@EBCDIC@ DB 'EBCDIC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELDAKMNC@USC4?5big?5endian@
CONST	SEGMENT
??_C@_0BA@ELDAKMNC@USC4?5big?5endian@ DB 'USC4 big endian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@ DB 'encoding not su'
	DB	'pported %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IJIIAAMB@USC4?5little?5endian@
CONST	SEGMENT
??_C@_0BD@IJIIAAMB@USC4?5little?5endian@ DB 'USC4 little endian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NFNLFCFA@encoding?5unknown?6@
CONST	SEGMENT
??_C@_0BC@NFNLFCFA@encoding?5unknown?6@ DB 'encoding unknown', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DIALIMHD@Internal?5error?0?5xmlCopyCharMult@
CONST	SEGMENT
??_C@_0DI@DIALIMHD@Internal?5error?0?5xmlCopyCharMult@ DB 'Internal error'
	DB	', xmlCopyCharMultiByte 0x%X out of bound', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OHGFBCJB@Char?50x0?5out?5of?5allowed?5range?6@
CONST	SEGMENT
??_C@_0BP@OHGFBCJB@Char?50x0?5out?5of?5allowed?5range?6@ DB 'Char 0x0 out'
	DB	' of allowed range', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
CONST	SEGMENT
??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@ DB 'Input is no'
	DB	't proper UTF-8, indicate encoding !', 0aH, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
CONST	SEGMENT
??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@ DB 'B'
	DB	'ytes: 0x%02X 0x%02X 0x%02X 0x%02X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@ICAIJAPJ@Input?5is?5not?5proper?5UTF?98?0?5indi@
CONST	SEGMENT
??_C@_0DA@ICAIJAPJ@Input?5is?5not?5proper?5UTF?98?0?5indi@ DB 'Input is n'
	DB	'ot proper UTF-8, indicate encoding !', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@
CONST	SEGMENT
??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@ DB 'Char 0x%'
	DB	'X out of allowed range', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FAKJAFPJ@Parser?5input?5data?5memory?5error?6@
CONST	SEGMENT
??_C@_0CA@FAKJAFPJ@Parser?5input?5data?5memory?5error?6@ DB 'Parser input'
	DB	' data memory error', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
CONST	SEGMENT
??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ DB 'Memory allocation fa'
	DB	'iled', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@MEIIIPCN@Warning?3?5program?5compiled?5again@
CONST	SEGMENT
??_C@_0DM@MEIIIPCN@Warning?3?5program?5compiled?5again@ DB 'Warning: prog'
	DB	'ram compiled against libxml %d using older %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@NPLHMNMP@Fatal?3?5program?5compiled?5against@
CONST	SEGMENT
??_C@_0DL@NPLHMNMP@Fatal?3?5program?5compiled?5against@ DB 'Fatal: progra'
	DB	'm compiled against libxml %d using libxml %d', 0aH, 00H ; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSwitchInputEncodingInt
_TEXT	SEGMENT
tv172 = -92						; size = 4
tv391 = -88						; size = 4
tv386 = -82						; size = 1
tv379 = -81						; size = 1
tv374 = -80						; size = 4
tv376 = -76						; size = 4
tv151 = -72						; size = 4
tv362 = -68						; size = 4
tv357 = -62						; size = 1
tv350 = -61						; size = 1
tv345 = -60						; size = 4
tv347 = -56						; size = 4
tv130 = -52						; size = 4
tv333 = -48						; size = 4
tv328 = -42						; size = 1
tv321 = -41						; size = 1
tv316 = -40						; size = 4
tv318 = -36						; size = 4
tv92 = -32						; size = 4
tv311 = -28						; size = 4
tv306 = -22						; size = 1
tv299 = -21						; size = 1
tv294 = -20						; size = 4
tv296 = -16						; size = 4
_use$1 = -12						; size = 4
_processed$2 = -8					; size = 4
_nbchars$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_input$ = 12						; size = 4
_handler$ = 16						; size = 4
_len$ = 20						; size = 4
_xmlSwitchInputEncodingInt PROC				; COMDAT

; 1131 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-92]
	mov	ecx, 23					; 00000017H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1132 :     int nbchars;
; 1133 : 
; 1134 :     if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN2@xmlSwitchI

; 1135 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlSwitchI
$LN2@xmlSwitchI:

; 1136 :     if (input == NULL)

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN3@xmlSwitchI

; 1137 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlSwitchI
$LN3@xmlSwitchI:

; 1138 :     if (input->buf != NULL) {

	mov	eax, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN4@xmlSwitchI

; 1139 :         if (input->buf->encoder != NULL) {

	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN6@xmlSwitchI

; 1140 :             /*
; 1141 :              * Check in case the auto encoding detetection triggered
; 1142 :              * in already.
; 1143 :              */
; 1144 :             if (input->buf->encoder == handler)

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _handler$[ebp]
	jne	SHORT $LN7@xmlSwitchI

; 1145 :                 return (0);

	xor	eax, eax
	jmp	$LN1@xmlSwitchI
$LN7@xmlSwitchI:

; 1146 : 
; 1147 :             /*
; 1148 :              * "UTF-16" can be used for both LE and BE
; 1149 :              if ((!xmlStrncmp(BAD_CAST input->buf->encoder->name,
; 1150 :              BAD_CAST "UTF-16", 6)) &&
; 1151 :              (!xmlStrncmp(BAD_CAST handler->name,
; 1152 :              BAD_CAST "UTF-16", 6))) {
; 1153 :              return(0);
; 1154 :              }
; 1155 :              */
; 1156 : 
; 1157 :             /*
; 1158 :              * Note: this is a bit dangerous, but that's what it
; 1159 :              * takes to use nearly compatible signature for different
; 1160 :              * encodings.
; 1161 :              */
; 1162 :             xmlCharEncCloseFunc(input->buf->encoder);

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_xmlCharEncCloseFunc
	add	esp, 4

; 1163 :             input->buf->encoder = handler;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _handler$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1164 :             return (0);

	xor	eax, eax
	jmp	$LN1@xmlSwitchI
$LN6@xmlSwitchI:

; 1165 :         }
; 1166 :         input->buf->encoder = handler;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _handler$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1167 : 
; 1168 :         /*
; 1169 :          * Is there already some content down the pipe to convert ?
; 1170 :          */
; 1171 :         if (xmlBufIsEmpty(input->buf->buffer) == 0) {

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufIsEmpty
	add	esp, 4
	test	eax, eax
	jne	$LN8@xmlSwitchI

; 1172 :             int processed;
; 1173 : 	    unsigned int use;
; 1174 : 
; 1175 :             /*
; 1176 :              * Specific handling of the Byte Order Mark for
; 1177 :              * UTF-16
; 1178 :              */
; 1179 :             if ((handler->name != NULL) &&
; 1180 :                 (!strcmp(handler->name, "UTF-16LE") ||
; 1181 :                  !strcmp(handler->name, "UTF-16")) &&
; 1182 :                 (input->cur[0] == 0xFF) && (input->cur[1] == 0xFE)) {

	mov	eax, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN9@xmlSwitchI
	mov	DWORD PTR tv296[ebp], OFFSET ??_C@_08NBDJLNFA@UTF?916LE@
	mov	ecx, DWORD PTR _handler$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv294[ebp], edx
$LL18@xmlSwitchI:
	mov	eax, DWORD PTR tv294[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv299[ebp], cl
	mov	edx, DWORD PTR tv296[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN19@xmlSwitchI
	cmp	BYTE PTR tv299[ebp], 0
	je	SHORT $LN20@xmlSwitchI
	mov	eax, DWORD PTR tv294[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv306[ebp], cl
	mov	edx, DWORD PTR tv296[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN19@xmlSwitchI
	add	DWORD PTR tv294[ebp], 2
	add	DWORD PTR tv296[ebp], 2
	cmp	BYTE PTR tv306[ebp], 0
	jne	SHORT $LL18@xmlSwitchI
$LN20@xmlSwitchI:
	mov	DWORD PTR tv311[ebp], 0
	jmp	SHORT $LN21@xmlSwitchI
$LN19@xmlSwitchI:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv311[ebp], eax
$LN21@xmlSwitchI:
	mov	ecx, DWORD PTR tv311[ebp]
	mov	DWORD PTR tv92[ebp], ecx
	cmp	DWORD PTR tv92[ebp], 0
	je	SHORT $LN10@xmlSwitchI
	mov	DWORD PTR tv318[ebp], OFFSET ??_C@_06KNDPGIKI@UTF?916@
	mov	edx, DWORD PTR _handler$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv316[ebp], eax
$LL22@xmlSwitchI:
	mov	ecx, DWORD PTR tv316[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv321[ebp], dl
	mov	eax, DWORD PTR tv318[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN23@xmlSwitchI
	cmp	BYTE PTR tv321[ebp], 0
	je	SHORT $LN24@xmlSwitchI
	mov	ecx, DWORD PTR tv316[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv328[ebp], dl
	mov	eax, DWORD PTR tv318[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN23@xmlSwitchI
	add	DWORD PTR tv316[ebp], 2
	add	DWORD PTR tv318[ebp], 2
	cmp	BYTE PTR tv328[ebp], 0
	jne	SHORT $LL22@xmlSwitchI
$LN24@xmlSwitchI:
	mov	DWORD PTR tv333[ebp], 0
	jmp	SHORT $LN25@xmlSwitchI
$LN23@xmlSwitchI:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv333[ebp], ecx
$LN25@xmlSwitchI:
	mov	edx, DWORD PTR tv333[ebp]
	mov	DWORD PTR tv130[ebp], edx
	cmp	DWORD PTR tv130[ebp], 0
	jne	SHORT $LN9@xmlSwitchI
$LN10@xmlSwitchI:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $LN9@xmlSwitchI
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 254				; 000000feH
	jne	SHORT $LN9@xmlSwitchI

; 1183 :                 input->cur += 2;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 2
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN9@xmlSwitchI:

; 1184 :             }
; 1185 :             if ((handler->name != NULL) &&
; 1186 :                 (!strcmp(handler->name, "UTF-16BE")) &&
; 1187 :                 (input->cur[0] == 0xFE) && (input->cur[1] == 0xFF)) {

	mov	eax, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN11@xmlSwitchI
	mov	DWORD PTR tv347[ebp], OFFSET ??_C@_08NLKHJAFK@UTF?916BE@
	mov	ecx, DWORD PTR _handler$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv345[ebp], edx
$LL26@xmlSwitchI:
	mov	eax, DWORD PTR tv345[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv350[ebp], cl
	mov	edx, DWORD PTR tv347[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN27@xmlSwitchI
	cmp	BYTE PTR tv350[ebp], 0
	je	SHORT $LN28@xmlSwitchI
	mov	eax, DWORD PTR tv345[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv357[ebp], cl
	mov	edx, DWORD PTR tv347[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN27@xmlSwitchI
	add	DWORD PTR tv345[ebp], 2
	add	DWORD PTR tv347[ebp], 2
	cmp	BYTE PTR tv357[ebp], 0
	jne	SHORT $LL26@xmlSwitchI
$LN28@xmlSwitchI:
	mov	DWORD PTR tv362[ebp], 0
	jmp	SHORT $LN29@xmlSwitchI
$LN27@xmlSwitchI:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv362[ebp], eax
$LN29@xmlSwitchI:
	mov	ecx, DWORD PTR tv362[ebp]
	mov	DWORD PTR tv151[ebp], ecx
	cmp	DWORD PTR tv151[ebp], 0
	jne	SHORT $LN11@xmlSwitchI
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	eax, 254				; 000000feH
	jne	SHORT $LN11@xmlSwitchI
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $LN11@xmlSwitchI

; 1188 :                 input->cur += 2;

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 2
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN11@xmlSwitchI:

; 1189 :             }
; 1190 :             /*
; 1191 :              * Errata on XML-1.0 June 20 2001
; 1192 :              * Specific handling of the Byte Order Mark for
; 1193 :              * UTF-8
; 1194 :              */
; 1195 :             if ((handler->name != NULL) &&
; 1196 :                 (!strcmp(handler->name, "UTF-8")) &&
; 1197 :                 (input->cur[0] == 0xEF) &&
; 1198 :                 (input->cur[1] == 0xBB) && (input->cur[2] == 0xBF)) {

	mov	edx, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN12@xmlSwitchI
	mov	DWORD PTR tv376[ebp], OFFSET ??_C@_05EGJIMALK@UTF?98@
	mov	eax, DWORD PTR _handler$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv374[ebp], ecx
$LL30@xmlSwitchI:
	mov	edx, DWORD PTR tv374[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv379[ebp], al
	mov	ecx, DWORD PTR tv376[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN31@xmlSwitchI
	cmp	BYTE PTR tv379[ebp], 0
	je	SHORT $LN32@xmlSwitchI
	mov	edx, DWORD PTR tv374[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv386[ebp], al
	mov	ecx, DWORD PTR tv376[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN31@xmlSwitchI
	add	DWORD PTR tv374[ebp], 2
	add	DWORD PTR tv376[ebp], 2
	cmp	BYTE PTR tv386[ebp], 0
	jne	SHORT $LL30@xmlSwitchI
$LN32@xmlSwitchI:
	mov	DWORD PTR tv391[ebp], 0
	jmp	SHORT $LN33@xmlSwitchI
$LN31@xmlSwitchI:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv391[ebp], edx
$LN33@xmlSwitchI:
	mov	eax, DWORD PTR tv391[ebp]
	mov	DWORD PTR tv172[ebp], eax
	cmp	DWORD PTR tv172[ebp], 0
	jne	SHORT $LN12@xmlSwitchI
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 239				; 000000efH
	jne	SHORT $LN12@xmlSwitchI
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	eax, 187				; 000000bbH
	jne	SHORT $LN12@xmlSwitchI
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 191				; 000000bfH
	jne	SHORT $LN12@xmlSwitchI

; 1199 :                 input->cur += 3;

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 3
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN12@xmlSwitchI:

; 1200 :             }
; 1201 : 
; 1202 :             /*
; 1203 :              * Shrink the current input buffer.
; 1204 :              * Move it as the raw buffer and create a new input buffer
; 1205 :              */
; 1206 :             processed = input->cur - input->base;

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _processed$2[ebp], ecx

; 1207 :             xmlBufShrink(input->buf->buffer, processed);

	mov	edx, DWORD PTR _processed$2[ebp]
	push	edx
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufShrink
	add	esp, 8

; 1208 :             input->buf->raw = input->buf->buffer;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+20], ecx

; 1209 :             input->buf->buffer = xmlBufCreate();

	call	_xmlBufCreate
	mov	edx, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+16], eax

; 1210 : 	    input->buf->rawconsumed = processed;

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _processed$2[ebp]
	mov	DWORD PTR [eax+32], ecx

; 1211 : 	    use = xmlBufUse(input->buf->raw);

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_xmlBufUse
	add	esp, 4
	mov	DWORD PTR _use$1[ebp], eax

; 1212 : 
; 1213 :             if (ctxt->html) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN13@xmlSwitchI

; 1214 :                 /*
; 1215 :                  * convert as much as possible of the buffer
; 1216 :                  */
; 1217 :                 nbchars = xmlCharEncInput(input->buf, 1);

	push	1
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlCharEncInput
	add	esp, 8
	mov	DWORD PTR _nbchars$[ebp], eax

; 1218 :             } else {

	jmp	SHORT $LN14@xmlSwitchI
$LN13@xmlSwitchI:

; 1219 :                 /*
; 1220 :                  * convert just enough to get
; 1221 :                  * '<?xml version="1.0" encoding="xxx"?>'
; 1222 :                  * parsed with the autodetected encoding
; 1223 :                  * into the parser reading buffer.
; 1224 :                  */
; 1225 :                 nbchars = xmlCharEncFirstLineInput(input->buf, len);

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlCharEncFirstLineInput
	add	esp, 8
	mov	DWORD PTR _nbchars$[ebp], eax
$LN14@xmlSwitchI:

; 1226 :             }
; 1227 :             xmlBufResetInput(input->buf->buffer, input);

	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufResetInput
	add	esp, 8

; 1228 :             if (nbchars < 0) {

	cmp	DWORD PTR _nbchars$[ebp], 0
	jge	SHORT $LN15@xmlSwitchI

; 1229 :                 xmlErrInternal(ctxt,

	push	0
	push	OFFSET ??_C@_0CD@JHGPNEDB@switching?5encoding?3?5encoder?5err@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1230 :                                "switching encoding: encoder error\n",
; 1231 :                                NULL);
; 1232 :                 return (-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSwitchI
$LN15@xmlSwitchI:

; 1233 :             }
; 1234 : 	    input->buf->rawconsumed += use - xmlBufUse(input->buf->raw);

	mov	ecx, DWORD PTR _input$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_xmlBufUse
	add	esp, 4
	mov	edx, DWORD PTR _use$1[ebp]
	sub	edx, eax
	add	edx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+32], edx
$LN8@xmlSwitchI:

; 1235 :         }
; 1236 :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSwitchI
	jmp	SHORT $LN5@xmlSwitchI
$LN4@xmlSwitchI:

; 1237 :     } else if (input->length == 0) {

	mov	edx, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN5@xmlSwitchI

; 1238 : 	/*
; 1239 : 	 * When parsing a static memory array one must know the
; 1240 : 	 * size to be able to convert the buffer.
; 1241 : 	 */
; 1242 : 	xmlErrInternal(ctxt, "switching encoding : no input\n", NULL);

	push	0
	push	OFFSET ??_C@_0BP@PLPBPMGM@switching?5encoding?5?3?5no?5input?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1243 :         /*
; 1244 :          * Callers assume that the input buffer takes ownership of the
; 1245 :          * encoding handler. xmlCharEncCloseFunc frees unregistered
; 1246 :          * handlers and avoids a memory leak.
; 1247 :          */
; 1248 :         xmlCharEncCloseFunc(handler);

	mov	ecx, DWORD PTR _handler$[ebp]
	push	ecx
	call	_xmlCharEncCloseFunc
	add	esp, 4

; 1249 : 	return (-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSwitchI
$LN5@xmlSwitchI:

; 1250 :     }
; 1251 :     /*
; 1252 :      * We should actually raise an error here, see issue #34.
; 1253 :      */
; 1254 :     xmlCharEncCloseFunc(handler);

	mov	edx, DWORD PTR _handler$[ebp]
	push	edx
	call	_xmlCharEncCloseFunc
	add	esp, 4

; 1255 :     return (0);

	xor	eax, eax
$LN1@xmlSwitchI:

; 1256 : }

	pop	edi
	pop	esi
	add	esp, 92					; 0000005cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSwitchInputEncodingInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSwitchToEncodingInt
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_handler$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlSwitchToEncodingInt PROC				; COMDAT

; 1290 :                        xmlCharEncodingHandlerPtr handler, int len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1291 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1292 : 
; 1293 :     if (handler != NULL) {

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN2@xmlSwitchT

; 1294 :         if (ctxt->input != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN4@xmlSwitchT

; 1295 : 	    ret = xmlSwitchInputEncodingInt(ctxt, ctxt->input, handler, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handler$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSwitchInputEncodingInt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 1296 : 	} else {

	jmp	SHORT $LN5@xmlSwitchT
$LN4@xmlSwitchT:

; 1297 : 	    xmlErrInternal(ctxt, "xmlSwitchToEncoding : no input\n",

	push	0
	push	OFFSET ??_C@_0CA@IBCMCMEC@xmlSwitchToEncoding?5?3?5no?5input?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1298 : 	                   NULL);
; 1299 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSwitchT
$LN5@xmlSwitchT:

; 1300 : 	}
; 1301 : 	/*
; 1302 : 	 * The parsing is now done in UTF8 natively
; 1303 : 	 */
; 1304 : 	ctxt->charset = XML_CHAR_ENCODING_UTF8;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+256], 1

; 1305 :     } else

	jmp	SHORT $LN3@xmlSwitchT
$LN2@xmlSwitchT:

; 1306 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSwitchT
$LN3@xmlSwitchT:

; 1307 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSwitchT:

; 1308 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSwitchToEncodingInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlErrEncodingInt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_val$ = 20						; size = 4
_xmlErrEncodingInt PROC					; COMDAT

; 203  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 204  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlErrEnco
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlErrEnco
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlErrEnco

; 205  :         (ctxt->instate == XML_PARSER_EOF))
; 206  : 	return;

	jmp	SHORT $LN1@xmlErrEnco
$LN2@xmlErrEnco:

; 207  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlErrEnco

; 208  :         ctxt->errNo = error;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [edx+84], eax
$LN3@xmlErrEnco:

; 209  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _error$[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 210  :                     ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
; 211  :                     NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
; 212  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN1@xmlErrEnco

; 213  :         ctxt->wellFormed = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+12], 0

; 214  :         if (ctxt->recovery == 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+288], 0
	jne	SHORT $LN1@xmlErrEnco

; 215  :             ctxt->disableSAX = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+212], 1
$LN1@xmlErrEnco:

; 216  :     }
; 217  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlErrEncodingInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlErrInternal
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_msg$ = 12						; size = 4
_str$ = 16						; size = 4
_xmlErrInternal PROC					; COMDAT

; 174  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 175  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlErrInte
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlErrInte
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlErrInte

; 176  :         (ctxt->instate == XML_PARSER_EOF))
; 177  : 	return;

	jmp	SHORT $LN1@xmlErrInte
$LN2@xmlErrInte:

; 178  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlErrInte

; 179  :         ctxt->errNo = XML_ERR_INTERNAL_ERROR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+84], 1
$LN3@xmlErrInte:

; 180  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	push	0
	push	0
	push	3
	push	1
	push	1
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 181  :                     ctxt, NULL, XML_FROM_PARSER, XML_ERR_INTERNAL_ERROR,
; 182  :                     XML_ERR_FATAL, NULL, 0, (const char *) str, NULL, NULL,
; 183  :                     0, 0, msg, str);
; 184  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN1@xmlErrInte

; 185  :         ctxt->wellFormed = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 186  :         if (ctxt->recovery == 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+288], 0
	jne	SHORT $LN1@xmlErrInte

; 187  :             ctxt->disableSAX = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+212], 1
$LN1@xmlErrInte:

; 188  :     }
; 189  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlErrInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlErrMemory
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlErrMemory PROC					; COMDAT

; 114  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 115  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlErrMemo
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlErrMemo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlErrMemo

; 116  :         (ctxt->instate == XML_PARSER_EOF))
; 117  : 	return;

	jmp	$LN1@xmlErrMemo
$LN2@xmlErrMemo:

; 118  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlErrMemo

; 119  :         ctxt->errNo = XML_ERR_NO_MEMORY;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+84], 2

; 120  :         ctxt->instate = XML_PARSER_EOF;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], -1

; 121  :         ctxt->disableSAX = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+212], 1
$LN3@xmlErrMemo:

; 122  :     }
; 123  :     if (extra)

	cmp	DWORD PTR _extra$[ebp], 0
	je	SHORT $LN4@xmlErrMemo

; 124  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	mov	edx, DWORD PTR _extra$[ebp]
	push	edx
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	0
	push	0
	push	3
	push	2
	push	1
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	jmp	SHORT $LN1@xmlErrMemo
$LN4@xmlErrMemo:

; 125  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
; 126  :                         NULL, NULL, 0, 0,
; 127  :                         "Memory allocation failed : %s\n", extra);
; 128  :     else
; 129  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	2
	push	1
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 64					; 00000040H
$LN1@xmlErrMemo:

; 130  :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
; 131  :                         NULL, NULL, 0, 0, "Memory allocation failed\n");
; 132  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserInputShrink
_TEXT	SEGMENT
_content$ = -16						; size = 4
_indx$ = -12						; size = 4
_ret$ = -8						; size = 4
_used$ = -4						; size = 4
_in$ = 8						; size = 4
_xmlParserInputShrink PROC				; COMDAT

; 358  : xmlParserInputShrink(xmlParserInputPtr in) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 359  :     size_t used;
; 360  :     size_t ret;
; 361  :     size_t indx;
; 362  :     const xmlChar *content;
; 363  : 
; 364  : #ifdef DEBUG_INPUT
; 365  :     xmlGenericError(xmlGenericErrorContext, "Shrink\n");
; 366  : #endif
; 367  :     if (in == NULL) return;

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN2@xmlParserI
	jmp	$LN1@xmlParserI
$LN2@xmlParserI:

; 368  :     if (in->buf == NULL) return;

	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@xmlParserI
	jmp	$LN1@xmlParserI
$LN3@xmlParserI:

; 369  :     if (in->base == NULL) return;

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN4@xmlParserI
	jmp	$LN1@xmlParserI
$LN4@xmlParserI:

; 370  :     if (in->cur == NULL) return;

	mov	edx, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN5@xmlParserI
	jmp	$LN1@xmlParserI
$LN5@xmlParserI:

; 371  :     if (in->buf->buffer == NULL) return;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN6@xmlParserI
	jmp	$LN1@xmlParserI
$LN6@xmlParserI:

; 372  : 
; 373  :     CHECK_BUFFER(in);
; 374  : 
; 375  :     used = in->cur - xmlBufContent(in->buf->buffer);

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufContent
	add	esp, 4
	mov	edx, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, eax
	mov	DWORD PTR _used$[ebp], ecx

; 376  :     /*
; 377  :      * Do not shrink on large buffers whose only a tiny fraction
; 378  :      * was consumed
; 379  :      */
; 380  :     if (used > INPUT_CHUNK) {

	cmp	DWORD PTR _used$[ebp], 250		; 000000faH
	jbe	SHORT $LN7@xmlParserI

; 381  : 	ret = xmlBufShrink(in->buf->buffer, used - LINE_LEN);

	mov	edx, DWORD PTR _used$[ebp]
	sub	edx, 80					; 00000050H
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufShrink
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 382  : 	if (ret > 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jbe	SHORT $LN8@xmlParserI

; 383  : 	    in->cur -= ret;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 384  : 	    in->consumed += ret;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN8@xmlParserI:

; 385  : 	}
; 386  : 	in->end = xmlBufEnd(in->buf->buffer);

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufEnd
	add	esp, 4
	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN7@xmlParserI:

; 387  :     }
; 388  : 
; 389  :     CHECK_BUFFER(in);
; 390  : 
; 391  :     if (xmlBufUse(in->buf->buffer) > INPUT_CHUNK) {

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufUse
	add	esp, 4
	cmp	eax, 250				; 000000faH
	jbe	SHORT $LN9@xmlParserI

; 392  :         return;

	jmp	SHORT $LN1@xmlParserI
$LN9@xmlParserI:

; 393  :     }
; 394  :     xmlParserInputBufferRead(in->buf, 2 * INPUT_CHUNK);

	push	500					; 000001f4H
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlParserInputBufferRead
	add	esp, 8

; 395  :     content = xmlBufContent(in->buf->buffer);

	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufContent
	add	esp, 4
	mov	DWORD PTR _content$[ebp], eax

; 396  :     if (in->base != content) {

	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _content$[ebp]
	je	SHORT $LN10@xmlParserI

; 397  :         /*
; 398  : 	 * the buffer has been reallocated
; 399  : 	 */
; 400  : 	indx = in->cur - in->base;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [eax+16]
	sub	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _indx$[ebp], edx

; 401  : 	in->base = content;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 402  : 	in->cur = &content[indx];

	mov	edx, DWORD PTR _content$[ebp]
	add	edx, DWORD PTR _indx$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR [eax+16], edx
$LN10@xmlParserI:

; 403  :     }
; 404  :     in->end = xmlBufEnd(in->buf->buffer);

	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufEnd
	add	esp, 4
	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN1@xmlParserI:

; 405  : 
; 406  :     CHECK_BUFFER(in);
; 407  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserInputShrink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNextChar
_TEXT	SEGMENT
_buffer$1 = -168					; size = 150
_val$2 = -12						; size = 4
_c$3 = -5						; size = 1
_cur$4 = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlNextChar PROC					; COMDAT

; 424  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	edi
	lea	edi, DWORD PTR [ebp-172]
	mov	ecx, 43					; 0000002bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 425  :     if ((ctxt == NULL) || (ctxt->instate == XML_PARSER_EOF) ||

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlNextCha
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	je	SHORT $LN3@xmlNextCha
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN2@xmlNextCha
$LN3@xmlNextCha:

; 426  :         (ctxt->input == NULL))
; 427  :         return;

	jmp	$LN1@xmlNextCha
$LN2@xmlNextCha:

; 428  : 
; 429  :     if (!(VALID_CTXT(ctxt))) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	eax, DWORD PTR [edx+20]
	jbe	SHORT $LN4@xmlNextCha

; 430  :         xmlErrInternal(ctxt, "Parser input data memory error\n", NULL);

	push	0
	push	OFFSET ??_C@_0CA@FAKJAFPJ@Parser?5input?5data?5memory?5error?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 431  : 	ctxt->errNo = XML_ERR_INTERNAL_ERROR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+84], 1

; 432  :         xmlStopParser(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlStopParser
	add	esp, 4

; 433  : 	return;

	jmp	$LN1@xmlNextCha
$LN4@xmlNextCha:

; 434  :     }
; 435  : 
; 436  :     if ((*ctxt->input->cur == 0) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@xmlNextCha
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
	test	eax, eax
	jg	SHORT $LN5@xmlNextCha

; 437  :         (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) {
; 438  :         return;

	jmp	$LN1@xmlNextCha
$LN5@xmlNextCha:

; 439  :     }
; 440  : 
; 441  :     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+256], 1
	jne	$LN6@xmlNextCha

; 442  :         const unsigned char *cur;
; 443  :         unsigned char c;
; 444  : 
; 445  :         /*
; 446  :          *   2.11 End-of-Line Handling
; 447  :          *   the literal two-character sequence "#xD#xA" or a standalone
; 448  :          *   literal #xD, an XML processor must pass to the application
; 449  :          *   the single character #xA.
; 450  :          */
; 451  :         if (*(ctxt->input->cur) == '\n') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN8@xmlNextCha

; 452  :             ctxt->input->line++; ctxt->input->col = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+28], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], 1

; 453  :         } else

	jmp	SHORT $LN9@xmlNextCha
$LN8@xmlNextCha:

; 454  :             ctxt->input->col++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
$LN9@xmlNextCha:

; 455  : 
; 456  :         /*
; 457  :          * We are supposed to handle UTF8, check it's valid
; 458  :          * From rfc2044: encoding of the Unicode values on UTF-8:
; 459  :          *
; 460  :          * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
; 461  :          * 0000 0000-0000 007F   0xxxxxxx
; 462  :          * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
; 463  :          * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
; 464  :          *
; 465  :          * Check for the 0x110000 limit too
; 466  :          */
; 467  :         cur = ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _cur$4[ebp], edx

; 468  : 
; 469  :         c = *cur;

	mov	eax, DWORD PTR _cur$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$3[ebp], cl

; 470  :         if (c & 0x80) {

	movzx	edx, BYTE PTR _c$3[ebp]
	and	edx, 128				; 00000080H
	je	$LN10@xmlNextCha

; 471  :             if (c == 0xC0)

	movzx	eax, BYTE PTR _c$3[ebp]
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN12@xmlNextCha

; 472  : 	        goto encoding_error;

	jmp	$encoding_error$38
$LN12@xmlNextCha:

; 473  :             if (cur[1] == 0) {

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN13@xmlNextCha

; 474  :                 xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8

; 475  :                 cur = ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _cur$4[ebp], edx
$LN13@xmlNextCha:

; 476  :             }
; 477  :             if ((cur[1] & 0xc0) != 0x80)

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 192				; 000000c0H
	cmp	edx, 128				; 00000080H
	je	SHORT $LN14@xmlNextCha

; 478  :                 goto encoding_error;

	jmp	$encoding_error$38
$LN14@xmlNextCha:

; 479  :             if ((c & 0xe0) == 0xe0) {

	movzx	eax, BYTE PTR _c$3[ebp]
	and	eax, 224				; 000000e0H
	cmp	eax, 224				; 000000e0H
	jne	$LN15@xmlNextCha

; 480  :                 unsigned int val;
; 481  : 
; 482  :                 if (cur[2] == 0) {

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _cur$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN17@xmlNextCha

; 483  :                     xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8

; 484  :                     cur = ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _cur$4[ebp], edx
$LN17@xmlNextCha:

; 485  :                 }
; 486  :                 if ((cur[2] & 0xc0) != 0x80)

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 192				; 000000c0H
	cmp	edx, 128				; 00000080H
	je	SHORT $LN18@xmlNextCha

; 487  :                     goto encoding_error;

	jmp	$encoding_error$38
$LN18@xmlNextCha:

; 488  :                 if ((c & 0xf0) == 0xf0) {

	movzx	eax, BYTE PTR _c$3[ebp]
	and	eax, 240				; 000000f0H
	cmp	eax, 240				; 000000f0H
	jne	$LN19@xmlNextCha

; 489  :                     if (cur[3] == 0) {

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _cur$4[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN21@xmlNextCha

; 490  :                         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8

; 491  :                         cur = ctxt->input->cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _cur$4[ebp], eax
$LN21@xmlNextCha:

; 492  :                     }
; 493  :                     if (((c & 0xf8) != 0xf0) ||

	movzx	ecx, BYTE PTR _c$3[ebp]
	and	ecx, 248				; 000000f8H
	cmp	ecx, 240				; 000000f0H
	jne	SHORT $LN23@xmlNextCha
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 192				; 000000c0H
	cmp	edx, 128				; 00000080H
	je	SHORT $LN22@xmlNextCha
$LN23@xmlNextCha:

; 494  :                         ((cur[3] & 0xc0) != 0x80))
; 495  :                         goto encoding_error;

	jmp	$encoding_error$38
$LN22@xmlNextCha:

; 496  :                     /* 4-byte code */
; 497  :                     ctxt->input->cur += 4;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 4
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx

; 498  :                     val = (cur[0] & 0x7) << 18;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 7
	shl	edx, 18					; 00000012H
	mov	DWORD PTR _val$2[ebp], edx

; 499  :                     val |= (cur[1] & 0x3f) << 12;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	shl	edx, 12					; 0000000cH
	or	edx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], edx

; 500  :                     val |= (cur[2] & 0x3f) << 6;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	shl	edx, 6
	or	edx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], edx

; 501  :                     val |= cur[3] & 0x3f;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _cur$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], eax

; 502  :                 } else {

	jmp	SHORT $LN20@xmlNextCha
$LN19@xmlNextCha:

; 503  :                     /* 3-byte code */
; 504  :                     ctxt->input->cur += 3;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax

; 505  :                     val = (cur[0] & 0xf) << 12;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 15					; 0000000fH
	shl	eax, 12					; 0000000cH
	mov	DWORD PTR _val$2[ebp], eax

; 506  :                     val |= (cur[1] & 0x3f) << 6;

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	shl	eax, 6
	or	eax, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], eax

; 507  :                     val |= cur[2] & 0x3f;

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _cur$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], eax
$LN20@xmlNextCha:

; 508  :                 }
; 509  :                 if (((val > 0xd7ff) && (val < 0xe000)) ||
; 510  :                     ((val > 0xfffd) && (val < 0x10000)) ||

	cmp	DWORD PTR _val$2[ebp], 55295		; 0000d7ffH
	jbe	SHORT $LN26@xmlNextCha
	cmp	DWORD PTR _val$2[ebp], 57344		; 0000e000H
	jb	SHORT $LN25@xmlNextCha
$LN26@xmlNextCha:
	cmp	DWORD PTR _val$2[ebp], 65533		; 0000fffdH
	jbe	SHORT $LN27@xmlNextCha
	cmp	DWORD PTR _val$2[ebp], 65536		; 00010000H
	jb	SHORT $LN25@xmlNextCha
$LN27@xmlNextCha:
	cmp	DWORD PTR _val$2[ebp], 1114112		; 00110000H
	jb	SHORT $LN24@xmlNextCha
$LN25@xmlNextCha:

; 511  :                     (val >= 0x110000)) {
; 512  : 		xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,

	mov	ecx, DWORD PTR _val$2[ebp]
	push	ecx
	push	OFFSET ??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@
	push	9
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrEncodingInt
	add	esp, 16					; 00000010H
$LN24@xmlNextCha:

; 513  : 				  "Char 0x%X out of allowed range\n",
; 514  : 				  val);
; 515  :                 }
; 516  :             } else

	jmp	SHORT $LN16@xmlNextCha
$LN15@xmlNextCha:

; 517  :                 /* 2-byte code */
; 518  :                 ctxt->input->cur += 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
$LN16@xmlNextCha:

; 519  :         } else

	jmp	SHORT $LN11@xmlNextCha
$LN10@xmlNextCha:

; 520  :             /* 1-byte code */
; 521  :             ctxt->input->cur++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
$LN11@xmlNextCha:

; 522  : 
; 523  :         ctxt->nbChars++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx

; 524  :     } else {

	jmp	SHORT $LN7@xmlNextCha
$LN6@xmlNextCha:

; 525  :         /*
; 526  :          * Assume it's a fixed length encoding (1) with
; 527  :          * a compatible encoding for the ASCII set, since
; 528  :          * XML constructs only use < 128 chars
; 529  :          */
; 530  : 
; 531  :         if (*(ctxt->input->cur) == '\n') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN28@xmlNextCha

; 532  :             ctxt->input->line++; ctxt->input->col = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], 1

; 533  :         } else

	jmp	SHORT $LN29@xmlNextCha
$LN28@xmlNextCha:

; 534  :             ctxt->input->col++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
$LN29@xmlNextCha:

; 535  :         ctxt->input->cur++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx

; 536  :         ctxt->nbChars++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
$LN7@xmlNextCha:

; 537  :     }
; 538  :     if (*ctxt->input->cur == 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN30@xmlNextCha

; 539  :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN30@xmlNextCha:

; 540  :     return;

	jmp	$LN1@xmlNextCha
$encoding_error$38:

; 541  : encoding_error:
; 542  :     /*
; 543  :      * If we detect an UTF8 error that probably mean that the
; 544  :      * input encoding didn't get properly advertised in the
; 545  :      * declaration header. Report the error and switch the encoding
; 546  :      * to ISO-Latin-1 (if you don't like this policy, just declare the
; 547  :      * encoding !)
; 548  :      */
; 549  :     if ((ctxt == NULL) || (ctxt->input == NULL) ||

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN33@xmlNextCha
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN33@xmlNextCha
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 4
	jge	SHORT $LN31@xmlNextCha
$LN33@xmlNextCha:

; 550  :         (ctxt->input->end - ctxt->input->cur < 4)) {
; 551  : 	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	push	0
	push	OFFSET ??_C@_0DA@ICAIJAPJ@Input?5is?5not?5proper?5UTF?98?0?5indi@
	push	9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 552  : 		     "Input is not proper UTF-8, indicate encoding !\n",
; 553  : 		     NULL, NULL);
; 554  :     } else {

	jmp	$LN32@xmlNextCha
$LN31@xmlNextCha:

; 555  :         char buffer[150];
; 556  : 
; 557  : 	snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	push	OFFSET ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
	push	149					; 00000095H
	lea	eax, DWORD PTR _buffer$1[ebp]
	push	eax
	call	_snprintf
	add	esp, 28					; 0000001cH

; 558  : 			ctxt->input->cur[0], ctxt->input->cur[1],
; 559  : 			ctxt->input->cur[2], ctxt->input->cur[3]);
; 560  : 	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	lea	ecx, DWORD PTR _buffer$1[ebp]
	push	ecx
	push	OFFSET ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
	push	9
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H
$LN32@xmlNextCha:

; 561  : 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 562  : 		     BAD_CAST buffer, NULL);
; 563  :     }
; 564  :     ctxt->charset = XML_CHAR_ENCODING_8859_1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+256], 10			; 0000000aH

; 565  :     ctxt->input->cur++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
$LN1@xmlNextCha:

; 566  :     return;
; 567  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN37@xmlNextCha
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 172				; 000000acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN37@xmlNextCha:
	DD	1
	DD	$LN36@xmlNextCha
$LN36@xmlNextCha:
	DD	-168					; ffffff58H
	DD	150					; 00000096H
	DD	$LN35@xmlNextCha
$LN35@xmlNextCha:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_xmlNextChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlCopyChar
_TEXT	SEGMENT
_len$ = 8						; size = 4
_out$ = 12						; size = 4
_val$ = 16						; size = 4
_xmlCopyChar PROC					; COMDAT

; 900  : xmlCopyChar(int len ATTRIBUTE_UNUSED, xmlChar *out, int val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 901  :     if (out == NULL) return(0);

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN2@xmlCopyCha
	xor	eax, eax
	jmp	SHORT $LN1@xmlCopyCha
$LN2@xmlCopyCha:

; 902  :     /* the len parameter is ignored */
; 903  :     if  (val >= 0x80) {

	cmp	DWORD PTR _val$[ebp], 128		; 00000080H
	jl	SHORT $LN3@xmlCopyCha

; 904  : 	return(xmlCopyCharMultiByte (out, val));

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_xmlCopyCharMultiByte
	add	esp, 8
	jmp	SHORT $LN1@xmlCopyCha
$LN3@xmlCopyCha:

; 905  :     }
; 906  :     *out = (xmlChar) val;

	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR _val$[ebp]
	mov	BYTE PTR [edx], al

; 907  :     return 1;

	mov	eax, 1
$LN1@xmlCopyCha:

; 908  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCopyChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlCopyCharMultiByte
_TEXT	SEGMENT
_bits$1 = -8						; size = 4
_savedout$2 = -4					; size = 4
_out$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlCopyCharMultiByte PROC				; COMDAT

; 857  : xmlCopyCharMultiByte(xmlChar *out, int val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 858  :     if (out == NULL) return(0);

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN5@xmlCopyCha
	xor	eax, eax
	jmp	$LN1@xmlCopyCha
$LN5@xmlCopyCha:

; 859  :     /*
; 860  :      * We are supposed to handle UTF8, check it's valid
; 861  :      * From rfc2044: encoding of the Unicode values on UTF-8:
; 862  :      *
; 863  :      * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
; 864  :      * 0000 0000-0000 007F   0xxxxxxx
; 865  :      * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
; 866  :      * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
; 867  :      */
; 868  :     if  (val >= 0x80) {

	cmp	DWORD PTR _val$[ebp], 128		; 00000080H
	jl	$LN6@xmlCopyCha

; 869  : 	xmlChar *savedout = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _savedout$2[ebp], eax

; 870  : 	int bits;
; 871  : 	if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }

	cmp	DWORD PTR _val$[ebp], 2048		; 00000800H
	jge	SHORT $LN7@xmlCopyCha
	mov	ecx, DWORD PTR _val$[ebp]
	sar	ecx, 6
	or	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$1[ebp], 0
	jmp	SHORT $LN8@xmlCopyCha
$LN7@xmlCopyCha:

; 872  : 	else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}

	cmp	DWORD PTR _val$[ebp], 65536		; 00010000H
	jge	SHORT $LN9@xmlCopyCha
	mov	ecx, DWORD PTR _val$[ebp]
	sar	ecx, 12					; 0000000cH
	or	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$1[ebp], 6
	jmp	SHORT $LN8@xmlCopyCha
$LN9@xmlCopyCha:

; 873  : 	else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }

	cmp	DWORD PTR _val$[ebp], 1114112		; 00110000H
	jge	SHORT $LN11@xmlCopyCha
	mov	ecx, DWORD PTR _val$[ebp]
	sar	ecx, 18					; 00000012H
	or	ecx, 240				; 000000f0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$1[ebp], 12		; 0000000cH
	jmp	SHORT $LN8@xmlCopyCha
$LN11@xmlCopyCha:

; 874  : 	else {
; 875  : 	    xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,

	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DI@DIALIMHD@Internal?5error?0?5xmlCopyCharMult@
	push	9
	push	0
	call	_xmlErrEncodingInt
	add	esp, 16					; 00000010H

; 876  : 		    "Internal error, xmlCopyCharMultiByte 0x%X out of bound\n",
; 877  : 			      val);
; 878  : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCopyCha
$LN8@xmlCopyCha:

; 879  : 	}
; 880  : 	for ( ; bits >= 0; bits-= 6)

	jmp	SHORT $LN4@xmlCopyCha
$LN2@xmlCopyCha:
	mov	edx, DWORD PTR _bits$1[ebp]
	sub	edx, 6
	mov	DWORD PTR _bits$1[ebp], edx
$LN4@xmlCopyCha:
	cmp	DWORD PTR _bits$1[ebp], 0
	jl	SHORT $LN3@xmlCopyCha

; 881  : 	    *out++= ((val >> bits) & 0x3F) | 0x80 ;

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _bits$1[ebp]
	sar	eax, cl
	and	eax, 63					; 0000003fH
	or	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	jmp	SHORT $LN2@xmlCopyCha
$LN3@xmlCopyCha:

; 882  : 	return (out - savedout);

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _savedout$2[ebp]
	jmp	SHORT $LN1@xmlCopyCha
$LN6@xmlCopyCha:

; 883  :     }
; 884  :     *out = (xmlChar) val;

	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR _val$[ebp]
	mov	BYTE PTR [eax], cl

; 885  :     return 1;

	mov	eax, 1
$LN1@xmlCopyCha:

; 886  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCopyCharMultiByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlCurrentChar
_TEXT	SEGMENT
tv241 = -184						; size = 4
tv243 = -180						; size = 4
tv242 = -176						; size = 4
_buffer$1 = -168					; size = 150
_val$2 = -12						; size = 4
_c$3 = -5						; size = 1
_cur$4 = -4						; size = 4
_ctxt$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlCurrentChar PROC					; COMDAT

; 588  : xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	push	edi
	lea	edi, DWORD PTR [ebp-184]
	mov	ecx, 46					; 0000002eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 589  :     if ((ctxt == NULL) || (len == NULL) || (ctxt->input == NULL)) return(0);

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlCurrent
	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN3@xmlCurrent
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN2@xmlCurrent
$LN3@xmlCurrent:
	xor	eax, eax
	jmp	$LN1@xmlCurrent
$LN2@xmlCurrent:

; 590  :     if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN4@xmlCurrent

; 591  : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlCurrent
$LN4@xmlCurrent:

; 592  : 
; 593  :     if ((*ctxt->input->cur >= 0x20) && (*ctxt->input->cur <= 0x7F)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jl	SHORT $LN5@xmlCurrent
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 127				; 0000007fH
	jg	SHORT $LN5@xmlCurrent

; 594  : 	    *len = 1;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], 1

; 595  : 	    return((int) *ctxt->input->cur);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [ecx]
	jmp	$LN1@xmlCurrent
$LN5@xmlCurrent:

; 596  :     }
; 597  :     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+256], 1
	jne	$LN6@xmlCurrent

; 598  : 	/*
; 599  : 	 * We are supposed to handle UTF8, check it's valid
; 600  : 	 * From rfc2044: encoding of the Unicode values on UTF-8:
; 601  : 	 *
; 602  : 	 * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
; 603  : 	 * 0000 0000-0000 007F   0xxxxxxx
; 604  : 	 * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
; 605  : 	 * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
; 606  : 	 *
; 607  : 	 * Check for the 0x110000 limit too
; 608  : 	 */
; 609  : 	const unsigned char *cur = ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _cur$4[ebp], edx

; 610  : 	unsigned char c;
; 611  : 	unsigned int val;
; 612  : 
; 613  : 	c = *cur;

	mov	eax, DWORD PTR _cur$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$3[ebp], cl

; 614  : 	if (c & 0x80) {

	movzx	edx, BYTE PTR _c$3[ebp]
	and	edx, 128				; 00000080H
	je	$LN7@xmlCurrent

; 615  : 	    if (((c & 0x40) == 0) || (c == 0xC0))

	movzx	eax, BYTE PTR _c$3[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN10@xmlCurrent
	movzx	ecx, BYTE PTR _c$3[ebp]
	cmp	ecx, 192				; 000000c0H
	jne	SHORT $LN9@xmlCurrent
$LN10@xmlCurrent:

; 616  : 		goto encoding_error;

	jmp	$encoding_error$47
$LN9@xmlCurrent:

; 617  : 	    if (cur[1] == 0) {

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$4[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN11@xmlCurrent

; 618  : 		xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8

; 619  :                 cur = ctxt->input->cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _cur$4[ebp], eax
$LN11@xmlCurrent:

; 620  :             }
; 621  : 	    if ((cur[1] & 0xc0) != 0x80)

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN12@xmlCurrent

; 622  : 		goto encoding_error;

	jmp	$encoding_error$47
$LN12@xmlCurrent:

; 623  : 	    if ((c & 0xe0) == 0xe0) {

	movzx	ecx, BYTE PTR _c$3[ebp]
	and	ecx, 224				; 000000e0H
	cmp	ecx, 224				; 000000e0H
	jne	$LN13@xmlCurrent

; 624  : 		if (cur[2] == 0) {

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _cur$4[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN15@xmlCurrent

; 625  : 		    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8

; 626  :                     cur = ctxt->input->cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _cur$4[ebp], eax
$LN15@xmlCurrent:

; 627  :                 }
; 628  : 		if ((cur[2] & 0xc0) != 0x80)

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _cur$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN16@xmlCurrent

; 629  : 		    goto encoding_error;

	jmp	$encoding_error$47
$LN16@xmlCurrent:

; 630  : 		if ((c & 0xf0) == 0xf0) {

	movzx	ecx, BYTE PTR _c$3[ebp]
	and	ecx, 240				; 000000f0H
	cmp	ecx, 240				; 000000f0H
	jne	$LN17@xmlCurrent

; 631  : 		    if (cur[3] == 0) {

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN19@xmlCurrent

; 632  : 			xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8

; 633  :                         cur = ctxt->input->cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _cur$4[ebp], ecx
$LN19@xmlCurrent:

; 634  :                     }
; 635  : 		    if (((c & 0xf8) != 0xf0) ||

	movzx	edx, BYTE PTR _c$3[ebp]
	and	edx, 248				; 000000f8H
	cmp	edx, 240				; 000000f0H
	jne	SHORT $LN21@xmlCurrent
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _cur$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN20@xmlCurrent
$LN21@xmlCurrent:

; 636  : 			((cur[3] & 0xc0) != 0x80))
; 637  : 			goto encoding_error;

	jmp	$encoding_error$47
$LN20@xmlCurrent:

; 638  : 		    /* 4-byte code */
; 639  : 		    *len = 4;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], 4

; 640  : 		    val = (cur[0] & 0x7) << 18;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 7
	shl	edx, 18					; 00000012H
	mov	DWORD PTR _val$2[ebp], edx

; 641  : 		    val |= (cur[1] & 0x3f) << 12;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	shl	edx, 12					; 0000000cH
	or	edx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], edx

; 642  : 		    val |= (cur[2] & 0x3f) << 6;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	shl	edx, 6
	or	edx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], edx

; 643  : 		    val |= cur[3] & 0x3f;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _cur$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], eax

; 644  : 		    if (val < 0x10000)

	cmp	DWORD PTR _val$2[ebp], 65536		; 00010000H
	jae	SHORT $LN22@xmlCurrent

; 645  : 			goto encoding_error;

	jmp	$encoding_error$47
$LN22@xmlCurrent:

; 646  : 		} else {

	jmp	SHORT $LN18@xmlCurrent
$LN17@xmlCurrent:

; 647  : 		  /* 3-byte code */
; 648  : 		    *len = 3;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], 3

; 649  : 		    val = (cur[0] & 0xf) << 12;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 15					; 0000000fH
	shl	edx, 12					; 0000000cH
	mov	DWORD PTR _val$2[ebp], edx

; 650  : 		    val |= (cur[1] & 0x3f) << 6;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	shl	edx, 6
	or	edx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], edx

; 651  : 		    val |= cur[2] & 0x3f;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _cur$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	or	edx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], edx

; 652  : 		    if (val < 0x800)

	cmp	DWORD PTR _val$2[ebp], 2048		; 00000800H
	jae	SHORT $LN18@xmlCurrent

; 653  : 			goto encoding_error;

	jmp	$encoding_error$47
$LN18@xmlCurrent:

; 654  : 		}
; 655  : 	    } else {

	jmp	SHORT $LN14@xmlCurrent
$LN13@xmlCurrent:

; 656  : 	      /* 2-byte code */
; 657  : 		*len = 2;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax], 2

; 658  : 		val = (cur[0] & 0x1f) << 6;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$4[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 31					; 0000001fH
	shl	ecx, 6
	mov	DWORD PTR _val$2[ebp], ecx

; 659  : 		val |= cur[1] & 0x3f;

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$4[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], ecx

; 660  : 		if (val < 0x80)

	cmp	DWORD PTR _val$2[ebp], 128		; 00000080H
	jae	SHORT $LN14@xmlCurrent

; 661  : 		    goto encoding_error;

	jmp	$encoding_error$47
$LN14@xmlCurrent:

; 662  : 	    }
; 663  : 	    if (!IS_CHAR(val)) {

	cmp	DWORD PTR _val$2[ebp], 256		; 00000100H
	jae	SHORT $LN42@xmlCurrent
	cmp	DWORD PTR _val$2[ebp], 9
	jb	SHORT $LN34@xmlCurrent
	cmp	DWORD PTR _val$2[ebp], 10		; 0000000aH
	jbe	SHORT $LN35@xmlCurrent
$LN34@xmlCurrent:
	cmp	DWORD PTR _val$2[ebp], 13		; 0000000dH
	je	SHORT $LN35@xmlCurrent
	cmp	DWORD PTR _val$2[ebp], 32		; 00000020H
	jae	SHORT $LN35@xmlCurrent
	mov	DWORD PTR tv242[ebp], 0
	jmp	SHORT $LN41@xmlCurrent
$LN35@xmlCurrent:
	mov	DWORD PTR tv242[ebp], 1
$LN41@xmlCurrent:
	mov	edx, DWORD PTR tv242[ebp]
	mov	DWORD PTR tv243[ebp], edx
	jmp	SHORT $LN43@xmlCurrent
$LN42@xmlCurrent:
	cmp	DWORD PTR _val$2[ebp], 256		; 00000100H
	jb	SHORT $LN36@xmlCurrent
	cmp	DWORD PTR _val$2[ebp], 55295		; 0000d7ffH
	jbe	SHORT $LN38@xmlCurrent
$LN36@xmlCurrent:
	cmp	DWORD PTR _val$2[ebp], 57344		; 0000e000H
	jb	SHORT $LN37@xmlCurrent
	cmp	DWORD PTR _val$2[ebp], 65533		; 0000fffdH
	jbe	SHORT $LN38@xmlCurrent
$LN37@xmlCurrent:
	cmp	DWORD PTR _val$2[ebp], 65536		; 00010000H
	jb	SHORT $LN39@xmlCurrent
	cmp	DWORD PTR _val$2[ebp], 1114111		; 0010ffffH
	jbe	SHORT $LN38@xmlCurrent
$LN39@xmlCurrent:
	mov	DWORD PTR tv241[ebp], 0
	jmp	SHORT $LN40@xmlCurrent
$LN38@xmlCurrent:
	mov	DWORD PTR tv241[ebp], 1
$LN40@xmlCurrent:
	mov	eax, DWORD PTR tv241[ebp]
	mov	DWORD PTR tv243[ebp], eax
$LN43@xmlCurrent:
	cmp	DWORD PTR tv243[ebp], 0
	jne	SHORT $LN25@xmlCurrent

; 664  : 	        xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,

	mov	ecx, DWORD PTR _val$2[ebp]
	push	ecx
	push	OFFSET ??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@
	push	9
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrEncodingInt
	add	esp, 16					; 00000010H
$LN25@xmlCurrent:

; 665  : 				  "Char 0x%X out of allowed range\n", val);
; 666  : 	    }
; 667  : 	    return(val);

	mov	eax, DWORD PTR _val$2[ebp]
	jmp	$LN1@xmlCurrent

; 668  : 	} else {

	jmp	$LN6@xmlCurrent
$LN7@xmlCurrent:

; 669  : 	    /* 1-byte code */
; 670  : 	    *len = 1;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax], 1

; 671  : 	    if (*ctxt->input->cur == 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN26@xmlCurrent

; 672  : 		xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN26@xmlCurrent:

; 673  : 	    if ((*ctxt->input->cur == 0) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN27@xmlCurrent
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN27@xmlCurrent

; 674  : 	        (ctxt->input->end > ctxt->input->cur)) {
; 675  : 	        xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	push	OFFSET ??_C@_0BP@OHGFBCJB@Char?50x0?5out?5of?5allowed?5range?6@
	push	9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrEncodingInt
	add	esp, 16					; 00000010H
$LN27@xmlCurrent:

; 676  : 				  "Char 0x0 out of allowed range\n", 0);
; 677  : 	    }
; 678  : 	    if (*ctxt->input->cur == 0xD) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN28@xmlCurrent

; 679  : 		if (ctxt->input->cur[1] == 0xA) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN29@xmlCurrent

; 680  : 		    ctxt->nbChars++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax

; 681  : 		    ctxt->input->cur++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
$LN29@xmlCurrent:

; 682  : 		}
; 683  : 		return(0xA);

	mov	eax, 10					; 0000000aH
	jmp	$LN1@xmlCurrent
$LN28@xmlCurrent:

; 684  : 	    }
; 685  : 	    return((int) *ctxt->input->cur);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [eax]
	jmp	$LN1@xmlCurrent
$LN6@xmlCurrent:

; 686  : 	}
; 687  :     }
; 688  :     /*
; 689  :      * Assume it's a fixed length encoding (1) with
; 690  :      * a compatible encoding for the ASCII set, since
; 691  :      * XML constructs only use < 128 chars
; 692  :      */
; 693  :     *len = 1;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], 1

; 694  :     if (*ctxt->input->cur == 0xD) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN30@xmlCurrent

; 695  : 	if (ctxt->input->cur[1] == 0xA) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN31@xmlCurrent

; 696  : 	    ctxt->nbChars++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax

; 697  : 	    ctxt->input->cur++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
$LN31@xmlCurrent:

; 698  : 	}
; 699  : 	return(0xA);

	mov	eax, 10					; 0000000aH
	jmp	$LN1@xmlCurrent
$LN30@xmlCurrent:

; 700  :     }
; 701  :     return((int) *ctxt->input->cur);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [eax]
	jmp	$LN1@xmlCurrent
$encoding_error$47:

; 702  : encoding_error:
; 703  :     /*
; 704  :      * An encoding problem may arise from a truncated input buffer
; 705  :      * splitting a character in the middle. In that case do not raise
; 706  :      * an error but return 0 to endicate an end of stream problem
; 707  :      */
; 708  :     if (ctxt->input->end - ctxt->input->cur < 4) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 4
	jge	SHORT $LN32@xmlCurrent

; 709  : 	*len = 0;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax], 0

; 710  : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlCurrent
$LN32@xmlCurrent:

; 711  :     }
; 712  : 
; 713  :     /*
; 714  :      * If we detect an UTF8 error that probably mean that the
; 715  :      * input encoding didn't get properly advertised in the
; 716  :      * declaration header. Report the error and switch the encoding
; 717  :      * to ISO-Latin-1 (if you don't like this policy, just declare the
; 718  :      * encoding !)
; 719  :      */
; 720  :     {
; 721  :         char buffer[150];
; 722  : 
; 723  : 	snprintf(&buffer[0], 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	push	ecx
	push	OFFSET ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
	push	149					; 00000095H
	mov	edx, 1
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _buffer$1[ebp+eax]
	push	ecx
	call	_snprintf
	add	esp, 28					; 0000001cH

; 724  : 			ctxt->input->cur[0], ctxt->input->cur[1],
; 725  : 			ctxt->input->cur[2], ctxt->input->cur[3]);
; 726  : 	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	lea	edx, DWORD PTR _buffer$1[ebp]
	push	edx
	push	OFFSET ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
	push	9
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 727  : 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 728  : 		     BAD_CAST buffer, NULL);
; 729  :     }
; 730  :     ctxt->charset = XML_CHAR_ENCODING_8859_1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+256], 10			; 0000000aH

; 731  :     *len = 1;

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx], 1

; 732  :     return((int) *ctxt->input->cur);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
$LN1@xmlCurrent:

; 733  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN46@xmlCurrent
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 184				; 000000b8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN46@xmlCurrent:
	DD	1
	DD	$LN45@xmlCurrent
$LN45@xmlCurrent:
	DD	-168					; ffffff58H
	DD	150					; 00000096H
	DD	$LN44@xmlCurrent
$LN44@xmlCurrent:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_xmlCurrentChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlStringCurrentChar
_TEXT	SEGMENT
tv187 = -180						; size = 4
tv189 = -176						; size = 4
tv188 = -172						; size = 4
_buffer$1 = -164					; size = 150
_val$2 = -8						; size = 4
_c$3 = -1						; size = 1
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlStringCurrentChar PROC				; COMDAT

; 749  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	edi
	lea	edi, DWORD PTR [ebp-180]
	mov	ecx, 45					; 0000002dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 750  :     if ((len == NULL) || (cur == NULL)) return(0);

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN3@xmlStringC
	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlStringC
$LN3@xmlStringC:
	xor	eax, eax
	jmp	$LN1@xmlStringC
$LN2@xmlStringC:

; 751  :     if ((ctxt == NULL) || (ctxt->charset == XML_CHAR_ENCODING_UTF8)) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN5@xmlStringC
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+256], 1
	jne	$LN4@xmlStringC
$LN5@xmlStringC:

; 752  :         /*
; 753  :          * We are supposed to handle UTF8, check it's valid
; 754  :          * From rfc2044: encoding of the Unicode values on UTF-8:
; 755  :          *
; 756  :          * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
; 757  :          * 0000 0000-0000 007F   0xxxxxxx
; 758  :          * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
; 759  :          * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
; 760  :          *
; 761  :          * Check for the 0x110000 limit too
; 762  :          */
; 763  :         unsigned char c;
; 764  :         unsigned int val;
; 765  : 
; 766  :         c = *cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$3[ebp], dl

; 767  :         if (c & 0x80) {

	movzx	eax, BYTE PTR _c$3[ebp]
	and	eax, 128				; 00000080H
	je	$LN6@xmlStringC

; 768  :             if ((cur[1] & 0xc0) != 0x80)

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN8@xmlStringC

; 769  :                 goto encoding_error;

	jmp	$encoding_error$33
$LN8@xmlStringC:

; 770  :             if ((c & 0xe0) == 0xe0) {

	movzx	ecx, BYTE PTR _c$3[ebp]
	and	ecx, 224				; 000000e0H
	cmp	ecx, 224				; 000000e0H
	jne	$LN9@xmlStringC

; 771  : 
; 772  :                 if ((cur[2] & 0xc0) != 0x80)

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 128				; 00000080H
	je	SHORT $LN11@xmlStringC

; 773  :                     goto encoding_error;

	jmp	$encoding_error$33
$LN11@xmlStringC:

; 774  :                 if ((c & 0xf0) == 0xf0) {

	movzx	edx, BYTE PTR _c$3[ebp]
	and	edx, 240				; 000000f0H
	cmp	edx, 240				; 000000f0H
	jne	$LN12@xmlStringC

; 775  :                     if (((c & 0xf8) != 0xf0) || ((cur[3] & 0xc0) != 0x80))

	movzx	eax, BYTE PTR _c$3[ebp]
	and	eax, 248				; 000000f8H
	cmp	eax, 240				; 000000f0H
	jne	SHORT $LN15@xmlStringC
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 128				; 00000080H
	je	SHORT $LN14@xmlStringC
$LN15@xmlStringC:

; 776  :                         goto encoding_error;

	jmp	$encoding_error$33
$LN14@xmlStringC:

; 777  :                     /* 4-byte code */
; 778  :                     *len = 4;

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx], 4

; 779  :                     val = (cur[0] & 0x7) << 18;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 7
	shl	eax, 18					; 00000012H
	mov	DWORD PTR _val$2[ebp], eax

; 780  :                     val |= (cur[1] & 0x3f) << 12;

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	shl	eax, 12					; 0000000cH
	or	eax, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], eax

; 781  :                     val |= (cur[2] & 0x3f) << 6;

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	shl	eax, 6
	or	eax, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], eax

; 782  :                     val |= cur[3] & 0x3f;

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], ecx

; 783  :                 } else {

	jmp	SHORT $LN13@xmlStringC
$LN12@xmlStringC:

; 784  :                     /* 3-byte code */
; 785  :                     *len = 3;

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx], 3

; 786  :                     val = (cur[0] & 0xf) << 12;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 15					; 0000000fH
	shl	eax, 12					; 0000000cH
	mov	DWORD PTR _val$2[ebp], eax

; 787  :                     val |= (cur[1] & 0x3f) << 6;

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	shl	eax, 6
	or	eax, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], eax

; 788  :                     val |= cur[2] & 0x3f;

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], eax
$LN13@xmlStringC:

; 789  :                 }
; 790  :             } else {

	jmp	SHORT $LN10@xmlStringC
$LN9@xmlStringC:

; 791  :                 /* 2-byte code */
; 792  :                 *len = 2;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], 2

; 793  :                 val = (cur[0] & 0x1f) << 6;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 31					; 0000001fH
	shl	edx, 6
	mov	DWORD PTR _val$2[ebp], edx

; 794  :                 val |= cur[1] & 0x3f;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	or	edx, DWORD PTR _val$2[ebp]
	mov	DWORD PTR _val$2[ebp], edx
$LN10@xmlStringC:

; 795  :             }
; 796  :             if (!IS_CHAR(val)) {

	cmp	DWORD PTR _val$2[ebp], 256		; 00000100H
	jae	SHORT $LN28@xmlStringC
	cmp	DWORD PTR _val$2[ebp], 9
	jb	SHORT $LN20@xmlStringC
	cmp	DWORD PTR _val$2[ebp], 10		; 0000000aH
	jbe	SHORT $LN21@xmlStringC
$LN20@xmlStringC:
	cmp	DWORD PTR _val$2[ebp], 13		; 0000000dH
	je	SHORT $LN21@xmlStringC
	cmp	DWORD PTR _val$2[ebp], 32		; 00000020H
	jae	SHORT $LN21@xmlStringC
	mov	DWORD PTR tv188[ebp], 0
	jmp	SHORT $LN27@xmlStringC
$LN21@xmlStringC:
	mov	DWORD PTR tv188[ebp], 1
$LN27@xmlStringC:
	mov	eax, DWORD PTR tv188[ebp]
	mov	DWORD PTR tv189[ebp], eax
	jmp	SHORT $LN29@xmlStringC
$LN28@xmlStringC:
	cmp	DWORD PTR _val$2[ebp], 256		; 00000100H
	jb	SHORT $LN22@xmlStringC
	cmp	DWORD PTR _val$2[ebp], 55295		; 0000d7ffH
	jbe	SHORT $LN24@xmlStringC
$LN22@xmlStringC:
	cmp	DWORD PTR _val$2[ebp], 57344		; 0000e000H
	jb	SHORT $LN23@xmlStringC
	cmp	DWORD PTR _val$2[ebp], 65533		; 0000fffdH
	jbe	SHORT $LN24@xmlStringC
$LN23@xmlStringC:
	cmp	DWORD PTR _val$2[ebp], 65536		; 00010000H
	jb	SHORT $LN25@xmlStringC
	cmp	DWORD PTR _val$2[ebp], 1114111		; 0010ffffH
	jbe	SHORT $LN24@xmlStringC
$LN25@xmlStringC:
	mov	DWORD PTR tv187[ebp], 0
	jmp	SHORT $LN26@xmlStringC
$LN24@xmlStringC:
	mov	DWORD PTR tv187[ebp], 1
$LN26@xmlStringC:
	mov	ecx, DWORD PTR tv187[ebp]
	mov	DWORD PTR tv189[ebp], ecx
$LN29@xmlStringC:
	cmp	DWORD PTR tv189[ebp], 0
	jne	SHORT $LN16@xmlStringC

; 797  : 	        xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,

	mov	edx, DWORD PTR _val$2[ebp]
	push	edx
	push	OFFSET ??_C@_0CA@EOJNGAKJ@Char?50x?$CFX?5out?5of?5allowed?5range?6@
	push	9
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrEncodingInt
	add	esp, 16					; 00000010H
$LN16@xmlStringC:

; 798  : 				  "Char 0x%X out of allowed range\n", val);
; 799  :             }
; 800  :             return (val);

	mov	eax, DWORD PTR _val$2[ebp]
	jmp	$LN1@xmlStringC

; 801  :         } else {

	jmp	SHORT $LN4@xmlStringC
$LN6@xmlStringC:

; 802  :             /* 1-byte code */
; 803  :             *len = 1;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], 1

; 804  :             return ((int) *cur);

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	jmp	$LN1@xmlStringC
$LN4@xmlStringC:

; 805  :         }
; 806  :     }
; 807  :     /*
; 808  :      * Assume it's a fixed length encoding (1) with
; 809  :      * a compatible encoding for the ASCII set, since
; 810  :      * XML constructs only use < 128 chars
; 811  :      */
; 812  :     *len = 1;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax], 1

; 813  :     return ((int) *cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [ecx]
	jmp	$LN1@xmlStringC
$encoding_error$33:

; 814  : encoding_error:
; 815  : 
; 816  :     /*
; 817  :      * An encoding problem may arise from a truncated input buffer
; 818  :      * splitting a character in the middle. In that case do not raise
; 819  :      * an error but return 0 to endicate an end of stream problem
; 820  :      */
; 821  :     if ((ctxt == NULL) || (ctxt->input == NULL) ||

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN18@xmlStringC
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN18@xmlStringC
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 4
	jge	SHORT $LN17@xmlStringC
$LN18@xmlStringC:

; 822  :         (ctxt->input->end - ctxt->input->cur < 4)) {
; 823  : 	*len = 0;

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx], 0

; 824  : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlStringC
$LN17@xmlStringC:

; 825  :     }
; 826  :     /*
; 827  :      * If we detect an UTF8 error that probably mean that the
; 828  :      * input encoding didn't get properly advertised in the
; 829  :      * declaration header. Report the error and switch the encoding
; 830  :      * to ISO-Latin-1 (if you don't like this policy, just declare the
; 831  :      * encoding !)
; 832  :      */
; 833  :     {
; 834  :         char buffer[150];
; 835  : 
; 836  : 	snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
	push	149					; 00000095H
	lea	ecx, DWORD PTR _buffer$1[ebp]
	push	ecx
	call	_snprintf
	add	esp, 28					; 0000001cH

; 837  : 			ctxt->input->cur[0], ctxt->input->cur[1],
; 838  : 			ctxt->input->cur[2], ctxt->input->cur[3]);
; 839  : 	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	lea	edx, DWORD PTR _buffer$1[ebp]
	push	edx
	push	OFFSET ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
	push	9
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 840  : 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 841  : 		     BAD_CAST buffer, NULL);
; 842  :     }
; 843  :     *len = 1;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], 1

; 844  :     return ((int) *cur);

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
$LN1@xmlStringC:

; 845  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@xmlStringC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 180				; 000000b4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN32@xmlStringC:
	DD	1
	DD	$LN31@xmlStringC
$LN31@xmlStringC:
	DD	-164					; ffffff5cH
	DD	150					; 00000096H
	DD	$LN30@xmlStringC
$LN30@xmlStringC:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_xmlStringCurrentChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewInputStream
_TEXT	SEGMENT
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlNewInputStream PROC					; COMDAT

; 1362 : xmlNewInputStream(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1363 :     xmlParserInputPtr input;
; 1364 : 
; 1365 :     input = (xmlParserInputPtr) xmlMalloc(sizeof(xmlParserInput));

	mov	esi, esp
	push	60					; 0000003cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _input$[ebp], eax

; 1366 :     if (input == NULL) {

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN2@xmlNewInpu

; 1367 :         xmlErrMemory(ctxt,  "couldn't allocate a new input stream\n");

	push	OFFSET ??_C@_0CG@CPFGJCJF@couldn?8t?5allocate?5a?5new?5input?5s@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 1368 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewInpu
$LN2@xmlNewInpu:

; 1369 :     }
; 1370 :     memset(input, 0, sizeof(xmlParserInput));

	push	60					; 0000003cH
	push	0
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1371 :     input->line = 1;

	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx+28], 1

; 1372 :     input->col = 1;

	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+32], 1

; 1373 :     input->standalone = -1;

	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+52], -1

; 1374 : 
; 1375 :     /*
; 1376 :      * If the context is NULL the id cannot be initialized, but that
; 1377 :      * should not happen while parsing which is the situation where
; 1378 :      * the id is actually needed.
; 1379 :      */
; 1380 :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlNewInpu

; 1381 :         input->id = ctxt->input_id++;

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	mov	DWORD PTR [edx+56], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+464]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+464], eax
$LN3@xmlNewInpu:

; 1382 : 
; 1383 :     return(input);

	mov	eax, DWORD PTR _input$[ebp]
$LN1@xmlNewInpu:

; 1384 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewInputFromFile
_TEXT	SEGMENT
_URI$ = -16						; size = 4
_directory$ = -12					; size = 4
_inputStream$ = -8					; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_xmlNewInputFromFile PROC				; COMDAT

; 1526 : xmlNewInputFromFile(xmlParserCtxtPtr ctxt, const char *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1527 :     xmlParserInputBufferPtr buf;
; 1528 :     xmlParserInputPtr inputStream;
; 1529 :     char *directory = NULL;

	mov	DWORD PTR _directory$[ebp], 0

; 1530 :     xmlChar *URI = NULL;

	mov	DWORD PTR _URI$[ebp], 0

; 1531 : 
; 1532 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@xmlNewInpu

; 1533 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@HHNDNGAE@new?5input?5from?5file?3?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@xmlNewInpu:

; 1534 : 		"new input from file: %s\n", filename);
; 1535 :     if (ctxt == NULL) return(NULL);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlNewInpu
	xor	eax, eax
	jmp	$LN1@xmlNewInpu
$LN3@xmlNewInpu:

; 1536 :     buf = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);

	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlParserInputBufferCreateFilename
	add	esp, 8
	mov	DWORD PTR _buf$[ebp], eax

; 1537 :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN4@xmlNewInpu

; 1538 : 	if (filename == NULL)

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN5@xmlNewInpu

; 1539 : 	    __xmlLoaderErr(ctxt,

	push	0
	push	OFFSET ??_C@_0DA@OFJNACAP@failed?5to?5load?5external?5entity?3@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	___xmlLoaderErr
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@xmlNewInpu
$LN5@xmlNewInpu:

; 1540 : 	                   "failed to load external entity: NULL filename \n",
; 1541 : 			   NULL);
; 1542 : 	else
; 1543 : 	    __xmlLoaderErr(ctxt, "failed to load external entity \"%s\"\n",

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	push	OFFSET ??_C@_0CF@NIPBAEPO@failed?5to?5load?5external?5entity?5@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	___xmlLoaderErr
	add	esp, 12					; 0000000cH
$LN6@xmlNewInpu:

; 1544 : 			   (const char *) filename);
; 1545 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewInpu
$LN4@xmlNewInpu:

; 1546 :     }
; 1547 : 
; 1548 :     inputStream = xmlNewInputStream(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNewInputStream
	add	esp, 4
	mov	DWORD PTR _inputStream$[ebp], eax

; 1549 :     if (inputStream == NULL)

	cmp	DWORD PTR _inputStream$[ebp], 0
	jne	SHORT $LN7@xmlNewInpu

; 1550 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewInpu
$LN7@xmlNewInpu:

; 1551 : 
; 1552 :     inputStream->buf = buf;

	mov	edx, DWORD PTR _inputStream$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx], eax

; 1553 :     inputStream = xmlCheckHTTPInput(ctxt, inputStream);

	mov	ecx, DWORD PTR _inputStream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCheckHTTPInput
	add	esp, 8
	mov	DWORD PTR _inputStream$[ebp], eax

; 1554 :     if (inputStream == NULL)

	cmp	DWORD PTR _inputStream$[ebp], 0
	jne	SHORT $LN8@xmlNewInpu

; 1555 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewInpu
$LN8@xmlNewInpu:

; 1556 : 
; 1557 :     if (inputStream->filename == NULL)

	mov	eax, DWORD PTR _inputStream$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@xmlNewInpu

; 1558 : 	URI = xmlStrdup((xmlChar *) filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _URI$[ebp], eax
	jmp	SHORT $LN10@xmlNewInpu
$LN9@xmlNewInpu:

; 1559 :     else
; 1560 : 	URI = xmlStrdup((xmlChar *) inputStream->filename);

	mov	edx, DWORD PTR _inputStream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _URI$[ebp], eax
$LN10@xmlNewInpu:

; 1561 :     directory = xmlParserGetDirectory((const char *) URI);

	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	DWORD PTR _directory$[ebp], eax

; 1562 :     if (inputStream->filename != NULL) xmlFree((char *)inputStream->filename);

	mov	edx, DWORD PTR _inputStream$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN11@xmlNewInpu
	mov	esi, esp
	mov	eax, DWORD PTR _inputStream$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlNewInpu:

; 1563 :     inputStream->filename = (char *) xmlCanonicPath((const xmlChar *) URI);

	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	call	_xmlCanonicPath
	add	esp, 4
	mov	ecx, DWORD PTR _inputStream$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1564 :     if (URI != NULL) xmlFree((char *) URI);

	cmp	DWORD PTR _URI$[ebp], 0
	je	SHORT $LN12@xmlNewInpu
	mov	esi, esp
	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlNewInpu:

; 1565 :     inputStream->directory = directory;

	mov	eax, DWORD PTR _inputStream$[ebp]
	mov	ecx, DWORD PTR _directory$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1566 : 
; 1567 :     xmlBufResetInput(inputStream->buf->buffer, inputStream);

	mov	edx, DWORD PTR _inputStream$[ebp]
	push	edx
	mov	eax, DWORD PTR _inputStream$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufResetInput
	add	esp, 8

; 1568 :     if ((ctxt->directory == NULL) && (directory != NULL))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+180], 0
	jne	SHORT $LN13@xmlNewInpu
	cmp	DWORD PTR _directory$[ebp], 0
	je	SHORT $LN13@xmlNewInpu

; 1569 :         ctxt->directory = (char *) xmlStrdup((const xmlChar *) directory);

	mov	ecx, DWORD PTR _directory$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+180], eax
$LN13@xmlNewInpu:

; 1570 :     return(inputStream);

	mov	eax, DWORD PTR _inputStream$[ebp]
$LN1@xmlNewInpu:

; 1571 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewInputFromFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlFreeInputStream
_TEXT	SEGMENT
_input$ = 8						; size = 4
_xmlFreeInputStream PROC				; COMDAT

; 1339 : xmlFreeInputStream(xmlParserInputPtr input) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1340 :     if (input == NULL) return;

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN2@xmlFreeInp
	jmp	$LN1@xmlFreeInp
$LN2@xmlFreeInp:

; 1341 : 
; 1342 :     if (input->filename != NULL) xmlFree((char *) input->filename);

	mov	eax, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@xmlFreeInp
	mov	esi, esp
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlFreeInp:

; 1343 :     if (input->directory != NULL) xmlFree((char *) input->directory);

	mov	eax, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN4@xmlFreeInp
	mov	esi, esp
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlFreeInp:

; 1344 :     if (input->encoding != NULL) xmlFree((char *) input->encoding);

	mov	eax, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN5@xmlFreeInp
	mov	esi, esp
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlFreeInp:

; 1345 :     if (input->version != NULL) xmlFree((char *) input->version);

	mov	eax, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN6@xmlFreeInp
	mov	esi, esp
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlFreeInp:

; 1346 :     if ((input->free != NULL) && (input->base != NULL))

	mov	eax, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN7@xmlFreeInp
	mov	ecx, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN7@xmlFreeInp

; 1347 :         input->free((xmlChar *) input->base);

	mov	esi, esp
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlFreeInp:

; 1348 :     if (input->buf != NULL)

	mov	eax, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@xmlFreeInp

; 1349 :         xmlFreeParserInputBuffer(input->buf);

	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlFreeParserInputBuffer
	add	esp, 4
$LN8@xmlFreeInp:

; 1350 :     xmlFree(input);

	mov	esi, esp
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlFreeInp:

; 1351 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFreeInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewEntityInputStream
_TEXT	SEGMENT
tv79 = -8						; size = 4
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_entity$ = 12						; size = 4
_xmlNewEntityInputStream PROC				; COMDAT

; 1430 : xmlNewEntityInputStream(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1431 :     xmlParserInputPtr input;
; 1432 : 
; 1433 :     if (entity == NULL) {

	cmp	DWORD PTR _entity$[ebp], 0
	jne	SHORT $LN4@xmlNewEnti

; 1434 :         xmlErrInternal(ctxt, "xmlNewEntityInputStream entity = NULL\n",

	push	0
	push	OFFSET ??_C@_0CH@MELJCKLM@xmlNewEntityInputStream?5entity?5@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1435 : 	               NULL);
; 1436 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewEnti
$LN4@xmlNewEnti:

; 1437 :     }
; 1438 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xmlNewEnti

; 1439 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _entity$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_0BL@NEFEMIEI@new?5input?5from?5entity?3?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlNewEnti:

; 1440 : 		"new input from entity: %s\n", entity->name);
; 1441 :     if (entity->content == NULL) {

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+40], 0
	jne	$LN6@xmlNewEnti

; 1442 : 	switch (entity->etype) {

	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR tv79[ebp], ecx
	mov	edx, DWORD PTR tv79[ebp]
	sub	edx, 1
	mov	DWORD PTR tv79[ebp], edx
	cmp	DWORD PTR tv79[ebp], 5
	ja	$LN2@xmlNewEnti
	mov	eax, DWORD PTR tv79[ebp]
	jmp	DWORD PTR $LN16@xmlNewEnti[eax*4]
$LN7@xmlNewEnti:

; 1443 :             case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 1444 : 	        xmlErrInternal(ctxt, "Cannot parse entity %s\n",

	mov	ecx, DWORD PTR _entity$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_0BI@JKMDPIMC@Cannot?5parse?5entity?5?$CFs?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1445 : 		               entity->name);
; 1446 :                 break;

	jmp	SHORT $LN2@xmlNewEnti
$LN8@xmlNewEnti:

; 1447 :             case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 1448 :             case XML_EXTERNAL_PARAMETER_ENTITY:
; 1449 : 		return(xmlLoadExternalEntity((char *) entity->URI,

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entity$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_xmlLoadExternalEntity
	add	esp, 12					; 0000000cH
	jmp	$LN1@xmlNewEnti
$LN9@xmlNewEnti:

; 1450 : 		       (char *) entity->ExternalID, ctxt));
; 1451 :             case XML_INTERNAL_GENERAL_ENTITY:
; 1452 : 	        xmlErrInternal(ctxt,

	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0CG@GPBALEIB@Internal?5entity?5?$CFs?5without?5cont@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1453 : 		      "Internal entity %s without content !\n",
; 1454 : 		               entity->name);
; 1455 :                 break;

	jmp	SHORT $LN2@xmlNewEnti
$LN10@xmlNewEnti:

; 1456 :             case XML_INTERNAL_PARAMETER_ENTITY:
; 1457 : 	        xmlErrInternal(ctxt,

	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0DA@IHKPCFAE@Internal?5parameter?5entity?5?$CFs?5wi@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1458 : 		      "Internal parameter entity %s without content !\n",
; 1459 : 		               entity->name);
; 1460 :                 break;

	jmp	SHORT $LN2@xmlNewEnti
$LN11@xmlNewEnti:

; 1461 :             case XML_INTERNAL_PREDEFINED_ENTITY:
; 1462 : 	        xmlErrInternal(ctxt,

	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0CI@JMHJJLAK@Predefined?5entity?5?$CFs?5without?5co@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH
$LN2@xmlNewEnti:

; 1463 : 		      "Predefined entity %s without content !\n",
; 1464 : 		               entity->name);
; 1465 :                 break;
; 1466 : 	}
; 1467 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewEnti
$LN6@xmlNewEnti:

; 1468 :     }
; 1469 :     input = xmlNewInputStream(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNewInputStream
	add	esp, 4
	mov	DWORD PTR _input$[ebp], eax

; 1470 :     if (input == NULL) {

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN12@xmlNewEnti

; 1471 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewEnti
$LN12@xmlNewEnti:

; 1472 :     }
; 1473 :     if (entity->URI != NULL)

	mov	ecx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [ecx+64], 0
	je	SHORT $LN13@xmlNewEnti

; 1474 : 	input->filename = (char *) xmlStrdup((xmlChar *) entity->URI);

	mov	edx, DWORD PTR _entity$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN13@xmlNewEnti:

; 1475 :     input->base = entity->content;

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+12], ecx

; 1476 :     if (entity->length == 0)

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+44], 0
	jne	SHORT $LN14@xmlNewEnti

; 1477 :         entity->length = xmlStrlen(entity->content);

	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	mov	edx, DWORD PTR _entity$[ebp]
	mov	DWORD PTR [edx+44], eax
$LN14@xmlNewEnti:

; 1478 :     input->cur = entity->content;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR _entity$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+16], edx

; 1479 :     input->length = entity->length;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR _entity$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+24], edx

; 1480 :     input->end = &entity->content[input->length];

	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _input$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1481 :     return(input);

	mov	eax, DWORD PTR _input$[ebp]
$LN1@xmlNewEnti:

; 1482 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN16@xmlNewEnti:
	DD	$LN9@xmlNewEnti
	DD	$LN8@xmlNewEnti
	DD	$LN7@xmlNewEnti
	DD	$LN10@xmlNewEnti
	DD	$LN8@xmlNewEnti
	DD	$LN11@xmlNewEnti
_xmlNewEntityInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewStringInputStream
_TEXT	SEGMENT
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_buffer$ = 12						; size = 4
_xmlNewStringInputStream PROC				; COMDAT

; 1493 : xmlNewStringInputStream(xmlParserCtxtPtr ctxt, const xmlChar *buffer) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1494 :     xmlParserInputPtr input;
; 1495 : 
; 1496 :     if (buffer == NULL) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN2@xmlNewStri

; 1497 :         xmlErrInternal(ctxt, "xmlNewStringInputStream string = NULL\n",

	push	0
	push	OFFSET ??_C@_0CH@LBBEPMHA@xmlNewStringInputStream?5string?5@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1498 : 	               NULL);
; 1499 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewStri
$LN2@xmlNewStri:

; 1500 :     }
; 1501 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlNewStri

; 1502 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BI@JLKHFHIO@new?5fixed?5input?3?5?$CF?430s?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlNewStri:

; 1503 : 		"new fixed input: %.30s\n", buffer);
; 1504 :     input = xmlNewInputStream(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNewInputStream
	add	esp, 4
	mov	DWORD PTR _input$[ebp], eax

; 1505 :     if (input == NULL) {

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN4@xmlNewStri

; 1506 :         xmlErrMemory(ctxt,  "couldn't allocate a new input stream\n");

	push	OFFSET ??_C@_0CG@CPFGJCJF@couldn?8t?5allocate?5a?5new?5input?5s@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 1507 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewStri
$LN4@xmlNewStri:

; 1508 :     }
; 1509 :     input->base = buffer;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1510 :     input->cur = buffer;

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [edx+16], eax

; 1511 :     input->length = xmlStrlen(buffer);

	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1512 :     input->end = &buffer[input->length];

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1513 :     return(input);

	mov	eax, DWORD PTR _input$[ebp]
$LN1@xmlNewStri:

; 1514 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewStringInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT ___xmlErrEncoding
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlerr$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_str2$ = 24						; size = 4
___xmlErrEncoding PROC					; COMDAT

; 147  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 148  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlErrEnco
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlErrEnco
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlErrEnco

; 149  :         (ctxt->instate == XML_PARSER_EOF))
; 150  : 	return;

	jmp	SHORT $LN1@xmlErrEnco
$LN2@xmlErrEnco:

; 151  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlErrEnco

; 152  :         ctxt->errNo = xmlerr;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _xmlerr$[ebp]
	mov	DWORD PTR [edx+84], eax
$LN3@xmlErrEnco:

; 153  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	ecx, DWORD PTR _str2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str1$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _str2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str1$[ebp]
	push	edx
	push	0
	push	0
	push	3
	mov	eax, DWORD PTR _xmlerr$[ebp]
	push	eax
	push	1
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 154  :                     ctxt, NULL, XML_FROM_PARSER, xmlerr, XML_ERR_FATAL,
; 155  :                     NULL, 0, (const char *) str1, (const char *) str2,
; 156  :                     NULL, 0, 0, msg, str1, str2);
; 157  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN1@xmlErrEnco

; 158  :         ctxt->wellFormed = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+12], 0

; 159  :         if (ctxt->recovery == 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+288], 0
	jne	SHORT $LN1@xmlErrEnco

; 160  :             ctxt->disableSAX = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+212], 1
$LN1@xmlErrEnco:

; 161  :     }
; 162  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___xmlErrEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSwitchInputEncoding
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_input$ = 12						; size = 4
_handler$ = 16						; size = 4
_xmlSwitchInputEncoding PROC				; COMDAT

; 1271 :                           xmlCharEncodingHandlerPtr handler) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1272 :     return(xmlSwitchInputEncodingInt(ctxt, input, handler, -1));

	push	-1
	mov	eax, DWORD PTR _handler$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSwitchInputEncodingInt
	add	esp, 16					; 00000010H

; 1273 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSwitchInputEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSwitchToEncoding
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_handler$ = 12						; size = 4
_xmlSwitchToEncoding PROC				; COMDAT

; 1322 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1323 :     return (xmlSwitchToEncodingInt(ctxt, handler, -1));

	push	-1
	mov	eax, DWORD PTR _handler$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSwitchToEncodingInt
	add	esp, 12					; 0000000cH

; 1324 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSwitchToEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSwitchEncoding
_TEXT	SEGMENT
tv163 = -20						; size = 4
tv65 = -16						; size = 4
_ret$ = -12						; size = 4
_len$ = -8						; size = 4
_handler$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_enc$ = 12						; size = 4
_xmlSwitchEncoding PROC					; COMDAT

; 934  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 935  :     xmlCharEncodingHandlerPtr handler;
; 936  :     int len = -1;

	mov	DWORD PTR _len$[ebp], -1

; 937  :     int ret;
; 938  : 
; 939  :     if (ctxt == NULL) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN6@xmlSwitchE
	or	eax, -1
	jmp	$LN1@xmlSwitchE
$LN6@xmlSwitchE:

; 940  :     switch (enc) {

	mov	eax, DWORD PTR _enc$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	add	ecx, 1
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 23			; 00000017H
	ja	$LN2@xmlSwitchE
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN36@xmlSwitchE[edx]
	jmp	DWORD PTR $LN38@xmlSwitchE[eax*4]
$LN7@xmlSwitchE:

; 941  : 	case XML_CHAR_ENCODING_ERROR:
; 942  : 	    __xmlErrEncoding(ctxt, XML_ERR_UNKNOWN_ENCODING,

	push	0
	push	0
	push	OFFSET ??_C@_0BC@NFNLFCFA@encoding?5unknown?6@
	push	31					; 0000001fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 943  : 	                   "encoding unknown\n", NULL, NULL);
; 944  : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSwitchE
$LN8@xmlSwitchE:

; 945  : 	case XML_CHAR_ENCODING_NONE:
; 946  : 	    /* let's assume it's UTF-8 without the XML decl */
; 947  : 	    ctxt->charset = XML_CHAR_ENCODING_UTF8;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+256], 1

; 948  : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlSwitchE
$LN9@xmlSwitchE:

; 949  : 	case XML_CHAR_ENCODING_UTF8:
; 950  : 	    /* default encoding, no conversion should be needed */
; 951  : 	    ctxt->charset = XML_CHAR_ENCODING_UTF8;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+256], 1

; 952  : 
; 953  : 	    /*
; 954  : 	     * Errata on XML-1.0 June 20 2001
; 955  : 	     * Specific handling of the Byte Order Mark for
; 956  : 	     * UTF-8
; 957  : 	     */
; 958  : 	    if ((ctxt->input != NULL) &&
; 959  : 		(ctxt->input->cur[0] == 0xEF) &&
; 960  : 		(ctxt->input->cur[1] == 0xBB) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN10@xmlSwitchE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 239				; 000000efH
	jne	SHORT $LN10@xmlSwitchE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 187				; 000000bbH
	jne	SHORT $LN10@xmlSwitchE
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 191				; 000000bfH
	jne	SHORT $LN10@xmlSwitchE

; 961  : 		(ctxt->input->cur[2] == 0xBF)) {
; 962  : 		ctxt->input->cur += 3;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
$LN10@xmlSwitchE:

; 963  : 	    }
; 964  : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlSwitchE
$LN11@xmlSwitchE:

; 965  :     case XML_CHAR_ENCODING_UTF16LE:
; 966  :     case XML_CHAR_ENCODING_UTF16BE:
; 967  :         /*The raw input characters are encoded
; 968  :          *in UTF-16. As we expect this function
; 969  :          *to be called after xmlCharEncInFunc, we expect
; 970  :          *ctxt->input->cur to contain UTF-8 encoded characters.
; 971  :          *So the raw UTF16 Byte Order Mark
; 972  :          *has also been converted into
; 973  :          *an UTF-8 BOM. Let's skip that BOM.
; 974  :          */
; 975  :         if ((ctxt->input != NULL) && (ctxt->input->cur != NULL) &&
; 976  :             (ctxt->input->cur[0] == 0xEF) &&
; 977  :             (ctxt->input->cur[1] == 0xBB) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN12@xmlSwitchE
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN12@xmlSwitchE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 239				; 000000efH
	jne	SHORT $LN12@xmlSwitchE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 187				; 000000bbH
	jne	SHORT $LN12@xmlSwitchE
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 191				; 000000bfH
	jne	SHORT $LN12@xmlSwitchE

; 978  :             (ctxt->input->cur[2] == 0xBF)) {
; 979  :             ctxt->input->cur += 3;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
$LN12@xmlSwitchE:

; 980  :         }
; 981  :         len = 90;

	mov	DWORD PTR _len$[ebp], 90		; 0000005aH

; 982  : 	break;

	jmp	SHORT $LN2@xmlSwitchE
$LN13@xmlSwitchE:

; 983  :     case XML_CHAR_ENCODING_UCS2:
; 984  :         len = 90;

	mov	DWORD PTR _len$[ebp], 90		; 0000005aH

; 985  : 	break;

	jmp	SHORT $LN2@xmlSwitchE
$LN14@xmlSwitchE:

; 986  :     case XML_CHAR_ENCODING_UCS4BE:
; 987  :     case XML_CHAR_ENCODING_UCS4LE:
; 988  :     case XML_CHAR_ENCODING_UCS4_2143:
; 989  :     case XML_CHAR_ENCODING_UCS4_3412:
; 990  :         len = 180;

	mov	DWORD PTR _len$[ebp], 180		; 000000b4H

; 991  : 	break;

	jmp	SHORT $LN2@xmlSwitchE
$LN15@xmlSwitchE:

; 992  :     case XML_CHAR_ENCODING_EBCDIC:
; 993  :     case XML_CHAR_ENCODING_8859_1:
; 994  :     case XML_CHAR_ENCODING_8859_2:
; 995  :     case XML_CHAR_ENCODING_8859_3:
; 996  :     case XML_CHAR_ENCODING_8859_4:
; 997  :     case XML_CHAR_ENCODING_8859_5:
; 998  :     case XML_CHAR_ENCODING_8859_6:
; 999  :     case XML_CHAR_ENCODING_8859_7:
; 1000 :     case XML_CHAR_ENCODING_8859_8:
; 1001 :     case XML_CHAR_ENCODING_8859_9:
; 1002 :     case XML_CHAR_ENCODING_ASCII:
; 1003 :     case XML_CHAR_ENCODING_2022_JP:
; 1004 :     case XML_CHAR_ENCODING_SHIFT_JIS:
; 1005 :     case XML_CHAR_ENCODING_EUC_JP:
; 1006 :         len = 45;

	mov	DWORD PTR _len$[ebp], 45		; 0000002dH
$LN2@xmlSwitchE:

; 1007 : 	break;
; 1008 :     }
; 1009 :     handler = xmlGetCharEncodingHandler(enc);

	mov	edx, DWORD PTR _enc$[ebp]
	push	edx
	call	_xmlGetCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1010 :     if (handler == NULL) {

	cmp	DWORD PTR _handler$[ebp], 0
	jne	$LN16@xmlSwitchE

; 1011 : 	/*
; 1012 : 	 * Default handlers.
; 1013 : 	 */
; 1014 : 	switch (enc) {

	mov	eax, DWORD PTR _enc$[ebp]
	mov	DWORD PTR tv163[ebp], eax
	mov	ecx, DWORD PTR tv163[ebp]
	sub	ecx, 4
	mov	DWORD PTR tv163[ebp], ecx
	cmp	DWORD PTR tv163[ebp], 18		; 00000012H
	ja	$LN16@xmlSwitchE
	mov	edx, DWORD PTR tv163[ebp]
	movzx	eax, BYTE PTR $LN37@xmlSwitchE[edx]
	jmp	DWORD PTR $LN39@xmlSwitchE[eax*4]
$LN17@xmlSwitchE:

; 1015 : 	    case XML_CHAR_ENCODING_ASCII:
; 1016 : 		/* default encoding, no conversion should be needed */
; 1017 : 		ctxt->charset = XML_CHAR_ENCODING_UTF8;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+256], 1

; 1018 : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlSwitchE

; 1019 : 	    case XML_CHAR_ENCODING_UTF16LE:
; 1020 : 		break;

	jmp	$LN16@xmlSwitchE

; 1021 : 	    case XML_CHAR_ENCODING_UTF16BE:
; 1022 : 		break;

	jmp	$LN16@xmlSwitchE
$LN20@xmlSwitchE:

; 1023 : 	    case XML_CHAR_ENCODING_UCS4LE:
; 1024 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_0BD@IJIIAAMB@USC4?5little?5endian@
	push	OFFSET ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
	push	32					; 00000020H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 1025 : 			       "encoding not supported %s\n",
; 1026 : 			       BAD_CAST "USC4 little endian", NULL);
; 1027 : 		break;

	jmp	$LN16@xmlSwitchE
$LN21@xmlSwitchE:

; 1028 : 	    case XML_CHAR_ENCODING_UCS4BE:
; 1029 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_0BA@ELDAKMNC@USC4?5big?5endian@
	push	OFFSET ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
	push	32					; 00000020H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 1030 : 			       "encoding not supported %s\n",
; 1031 : 			       BAD_CAST "USC4 big endian", NULL);
; 1032 : 		break;

	jmp	$LN16@xmlSwitchE
$LN22@xmlSwitchE:

; 1033 : 	    case XML_CHAR_ENCODING_EBCDIC:
; 1034 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_06JJAKJGEC@EBCDIC@
	push	OFFSET ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
	push	32					; 00000020H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 1035 : 			       "encoding not supported %s\n",
; 1036 : 			       BAD_CAST "EBCDIC", NULL);
; 1037 : 		break;

	jmp	$LN16@xmlSwitchE
$LN23@xmlSwitchE:

; 1038 : 	    case XML_CHAR_ENCODING_UCS4_2143:
; 1039 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_09GAABMJEL@UCS4?52143@
	push	OFFSET ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
	push	32					; 00000020H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 1040 : 			       "encoding not supported %s\n",
; 1041 : 			       BAD_CAST "UCS4 2143", NULL);
; 1042 : 		break;

	jmp	$LN16@xmlSwitchE
$LN24@xmlSwitchE:

; 1043 : 	    case XML_CHAR_ENCODING_UCS4_3412:
; 1044 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_09HFGPODGD@UCS4?53412@
	push	OFFSET ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
	push	32					; 00000020H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 1045 : 			       "encoding not supported %s\n",
; 1046 : 			       BAD_CAST "UCS4 3412", NULL);
; 1047 : 		break;

	jmp	$LN16@xmlSwitchE
$LN25@xmlSwitchE:

; 1048 : 	    case XML_CHAR_ENCODING_UCS2:
; 1049 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_04MDAFHLBC@UCS2@
	push	OFFSET ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
	push	32					; 00000020H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 1050 : 			       "encoding not supported %s\n",
; 1051 : 			       BAD_CAST "UCS2", NULL);
; 1052 : 		break;

	jmp	$LN16@xmlSwitchE
$LN26@xmlSwitchE:

; 1053 : 	    case XML_CHAR_ENCODING_8859_1:
; 1054 : 	    case XML_CHAR_ENCODING_8859_2:
; 1055 : 	    case XML_CHAR_ENCODING_8859_3:
; 1056 : 	    case XML_CHAR_ENCODING_8859_4:
; 1057 : 	    case XML_CHAR_ENCODING_8859_5:
; 1058 : 	    case XML_CHAR_ENCODING_8859_6:
; 1059 : 	    case XML_CHAR_ENCODING_8859_7:
; 1060 : 	    case XML_CHAR_ENCODING_8859_8:
; 1061 : 	    case XML_CHAR_ENCODING_8859_9:
; 1062 : 		/*
; 1063 : 		 * We used to keep the internal content in the
; 1064 : 		 * document encoding however this turns being unmaintainable
; 1065 : 		 * So xmlGetCharEncodingHandler() will return non-null
; 1066 : 		 * values for this now.
; 1067 : 		 */
; 1068 : 		if ((ctxt->inputNr == 1) &&
; 1069 : 		    (ctxt->encoding == NULL) &&
; 1070 : 		    (ctxt->input != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1
	jne	SHORT $LN27@xmlSwitchE
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN27@xmlSwitchE
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN27@xmlSwitchE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN27@xmlSwitchE

; 1071 : 		    (ctxt->input->encoding != NULL)) {
; 1072 : 		    ctxt->encoding = xmlStrdup(ctxt->input->encoding);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN27@xmlSwitchE:

; 1073 : 		}
; 1074 : 		ctxt->charset = enc;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _enc$[ebp]
	mov	DWORD PTR [edx+256], eax

; 1075 : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlSwitchE
$LN28@xmlSwitchE:

; 1076 : 	    case XML_CHAR_ENCODING_2022_JP:
; 1077 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_0M@LMIFKILO@ISO?92022?9JP@
	push	OFFSET ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
	push	32					; 00000020H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 1078 : 			       "encoding not supported %s\n",
; 1079 : 			       BAD_CAST "ISO-2022-JP", NULL);
; 1080 : 		break;

	jmp	SHORT $LN16@xmlSwitchE
$LN29@xmlSwitchE:

; 1081 : 	    case XML_CHAR_ENCODING_SHIFT_JIS:
; 1082 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_09LOKLFMHN@Shift_JIS@
	push	OFFSET ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
	push	32					; 00000020H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 1083 : 			       "encoding not supported %s\n",
; 1084 : 			       BAD_CAST "Shift_JIS", NULL);
; 1085 : 		break;

	jmp	SHORT $LN16@xmlSwitchE
$LN30@xmlSwitchE:

; 1086 : 	    case XML_CHAR_ENCODING_EUC_JP:
; 1087 : 		__xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	push	0
	push	OFFSET ??_C@_06KCFOODCD@EUC?9JP@
	push	OFFSET ??_C@_0BL@CGHDNGKJ@encoding?5not?5supported?5?$CFs?6@
	push	32					; 00000020H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H
$LN16@xmlSwitchE:

; 1088 : 			       "encoding not supported %s\n",
; 1089 : 			       BAD_CAST "EUC-JP", NULL);
; 1090 : 		break;
; 1091 : 	    default:
; 1092 : 	        break;
; 1093 : 	}
; 1094 :     }
; 1095 :     /*
; 1096 :      * TODO: We could recover from errors in external entites if we
; 1097 :      * didn't stop the parser. But most callers of this function don't
; 1098 :      * check the return value.
; 1099 :      */
; 1100 :     if (handler == NULL) {

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN32@xmlSwitchE

; 1101 :         xmlStopParser(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlStopParser
	add	esp, 4

; 1102 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSwitchE
$LN32@xmlSwitchE:

; 1103 :     }
; 1104 :     ctxt->charset = XML_CHAR_ENCODING_UTF8;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+256], 1

; 1105 :     ret = xmlSwitchToEncodingInt(ctxt, handler, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handler$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSwitchToEncodingInt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 1106 :     if ((ret < 0) || (ctxt->errNo == XML_I18N_CONV_FAILED)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jl	SHORT $LN34@xmlSwitchE
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 6003		; 00001773H
	jne	SHORT $LN33@xmlSwitchE
$LN34@xmlSwitchE:

; 1107 :         /*
; 1108 : 	 * on encoding conversion errors, stop the parser
; 1109 : 	 */
; 1110 :         xmlStopParser(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlStopParser
	add	esp, 4

; 1111 : 	ctxt->errNo = XML_I18N_CONV_FAILED;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+84], 6003		; 00001773H
$LN33@xmlSwitchE:

; 1112 :     }
; 1113 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSwitchE:

; 1114 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN38@xmlSwitchE:
	DD	$LN7@xmlSwitchE
	DD	$LN8@xmlSwitchE
	DD	$LN9@xmlSwitchE
	DD	$LN11@xmlSwitchE
	DD	$LN14@xmlSwitchE
	DD	$LN15@xmlSwitchE
	DD	$LN13@xmlSwitchE
$LN36@xmlSwitchE:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	3
	DB	4
	DB	4
	DB	5
	DB	4
	DB	4
	DB	6
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
$LN39@xmlSwitchE:
	DD	$LN20@xmlSwitchE
	DD	$LN21@xmlSwitchE
	DD	$LN22@xmlSwitchE
	DD	$LN23@xmlSwitchE
	DD	$LN24@xmlSwitchE
	DD	$LN25@xmlSwitchE
	DD	$LN26@xmlSwitchE
	DD	$LN28@xmlSwitchE
	DD	$LN29@xmlSwitchE
	DD	$LN30@xmlSwitchE
	DD	$LN17@xmlSwitchE
$LN37@xmlSwitchE:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
_xmlSwitchEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlIsLetter
_TEXT	SEGMENT
tv89 = -20						; size = 4
tv85 = -16						; size = 4
tv86 = -12						; size = 4
tv78 = -8						; size = 4
tv77 = -4						; size = 4
_c$ = 8							; size = 4
_xmlIsLetter PROC					; COMDAT

; 229  : xmlIsLetter(int c) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 230  :     return(IS_BASECHAR(c) || IS_IDEOGRAPHIC(c));

	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN9@xmlIsLette
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN3@xmlIsLette
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	SHORT $LN5@xmlIsLette
$LN3@xmlIsLette:
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN4@xmlIsLette
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	SHORT $LN5@xmlIsLette
$LN4@xmlIsLette:
	cmp	DWORD PTR _c$[ebp], 192			; 000000c0H
	jl	SHORT $LN6@xmlIsLette
	cmp	DWORD PTR _c$[ebp], 214			; 000000d6H
	jle	SHORT $LN5@xmlIsLette
$LN6@xmlIsLette:
	cmp	DWORD PTR _c$[ebp], 216			; 000000d8H
	jl	SHORT $LN7@xmlIsLette
	cmp	DWORD PTR _c$[ebp], 246			; 000000f6H
	jle	SHORT $LN5@xmlIsLette
$LN7@xmlIsLette:
	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jge	SHORT $LN5@xmlIsLette
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN8@xmlIsLette
$LN5@xmlIsLette:
	mov	DWORD PTR tv77[ebp], 1
$LN8@xmlIsLette:
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN10@xmlIsLette
$LN9@xmlIsLette:
	push	OFFSET _xmlIsBaseCharGroup
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv78[ebp], eax
$LN10@xmlIsLette:
	cmp	DWORD PTR tv78[ebp], 0
	jne	SHORT $LN17@xmlIsLette
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN15@xmlIsLette
	mov	DWORD PTR tv86[ebp], 0
	jmp	SHORT $LN16@xmlIsLette
$LN15@xmlIsLette:
	cmp	DWORD PTR _c$[ebp], 19968		; 00004e00H
	jl	SHORT $LN11@xmlIsLette
	cmp	DWORD PTR _c$[ebp], 40869		; 00009fa5H
	jle	SHORT $LN12@xmlIsLette
$LN11@xmlIsLette:
	cmp	DWORD PTR _c$[ebp], 12295		; 00003007H
	je	SHORT $LN12@xmlIsLette
	cmp	DWORD PTR _c$[ebp], 12321		; 00003021H
	jl	SHORT $LN13@xmlIsLette
	cmp	DWORD PTR _c$[ebp], 12329		; 00003029H
	jle	SHORT $LN12@xmlIsLette
$LN13@xmlIsLette:
	mov	DWORD PTR tv85[ebp], 0
	jmp	SHORT $LN14@xmlIsLette
$LN12@xmlIsLette:
	mov	DWORD PTR tv85[ebp], 1
$LN14@xmlIsLette:
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR tv86[ebp], edx
$LN16@xmlIsLette:
	cmp	DWORD PTR tv86[ebp], 0
	jne	SHORT $LN17@xmlIsLette
	mov	DWORD PTR tv89[ebp], 0
	jmp	SHORT $LN18@xmlIsLette
$LN17@xmlIsLette:
	mov	DWORD PTR tv89[ebp], 1
$LN18@xmlIsLette:
	mov	eax, DWORD PTR tv89[ebp]

; 231  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlIsLetter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserAddNodeInfo
_TEXT	SEGMENT
_i$1 = -16						; size = 4
_byte_size$2 = -12					; size = 4
_tmp_buffer$3 = -8					; size = 4
_pos$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_info$ = 12						; size = 4
_xmlParserAddNodeInfo PROC				; COMDAT

; 2013 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 2014 :     unsigned long pos;
; 2015 : 
; 2016 :     if ((ctxt == NULL) || (info == NULL)) return;

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN6@xmlParserA
	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN5@xmlParserA
$LN6@xmlParserA:
	jmp	$LN1@xmlParserA
$LN5@xmlParserA:

; 2017 : 
; 2018 :     /* Find pos and check to see if node is already in the sequence */
; 2019 :     pos = xmlParserFindNodeInfoIndex(&ctxt->node_seq, (xmlNodePtr)

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	call	_xmlParserFindNodeInfoIndex
	add	esp, 8
	mov	DWORD PTR _pos$[ebp], eax

; 2020 :                                      info->node);
; 2021 : 
; 2022 :     if ((pos < ctxt->node_seq.length) &&
; 2023 :         (ctxt->node_seq.buffer != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	cmp	ecx, DWORD PTR [eax+76]
	jae	SHORT $LN7@xmlParserA
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+80], 0
	je	SHORT $LN7@xmlParserA
	imul	eax, DWORD PTR _pos$[ebp], 20
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [edx+eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN7@xmlParserA

; 2024 :         (ctxt->node_seq.buffer[pos].node == info->node)) {
; 2025 :         ctxt->node_seq.buffer[pos] = *info;

	imul	eax, DWORD PTR _pos$[ebp], 20
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	add	edx, eax
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], eax

; 2026 :     }

	jmp	$LN1@xmlParserA
$LN7@xmlParserA:

; 2027 : 
; 2028 :     /* Otherwise, we need to add new node to buffer */
; 2029 :     else {
; 2030 :         if ((ctxt->node_seq.length + 1 > ctxt->node_seq.maximum) ||

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	edx, DWORD PTR [eax+72]
	ja	SHORT $LN10@xmlParserA
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+80], 0
	jne	$LN9@xmlParserA
$LN10@xmlParserA:

; 2031 : 	    (ctxt->node_seq.buffer == NULL)) {
; 2032 :             xmlParserNodeInfo *tmp_buffer;
; 2033 :             unsigned int byte_size;
; 2034 : 
; 2035 :             if (ctxt->node_seq.maximum == 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+72], 0
	jne	SHORT $LN11@xmlParserA

; 2036 :                 ctxt->node_seq.maximum = 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+72], 2
$LN11@xmlParserA:

; 2037 :             byte_size = (sizeof(*ctxt->node_seq.buffer) *

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	shl	edx, 1
	imul	eax, edx, 20
	mov	DWORD PTR _byte_size$2[ebp], eax

; 2038 : 			(2 * ctxt->node_seq.maximum));
; 2039 : 
; 2040 :             if (ctxt->node_seq.buffer == NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+80], 0
	jne	SHORT $LN12@xmlParserA

; 2041 :                 tmp_buffer = (xmlParserNodeInfo *) xmlMalloc(byte_size);

	mov	esi, esp
	mov	edx, DWORD PTR _byte_size$2[ebp]
	push	edx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp_buffer$3[ebp], eax
	jmp	SHORT $LN13@xmlParserA
$LN12@xmlParserA:

; 2042 :             else
; 2043 :                 tmp_buffer =

	mov	esi, esp
	mov	eax, DWORD PTR _byte_size$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp_buffer$3[ebp], eax
$LN13@xmlParserA:

; 2044 :                     (xmlParserNodeInfo *) xmlRealloc(ctxt->node_seq.buffer,
; 2045 :                                                      byte_size);
; 2046 : 
; 2047 :             if (tmp_buffer == NULL) {

	cmp	DWORD PTR _tmp_buffer$3[ebp], 0
	jne	SHORT $LN14@xmlParserA

; 2048 : 		xmlErrMemory(ctxt, "failed to allocate buffer\n");

	push	OFFSET ??_C@_0BL@OCEPNLLN@failed?5to?5allocate?5buffer?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 2049 :                 return;

	jmp	$LN1@xmlParserA
$LN14@xmlParserA:

; 2050 :             }
; 2051 :             ctxt->node_seq.buffer = tmp_buffer;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _tmp_buffer$3[ebp]
	mov	DWORD PTR [ecx+80], edx

; 2052 :             ctxt->node_seq.maximum *= 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+72], ecx
$LN9@xmlParserA:

; 2053 :         }
; 2054 : 
; 2055 :         /* If position is not at end, move elements out of the way */
; 2056 :         if (pos != ctxt->node_seq.length) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	cmp	ecx, DWORD PTR [eax+76]
	je	SHORT $LN15@xmlParserA

; 2057 :             unsigned long i;
; 2058 : 
; 2059 :             for (i = ctxt->node_seq.length; i > pos; i--)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@xmlParserA
$LN2@xmlParserA:
	mov	ecx, DWORD PTR _i$1[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@xmlParserA:
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR _pos$[ebp]
	jbe	SHORT $LN15@xmlParserA

; 2060 :                 ctxt->node_seq.buffer[i] = ctxt->node_seq.buffer[i - 1];

	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+80]
	add	eax, ecx
	imul	ecx, DWORD PTR _i$1[ebp], 20
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+80]
	add	edx, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], eax
	jmp	SHORT $LN2@xmlParserA
$LN15@xmlParserA:

; 2061 :         }
; 2062 : 
; 2063 :         /* Copy element and increase length */
; 2064 :         ctxt->node_seq.buffer[pos] = *info;

	imul	ecx, DWORD PTR _pos$[ebp], 20
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+80]
	add	eax, ecx
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx

; 2065 :         ctxt->node_seq.length++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+76]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+76], eax
$LN1@xmlParserA:

; 2066 :     }
; 2067 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserAddNodeInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserFindNodeInfoIndex
_TEXT	SEGMENT
_found$ = -16						; size = 4
_middle$ = -12						; size = 4
_lower$ = -8						; size = 4
_upper$ = -4						; size = 4
_seq$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlParserFindNodeInfoIndex PROC			; COMDAT

; 1974 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1975 :     unsigned long upper, lower, middle;
; 1976 :     int found = 0;

	mov	DWORD PTR _found$[ebp], 0

; 1977 : 
; 1978 :     if ((seq == NULL) || (node == NULL))

	cmp	DWORD PTR _seq$[ebp], 0
	je	SHORT $LN5@xmlParserF
	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN4@xmlParserF
$LN5@xmlParserF:

; 1979 :         return ((unsigned long) -1);

	or	eax, -1
	jmp	$LN1@xmlParserF
$LN4@xmlParserF:

; 1980 : 
; 1981 :     /* Do a binary search for the key */
; 1982 :     lower = 1;

	mov	DWORD PTR _lower$[ebp], 1

; 1983 :     upper = seq->length;

	mov	eax, DWORD PTR _seq$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _upper$[ebp], ecx

; 1984 :     middle = 0;

	mov	DWORD PTR _middle$[ebp], 0
$LN2@xmlParserF:

; 1985 :     while (lower <= upper && !found) {

	mov	edx, DWORD PTR _lower$[ebp]
	cmp	edx, DWORD PTR _upper$[ebp]
	ja	SHORT $LN3@xmlParserF
	cmp	DWORD PTR _found$[ebp], 0
	jne	SHORT $LN3@xmlParserF

; 1986 :         middle = lower + (upper - lower) / 2;

	mov	eax, DWORD PTR _upper$[ebp]
	sub	eax, DWORD PTR _lower$[ebp]
	shr	eax, 1
	add	eax, DWORD PTR _lower$[ebp]
	mov	DWORD PTR _middle$[ebp], eax

; 1987 :         if (node == seq->buffer[middle - 1].node)

	mov	ecx, DWORD PTR _middle$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 20
	mov	eax, DWORD PTR _seq$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _node$[ebp]
	cmp	eax, DWORD PTR [ecx+edx]
	jne	SHORT $LN6@xmlParserF

; 1988 :             found = 1;

	mov	DWORD PTR _found$[ebp], 1
	jmp	SHORT $LN7@xmlParserF
$LN6@xmlParserF:

; 1989 :         else if (node < seq->buffer[middle - 1].node)

	mov	ecx, DWORD PTR _middle$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 20
	mov	eax, DWORD PTR _seq$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _node$[ebp]
	cmp	eax, DWORD PTR [ecx+edx]
	jae	SHORT $LN8@xmlParserF

; 1990 :             upper = middle - 1;

	mov	ecx, DWORD PTR _middle$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _upper$[ebp], ecx
	jmp	SHORT $LN7@xmlParserF
$LN8@xmlParserF:

; 1991 :         else
; 1992 :             lower = middle + 1;

	mov	edx, DWORD PTR _middle$[ebp]
	add	edx, 1
	mov	DWORD PTR _lower$[ebp], edx
$LN7@xmlParserF:

; 1993 :     }

	jmp	SHORT $LN2@xmlParserF
$LN3@xmlParserF:

; 1994 : 
; 1995 :     /* Return position */
; 1996 :     if (middle == 0 || seq->buffer[middle - 1].node < node)

	cmp	DWORD PTR _middle$[ebp], 0
	je	SHORT $LN12@xmlParserF
	mov	eax, DWORD PTR _middle$[ebp]
	sub	eax, 1
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _seq$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx]
	cmp	ecx, DWORD PTR _node$[ebp]
	jae	SHORT $LN10@xmlParserF
$LN12@xmlParserF:

; 1997 :         return middle;

	mov	eax, DWORD PTR _middle$[ebp]
	jmp	SHORT $LN1@xmlParserF
	jmp	SHORT $LN1@xmlParserF
$LN10@xmlParserF:

; 1998 :     else
; 1999 :         return middle - 1;

	mov	eax, DWORD PTR _middle$[ebp]
	sub	eax, 1
$LN1@xmlParserF:

; 2000 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserFindNodeInfoIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlClearNodeInfoSeq
_TEXT	SEGMENT
_seq$ = 8						; size = 4
_xmlClearNodeInfoSeq PROC				; COMDAT

; 1952 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1953 :     if (seq == NULL)

	cmp	DWORD PTR _seq$[ebp], 0
	jne	SHORT $LN2@xmlClearNo

; 1954 :         return;

	jmp	SHORT $LN1@xmlClearNo
$LN2@xmlClearNo:

; 1955 :     if (seq->buffer != NULL)

	mov	eax, DWORD PTR _seq$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@xmlClearNo

; 1956 :         xmlFree(seq->buffer);

	mov	esi, esp
	mov	ecx, DWORD PTR _seq$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlClearNo:

; 1957 :     xmlInitNodeInfoSeq(seq);

	mov	eax, DWORD PTR _seq$[ebp]
	push	eax
	call	_xmlInitNodeInfoSeq
	add	esp, 4
$LN1@xmlClearNo:

; 1958 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlClearNodeInfoSeq ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlInitNodeInfoSeq
_TEXT	SEGMENT
_seq$ = 8						; size = 4
_xmlInitNodeInfoSeq PROC				; COMDAT

; 1935 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1936 :     if (seq == NULL)

	cmp	DWORD PTR _seq$[ebp], 0
	jne	SHORT $LN2@xmlInitNod

; 1937 :         return;

	jmp	SHORT $LN1@xmlInitNod
$LN2@xmlInitNod:

; 1938 :     seq->length = 0;

	mov	eax, DWORD PTR _seq$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1939 :     seq->maximum = 0;

	mov	ecx, DWORD PTR _seq$[ebp]
	mov	DWORD PTR [ecx], 0

; 1940 :     seq->buffer = NULL;

	mov	edx, DWORD PTR _seq$[ebp]
	mov	DWORD PTR [edx+8], 0
$LN1@xmlInitNod:

; 1941 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlInitNodeInfoSeq ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserFindNodeInfo
_TEXT	SEGMENT
_pos$ = -4						; size = 4
_ctx$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlParserFindNodeInfo PROC				; COMDAT

; 1912 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1913 :     unsigned long pos;
; 1914 : 
; 1915 :     if ((ctx == NULL) || (node == NULL))

	cmp	DWORD PTR _ctx$[ebp], 0
	je	SHORT $LN3@xmlParserF
	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN2@xmlParserF
$LN3@xmlParserF:

; 1916 :         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParserF
$LN2@xmlParserF:

; 1917 :     /* Find position where node should be at */
; 1918 :     pos = xmlParserFindNodeInfoIndex(&ctx->node_seq, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctx$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	call	_xmlParserFindNodeInfoIndex
	add	esp, 8
	mov	DWORD PTR _pos$[ebp], eax

; 1919 :     if (pos < ctx->node_seq.length
; 1920 :         && ctx->node_seq.buffer[pos].node == node)

	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	cmp	eax, DWORD PTR [edx+76]
	jae	SHORT $LN4@xmlParserF
	imul	ecx, DWORD PTR _pos$[ebp], 20
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR [eax+ecx]
	cmp	ecx, DWORD PTR _node$[ebp]
	jne	SHORT $LN4@xmlParserF

; 1921 :         return &ctx->node_seq.buffer[pos];

	imul	eax, DWORD PTR _pos$[ebp], 20
	mov	edx, DWORD PTR _ctx$[ebp]
	add	eax, DWORD PTR [edx+80]
	jmp	SHORT $LN1@xmlParserF
	jmp	SHORT $LN1@xmlParserF
$LN4@xmlParserF:

; 1922 :     else
; 1923 :         return NULL;

	xor	eax, eax
$LN1@xmlParserF:

; 1924 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserFindNodeInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewIOInputStream
_TEXT	SEGMENT
_inputStream$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_input$ = 12						; size = 4
_enc$ = 16						; size = 4
_xmlNewIOInputStream PROC				; COMDAT

; 1399 : 	            xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1400 :     xmlParserInputPtr inputStream;
; 1401 : 
; 1402 :     if (input == NULL) return(NULL);

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN2@xmlNewIOIn
	xor	eax, eax
	jmp	$LN1@xmlNewIOIn
$LN2@xmlNewIOIn:

; 1403 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlNewIOIn

; 1404 : 	xmlGenericError(xmlGenericErrorContext, "new input from I/O\n");

	mov	esi, esp
	push	OFFSET ??_C@_0BE@PIBHFBFO@new?5input?5from?5I?1O?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlNewIOIn:

; 1405 :     inputStream = xmlNewInputStream(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNewInputStream
	add	esp, 4
	mov	DWORD PTR _inputStream$[ebp], eax

; 1406 :     if (inputStream == NULL) {

	cmp	DWORD PTR _inputStream$[ebp], 0
	jne	SHORT $LN4@xmlNewIOIn

; 1407 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewIOIn
$LN4@xmlNewIOIn:

; 1408 :     }
; 1409 :     inputStream->filename = NULL;

	mov	eax, DWORD PTR _inputStream$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1410 :     inputStream->buf = input;

	mov	ecx, DWORD PTR _inputStream$[ebp]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx], edx

; 1411 :     xmlBufResetInput(inputStream->buf->buffer, inputStream);

	mov	eax, DWORD PTR _inputStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inputStream$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufResetInput
	add	esp, 8

; 1412 : 
; 1413 :     if (enc != XML_CHAR_ENCODING_NONE) {

	cmp	DWORD PTR _enc$[ebp], 0
	je	SHORT $LN5@xmlNewIOIn

; 1414 :         xmlSwitchEncoding(ctxt, enc);

	mov	ecx, DWORD PTR _enc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSwitchEncoding
	add	esp, 8
$LN5@xmlNewIOIn:

; 1415 :     }
; 1416 : 
; 1417 :     return(inputStream);

	mov	eax, DWORD PTR _inputStream$[ebp]
$LN1@xmlNewIOIn:

; 1418 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewIOInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlFreeParserCtxt
_TEXT	SEGMENT
_next$1 = -20						; size = 4
_cur$2 = -16						; size = 4
_next$3 = -12						; size = 4
_cur$4 = -8						; size = 4
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlFreeParserCtxt PROC					; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1777 :     xmlParserInputPtr input;
; 1778 : 
; 1779 :     if (ctxt == NULL) return;

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlFreePar
	jmp	$LN1@xmlFreePar
$LN2@xmlFreePar:

; 1780 : 
; 1781 :     while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_inputPop
	add	esp, 4
	mov	DWORD PTR _input$[ebp], eax
	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN3@xmlFreePar

; 1782 :         xmlFreeInputStream(input);

	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	call	_xmlFreeInputStream
	add	esp, 4

; 1783 :     }

	jmp	SHORT $LN2@xmlFreePar
$LN3@xmlFreePar:

; 1784 :     if (ctxt->spaceTab != NULL) xmlFree(ctxt->spaceTab);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+244], 0
	je	SHORT $LN9@xmlFreePar
	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlFreePar:

; 1785 :     if (ctxt->nameTab != NULL) xmlFree((xmlChar * *)ctxt->nameTab);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+196], 0
	je	SHORT $LN10@xmlFreePar
	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlFreePar:

; 1786 :     if (ctxt->nodeTab != NULL) xmlFree(ctxt->nodeTab);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $LN11@xmlFreePar
	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlFreePar:

; 1787 :     if (ctxt->nodeInfoTab != NULL) xmlFree(ctxt->nodeInfoTab);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+460], 0
	je	SHORT $LN12@xmlFreePar
	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+460]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlFreePar:

; 1788 :     if (ctxt->inputTab != NULL) xmlFree(ctxt->inputTab);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN13@xmlFreePar
	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlFreePar:

; 1789 :     if (ctxt->version != NULL) xmlFree((char *) ctxt->version);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN14@xmlFreePar
	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlFreePar:

; 1790 :     if (ctxt->encoding != NULL) xmlFree((char *) ctxt->encoding);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN15@xmlFreePar
	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlFreePar:

; 1791 :     if (ctxt->extSubURI != NULL) xmlFree((char *) ctxt->extSubURI);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+224], 0
	je	SHORT $LN16@xmlFreePar
	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlFreePar:

; 1792 :     if (ctxt->extSubSystem != NULL) xmlFree((char *) ctxt->extSubSystem);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+228], 0
	je	SHORT $LN17@xmlFreePar
	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+228]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@xmlFreePar:

; 1793 : #ifdef LIBXML_SAX1_ENABLED
; 1794 :     if ((ctxt->sax != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN18@xmlFreePar
	call	___xmlDefaultSAXHandler
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN18@xmlFreePar

; 1795 :         (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler))
; 1796 : #else
; 1797 :     if (ctxt->sax != NULL)
; 1798 : #endif /* LIBXML_SAX1_ENABLED */
; 1799 :         xmlFree(ctxt->sax);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@xmlFreePar:

; 1800 :     if (ctxt->directory != NULL) xmlFree((char *) ctxt->directory);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+180], 0
	je	SHORT $LN19@xmlFreePar
	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@xmlFreePar:

; 1801 :     if (ctxt->vctxt.nodeTab != NULL) xmlFree(ctxt->vctxt.nodeTab);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+132], 0
	je	SHORT $LN20@xmlFreePar
	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+132]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@xmlFreePar:

; 1802 :     if (ctxt->atts != NULL) xmlFree((xmlChar * *)ctxt->atts);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+300], 0
	je	SHORT $LN21@xmlFreePar
	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+300]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@xmlFreePar:

; 1803 :     if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+296], 0
	je	SHORT $LN22@xmlFreePar
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN22@xmlFreePar:

; 1804 :     if (ctxt->nsTab != NULL) xmlFree((char *) ctxt->nsTab);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+336], 0
	je	SHORT $LN23@xmlFreePar
	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+336]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN23@xmlFreePar:

; 1805 :     if (ctxt->pushTab != NULL) xmlFree(ctxt->pushTab);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+344], 0
	je	SHORT $LN24@xmlFreePar
	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+344]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN24@xmlFreePar:

; 1806 :     if (ctxt->attallocs != NULL) xmlFree(ctxt->attallocs);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+340], 0
	je	SHORT $LN25@xmlFreePar
	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+340]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN25@xmlFreePar:

; 1807 :     if (ctxt->attsDefault != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+348], 0
	je	SHORT $LN26@xmlFreePar

; 1808 :         xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);

	push	OFFSET _xmlHashDefaultDeallocator
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+348]
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN26@xmlFreePar:

; 1809 :     if (ctxt->attsSpecial != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+352], 0
	je	SHORT $LN27@xmlFreePar

; 1810 :         xmlHashFree(ctxt->attsSpecial, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+352]
	push	eax
	call	_xmlHashFree
	add	esp, 8
$LN27@xmlFreePar:

; 1811 :     if (ctxt->freeElems != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+372], 0
	je	SHORT $LN28@xmlFreePar

; 1812 :         xmlNodePtr cur, next;
; 1813 : 
; 1814 : 	cur = ctxt->freeElems;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+372]
	mov	DWORD PTR _cur$4[ebp], eax
$LN4@xmlFreePar:

; 1815 : 	while (cur != NULL) {

	cmp	DWORD PTR _cur$4[ebp], 0
	je	SHORT $LN28@xmlFreePar

; 1816 : 	    next = cur->next;

	mov	ecx, DWORD PTR _cur$4[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _next$3[ebp], edx

; 1817 : 	    xmlFree(cur);

	mov	esi, esp
	mov	eax, DWORD PTR _cur$4[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1818 : 	    cur = next;

	mov	ecx, DWORD PTR _next$3[ebp]
	mov	DWORD PTR _cur$4[ebp], ecx

; 1819 : 	}

	jmp	SHORT $LN4@xmlFreePar
$LN28@xmlFreePar:

; 1820 :     }
; 1821 :     if (ctxt->freeAttrs != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+380], 0
	je	SHORT $LN29@xmlFreePar

; 1822 :         xmlAttrPtr cur, next;
; 1823 : 
; 1824 : 	cur = ctxt->freeAttrs;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+380]
	mov	DWORD PTR _cur$2[ebp], ecx
$LN6@xmlFreePar:

; 1825 : 	while (cur != NULL) {

	cmp	DWORD PTR _cur$2[ebp], 0
	je	SHORT $LN29@xmlFreePar

; 1826 : 	    next = cur->next;

	mov	edx, DWORD PTR _cur$2[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _next$1[ebp], eax

; 1827 : 	    xmlFree(cur);

	mov	esi, esp
	mov	ecx, DWORD PTR _cur$2[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1828 : 	    cur = next;

	mov	edx, DWORD PTR _next$1[ebp]
	mov	DWORD PTR _cur$2[ebp], edx

; 1829 : 	}

	jmp	SHORT $LN6@xmlFreePar
$LN29@xmlFreePar:

; 1830 :     }
; 1831 :     /*
; 1832 :      * cleanup the error strings
; 1833 :      */
; 1834 :     if (ctxt->lastError.message != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+392], 0
	je	SHORT $LN30@xmlFreePar

; 1835 :         xmlFree(ctxt->lastError.message);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN30@xmlFreePar:

; 1836 :     if (ctxt->lastError.file != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+400], 0
	je	SHORT $LN31@xmlFreePar

; 1837 :         xmlFree(ctxt->lastError.file);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN31@xmlFreePar:

; 1838 :     if (ctxt->lastError.str1 != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+408], 0
	je	SHORT $LN32@xmlFreePar

; 1839 :         xmlFree(ctxt->lastError.str1);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+408]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN32@xmlFreePar:

; 1840 :     if (ctxt->lastError.str2 != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+412], 0
	je	SHORT $LN33@xmlFreePar

; 1841 :         xmlFree(ctxt->lastError.str2);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+412]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN33@xmlFreePar:

; 1842 :     if (ctxt->lastError.str3 != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+416], 0
	je	SHORT $LN34@xmlFreePar

; 1843 :         xmlFree(ctxt->lastError.str3);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+416]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN34@xmlFreePar:

; 1844 : 
; 1845 : #ifdef LIBXML_CATALOG_ENABLED
; 1846 :     if (ctxt->catalogs != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+284], 0
	je	SHORT $LN35@xmlFreePar

; 1847 : 	xmlCatalogFreeLocal(ctxt->catalogs);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+284]
	push	edx
	call	_xmlCatalogFreeLocal
	add	esp, 4
$LN35@xmlFreePar:

; 1848 : #endif
; 1849 :     xmlFree(ctxt);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlFreePar:

; 1850 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFreeParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlClearParserCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlClearParserCtxt PROC				; COMDAT

; 1893 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1894 :   if (ctxt==NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlClearPa

; 1895 :     return;

	jmp	SHORT $LN1@xmlClearPa
$LN2@xmlClearPa:

; 1896 :   xmlClearNodeInfoSeq(&ctxt->node_seq);

	mov	eax, DWORD PTR _ctxt$[ebp]
	add	eax, 72					; 00000048H
	push	eax
	call	_xmlClearNodeInfoSeq
	add	esp, 4

; 1897 :   xmlCtxtReset(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtReset
	add	esp, 4
$LN1@xmlClearPa:

; 1898 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlClearParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlInitParserCtxt
_TEXT	SEGMENT
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlInitParserCtxt PROC					; COMDAT

; 1590 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1591 :     xmlParserInputPtr input;
; 1592 : 
; 1593 :     if(ctxt==NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN4@xmlInitPar

; 1594 :         xmlErrInternal(NULL, "Got NULL parser context\n", NULL);

	push	0
	push	OFFSET ??_C@_0BJ@CKGPPCDK@Got?5NULL?5parser?5context?6@
	push	0
	call	_xmlErrInternal
	add	esp, 12					; 0000000cH

; 1595 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlInitPar
$LN4@xmlInitPar:

; 1596 :     }
; 1597 : 
; 1598 :     xmlDefaultSAXHandlerInit();

	call	_xmlDefaultSAXHandlerInit

; 1599 : 
; 1600 :     if (ctxt->dict == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+296], 0
	jne	SHORT $LN5@xmlInitPar

; 1601 : 	ctxt->dict = xmlDictCreate();

	call	_xmlDictCreate
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+296], eax
$LN5@xmlInitPar:

; 1602 :     if (ctxt->dict == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+296], 0
	jne	SHORT $LN6@xmlInitPar

; 1603 :         xmlErrMemory(NULL, "cannot initialize parser context\n");

	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 1604 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlInitPar
$LN6@xmlInitPar:

; 1605 :     }
; 1606 :     xmlDictSetLimit(ctxt->dict, XML_MAX_DICTIONARY_LIMIT);

	push	10000000				; 00989680H
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	call	_xmlDictSetLimit
	add	esp, 8

; 1607 : 
; 1608 :     if (ctxt->sax == NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN7@xmlInitPar

; 1609 : 	ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));

	mov	esi, esp
	push	128					; 00000080H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
$LN7@xmlInitPar:

; 1610 :     if (ctxt->sax == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN8@xmlInitPar

; 1611 :         xmlErrMemory(NULL, "cannot initialize parser context\n");

	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 1612 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlInitPar

; 1613 :     }

	jmp	SHORT $LN9@xmlInitPar
$LN8@xmlInitPar:

; 1614 :     else
; 1615 :         xmlSAXVersion(ctxt->sax, 2);

	push	2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlSAXVersion
	add	esp, 8
$LN9@xmlInitPar:

; 1616 : 
; 1617 :     ctxt->maxatts = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+304], 0

; 1618 :     ctxt->atts = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+300], 0

; 1619 :     /* Allocate the Input stack */
; 1620 :     if (ctxt->inputTab == NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN10@xmlInitPar

; 1621 : 	ctxt->inputTab = (xmlParserInputPtr *)

	mov	esi, esp
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+48], eax

; 1622 : 		    xmlMalloc(5 * sizeof(xmlParserInputPtr));
; 1623 : 	ctxt->inputMax = 5;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+44], 5
$LN10@xmlInitPar:

; 1624 :     }
; 1625 :     if (ctxt->inputTab == NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN2@xmlInitPar

; 1626 :         xmlErrMemory(NULL, "cannot initialize parser context\n");

	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 1627 : 	ctxt->inputNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+40], 0

; 1628 : 	ctxt->inputMax = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+44], 0

; 1629 : 	ctxt->input = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 1630 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlInitPar
$LN2@xmlInitPar:

; 1631 :     }
; 1632 :     while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_inputPop
	add	esp, 4
	mov	DWORD PTR _input$[ebp], eax
	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN3@xmlInitPar

; 1633 :         xmlFreeInputStream(input);

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	call	_xmlFreeInputStream
	add	esp, 4

; 1634 :     }

	jmp	SHORT $LN2@xmlInitPar
$LN3@xmlInitPar:

; 1635 :     ctxt->inputNr = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 1636 :     ctxt->input = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+36], 0

; 1637 : 
; 1638 :     ctxt->version = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1639 :     ctxt->encoding = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 1640 :     ctxt->standalone = -1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+28], -1

; 1641 :     ctxt->hasExternalSubset = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+88], 0

; 1642 :     ctxt->hasPErefs = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+92], 0

; 1643 :     ctxt->html = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+32], 0

; 1644 :     ctxt->external = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+96], 0

; 1645 :     ctxt->instate = XML_PARSER_START;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 0

; 1646 :     ctxt->token = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+176], 0

; 1647 :     ctxt->directory = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+180], 0

; 1648 : 
; 1649 :     /* Allocate the Node stack */
; 1650 :     if (ctxt->nodeTab == NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+64], 0
	jne	SHORT $LN12@xmlInitPar

; 1651 : 	ctxt->nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));

	mov	esi, esp
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+64], eax

; 1652 : 	ctxt->nodeMax = 10;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+60], 10			; 0000000aH
$LN12@xmlInitPar:

; 1653 :     }
; 1654 :     if (ctxt->nodeTab == NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+64], 0
	jne	SHORT $LN13@xmlInitPar

; 1655 :         xmlErrMemory(NULL, "cannot initialize parser context\n");

	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 1656 : 	ctxt->nodeNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+56], 0

; 1657 : 	ctxt->nodeMax = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+60], 0

; 1658 : 	ctxt->node = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 1659 : 	ctxt->inputNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+40], 0

; 1660 : 	ctxt->inputMax = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+44], 0

; 1661 : 	ctxt->input = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 1662 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlInitPar
$LN13@xmlInitPar:

; 1663 :     }
; 1664 :     ctxt->nodeNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+56], 0

; 1665 :     ctxt->node = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+52], 0

; 1666 : 
; 1667 :     /* Allocate the Name stack */
; 1668 :     if (ctxt->nameTab == NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+196], 0
	jne	SHORT $LN14@xmlInitPar

; 1669 : 	ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));

	mov	esi, esp
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+196], eax

; 1670 : 	ctxt->nameMax = 10;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+192], 10			; 0000000aH
$LN14@xmlInitPar:

; 1671 :     }
; 1672 :     if (ctxt->nameTab == NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+196], 0
	jne	SHORT $LN15@xmlInitPar

; 1673 :         xmlErrMemory(NULL, "cannot initialize parser context\n");

	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 1674 : 	ctxt->nodeNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+56], 0

; 1675 : 	ctxt->nodeMax = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+60], 0

; 1676 : 	ctxt->node = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 1677 : 	ctxt->inputNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+40], 0

; 1678 : 	ctxt->inputMax = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+44], 0

; 1679 : 	ctxt->input = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 1680 : 	ctxt->nameNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+188], 0

; 1681 : 	ctxt->nameMax = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+192], 0

; 1682 : 	ctxt->name = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+184], 0

; 1683 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlInitPar
$LN15@xmlInitPar:

; 1684 :     }
; 1685 :     ctxt->nameNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+188], 0

; 1686 :     ctxt->name = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+184], 0

; 1687 : 
; 1688 :     /* Allocate the space stack */
; 1689 :     if (ctxt->spaceTab == NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+244], 0
	jne	SHORT $LN16@xmlInitPar

; 1690 : 	ctxt->spaceTab = (int *) xmlMalloc(10 * sizeof(int));

	mov	esi, esp
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+244], eax

; 1691 : 	ctxt->spaceMax = 10;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+240], 10			; 0000000aH
$LN16@xmlInitPar:

; 1692 :     }
; 1693 :     if (ctxt->spaceTab == NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+244], 0
	jne	$LN17@xmlInitPar

; 1694 :         xmlErrMemory(NULL, "cannot initialize parser context\n");

	push	OFFSET ??_C@_0CC@LDKNCGMI@cannot?5initialize?5parser?5contex@
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 1695 : 	ctxt->nodeNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+56], 0

; 1696 : 	ctxt->nodeMax = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+60], 0

; 1697 : 	ctxt->node = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 1698 : 	ctxt->inputNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+40], 0

; 1699 : 	ctxt->inputMax = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+44], 0

; 1700 : 	ctxt->input = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 1701 : 	ctxt->nameNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+188], 0

; 1702 : 	ctxt->nameMax = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+192], 0

; 1703 : 	ctxt->name = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+184], 0

; 1704 : 	ctxt->spaceNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+236], 0

; 1705 : 	ctxt->spaceMax = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+240], 0

; 1706 : 	ctxt->space = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+232], 0

; 1707 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlInitPar
$LN17@xmlInitPar:

; 1708 :     }
; 1709 :     ctxt->spaceNr = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+236], 1

; 1710 :     ctxt->spaceMax = 10;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+240], 10			; 0000000aH

; 1711 :     ctxt->spaceTab[0] = -1;

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	DWORD PTR [edx+ecx], -1

; 1712 :     ctxt->space = &ctxt->spaceTab[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	eax, DWORD PTR [ecx+244]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+232], eax

; 1713 :     ctxt->userData = ctxt;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1714 :     ctxt->myDoc = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1715 :     ctxt->wellFormed = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+12], 1

; 1716 :     ctxt->nsWellFormed = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+356], 1

; 1717 :     ctxt->valid = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+100], 1

; 1718 :     ctxt->loadsubset = xmlLoadExtDtdDefaultValue;

	call	___xmlLoadExtDtdDefaultValue
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+276], edx

; 1719 :     if (ctxt->loadsubset) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+276], 0
	je	SHORT $LN18@xmlInitPar

; 1720 :         ctxt->options |= XML_PARSE_DTDLOAD;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	or	edx, 4
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+360], edx
$LN18@xmlInitPar:

; 1721 :     }
; 1722 :     ctxt->validate = xmlDoValidityCheckingDefaultValue;

	call	___xmlDoValidityCheckingDefaultValue
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+104], edx

; 1723 :     ctxt->pedantic = xmlPedanticParserDefaultValue;

	call	___xmlPedanticParserDefaultValue
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+268], edx

; 1724 :     if (ctxt->pedantic) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+268], 0
	je	SHORT $LN19@xmlInitPar

; 1725 :         ctxt->options |= XML_PARSE_PEDANTIC;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+360], edx
$LN19@xmlInitPar:

; 1726 :     }
; 1727 :     ctxt->linenumbers = xmlLineNumbersDefaultValue;

	call	___xmlLineNumbersDefaultValue
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+280], edx

; 1728 :     ctxt->keepBlanks = xmlKeepBlanksDefaultValue;

	call	___xmlKeepBlanksDefaultValue
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+208], edx

; 1729 :     if (ctxt->keepBlanks == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+208], 0
	jne	SHORT $LN20@xmlInitPar

; 1730 : 	ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+72], OFFSET _xmlSAX2IgnorableWhitespace

; 1731 : 	ctxt->options |= XML_PARSE_NOBLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+360], ecx
$LN20@xmlInitPar:

; 1732 :     }
; 1733 : 
; 1734 :     ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+136], -1412623820	; abcd1234H

; 1735 :     ctxt->vctxt.userData = ctxt;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+108], edx

; 1736 :     ctxt->vctxt.error = xmlParserValidityError;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+112], OFFSET _xmlParserValidityError

; 1737 :     ctxt->vctxt.warning = xmlParserValidityWarning;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+116], OFFSET _xmlParserValidityWarning

; 1738 :     if (ctxt->validate) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+104], 0
	je	SHORT $LN21@xmlInitPar

; 1739 : 	if (xmlGetWarningsDefaultValue == 0)

	call	___xmlGetWarningsDefaultValue
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN22@xmlInitPar

; 1740 : 	    ctxt->vctxt.warning = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+116], 0
	jmp	SHORT $LN23@xmlInitPar
$LN22@xmlInitPar:

; 1741 : 	else
; 1742 : 	    ctxt->vctxt.warning = xmlParserValidityWarning;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+116], OFFSET _xmlParserValidityWarning
$LN23@xmlInitPar:

; 1743 : 	ctxt->vctxt.nodeMax = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+128], 0

; 1744 :         ctxt->options |= XML_PARSE_DTDVALID;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+360], ecx
$LN21@xmlInitPar:

; 1745 :     }
; 1746 :     ctxt->replaceEntities = xmlSubstituteEntitiesDefaultValue;

	call	___xmlSubstituteEntitiesDefaultValue
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+16], edx

; 1747 :     if (ctxt->replaceEntities) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN24@xmlInitPar

; 1748 :         ctxt->options |= XML_PARSE_NOENT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	or	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+360], edx
$LN24@xmlInitPar:

; 1749 :     }
; 1750 :     ctxt->record_info = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 1751 :     ctxt->nbChars = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], 0

; 1752 :     ctxt->checkIndex = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+204], 0

; 1753 :     ctxt->inSubset = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+216], 0

; 1754 :     ctxt->errNo = XML_ERR_OK;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+84], 0

; 1755 :     ctxt->depth = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+248], 0

; 1756 :     ctxt->charset = XML_CHAR_ENCODING_UTF8;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+256], 1

; 1757 :     ctxt->catalogs = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+284], 0

; 1758 :     ctxt->nbentities = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+440], 0

; 1759 :     ctxt->sizeentities = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+444], 0

; 1760 :     ctxt->sizeentcopy = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+468], 0

; 1761 :     ctxt->input_id = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+464], 1

; 1762 :     xmlInitNodeInfoSeq(&ctxt->node_seq);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	call	_xmlInitNodeInfoSeq
	add	esp, 4

; 1763 :     return(0);

	xor	eax, eax
$LN1@xmlInitPar:

; 1764 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlInitParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlNewParserCtxt
_TEXT	SEGMENT
_ctxt$ = -4						; size = 4
_xmlNewParserCtxt PROC					; COMDAT

; 1862 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 1863 :     xmlParserCtxtPtr ctxt;
; 1864 : 
; 1865 :     ctxt = (xmlParserCtxtPtr) xmlMalloc(sizeof(xmlParserCtxt));

	mov	esi, esp
	push	472					; 000001d8H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ctxt$[ebp], eax

; 1866 :     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlNewPars

; 1867 : 	xmlErrMemory(NULL, "cannot allocate parser context\n");

	push	OFFSET ??_C@_0CA@PHAEKKDI@cannot?5allocate?5parser?5context?6@
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 1868 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewPars
$LN2@xmlNewPars:

; 1869 :     }
; 1870 :     memset(ctxt, 0, sizeof(xmlParserCtxt));

	push	472					; 000001d8H
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1871 :     if (xmlInitParserCtxt(ctxt) < 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlInitParserCtxt
	add	esp, 4
	test	eax, eax
	jge	SHORT $LN3@xmlNewPars

; 1872 :         xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 1873 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewPars
$LN3@xmlNewPars:

; 1874 :     }
; 1875 :     return(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
$LN1@xmlNewPars:

; 1876 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlLineNumbersDefault
_TEXT	SEGMENT
_old$ = -4						; size = 4
_val$ = 8						; size = 4
_xmlLineNumbersDefault PROC				; COMDAT

; 2102 : xmlLineNumbersDefault(int val) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 2103 :     int old = xmlLineNumbersDefaultValue;

	call	___xmlLineNumbersDefaultValue
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _old$[ebp], eax

; 2104 : 
; 2105 :     xmlLineNumbersDefaultValue = val;

	call	___xmlLineNumbersDefaultValue
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx

; 2106 :     return(old);

	mov	eax, DWORD PTR _old$[ebp]

; 2107 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlLineNumbersDefault ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlPedanticParserDefault
_TEXT	SEGMENT
_old$ = -4						; size = 4
_val$ = 8						; size = 4
_xmlPedanticParserDefault PROC				; COMDAT

; 2084 : xmlPedanticParserDefault(int val) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 2085 :     int old = xmlPedanticParserDefaultValue;

	call	___xmlPedanticParserDefaultValue
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _old$[ebp], eax

; 2086 : 
; 2087 :     xmlPedanticParserDefaultValue = val;

	call	___xmlPedanticParserDefaultValue
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx

; 2088 :     return(old);

	mov	eax, DWORD PTR _old$[ebp]

; 2089 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPedanticParserDefault ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlKeepBlanksDefault
_TEXT	SEGMENT
_old$ = -4						; size = 4
_val$ = 8						; size = 4
_xmlKeepBlanksDefault PROC				; COMDAT

; 2156 : xmlKeepBlanksDefault(int val) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 2157 :     int old = xmlKeepBlanksDefaultValue;

	call	___xmlKeepBlanksDefaultValue
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _old$[ebp], eax

; 2158 : 
; 2159 :     xmlKeepBlanksDefaultValue = val;

	call	___xmlKeepBlanksDefaultValue
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx

; 2160 :     if (!val) xmlIndentTreeOutput = 1;

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN2@xmlKeepBla
	call	___xmlIndentTreeOutput
	mov	DWORD PTR [eax], 1
$LN2@xmlKeepBla:

; 2161 :     return(old);

	mov	eax, DWORD PTR _old$[ebp]

; 2162 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlKeepBlanksDefault ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlSubstituteEntitiesDefault
_TEXT	SEGMENT
_old$ = -4						; size = 4
_val$ = 8						; size = 4
_xmlSubstituteEntitiesDefault PROC			; COMDAT

; 2124 : xmlSubstituteEntitiesDefault(int val) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 2125 :     int old = xmlSubstituteEntitiesDefaultValue;

	call	___xmlSubstituteEntitiesDefaultValue
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _old$[ebp], eax

; 2126 : 
; 2127 :     xmlSubstituteEntitiesDefaultValue = val;

	call	___xmlSubstituteEntitiesDefaultValue
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], ecx

; 2128 :     return(old);

	mov	eax, DWORD PTR _old$[ebp]

; 2129 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSubstituteEntitiesDefault ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserInputGrow
_TEXT	SEGMENT
_content$ = -12						; size = 4
_indx$ = -8						; size = 4
_ret$ = -4						; size = 4
_in$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlParserInputGrow PROC				; COMDAT

; 300  : xmlParserInputGrow(xmlParserInputPtr in, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 301  :     int ret;
; 302  :     size_t indx;
; 303  :     const xmlChar *content;
; 304  : 
; 305  :     if ((in == NULL) || (len < 0)) return(-1);

	cmp	DWORD PTR _in$[ebp], 0
	je	SHORT $LN3@xmlParserI
	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN2@xmlParserI
$LN3@xmlParserI:
	or	eax, -1
	jmp	$LN1@xmlParserI
$LN2@xmlParserI:

; 306  : #ifdef DEBUG_INPUT
; 307  :     xmlGenericError(xmlGenericErrorContext, "Grow\n");
; 308  : #endif
; 309  :     if (in->buf == NULL) return(-1);

	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@xmlParserI
	or	eax, -1
	jmp	$LN1@xmlParserI
$LN4@xmlParserI:

; 310  :     if (in->base == NULL) return(-1);

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN5@xmlParserI
	or	eax, -1
	jmp	$LN1@xmlParserI
$LN5@xmlParserI:

; 311  :     if (in->cur == NULL) return(-1);

	mov	edx, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN6@xmlParserI
	or	eax, -1
	jmp	$LN1@xmlParserI
$LN6@xmlParserI:

; 312  :     if (in->buf->buffer == NULL) return(-1);

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN7@xmlParserI
	or	eax, -1
	jmp	$LN1@xmlParserI
$LN7@xmlParserI:

; 313  : 
; 314  :     CHECK_BUFFER(in);
; 315  : 
; 316  :     indx = in->cur - in->base;

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _indx$[ebp], ecx

; 317  :     if (xmlBufUse(in->buf->buffer) > (unsigned int) indx + INPUT_CHUNK) {

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufUse
	add	esp, 4
	mov	edx, DWORD PTR _indx$[ebp]
	add	edx, 250				; 000000faH
	cmp	eax, edx
	jbe	SHORT $LN8@xmlParserI

; 318  : 
; 319  : 	CHECK_BUFFER(in);
; 320  : 
; 321  :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlParserI
$LN8@xmlParserI:

; 322  :     }
; 323  :     if (in->buf->readcallback != NULL) {

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN9@xmlParserI

; 324  : 	ret = xmlParserInputBufferGrow(in->buf, len);

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlParserInputBufferGrow
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 325  :     } else

	jmp	SHORT $LN10@xmlParserI
$LN9@xmlParserI:

; 326  :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParserI
$LN10@xmlParserI:

; 327  : 
; 328  :     /*
; 329  :      * NOTE : in->base may be a "dangling" i.e. freed pointer in this
; 330  :      *        block, but we use it really as an integer to do some
; 331  :      *        pointer arithmetic. Insure will raise it as a bug but in
; 332  :      *        that specific case, that's not !
; 333  :      */
; 334  : 
; 335  :     content = xmlBufContent(in->buf->buffer);

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufContent
	add	esp, 4
	mov	DWORD PTR _content$[ebp], eax

; 336  :     if (in->base != content) {

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _content$[ebp]
	je	SHORT $LN11@xmlParserI

; 337  :         /*
; 338  : 	 * the buffer has been reallocated
; 339  : 	 */
; 340  : 	indx = in->cur - in->base;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _indx$[ebp], eax

; 341  : 	in->base = content;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 342  : 	in->cur = &content[indx];

	mov	eax, DWORD PTR _content$[ebp]
	add	eax, DWORD PTR _indx$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN11@xmlParserI:

; 343  :     }
; 344  :     in->end = xmlBufEnd(in->buf->buffer);

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufEnd
	add	esp, 4
	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [edx+20], eax

; 345  : 
; 346  :     CHECK_BUFFER(in);
; 347  : 
; 348  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParserI:

; 349  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserInputGrow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlParserInputRead
_TEXT	SEGMENT
_in$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlParserInputRead PROC				; COMDAT

; 284  : xmlParserInputRead(xmlParserInputPtr in ATTRIBUTE_UNUSED, int len ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 285  :     return(-1);

	or	eax, -1

; 286  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParserInputRead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Stream$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parserinternals.c
;	COMDAT _xmlCheckVersion
_TEXT	SEGMENT
_myversion$ = -4					; size = 4
_version$ = 8						; size = 4
_xmlCheckVersion PROC					; COMDAT

; 77   : xmlCheckVersion(int version) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __3A8479ED_parserinternals@c
	call	@__CheckForDebuggerJustMyCode@4

; 78   :     int myversion = (int) LIBXML_VERSION;

	mov	DWORD PTR _myversion$[ebp], 20909	; 000051adH

; 79   : 
; 80   :     xmlInitParser();

	call	_xmlInitParser

; 81   : 
; 82   :     if ((myversion / 10000) != (version / 10000)) {

	mov	eax, DWORD PTR _myversion$[ebp]
	cdq
	mov	ecx, 10000				; 00002710H
	idiv	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR _version$[ebp]
	cdq
	mov	esi, 10000				; 00002710H
	idiv	esi
	cmp	ecx, eax
	je	SHORT $LN2@xmlCheckVe

; 83   : 	xmlGenericError(xmlGenericErrorContext,

	mov	eax, DWORD PTR _myversion$[ebp]
	cdq
	mov	ecx, 10000				; 00002710H
	idiv	ecx
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _version$[ebp]
	cdq
	mov	ecx, 10000				; 00002710H
	idiv	ecx
	push	eax
	push	OFFSET ??_C@_0DL@NPLHMNMP@Fatal?3?5program?5compiled?5against@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 84   : 		"Fatal: program compiled against libxml %d using libxml %d\n",
; 85   : 		(version / 10000), (myversion / 10000));
; 86   : 	fprintf(stderr,

	mov	eax, DWORD PTR _myversion$[ebp]
	cdq
	mov	ecx, 10000				; 00002710H
	idiv	ecx
	push	eax
	mov	eax, DWORD PTR _version$[ebp]
	cdq
	mov	ecx, 10000				; 00002710H
	idiv	ecx
	push	eax
	push	OFFSET ??_C@_0DL@NPLHMNMP@Fatal?3?5program?5compiled?5against@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H
$LN2@xmlCheckVe:

; 87   : 		"Fatal: program compiled against libxml %d using libxml %d\n",
; 88   : 		(version / 10000), (myversion / 10000));
; 89   :     }
; 90   :     if ((myversion / 100) < (version / 100)) {

	mov	eax, DWORD PTR _myversion$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR _version$[ebp]
	cdq
	mov	esi, 100				; 00000064H
	idiv	esi
	cmp	ecx, eax
	jge	SHORT $LN1@xmlCheckVe

; 91   : 	xmlGenericError(xmlGenericErrorContext,

	mov	eax, DWORD PTR _myversion$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _version$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	push	eax
	push	OFFSET ??_C@_0DM@MEIIIPCN@Warning?3?5program?5compiled?5again@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlCheckVe:

; 92   : 		"Warning: program compiled against libxml %d using older %d\n",
; 93   : 		(version / 100), (myversion / 100));
; 94   :     }
; 95   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCheckVersion ENDP
_TEXT	ENDS
END
