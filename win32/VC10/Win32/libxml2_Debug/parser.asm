; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\parser.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_xmlParserMaxDepth
PUBLIC	??_C@_0P@HPOCOPDB@xml?9stylesheet@		; `string'
PUBLIC	??_C@_09OBPBGIJC@xml?9model@			; `string'
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
CONST	SEGMENT
_test_char_data DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	09H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	00H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	00H
	DB	03dH
	DB	03eH
	DB	03fH
	DB	040H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	05bH
	DB	05cH
	DB	00H
	DB	05eH
	DB	05fH
	DB	060H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	07cH
	DB	07dH
	DB	07eH
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__A40A425D_stat@h DB 01H
__B9AC27D5_parser@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_09OBPBGIJC@xml?9model@
CONST	SEGMENT
??_C@_09OBPBGIJC@xml?9model@ DB 'xml-model', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HPOCOPDB@xml?9stylesheet@
CONST	SEGMENT
??_C@_0P@HPOCOPDB@xml?9stylesheet@ DB 'xml-stylesheet', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlParserMaxDepth DD 0100H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_snprintf
PUBLIC	_xmlInitParser
PUBLIC	_xmlCleanupParser
PUBLIC	_xmlParseDoc
PUBLIC	_xmlParseFile
PUBLIC	_xmlParseMemory
PUBLIC	_xmlStopParser
PUBLIC	_xmlRecoverDoc
PUBLIC	_xmlRecoverMemory
PUBLIC	_xmlRecoverFile
PUBLIC	_xmlParseDocument
PUBLIC	_xmlParseExtParsedEnt
PUBLIC	_xmlSAXUserParseFile
PUBLIC	_xmlSAXUserParseMemory
PUBLIC	_xmlSAXParseDoc
PUBLIC	_xmlSAXParseMemory
PUBLIC	_xmlSAXParseMemoryWithData
PUBLIC	_xmlSAXParseFile
PUBLIC	_xmlSAXParseFileWithData
PUBLIC	_xmlSAXParseEntity
PUBLIC	_xmlParseEntity
PUBLIC	_xmlSAXParseDTD
PUBLIC	_xmlParseDTD
PUBLIC	_xmlIOParseDTD
PUBLIC	_xmlParseBalancedChunkMemory
PUBLIC	_xmlParseInNodeContext
PUBLIC	_xmlParseBalancedChunkMemoryRecover
PUBLIC	_xmlParseExternalEntity
PUBLIC	_xmlParseCtxtExternalEntity
PUBLIC	_xmlSetupParserForBuffer
PUBLIC	_xmlCreateDocParserCtxt
PUBLIC	_xmlCreatePushParserCtxt
PUBLIC	_xmlParseChunk
PUBLIC	_xmlCreateIOParserCtxt
PUBLIC	_xmlCtxtReset
PUBLIC	_xmlCtxtResetPush
PUBLIC	_xmlCtxtUseOptions
PUBLIC	_xmlReadDoc
PUBLIC	_xmlReadFile
PUBLIC	_xmlReadMemory
PUBLIC	_xmlReadFd
PUBLIC	_xmlReadIO
PUBLIC	_xmlCtxtReadDoc
PUBLIC	_xmlCtxtReadFile
PUBLIC	_xmlCtxtReadMemory
PUBLIC	_xmlCtxtReadFd
PUBLIC	_xmlCtxtReadIO
PUBLIC	_xmlHasFeature
PUBLIC	_xmlCreateFileParserCtxt
PUBLIC	_xmlCreateURLParserCtxt
PUBLIC	_xmlCreateMemoryParserCtxt
PUBLIC	_xmlCreateEntityParserCtxt
PUBLIC	_xmlPushInput
PUBLIC	_xmlPopInput
PUBLIC	_xmlSplitQName
PUBLIC	_xmlParseName
PUBLIC	_xmlParseNmtoken
PUBLIC	_xmlParseEntityValue
PUBLIC	_xmlParseAttValue
PUBLIC	_xmlParseSystemLiteral
PUBLIC	_xmlParsePubidLiteral
PUBLIC	_xmlParseCharData
PUBLIC	_xmlParseExternalID
PUBLIC	_xmlParseComment
PUBLIC	_xmlParsePITarget
PUBLIC	_xmlParsePI
PUBLIC	_xmlParseNotationDecl
PUBLIC	_xmlParseEntityDecl
PUBLIC	_xmlParseDefaultDecl
PUBLIC	_xmlParseNotationType
PUBLIC	_xmlParseEnumerationType
PUBLIC	_xmlParseEnumeratedType
PUBLIC	_xmlParseAttributeType
PUBLIC	_xmlParseAttributeListDecl
PUBLIC	_xmlParseElementMixedContentDecl
PUBLIC	_xmlParseElementChildrenContentDecl
PUBLIC	_xmlParseElementContentDecl
PUBLIC	_xmlParseElementDecl
PUBLIC	_xmlParseMarkupDecl
PUBLIC	_xmlParseCharRef
PUBLIC	_xmlParseEntityRef
PUBLIC	_xmlParseReference
PUBLIC	_xmlParsePEReference
PUBLIC	_xmlParseDocTypeDecl
PUBLIC	_xmlParseAttribute
PUBLIC	_xmlParseStartTag
PUBLIC	_xmlParseEndTag
PUBLIC	_xmlParseCDSect
PUBLIC	_xmlParseContent
PUBLIC	_xmlParseElement
PUBLIC	_xmlParseVersionNum
PUBLIC	_xmlParseVersionInfo
PUBLIC	_xmlParseEncName
PUBLIC	_xmlParseEncodingDecl
PUBLIC	_xmlParseSDDecl
PUBLIC	_xmlParseXMLDecl
PUBLIC	_xmlParseTextDecl
PUBLIC	_xmlParseMisc
PUBLIC	_xmlParseExternalSubset
PUBLIC	_xmlStringDecodeEntities
PUBLIC	_xmlStringLenDecodeEntities
PUBLIC	_nodePush
PUBLIC	_nodePop
PUBLIC	_inputPush
PUBLIC	_inputPop
PUBLIC	_namePop
PUBLIC	_namePush
PUBLIC	_xmlSkipBlankChars
PUBLIC	_xmlParserHandlePEReference
PUBLIC	_xmlCheckLanguageID
PUBLIC	_xmlSetEntityReferenceFunc
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BI@LJKBJNKP@Attribute?5?$CFs?5redefined?6@ ; `string'
PUBLIC	??_C@_0BL@GJOEMOIC@Attribute?5?$CFs?3?$CFs?5redefined?6@ ; `string'
PUBLIC	??_C@_0CD@IIBKOMHK@CharRef?3?5invalid?5hexadecimal?5va@ ; `string'
PUBLIC	??_C@_0BP@DEJKBBIB@CharRef?3?5invalid?5decimal?5value@ ; `string'
PUBLIC	??_C@_0BH@OCLALBPG@CharRef?3?5invalid?5value@	; `string'
PUBLIC	??_C@_0P@LPIEGNHB@internal?5error@		; `string'
PUBLIC	??_C@_0BP@MALDLPDI@PEReference?5at?5end?5of?5document@ ; `string'
PUBLIC	??_C@_0BG@GLMIGPKG@PEReference?5in?5prolog@	; `string'
PUBLIC	??_C@_0BG@JMKGIIGE@PEReference?5in?5epilog@	; `string'
PUBLIC	??_C@_0BF@DCHKIALM@PEReference?3?5no?5name@	; `string'
PUBLIC	??_C@_0BL@PFALGNCI@PEReference?3?5expecting?5?8?$DL?8@ ; `string'
PUBLIC	??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@ ; `string'
PUBLIC	??_C@_0BN@DPACNJHE@EntityValue?3?5?$CC?5or?5?8?5expected@ ; `string'
PUBLIC	??_C@_0CK@GAJOCPOL@PEReferences?5forbidden?5in?5inter@ ; `string'
PUBLIC	??_C@_0BK@ELBMECGA@AttValue?3?5?$CC?5or?5?8?5expected@ ; `string'
PUBLIC	??_C@_0CP@FNIFNHDI@Unescaped?5?8?$DM?8?5not?5allowed?5in?5at@ ; `string'
PUBLIC	??_C@_0BO@NINNHDOL@SystemLiteral?5?$CC?5or?5?8?5expected@ ; `string'
PUBLIC	??_C@_0CP@PIPOCKJD@Unfinished?5System?5or?5Public?5ID?5@ ; `string'
PUBLIC	??_C@_0CG@PLPMIKHI@Sequence?5?8?$FN?$FN?$DO?8?5not?5allowed?5in?5c@ ; `string'
PUBLIC	??_C@_0CF@GDPMMHJJ@SYSTEM?5or?5PUBLIC?0?5the?5URI?5is?5mi@ ; `string'
PUBLIC	??_C@_0CJ@ICNPKBIN@PUBLIC?0?5the?5Public?5Identifier?5i@ ; `string'
PUBLIC	??_C@_0CO@IKEFGBAE@Comment?5must?5not?5contain?5?8?9?9?8?5?$CI@ ; `string'
PUBLIC	??_C@_0BM@HPBPCNCM@xmlParsePI?5?3?5no?5target?5name@ ; `string'
PUBLIC	??_C@_0BA@KMPMBNCM@Invalid?5PI?5name@		; `string'
PUBLIC	??_C@_0BN@HECCFNBP@NOTATION?3?5Name?5expected?5here@ ; `string'
PUBLIC	??_C@_0CL@MHMGOJAD@?8?$DO?8?5required?5to?5close?5NOTATION?5@ ; `string'
PUBLIC	??_C@_0BG@LMNHCPFE@Entity?5value?5required@	; `string'
PUBLIC	??_C@_0BF@DMGJOFPK@Fragment?5not?5allowed@	; `string'
PUBLIC	??_C@_0CK@NNFMCGNH@?8?$CI?8?5required?5to?5start?5ATTLIST?5e@ ; `string'
PUBLIC	??_C@_0CI@EHCBGKID@NmToken?5expected?5in?5ATTLIST?5enu@ ; `string'
PUBLIC	??_C@_0CL@KPIIIINI@?8?$CJ?8?5required?5to?5finish?5ATTLIST?5@ ; `string'
PUBLIC	??_C@_0CI@LOAMKAA@MixedContentDecl?5?3?5?8?$HM?8?5or?5?8?$CJ?$CK?8?5@ ; `string'
PUBLIC	??_C@_0CG@HEHENOGB@MixedContentDecl?5?3?5?8?$CDPCDATA?8?5ex@ ; `string'
PUBLIC	??_C@_0CD@NHADBOBB@ContentDecl?5?3?5Name?5or?5?8?$CI?8?5expec@ ; `string'
PUBLIC	??_C@_0CG@EHNJPHMB@ContentDecl?5?3?5?8?0?8?5?8?$HM?8?5or?5?8?$CJ?8?5ex@ ; `string'
PUBLIC	??_C@_0DN@CEDHFOGD@PEReference?3?5forbidden?5within?5m@ ; `string'
PUBLIC	??_C@_0N@HPGHEIE@expected?5?8?$DO?8@		; `string'
PUBLIC	??_C@_0CF@GGBMHDE@XML?5conditional?5section?5?8?$FL?8?5exp@ ; `string'
PUBLIC	??_C@_0CF@HHCGNGIK@Content?5error?5in?5the?5external?5s@ ; `string'
PUBLIC	??_C@_0DH@JDEKAAA@conditional?5section?5INCLUDE?5or?5@ ; `string'
PUBLIC	??_C@_0CD@OHPJFFIN@XML?5conditional?5section?5not?5clo@ ; `string'
PUBLIC	??_C@_0CC@HHECNJCA@Text?5declaration?5?8?$DM?$DPxml?8?5requir@ ; `string'
PUBLIC	??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@ ; `string'
PUBLIC	??_C@_0CO@LJALGGHL@external?5parsed?5entities?5cannot@ ; `string'
PUBLIC	??_C@_0BJ@KLEMOBLL@EntityRef?3?5expecting?5?8?$DL?8@ ; `string'
PUBLIC	??_C@_0BO@NIFLODD@DOCTYPE?5improperly?5terminated@ ; `string'
PUBLIC	??_C@_0BH@ELMJBAIC@EndTag?3?5?8?$DM?1?8?5not?5found@ ; `string'
PUBLIC	??_C@_0N@FLAMKNN@expected?5?8?$DN?8@		; `string'
PUBLIC	??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@ ; `string'
PUBLIC	??_C@_0CE@EGHHEGNE@String?5not?5started?5expecting?5?8?5@ ; `string'
PUBLIC	??_C@_0BK@CMOJKGNC@Invalid?5XML?5encoding?5name@ ; `string'
PUBLIC	??_C@_0CG@MBLHCBEE@standalone?5accepts?5only?5?8yes?8?5o@ ; `string'
PUBLIC	??_C@_0BC@LDMJLCHP@Document?5is?5empty@		; `string'
PUBLIC	??_C@_0CJ@JKANOFNI@Extra?5content?5at?5the?5end?5of?5the@ ; `string'
PUBLIC	??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@ ; `string'
PUBLIC	??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@ ; `string'
PUBLIC	??_C@_0CI@FHFOLBEM@Malformed?5declaration?5expecting@ ; `string'
PUBLIC	??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@ ; `string'
PUBLIC	??_C@_0BL@COECCIID@Unregistered?5error?5message@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_03PJHHNEEI@xml@				; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns@				; `string'
PUBLIC	??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ ; `string'
PUBLIC	??_C@_08OIBPHJGN@external@			; `string'
PUBLIC	??_C@_0BD@KIFBOAFI@Pbm?5popping?5?$CFd?5NS?6@	; `string'
PUBLIC	??_C@_0DL@HADOBDDE@Excessive?5depth?5in?5document?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0BC@BAMNGBKO@Huge?5input?5lookup@		; `string'
PUBLIC	??_C@_0BH@JOKBAJC@cur?5index?5out?5of?5bound@	; `string'
PUBLIC	??_C@_0BC@LEKDBCEK@Popping?5input?5?$CFd?6@	; `string'
PUBLIC	??_C@_0CC@JODEMIEP@Unfinished?5entity?5outside?5the?5D@ ; `string'
PUBLIC	??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@	; `string'
PUBLIC	??_C@_0BK@IPLLKNJK@Pushing?5input?5?$CFd?5?3?5?$CF?430s?6@ ; `string'
PUBLIC	??_C@_0CL@KEGPHPPF@xmlParseCharRef?3?5invalid?5xmlCha@ ; `string'
PUBLIC	??_C@_0DB@EJFBNJEE@xmlParseStringCharRef?3?5invalid?5@ ; `string'
PUBLIC	??_C@_0CJ@JICBMJMM@String?5decoding?5Entity?5Referenc@ ; `string'
PUBLIC	??_C@_0CC@KGDPFIJL@predefined?5entity?5has?5no?5conten@ ; `string'
PUBLIC	??_C@_0CF@DIAKJGNK@String?5decoding?5PE?5Reference?3?5?$CF@ ; `string'
PUBLIC	??_C@_0DH@IENLJLFO@not?5validating?5will?5not?5read?5co@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0CI@GHNHPHHB@Name?5?$CFs?5is?5not?5XML?5Namespace?5co@ ; `string'
PUBLIC	??_C@_04FABLJDN@Name@				; `string'
PUBLIC	??_C@_0CC@JIBKNHBD@unexpected?5change?5of?5input?5buff@ ; `string'
PUBLIC	??_C@_06MDLHOHLI@NCName@			; `string'
PUBLIC	??_C@_07JJJDEIPB@NmToken@			; `string'
PUBLIC	??_C@_0DM@GJGLHMKL@EntityValue?3?5?8?$CFc?8?5forbidden?5exc@ ; `string'
PUBLIC	??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@ ; `string'
PUBLIC	??_C@_0CG@LEIKKIHB@invalid?5character?5in?5attribute?5@ ; `string'
PUBLIC	??_C@_0BG@NKOFEMFC@AttValue?3?5?8?5expected?6@	; `string'
PUBLIC	??_C@_0O@CPJEEBHF@SystemLiteral@		; `string'
PUBLIC	??_C@_09HLIINGHD@Public?5ID@			; `string'
PUBLIC	??_C@_0BO@IODKMKKF@PCDATA?5invalid?5Char?5value?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BP@CCMMHADN@Space?5required?5after?5?8SYSTEM?8?6@ ; `string'
PUBLIC	??_C@_0BP@EHONNEAJ@Space?5required?5after?5?8PUBLIC?8?6@ ; `string'
PUBLIC	??_C@_0CM@PJLPICDD@Space?5required?5after?5the?5Public@ ; `string'
PUBLIC	??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@ ; `string'
PUBLIC	??_C@_0BG@BAOBDEOI@Comment?5too?5big?5found@	; `string'
PUBLIC	??_C@_0CD@MHPLKFMN@Comment?5not?5terminated?5?6?$DM?$CB?9?9?$CF?45@ ; `string'
PUBLIC	??_C@_0DD@BIJIOHJJ@Comment?5doesn?8t?5start?5and?5stop?5@ ; `string'
PUBLIC	??_C@_0BI@ELKFFAAB@Comment?5not?5terminated?6@	; `string'
PUBLIC	??_C@_0DD@DDHAOEGP@comment?5doesn?8t?5start?5and?5stop?5@ ; `string'
PUBLIC	??_C@_0CJ@CBOBCJAG@Double?5hyphen?5within?5comment?3?5?$DM@ ; `string'
PUBLIC	??_C@_0BO@PENANJHM@Double?5hyphen?5within?5comment?6@ ; `string'
PUBLIC	??_C@_0DL@PMHMGOPA@XML?5declaration?5allowed?5only?5at@ ; `string'
PUBLIC	??_C@_0CN@KJOCGNCM@xmlParsePITarget?3?5invalid?5name?5@ ; `string'
PUBLIC	??_C@_0CJ@KOKAGEDL@colons?5are?5forbidden?5from?5PI?5na@ ; `string'
PUBLIC	??_C@_07MFFOOIHD@catalog@			; `string'
PUBLIC	??_C@_0BN@MALFACIE@Catalog?5PI?5syntax?5error?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DK@LAKAFNGA@PI?5declaration?5doesn?8t?5start?5an@ ; `string'
PUBLIC	??_C@_0BP@KBNJPEOK@ParsePI?3?5PI?5?$CFs?5space?5expected?6@ ; `string'
PUBLIC	??_C@_0BE@KDNCGJGM@PI?5?$CFs?5too?5big?5found@	; `string'
PUBLIC	??_C@_0BO@OGPJFKEP@ParsePI?3?5PI?5?$CFs?5never?5end?5?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BC@IDENENGP@oasis?9xml?9catalog@		; `string'
PUBLIC	??_C@_0CD@ILKLDDEI@Space?5required?5after?5?8?$DM?$CBNOTATIO@ ; `string'
PUBLIC	??_C@_0CP@BOHPCDLP@colons?5are?5forbidden?5from?5notat@ ; `string'
PUBLIC	??_C@_0CJ@PMDGLIHG@Space?5required?5after?5the?5NOTATI@ ; `string'
PUBLIC	??_C@_0EA@DCHCOJDP@Notation?5declaration?5doesn?8t?5st@ ; `string'
PUBLIC	??_C@_0CB@NEOBPNBE@Space?5required?5after?5?8?$DM?$CBENTITY?8@ ; `string'
PUBLIC	??_C@_0BL@KGADBCMF@Space?5required?5after?5?8?$CF?$CF?8?6@ ; `string'
PUBLIC	??_C@_0BN@GJOFDJCB@xmlParseEntityDecl?3?5no?5name?6@ ; `string'
PUBLIC	??_C@_0CP@IEOCAMEB@colons?5are?5forbidden?5from?5entit@ ; `string'
PUBLIC	??_C@_0CG@IGJCKADK@Space?5required?5after?5the?5entity@ ; `string'
PUBLIC	??_C@_0BB@JHEINHI@Invalid?5URI?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@ ; `string'
PUBLIC	??_C@_0P@IDBIGKBI@New?5Doc?5failed@		; `string'
PUBLIC	??_C@_04PADNKBEK@fake@				; `string'
PUBLIC	??_C@_0BP@NPDMAEIM@Space?5required?5before?5?8NDATA?8?6@ ; `string'
PUBLIC	??_C@_0BO@GLBCJEIC@Space?5required?5after?5?8NDATA?8?6@ ; `string'
PUBLIC	??_C@_0CO@GFOAPJBJ@xmlParseEntityDecl?3?5entity?5?$CFs?5n@ ; `string'
PUBLIC	??_C@_0DO@BLCODNOK@Entity?5declaration?5doesn?8t?5star@ ; `string'
PUBLIC	??_C@_0BP@LOJANMBO@Space?5required?5after?5?8?$CDFIXED?8?6@ ; `string'
PUBLIC	??_C@_0CL@MHGJEBGE@Attribute?5default?5value?5declara@ ; `string'
PUBLIC	??_C@_0CH@MHDABFNP@Name?5expected?5in?5NOTATION?5decla@ ; `string'
PUBLIC	??_C@_0DK@HOPAGHFB@standalone?3?5attribute?5notation?5@ ; `string'
PUBLIC	??_C@_0DN@GKJDABEM@standalone?3?5attribute?5enumerati@ ; `string'
PUBLIC	??_C@_0CB@FOEKPMO@Space?5required?5after?5?8NOTATION?8@ ; `string'
PUBLIC	??_C@_0CC@DODLEJBN@Space?5required?5after?5?8?$DM?$CBATTLIST@ ; `string'
PUBLIC	??_C@_0BO@PIKFFONH@ATTLIST?3?5no?5name?5for?5Element?6@ ; `string'
PUBLIC	??_C@_0CA@GKDLKFPE@ATTLIST?3?5no?5name?5for?5Attribute?6@ ; `string'
PUBLIC	??_C@_0CJ@BMNHNBNL@Space?5required?5after?5the?5attrib@ ; `string'
PUBLIC	??_C@_0CJ@EMHJKDCH@Space?5required?5after?5the?5attrib@ ; `string'
PUBLIC	??_C@_0DC@NGABIAJF@Space?5required?5after?5the?5attrib@ ; `string'
PUBLIC	??_C@_0EG@JGLJABBC@Attribute?5list?5declaration?5does@ ; `string'
PUBLIC	??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@ ; `string'
PUBLIC	??_C@_0DB@BEFMOJIK@xmlParseElementMixedContentDecl@ ; `string'
PUBLIC	??_C@_0EM@OINCFINP@xmlParseElementChildrenContentD@ ; `string'
PUBLIC	??_C@_0DE@IJONAOBP@xmlParseElementChildrenContentD@ ; `string'
PUBLIC	??_C@_0CO@FLMKOMHK@xmlParseElementContentDecl?5?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0CA@CIGPNPNK@Space?5required?5after?5?8ELEMENT?8?6@ ; `string'
PUBLIC	??_C@_0CK@LMDMNJGO@xmlParseElementDecl?3?5no?5name?5fo@ ; `string'
PUBLIC	??_C@_0CH@MFBAJJC@Space?5required?5after?5the?5elemen@ ; `string'
PUBLIC	??_C@_0DO@COHAOPDG@PEReference?3?5forbidden?5within?5m@ ; `string'
PUBLIC	??_C@_0DF@CHNHOLDO@xmlParseElementDecl?3?5?8EMPTY?8?0?5?8@ ; `string'
PUBLIC	??_C@_0DP@KIKIPMFE@Element?5declaration?5doesn?8t?5sta@ ; `string'
PUBLIC	??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@ ; `string'
PUBLIC	??_C@_0CG@FMCBAD@Entering?5INCLUDE?5Conditional?5Se@ ; `string'
PUBLIC	??_C@_0CF@KBFPDCLM@Leaving?5INCLUDE?5Conditional?5Sec@ ; `string'
PUBLIC	??_C@_0CF@BNLECKJM@Entering?5IGNORE?5Conditional?5Sec@ ; `string'
PUBLIC	??_C@_0CE@MPDEOLDN@Leaving?5IGNORE?5Conditional?5Sect@ ; `string'
PUBLIC	??_C@_0BM@OIPNJGND@Space?5needed?5after?5?8?$DM?$DPxml?8?6@ ; `string'
PUBLIC	??_C@_03HLLJOCDO@1?40@				; `string'
PUBLIC	??_C@_0BD@LJKHCJDH@Space?5needed?5here?6@	; `string'
PUBLIC	??_C@_0CG@OFFEFIEL@Missing?5encoding?5in?5text?5declar@ ; `string'
PUBLIC	??_C@_04FNNDIGBC@?$CDx?$CFX@			; `string'
PUBLIC	??_C@_03FDCLAKJL@?$CD?$CFd@			; `string'
PUBLIC	??_C@_0BL@EBFCDHBG@invalid?5entity?5type?5found?6@ ; `string'
PUBLIC	??_C@_0BN@EOPGEOPH@Entity?5?8?$CFs?8?5failed?5to?5parse?6@ ; `string'
PUBLIC	??_C@_07DALNPEGO@nbktext@			; `string'
PUBLIC	??_C@_0BM@NMGBIIDP@xmlParseEntityRef?3?5no?5name?6@ ; `string'
PUBLIC	??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@ ; `string'
PUBLIC	??_C@_0CI@ILCMJJAO@Entity?5reference?5to?5unparsed?5en@ ; `string'
PUBLIC	??_C@_0CL@HLODLGOA@Attribute?5references?5external?5e@ ; `string'
PUBLIC	??_C@_0DI@FDECCCAO@?8?$DM?8?5in?5entity?5?8?$CFs?8?5is?5not?5allow@ ; `string'
PUBLIC	??_C@_0DA@CCPGIFBP@Attempt?5to?5reference?5the?5parame@ ; `string'
PUBLIC	??_C@_0CC@PKJKLMCM@xmlParseStringEntityRef?3?5no?5nam@ ; `string'
PUBLIC	??_C@_0BG@DIAKGNKN@PEReference?3?5no?5name?6@	; `string'
PUBLIC	??_C@_0BB@MFPJKDDB@PEReference?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@ ; `string'
PUBLIC	??_C@_0CL@BLGDJGPF@Internal?3?5?$CF?$CF?$CFs?$DL?5is?5not?5a?5parame@ ; `string'
PUBLIC	??_C@_0CF@PMEPEHIL@xmlLoadEntityContent?5parameter?5@ ; `string'
PUBLIC	??_C@_0CB@NCAMLBBH@Reading?5?$CFs?5entity?5content?5input@ ; `string'
PUBLIC	??_C@_0CB@HEAOEFBK@xmlLoadEntityContent?5input?5erro@ ; `string'
PUBLIC	??_C@_0CN@NHLEKBNA@xmlLoadEntityContent?3?5invalid?5c@ ; `string'
PUBLIC	??_C@_0CE@PLGLFALL@xmlParseStringPEReference?3?5no?5n@ ; `string'
PUBLIC	??_C@_0CB@HMFAEMHO@?$CF?$CF?$CFs?$DL?5is?5not?5a?5parameter?5entity@ ; `string'
PUBLIC	??_C@_0CJ@JPAMJNGL@xmlParseDocTypeDecl?5?3?5no?5DOCTYP@ ; `string'
PUBLIC	??_C@_0DO@IJLBCNCA@xmlParseInternalSubset?3?5error?5d@ ; `string'
PUBLIC	??_C@_0BO@BHLKDNI@error?5parsing?5attribute?5name?6@ ; `string'
PUBLIC	??_C@_0CP@LHHGCLP@Specification?5mandates?5value?5fo@ ; `string'
PUBLIC	??_C@_08EHDJCMMM@xml?3lang@			; `string'
PUBLIC	??_C@_0CD@OAOAJGL@Malformed?5value?5for?5xml?3lang?5?3?5@ ; `string'
PUBLIC	??_C@_09HKHFJOKD@xml?3space@			; `string'
PUBLIC	??_C@_07DLHCIBDH@default@			; `string'
PUBLIC	??_C@_08ILAKLJGO@preserve@			; `string'
PUBLIC	??_C@_0EF@GNALPKCP@Invalid?5value?5?$CC?$CFs?$CC?5for?5xml?3spac@ ; `string'
PUBLIC	??_C@_0CI@FEOPKDBB@xmlParseStartTag?3?5invalid?5eleme@ ; `string'
PUBLIC	??_C@_0BM@FKPAGOOK@attributes?5construct?5error?6@ ; `string'
PUBLIC	??_C@_0CO@KAECIKGE@xmlParseStartTag?3?5problem?5parsi@ ; `string'
PUBLIC	??_C@_0CA@PJGJPBIH@xmlParseEndTag?3?5?8?$DM?1?8?5not?5found?6@ ; `string'
PUBLIC	??_C@_0M@IAMGGMFE@unparseable@			; `string'
PUBLIC	??_C@_0DE@OCMDIBAP@Opening?5and?5ending?5tag?5mismatch@ ; `string'
PUBLIC	??_C@_0BM@DBJGDKCH@Failed?5to?5parse?5QName?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BN@MNDCJBCK@Failed?5to?5parse?5QName?5?8?$CFs?3?8?6@ ; `string'
PUBLIC	??_C@_0CA@HECGKKLP@Failed?5to?5parse?5QName?5?8?$CFs?3?$CFs?3?8?6@ ; `string'
PUBLIC	??_C@_04IOHABJIC@lang@				; `string'
PUBLIC	??_C@_05OLNILLAB@space@				; `string'
PUBLIC	??_C@_0CA@LKOHNLNN@StartTag?3?5invalid?5element?5name?6@ ; `string'
PUBLIC	??_C@_0BO@NHFMDAKF@dictionary?5allocation?5failure@ ; `string'
PUBLIC	??_C@_0CA@IPMJMNFH@xmlns?3?5?8?$CFs?8?5is?5not?5a?5valid?5URI?6@ ; `string'
PUBLIC	??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@ ; `string'
PUBLIC	??_C@_0DD@IPHAILAA@xml?5namespace?5URI?5cannot?5be?5the@ ; `string'
PUBLIC	??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@ ; `string'
PUBLIC	??_C@_0DA@DPCHHACL@reuse?5of?5the?5xmlns?5namespace?5na@ ; `string'
PUBLIC	??_C@_0CK@HOGKMNCM@xml?5namespace?5prefix?5mapped?5to?5@ ; `string'
PUBLIC	??_C@_0CK@HFNNIPGF@xml?5namespace?5URI?5mapped?5to?5wro@ ; `string'
PUBLIC	??_C@_0CP@FCHEBDCM@redefinition?5of?5the?5xmlns?5prefi@ ; `string'
PUBLIC	??_C@_0CO@JLGJJKB@xmlns?3?$CFs?3?5Empty?5XML?5namespace?5i@ ; `string'
PUBLIC	??_C@_0CD@IMLPGLBN@xmlns?3?$CFs?3?5?8?$CFs?8?5is?5not?5a?5valid?5U@ ; `string'
PUBLIC	??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@ ; `string'
PUBLIC	??_C@_0BM@HDEBIHCG@Unexpected?5change?5of?5input?6@ ; `string'
PUBLIC	??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0DB@GMKAHOEK@Namespace?5prefix?5?$CFs?5for?5?$CFs?5on?5?$CF@ ; `string'
PUBLIC	??_C@_0CL@BDHHCEFP@Namespaced?5Attribute?5?$CFs?5in?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_0CK@EJLCFGPG@Namespace?5prefix?5?$CFs?5on?5?$CFs?5is?5no@ ; `string'
PUBLIC	??_C@_0BM@HGOGNNNB@CData?5section?5too?5big?5found@ ; `string'
PUBLIC	??_C@_0CC@HAEHMHLE@CData?5section?5not?5finished?6?$CF?450@ ; `string'
PUBLIC	??_C@_0CG@FCFCBOFE@detected?5an?5error?5in?5element?5co@ ; `string'
PUBLIC	??_C@_0CL@LKDFGLKB@Couldn?8t?5find?5end?5of?5Start?5Tag?5@ ; `string'
PUBLIC	??_C@_0CJ@JPBGMEM@Premature?5end?5of?5data?5in?5tag?5?$CFs@ ; `string'
PUBLIC	??_C@_06KNDPGIKI@UTF?916@			; `string'
PUBLIC	??_C@_05MNCHLHCA@UTF16@				; `string'
PUBLIC	??_C@_0DA@MEEPFAA@Document?5labelled?5UTF?916?5but?5ha@ ; `string'
PUBLIC	??_C@_05EGJIMALK@UTF?98@			; `string'
PUBLIC	??_C@_04OOMJJNCF@UTF8@				; `string'
PUBLIC	??_C@_0BJ@FCHADMKI@Unsupported?5encoding?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BM@BPKNILCI@Blank?5needed?5after?5?8?$DM?$DPxml?8?6@ ; `string'
PUBLIC	??_C@_0BK@MGCDLOCB@Unsupported?5version?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BD@KLGEONFL@Blank?5needed?5here?6@	; `string'
PUBLIC	??_C@_0CD@NCHPNICC@Start?5tag?5expected?0?5?8?$DM?8?5not?5fou@ ; `string'
PUBLIC	??_C@_0CC@HDEJLGKL@Internal?5error?3?5xmlParseGetLast@ ; `string'
PUBLIC	??_C@_0CD@HIMAKCPA@Couldn?8t?5find?5end?5of?5Start?5Tag?5@ ; `string'
PUBLIC	??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@		; `string'
PUBLIC	??_C@_0CG@PHGFCMFA@PP?3?5internal?5error?0?5state?5?$DN?$DN?5CO@ ; `string'
PUBLIC	??_C@_0CE@CFNIBLKF@PP?3?5internal?5error?0?5state?5?$DN?$DN?5IG@ ; `string'
PUBLIC	??_C@_0CB@LNKCECMO@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PI@ ; `string'
PUBLIC	??_C@_0CK@EGFEGMNP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@ ; `string'
PUBLIC	??_C@_0CL@FDJCPJGL@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@ ; `string'
PUBLIC	??_C@_0CO@BNGPOFIK@PP?3?5internal?5error?0?5state?5?$DN?$DN?5AT@ ; `string'
PUBLIC	??_C@_0CN@JHJPBNDP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5SY@ ; `string'
PUBLIC	??_C@_0CN@LJGHMOAD@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PU@ ; `string'
PUBLIC	??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@ ; `string'
PUBLIC	??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@ ; `string'
PUBLIC	??_C@_05FPCKGDIJ@UCS?94@			; `string'
PUBLIC	??_C@_04JFFPNMJE@UCS4@				; `string'
PUBLIC	??_C@_0BO@IBAMLEHI@xmlParseChunk?3?5encoder?5error?6@ ; `string'
PUBLIC	??_C@_01LIIJDEN@?$AN@				; `string'
PUBLIC	??_C@_0CA@CCOLJACP@creating?5parser?3?5out?5of?5memory?6@ ; `string'
PUBLIC	??_C@_04CGFJFPFD@none@				; `string'
PUBLIC	??_C@_0L@OLLEMIAI@pseudoroot@			; `string'
PUBLIC	??_C@_0CO@FDJENMMD@Version?5mismatch?5between?5docume@ ; `string'
PUBLIC	??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@ ; `string'
PUBLIC	??_C@_0CD@FOJADJIB@parsing?5new?5buffer?3?5out?5of?5memo@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlCharStrdup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrcasestr:PROC
EXTRN	_xmlStrncmp:PROC
EXTRN	_xmlStrcasecmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	___htmlParseContent:PROC
EXTRN	___xmlGlobalInitMutexLock:PROC
EXTRN	___xmlGlobalInitMutexUnlock:PROC
EXTRN	_xmlInputReadCallbackNop:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	_xmlInitMemory:PROC
EXTRN	_xmlCleanupMemory:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlInitializeDict:PROC
EXTRN	_xmlDictSetLimit:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictOwns:PROC
EXTRN	_xmlDictCleanup:PROC
EXTRN	_xmlBuildQName:PROC
EXTRN	_xmlSplitQName3:PROC
EXTRN	_xmlBufferCreate:PROC
EXTRN	_xmlBufferFree:PROC
EXTRN	_xmlBufferAdd:PROC
EXTRN	_xmlCreateIntSubset:PROC
EXTRN	_xmlNewDtd:PROC
EXTRN	_xmlNewDoc:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlNewDocNode:PROC
EXTRN	_xmlNewComment:PROC
EXTRN	_xmlDocCopyNode:PROC
EXTRN	_xmlGetLastChild:PROC
EXTRN	_xmlNodeIsText:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlAddChildList:PROC
EXTRN	_xmlUnlinkNode:PROC
EXTRN	_xmlFreeNodeList:PROC
EXTRN	_xmlFreeNode:PROC
EXTRN	_xmlSetTreeDoc:PROC
EXTRN	_xmlSearchNsByHref:PROC
EXTRN	_xmlHashCreateDict:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashDefaultDeallocator:PROC
EXTRN	_xmlHashAddEntry2:PROC
EXTRN	_xmlHashUpdateEntry2:PROC
EXTRN	_xmlHashRemoveEntry2:PROC
EXTRN	_xmlHashLookup2:PROC
EXTRN	_xmlHashQLookup2:PROC
EXTRN	_xmlHashSize:PROC
EXTRN	_xmlHashScanFull:PROC
EXTRN	_initGenericErrorDefaultFunc:PROC
EXTRN	_xmlResetLastError:PROC
EXTRN	_xmlResetError:PROC
EXTRN	_xmlCopyError:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlNewDocElementContent:PROC
EXTRN	_xmlFreeDocElementContent:PROC
EXTRN	_xmlCreateEnumeration:PROC
EXTRN	_xmlFreeEnumeration:PROC
EXTRN	_xmlValidateRoot:PROC
EXTRN	_xmlValidateElement:PROC
EXTRN	_xmlIsMixedElement:PROC
EXTRN	_xmlGetPredefinedEntity:PROC
EXTRN	_xmlInitCharEncodingHandlers:PROC
EXTRN	_xmlCleanupCharEncodingHandlers:PROC
EXTRN	_xmlFindCharEncodingHandler:PROC
EXTRN	_xmlDetectCharEncoding:PROC
EXTRN	_xmlCleanupInputCallbacks:PROC
EXTRN	_xmlRegisterDefaultInputCallbacks:PROC
EXTRN	_xmlAllocParserInputBuffer:PROC
EXTRN	_xmlParserInputBufferCreateFd:PROC
EXTRN	_xmlParserInputBufferCreateMem:PROC
EXTRN	_xmlParserInputBufferCreateIO:PROC
EXTRN	_xmlParserInputBufferPush:PROC
EXTRN	_xmlFreeParserInputBuffer:PROC
EXTRN	_xmlParserGetDirectory:PROC
EXTRN	_xmlCleanupOutputCallbacks:PROC
EXTRN	_xmlRegisterDefaultOutputCallbacks:PROC
EXTRN	_xmlParserInputGrow:PROC
EXTRN	_xmlNewParserCtxt:PROC
EXTRN	_xmlClearParserCtxt:PROC
EXTRN	_xmlFreeParserCtxt:PROC
EXTRN	_xmlNewIOInputStream:PROC
EXTRN	_xmlInitNodeInfoSeq:PROC
EXTRN	_xmlParserAddNodeInfo:PROC
EXTRN	_xmlLoadExternalEntity:PROC
EXTRN	_xmlSAX2GetEntity:PROC
EXTRN	_xmlSAX2EntityDecl:PROC
EXTRN	_xmlSAX2StartElement:PROC
EXTRN	_xmlSAX2EndElement:PROC
EXTRN	_xmlSAX2IgnorableWhitespace:PROC
EXTRN	_htmlDefaultSAXHandlerInit:PROC
EXTRN	_xmlDefaultSAXHandlerInit:PROC
EXTRN	_xmlInitGlobals:PROC
EXTRN	_xmlCleanupGlobals:PROC
EXTRN	___xmlDefaultSAXHandler:PROC
EXTRN	___xmlDefaultSAXLocator:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	___xmlParserDebugEntities:PROC
EXTRN	_xmlInitThreads:PROC
EXTRN	_xmlCleanupThreads:PROC
EXTRN	_htmlCreateMemoryParserCtxt:PROC
EXTRN	_xmlCharInRange:PROC
EXTRN	_xmlSwitchEncoding:PROC
EXTRN	_xmlSwitchToEncoding:PROC
EXTRN	___xmlErrEncoding:PROC
EXTRN	_xmlNewStringInputStream:PROC
EXTRN	_xmlNewEntityInputStream:PROC
EXTRN	_xmlFreeInputStream:PROC
EXTRN	_xmlNewInputStream:PROC
EXTRN	_xmlStringCurrentChar:PROC
EXTRN	_xmlCurrentChar:PROC
EXTRN	_xmlCopyCharMultiByte:PROC
EXTRN	_xmlCopyChar:PROC
EXTRN	_xmlNextChar:PROC
EXTRN	_xmlParserInputShrink:PROC
EXTRN	_htmlInitAutoClose:PROC
EXTRN	_xmlErrMemory:PROC
EXTRN	_xmlBuildURI:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlCanonicPath:PROC
EXTRN	_xmlCatalogCleanup:PROC
EXTRN	_xmlCatalogFreeLocal:PROC
EXTRN	_xmlCatalogAddLocal:PROC
EXTRN	_xmlCatalogGetDefaults:PROC
EXTRN	_xmlSchemaCleanupTypes:PROC
EXTRN	_xmlRelaxNGCleanupTypes:PROC
EXTRN	_xmlBufIsEmpty:PROC
EXTRN	_xmlBufResetInput:PROC
EXTRN	_xmlBufGetInputBase:PROC
EXTRN	_xmlBufSetInputBaseCur:PROC
EXTRN	_xmlCharEncInput:PROC
EXTRN	_xmlXPathInit:PROC
EXTRN	_xmlGenericErrorDefaultFunc:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlEntityRefFunc DD 01H DUP (?)
_xmlParserInitialized DD 01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CD@FOJADJIB@parsing?5new?5buffer?3?5out?5of?5memo@
CONST	SEGMENT
??_C@_0CD@FOJADJIB@parsing?5new?5buffer?3?5out?5of?5memo@ DB 'parsing new'
	DB	' buffer: out of memory', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@
CONST	SEGMENT
??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@ DB 'cannot allocate'
	DB	' parser context', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FDJENMMD@Version?5mismatch?5between?5docume@
CONST	SEGMENT
??_C@_0CO@FDJENMMD@Version?5mismatch?5between?5docume@ DB 'Version mismat'
	DB	'ch between document and entity', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OLLEMIAI@pseudoroot@
CONST	SEGMENT
??_C@_0L@OLLEMIAI@pseudoroot@ DB 'pseudoroot', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGFJFPFD@none@
CONST	SEGMENT
??_C@_04CGFJFPFD@none@ DB 'none', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CCOLJACP@creating?5parser?3?5out?5of?5memory?6@
CONST	SEGMENT
??_C@_0CA@CCOLJACP@creating?5parser?3?5out?5of?5memory?6@ DB 'creating pa'
	DB	'rser: out of memory', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LIIJDEN@?$AN@
CONST	SEGMENT
??_C@_01LIIJDEN@?$AN@ DB 0dH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IBAMLEHI@xmlParseChunk?3?5encoder?5error?6@
CONST	SEGMENT
??_C@_0BO@IBAMLEHI@xmlParseChunk?3?5encoder?5error?6@ DB 'xmlParseChunk: '
	DB	'encoder error', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFFPNMJE@UCS4@
CONST	SEGMENT
??_C@_04JFFPNMJE@UCS4@ DB 'UCS4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FPCKGDIJ@UCS?94@
CONST	SEGMENT
??_C@_05FPCKGDIJ@UCS?94@ DB 'UCS-4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
CONST	SEGMENT
??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@ DB 'Input is no'
	DB	't proper UTF-8, indicate encoding !', 0aH, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
CONST	SEGMENT
??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@ DB 'B'
	DB	'ytes: 0x%02X 0x%02X 0x%02X 0x%02X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LJGHMOAD@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PU@
CONST	SEGMENT
??_C@_0CN@LJGHMOAD@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PU@ DB 'PP: '
	DB	'internal error, state == PUBLIC_LITERAL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JHJPBNDP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5SY@
CONST	SEGMENT
??_C@_0CN@JHJPBNDP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5SY@ DB 'PP: '
	DB	'internal error, state == SYSTEM_LITERAL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BNGPOFIK@PP?3?5internal?5error?0?5state?5?$DN?$DN?5AT@
CONST	SEGMENT
??_C@_0CO@BNGPOFIK@PP?3?5internal?5error?0?5state?5?$DN?$DN?5AT@ DB 'PP: '
	DB	'internal error, state == ATTRIBUTE_VALUE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FDJCPJGL@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@
CONST	SEGMENT
??_C@_0CL@FDJCPJGL@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@ DB 'PP: '
	DB	'internal error, state == ENTITY_VALUE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EGFEGMNP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@
CONST	SEGMENT
??_C@_0CK@EGFEGMNP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@ DB 'PP: '
	DB	'internal error, state == ENTITY_DECL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LNKCECMO@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PI@
CONST	SEGMENT
??_C@_0CB@LNKCECMO@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PI@ DB 'PP: '
	DB	'internal error, state == PI', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CFNIBLKF@PP?3?5internal?5error?0?5state?5?$DN?$DN?5IG@
CONST	SEGMENT
??_C@_0CE@CFNIBLKF@PP?3?5internal?5error?0?5state?5?$DN?$DN?5IG@ DB 'PP: '
	DB	'internal error, state == IGNORE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PHGFCMFA@PP?3?5internal?5error?0?5state?5?$DN?$DN?5CO@
CONST	SEGMENT
??_C@_0CG@PHGFCMFA@PP?3?5internal?5error?0?5state?5?$DN?$DN?5CO@ DB 'PP: '
	DB	'internal error, state == COMMENT', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
CONST	SEGMENT
??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@ DB '<![CDATA[', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HIMAKCPA@Couldn?8t?5find?5end?5of?5Start?5Tag?5@
CONST	SEGMENT
??_C@_0CD@HIMAKCPA@Couldn?8t?5find?5end?5of?5Start?5Tag?5@ DB 'Couldn''t '
	DB	'find end of Start Tag %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HDEJLGKL@Internal?5error?3?5xmlParseGetLast@
CONST	SEGMENT
??_C@_0CC@HDEJLGKL@Internal?5error?3?5xmlParseGetLast@ DB 'Internal error'
	DB	': xmlParseGetLasts', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NCHPNICC@Start?5tag?5expected?0?5?8?$DM?8?5not?5fou@
CONST	SEGMENT
??_C@_0CD@NCHPNICC@Start?5tag?5expected?0?5?8?$DM?8?5not?5fou@ DB 'Start '
	DB	'tag expected, ''<'' not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KLGEONFL@Blank?5needed?5here?6@
CONST	SEGMENT
??_C@_0BD@KLGEONFL@Blank?5needed?5here?6@ DB 'Blank needed here', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MGCDLOCB@Unsupported?5version?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BK@MGCDLOCB@Unsupported?5version?5?8?$CFs?8?6@ DB 'Unsupported ver'
	DB	'sion ''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BPKNILCI@Blank?5needed?5after?5?8?$DM?$DPxml?8?6@
CONST	SEGMENT
??_C@_0BM@BPKNILCI@Blank?5needed?5after?5?8?$DM?$DPxml?8?6@ DB 'Blank nee'
	DB	'ded after ''<?xml''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FCHADMKI@Unsupported?5encoding?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@FCHADMKI@Unsupported?5encoding?5?$CFs?6@ DB 'Unsupported encodi'
	DB	'ng %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04OOMJJNCF@UTF8@
CONST	SEGMENT
??_C@_04OOMJJNCF@UTF8@ DB 'UTF8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EGJIMALK@UTF?98@
CONST	SEGMENT
??_C@_05EGJIMALK@UTF?98@ DB 'UTF-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MEEPFAA@Document?5labelled?5UTF?916?5but?5ha@
CONST	SEGMENT
??_C@_0DA@MEEPFAA@Document?5labelled?5UTF?916?5but?5ha@ DB 'Document labe'
	DB	'lled UTF-16 but has UTF-8 content', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNCHLHCA@UTF16@
CONST	SEGMENT
??_C@_05MNCHLHCA@UTF16@ DB 'UTF16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KNDPGIKI@UTF?916@
CONST	SEGMENT
??_C@_06KNDPGIKI@UTF?916@ DB 'UTF-16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JPBGMEM@Premature?5end?5of?5data?5in?5tag?5?$CFs@
CONST	SEGMENT
??_C@_0CJ@JPBGMEM@Premature?5end?5of?5data?5in?5tag?5?$CFs@ DB 'Premature'
	DB	' end of data in tag %s line %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LKDFGLKB@Couldn?8t?5find?5end?5of?5Start?5Tag?5@
CONST	SEGMENT
??_C@_0CL@LKDFGLKB@Couldn?8t?5find?5end?5of?5Start?5Tag?5@ DB 'Couldn''t '
	DB	'find end of Start Tag %s line %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FCFCBOFE@detected?5an?5error?5in?5element?5co@
CONST	SEGMENT
??_C@_0CG@FCFCBOFE@detected?5an?5error?5in?5element?5co@ DB 'detected an '
	DB	'error in element content', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HAEHMHLE@CData?5section?5not?5finished?6?$CF?450@
CONST	SEGMENT
??_C@_0CC@HAEHMHLE@CData?5section?5not?5finished?6?$CF?450@ DB 'CData sec'
	DB	'tion not finished', 0aH, '%.50s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HGOGNNNB@CData?5section?5too?5big?5found@
CONST	SEGMENT
??_C@_0BM@HGOGNNNB@CData?5section?5too?5big?5found@ DB 'CData section too'
	DB	' big found', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EJLCFGPG@Namespace?5prefix?5?$CFs?5on?5?$CFs?5is?5no@
CONST	SEGMENT
??_C@_0CK@EJLCFGPG@Namespace?5prefix?5?$CFs?5on?5?$CFs?5is?5no@ DB 'Names'
	DB	'pace prefix %s on %s is not defined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BDHHCEFP@Namespaced?5Attribute?5?$CFs?5in?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0CL@BDHHCEFP@Namespaced?5Attribute?5?$CFs?5in?5?8?$CFs?8@ DB 'Names'
	DB	'paced Attribute %s in ''%s'' redefined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GMKAHOEK@Namespace?5prefix?5?$CFs?5for?5?$CFs?5on?5?$CF@
CONST	SEGMENT
??_C@_0DB@GMKAHOEK@Namespace?5prefix?5?$CFs?5for?5?$CFs?5on?5?$CF@ DB 'Na'
	DB	'mespace prefix %s for %s on %s is not defined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@
CONST	SEGMENT
??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@ DB 'stand'
	DB	'alone: attribute %s on %s defaulted from external subset', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HDEBIHCG@Unexpected?5change?5of?5input?6@
CONST	SEGMENT
??_C@_0BM@HDEBIHCG@Unexpected?5change?5of?5input?6@ DB 'Unexpected change'
	DB	' of input', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@
CONST	SEGMENT
??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@ DB 'xmln'
	DB	's:%s: URI %s is not absolute', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IMLPGLBN@xmlns?3?$CFs?3?5?8?$CFs?8?5is?5not?5a?5valid?5U@
CONST	SEGMENT
??_C@_0CD@IMLPGLBN@xmlns?3?$CFs?3?5?8?$CFs?8?5is?5not?5a?5valid?5U@ DB 'x'
	DB	'mlns:%s: ''%s'' is not a valid URI', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JLGJJKB@xmlns?3?$CFs?3?5Empty?5XML?5namespace?5i@
CONST	SEGMENT
??_C@_0CO@JLGJJKB@xmlns?3?$CFs?3?5Empty?5XML?5namespace?5i@ DB 'xmlns:%s:'
	DB	' Empty XML namespace is not allowed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FCHEBDCM@redefinition?5of?5the?5xmlns?5prefi@
CONST	SEGMENT
??_C@_0CP@FCHEBDCM@redefinition?5of?5the?5xmlns?5prefi@ DB 'redefinition '
	DB	'of the xmlns prefix is forbidden', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HFNNIPGF@xml?5namespace?5URI?5mapped?5to?5wro@
CONST	SEGMENT
??_C@_0CK@HFNNIPGF@xml?5namespace?5URI?5mapped?5to?5wro@ DB 'xml namespac'
	DB	'e URI mapped to wrong prefix', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HOGKMNCM@xml?5namespace?5prefix?5mapped?5to?5@
CONST	SEGMENT
??_C@_0CK@HOGKMNCM@xml?5namespace?5prefix?5mapped?5to?5@ DB 'xml namespac'
	DB	'e prefix mapped to wrong URI', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DPCHHACL@reuse?5of?5the?5xmlns?5namespace?5na@
CONST	SEGMENT
??_C@_0DA@DPCHHACL@reuse?5of?5the?5xmlns?5namespace?5na@ DB 'reuse of the'
	DB	' xmlns namespace name is forbidden', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
CONST	SEGMENT
??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@ DB 'http://www.'
	DB	'w3.org/2000/xmlns/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IPHAILAA@xml?5namespace?5URI?5cannot?5be?5the@
CONST	SEGMENT
??_C@_0DD@IPHAILAA@xml?5namespace?5URI?5cannot?5be?5the@ DB 'xml namespac'
	DB	'e URI cannot be the default namespace', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@
CONST	SEGMENT
??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@ DB 'xmlns: U'
	DB	'RI %s is not absolute', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IPMJMNFH@xmlns?3?5?8?$CFs?8?5is?5not?5a?5valid?5URI?6@
CONST	SEGMENT
??_C@_0CA@IPMJMNFH@xmlns?3?5?8?$CFs?8?5is?5not?5a?5valid?5URI?6@ DB 'xmln'
	DB	's: ''%s'' is not a valid URI', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NHFMDAKF@dictionary?5allocation?5failure@
CONST	SEGMENT
??_C@_0BO@NHFMDAKF@dictionary?5allocation?5failure@ DB 'dictionary alloca'
	DB	'tion failure', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LKOHNLNN@StartTag?3?5invalid?5element?5name?6@
CONST	SEGMENT
??_C@_0CA@LKOHNLNN@StartTag?3?5invalid?5element?5name?6@ DB 'StartTag: in'
	DB	'valid element name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OLNILLAB@space@
CONST	SEGMENT
??_C@_05OLNILLAB@space@ DB 'space', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOHABJIC@lang@
CONST	SEGMENT
??_C@_04IOHABJIC@lang@ DB 'lang', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HECGKKLP@Failed?5to?5parse?5QName?5?8?$CFs?3?$CFs?3?8?6@
CONST	SEGMENT
??_C@_0CA@HECGKKLP@Failed?5to?5parse?5QName?5?8?$CFs?3?$CFs?3?8?6@ DB 'Fa'
	DB	'iled to parse QName ''%s:%s:''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MNDCJBCK@Failed?5to?5parse?5QName?5?8?$CFs?3?8?6@
CONST	SEGMENT
??_C@_0BN@MNDCJBCK@Failed?5to?5parse?5QName?5?8?$CFs?3?8?6@ DB 'Failed to'
	DB	' parse QName ''%s:''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DBJGDKCH@Failed?5to?5parse?5QName?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BM@DBJGDKCH@Failed?5to?5parse?5QName?5?8?$CFs?8?6@ DB 'Failed to p'
	DB	'arse QName ''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OCMDIBAP@Opening?5and?5ending?5tag?5mismatch@
CONST	SEGMENT
??_C@_0DE@OCMDIBAP@Opening?5and?5ending?5tag?5mismatch@ DB 'Opening and e'
	DB	'nding tag mismatch: %s line %d and %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IAMGGMFE@unparseable@
CONST	SEGMENT
??_C@_0M@IAMGGMFE@unparseable@ DB 'unparseable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PJGJPBIH@xmlParseEndTag?3?5?8?$DM?1?8?5not?5found?6@
CONST	SEGMENT
??_C@_0CA@PJGJPBIH@xmlParseEndTag?3?5?8?$DM?1?8?5not?5found?6@ DB 'xmlPar'
	DB	'seEndTag: ''</'' not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KAECIKGE@xmlParseStartTag?3?5problem?5parsi@
CONST	SEGMENT
??_C@_0CO@KAECIKGE@xmlParseStartTag?3?5problem?5parsi@ DB 'xmlParseStartT'
	DB	'ag: problem parsing attributes', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FKPAGOOK@attributes?5construct?5error?6@
CONST	SEGMENT
??_C@_0BM@FKPAGOOK@attributes?5construct?5error?6@ DB 'attributes constru'
	DB	'ct error', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FEOPKDBB@xmlParseStartTag?3?5invalid?5eleme@
CONST	SEGMENT
??_C@_0CI@FEOPKDBB@xmlParseStartTag?3?5invalid?5eleme@ DB 'xmlParseStartT'
	DB	'ag: invalid element name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@GNALPKCP@Invalid?5value?5?$CC?$CFs?$CC?5for?5xml?3spac@
CONST	SEGMENT
??_C@_0EF@GNALPKCP@Invalid?5value?5?$CC?$CFs?$CC?5for?5xml?3spac@ DB 'Inv'
	DB	'alid value "%s" for xml:space : "default" or "preserve" expec'
	DB	'ted', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILAKLJGO@preserve@
CONST	SEGMENT
??_C@_08ILAKLJGO@preserve@ DB 'preserve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default@
CONST	SEGMENT
??_C@_07DLHCIBDH@default@ DB 'default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HKHFJOKD@xml?3space@
CONST	SEGMENT
??_C@_09HKHFJOKD@xml?3space@ DB 'xml:space', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OAOAJGL@Malformed?5value?5for?5xml?3lang?5?3?5@
CONST	SEGMENT
??_C@_0CD@OAOAJGL@Malformed?5value?5for?5xml?3lang?5?3?5@ DB 'Malformed v'
	DB	'alue for xml:lang : %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EHDJCMMM@xml?3lang@
CONST	SEGMENT
??_C@_08EHDJCMMM@xml?3lang@ DB 'xml:lang', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LHHGCLP@Specification?5mandates?5value?5fo@
CONST	SEGMENT
??_C@_0CP@LHHGCLP@Specification?5mandates?5value?5fo@ DB 'Specification m'
	DB	'andates value for attribute %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BHLKDNI@error?5parsing?5attribute?5name?6@
CONST	SEGMENT
??_C@_0BO@BHLKDNI@error?5parsing?5attribute?5name?6@ DB 'error parsing at'
	DB	'tribute name', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@IJLBCNCA@xmlParseInternalSubset?3?5error?5d@
CONST	SEGMENT
??_C@_0DO@IJLBCNCA@xmlParseInternalSubset?3?5error?5d@ DB 'xmlParseIntern'
	DB	'alSubset: error detected in Markup declaration', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JPAMJNGL@xmlParseDocTypeDecl?5?3?5no?5DOCTYP@
CONST	SEGMENT
??_C@_0CJ@JPAMJNGL@xmlParseDocTypeDecl?5?3?5no?5DOCTYP@ DB 'xmlParseDocTy'
	DB	'peDecl : no DOCTYPE name !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HMFAEMHO@?$CF?$CF?$CFs?$DL?5is?5not?5a?5parameter?5entity@
CONST	SEGMENT
??_C@_0CB@HMFAEMHO@?$CF?$CF?$CFs?$DL?5is?5not?5a?5parameter?5entity@ DB '%'
	DB	'%%s; is not a parameter entity', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PLGLFALL@xmlParseStringPEReference?3?5no?5n@
CONST	SEGMENT
??_C@_0CE@PLGLFALL@xmlParseStringPEReference?3?5no?5n@ DB 'xmlParseString'
	DB	'PEReference: no name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NHLEKBNA@xmlLoadEntityContent?3?5invalid?5c@
CONST	SEGMENT
??_C@_0CN@NHLEKBNA@xmlLoadEntityContent?3?5invalid?5c@ DB 'xmlLoadEntityC'
	DB	'ontent: invalid char value %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HEAOEFBK@xmlLoadEntityContent?5input?5erro@
CONST	SEGMENT
??_C@_0CB@HEAOEFBK@xmlLoadEntityContent?5input?5erro@ DB 'xmlLoadEntityCo'
	DB	'ntent input error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NCAMLBBH@Reading?5?$CFs?5entity?5content?5input@
CONST	SEGMENT
??_C@_0CB@NCAMLBBH@Reading?5?$CFs?5entity?5content?5input@ DB 'Reading %s'
	DB	' entity content input', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PMEPEHIL@xmlLoadEntityContent?5parameter?5@
CONST	SEGMENT
??_C@_0CF@PMEPEHIL@xmlLoadEntityContent?5parameter?5@ DB 'xmlLoadEntityCo'
	DB	'ntent parameter error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BLGDJGPF@Internal?3?5?$CF?$CF?$CFs?$DL?5is?5not?5a?5parame@
CONST	SEGMENT
??_C@_0CL@BLGDJGPF@Internal?3?5?$CF?$CF?$CFs?$DL?5is?5not?5a?5parame@ DB 'I'
	DB	'nternal: %%%s; is not a parameter entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
CONST	SEGMENT
??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@ DB 'PE'
	DB	'Reference: %%%s; not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MFPJKDDB@PEReference?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BB@MFPJKDDB@PEReference?3?5?$CFs?6@ DB 'PEReference: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DIAKGNKN@PEReference?3?5no?5name?6@
CONST	SEGMENT
??_C@_0BG@DIAKGNKN@PEReference?3?5no?5name?6@ DB 'PEReference: no name', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PKJKLMCM@xmlParseStringEntityRef?3?5no?5nam@
CONST	SEGMENT
??_C@_0CC@PKJKLMCM@xmlParseStringEntityRef?3?5no?5nam@ DB 'xmlParseString'
	DB	'EntityRef: no name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CCPGIFBP@Attempt?5to?5reference?5the?5parame@
CONST	SEGMENT
??_C@_0DA@CCPGIFBP@Attempt?5to?5reference?5the?5parame@ DB 'Attempt to re'
	DB	'ference the parameter entity ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@FDECCCAO@?8?$DM?8?5in?5entity?5?8?$CFs?8?5is?5not?5allow@
CONST	SEGMENT
??_C@_0DI@FDECCCAO@?8?$DM?8?5in?5entity?5?8?$CFs?8?5is?5not?5allow@ DB ''''
	DB	'<'' in entity ''%s'' is not allowed in attributes values', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HLODLGOA@Attribute?5references?5external?5e@
CONST	SEGMENT
??_C@_0CL@HLODLGOA@Attribute?5references?5external?5e@ DB 'Attribute refe'
	DB	'rences external entity ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@ILCMJJAO@Entity?5reference?5to?5unparsed?5en@
CONST	SEGMENT
??_C@_0CI@ILCMJJAO@Entity?5reference?5to?5unparsed?5en@ DB 'Entity refere'
	DB	'nce to unparsed entity %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@
CONST	SEGMENT
??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@ DB 'Entity ''%s'' n'
	DB	'ot defined', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NMGBIIDP@xmlParseEntityRef?3?5no?5name?6@
CONST	SEGMENT
??_C@_0BM@NMGBIIDP@xmlParseEntityRef?3?5no?5name?6@ DB 'xmlParseEntityRef'
	DB	': no name', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DALNPEGO@nbktext@
CONST	SEGMENT
??_C@_07DALNPEGO@nbktext@ DB 'nbktext', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EOPGEOPH@Entity?5?8?$CFs?8?5failed?5to?5parse?6@
CONST	SEGMENT
??_C@_0BN@EOPGEOPH@Entity?5?8?$CFs?8?5failed?5to?5parse?6@ DB 'Entity ''%'
	DB	's'' failed to parse', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EBFCDHBG@invalid?5entity?5type?5found?6@
CONST	SEGMENT
??_C@_0BL@EBFCDHBG@invalid?5entity?5type?5found?6@ DB 'invalid entity typ'
	DB	'e found', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03FDCLAKJL@?$CD?$CFd@
CONST	SEGMENT
??_C@_03FDCLAKJL@?$CD?$CFd@ DB '#%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FNNDIGBC@?$CDx?$CFX@
CONST	SEGMENT
??_C@_04FNNDIGBC@?$CDx?$CFX@ DB '#x%X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OFFEFIEL@Missing?5encoding?5in?5text?5declar@
CONST	SEGMENT
??_C@_0CG@OFFEFIEL@Missing?5encoding?5in?5text?5declar@ DB 'Missing encod'
	DB	'ing in text declaration', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LJKHCJDH@Space?5needed?5here?6@
CONST	SEGMENT
??_C@_0BD@LJKHCJDH@Space?5needed?5here?6@ DB 'Space needed here', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HLLJOCDO@1?40@
CONST	SEGMENT
??_C@_03HLLJOCDO@1?40@ DB '1.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OIPNJGND@Space?5needed?5after?5?8?$DM?$DPxml?8?6@
CONST	SEGMENT
??_C@_0BM@OIPNJGND@Space?5needed?5after?5?8?$DM?$DPxml?8?6@ DB 'Space nee'
	DB	'ded after ''<?xml''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MPDEOLDN@Leaving?5IGNORE?5Conditional?5Sect@
CONST	SEGMENT
??_C@_0CE@MPDEOLDN@Leaving?5IGNORE?5Conditional?5Sect@ DB 'Leaving IGNORE'
	DB	' Conditional Section', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BNLECKJM@Entering?5IGNORE?5Conditional?5Sec@
CONST	SEGMENT
??_C@_0CF@BNLECKJM@Entering?5IGNORE?5Conditional?5Sec@ DB 'Entering IGNOR'
	DB	'E Conditional Section', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KBFPDCLM@Leaving?5INCLUDE?5Conditional?5Sec@
CONST	SEGMENT
??_C@_0CF@KBFPDCLM@Leaving?5INCLUDE?5Conditional?5Sec@ DB 'Leaving INCLUD'
	DB	'E Conditional Section', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FMCBAD@Entering?5INCLUDE?5Conditional?5Se@
CONST	SEGMENT
??_C@_0CG@FMCBAD@Entering?5INCLUDE?5Conditional?5Se@ DB 'Entering INCLUDE'
	DB	' Conditional Section', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@
CONST	SEGMENT
??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@ DB 'All markup o'
	DB	'f the conditional section is not in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KIKIPMFE@Element?5declaration?5doesn?8t?5sta@
CONST	SEGMENT
??_C@_0DP@KIKIPMFE@Element?5declaration?5doesn?8t?5sta@ DB 'Element decla'
	DB	'ration doesn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CHNHOLDO@xmlParseElementDecl?3?5?8EMPTY?8?0?5?8@
CONST	SEGMENT
??_C@_0DF@CHNHOLDO@xmlParseElementDecl?3?5?8EMPTY?8?0?5?8@ DB 'xmlParseEl'
	DB	'ementDecl: ''EMPTY'', ''ANY'' or ''('' expected', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@COHAOPDG@PEReference?3?5forbidden?5within?5m@
CONST	SEGMENT
??_C@_0DO@COHAOPDG@PEReference?3?5forbidden?5within?5m@ DB 'PEReference: '
	DB	'forbidden within markup decl in internal subset', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MFBAJJC@Space?5required?5after?5the?5elemen@
CONST	SEGMENT
??_C@_0CH@MFBAJJC@Space?5required?5after?5the?5elemen@ DB 'Space required'
	DB	' after the element name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LMDMNJGO@xmlParseElementDecl?3?5no?5name?5fo@
CONST	SEGMENT
??_C@_0CK@LMDMNJGO@xmlParseElementDecl?3?5no?5name?5fo@ DB 'xmlParseEleme'
	DB	'ntDecl: no name for Element', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CIGPNPNK@Space?5required?5after?5?8ELEMENT?8?6@
CONST	SEGMENT
??_C@_0CA@CIGPNPNK@Space?5required?5after?5?8ELEMENT?8?6@ DB 'Space requi'
	DB	'red after ''ELEMENT''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FLMKOMHK@xmlParseElementContentDecl?5?3?5?$CFs@
CONST	SEGMENT
??_C@_0CO@FLMKOMHK@xmlParseElementContentDecl?5?3?5?$CFs@ DB 'xmlParseEle'
	DB	'mentContentDecl : %s ''('' expected', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IJONAOBP@xmlParseElementChildrenContentD@
CONST	SEGMENT
??_C@_0DE@IJONAOBP@xmlParseElementChildrenContentD@ DB 'xmlParseElementCh'
	DB	'ildrenContentDecl : ''%c'' expected', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@OINCFINP@xmlParseElementChildrenContentD@
CONST	SEGMENT
??_C@_0EM@OINCFINP@xmlParseElementChildrenContentD@ DB 'xmlParseElementCh'
	DB	'ildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BEFMOJIK@xmlParseElementMixedContentDecl@
CONST	SEGMENT
??_C@_0DB@BEFMOJIK@xmlParseElementMixedContentDecl@ DB 'xmlParseElementMi'
	DB	'xedContentDecl : Name expected', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@
CONST	SEGMENT
??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@ DB 'Element conten'
	DB	't declaration doesn''t start and stop in the same entity', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@JGLJABBC@Attribute?5list?5declaration?5does@
CONST	SEGMENT
??_C@_0EG@JGLJABBC@Attribute?5list?5declaration?5does@ DB 'Attribute list'
	DB	' declaration doesn''t start and stop in the same entity', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@NGABIAJF@Space?5required?5after?5the?5attrib@
CONST	SEGMENT
??_C@_0DC@NGABIAJF@Space?5required?5after?5the?5attrib@ DB 'Space require'
	DB	'd after the attribute default value', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EMHJKDCH@Space?5required?5after?5the?5attrib@
CONST	SEGMENT
??_C@_0CJ@EMHJKDCH@Space?5required?5after?5the?5attrib@ DB 'Space require'
	DB	'd after the attribute type', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BMNHNBNL@Space?5required?5after?5the?5attrib@
CONST	SEGMENT
??_C@_0CJ@BMNHNBNL@Space?5required?5after?5the?5attrib@ DB 'Space require'
	DB	'd after the attribute name', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GKDLKFPE@ATTLIST?3?5no?5name?5for?5Attribute?6@
CONST	SEGMENT
??_C@_0CA@GKDLKFPE@ATTLIST?3?5no?5name?5for?5Attribute?6@ DB 'ATTLIST: no'
	DB	' name for Attribute', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PIKFFONH@ATTLIST?3?5no?5name?5for?5Element?6@
CONST	SEGMENT
??_C@_0BO@PIKFFONH@ATTLIST?3?5no?5name?5for?5Element?6@ DB 'ATTLIST: no n'
	DB	'ame for Element', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DODLEJBN@Space?5required?5after?5?8?$DM?$CBATTLIST@
CONST	SEGMENT
??_C@_0CC@DODLEJBN@Space?5required?5after?5?8?$DM?$CBATTLIST@ DB 'Space r'
	DB	'equired after ''<!ATTLIST''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FOEKPMO@Space?5required?5after?5?8NOTATION?8@
CONST	SEGMENT
??_C@_0CB@FOEKPMO@Space?5required?5after?5?8NOTATION?8@ DB 'Space require'
	DB	'd after ''NOTATION''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GKJDABEM@standalone?3?5attribute?5enumerati@
CONST	SEGMENT
??_C@_0DN@GKJDABEM@standalone?3?5attribute?5enumerati@ DB 'standalone: at'
	DB	'tribute enumeration value token %s duplicated', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HOPAGHFB@standalone?3?5attribute?5notation?5@
CONST	SEGMENT
??_C@_0DK@HOPAGHFB@standalone?3?5attribute?5notation?5@ DB 'standalone: a'
	DB	'ttribute notation value token %s duplicated', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MHDABFNP@Name?5expected?5in?5NOTATION?5decla@
CONST	SEGMENT
??_C@_0CH@MHDABFNP@Name?5expected?5in?5NOTATION?5decla@ DB 'Name expected'
	DB	' in NOTATION declaration', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MHGJEBGE@Attribute?5default?5value?5declara@
CONST	SEGMENT
??_C@_0CL@MHGJEBGE@Attribute?5default?5value?5declara@ DB 'Attribute defa'
	DB	'ult value declaration error', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LOJANMBO@Space?5required?5after?5?8?$CDFIXED?8?6@
CONST	SEGMENT
??_C@_0BP@LOJANMBO@Space?5required?5after?5?8?$CDFIXED?8?6@ DB 'Space req'
	DB	'uired after ''#FIXED''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@BLCODNOK@Entity?5declaration?5doesn?8t?5star@
CONST	SEGMENT
??_C@_0DO@BLCODNOK@Entity?5declaration?5doesn?8t?5star@ DB 'Entity declar'
	DB	'ation doesn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GFOAPJBJ@xmlParseEntityDecl?3?5entity?5?$CFs?5n@
CONST	SEGMENT
??_C@_0CO@GFOAPJBJ@xmlParseEntityDecl?3?5entity?5?$CFs?5n@ DB 'xmlParseEn'
	DB	'tityDecl: entity %s not terminated', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GLBCJEIC@Space?5required?5after?5?8NDATA?8?6@
CONST	SEGMENT
??_C@_0BO@GLBCJEIC@Space?5required?5after?5?8NDATA?8?6@ DB 'Space require'
	DB	'd after ''NDATA''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NPDMAEIM@Space?5required?5before?5?8NDATA?8?6@
CONST	SEGMENT
??_C@_0BP@NPDMAEIM@Space?5required?5before?5?8NDATA?8?6@ DB 'Space requir'
	DB	'ed before ''NDATA''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PADNKBEK@fake@
CONST	SEGMENT
??_C@_04PADNKBEK@fake@ DB 'fake', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IDBIGKBI@New?5Doc?5failed@
CONST	SEGMENT
??_C@_0P@IDBIGKBI@New?5Doc?5failed@ DB 'New Doc failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
CONST	SEGMENT
??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@ DB 'SAX compatibil'
	DB	'ity mode document', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JHEINHI@Invalid?5URI?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BB@JHEINHI@Invalid?5URI?3?5?$CFs?6@ DB 'Invalid URI: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IGJCKADK@Space?5required?5after?5the?5entity@
CONST	SEGMENT
??_C@_0CG@IGJCKADK@Space?5required?5after?5the?5entity@ DB 'Space require'
	DB	'd after the entity name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IEOCAMEB@colons?5are?5forbidden?5from?5entit@
CONST	SEGMENT
??_C@_0CP@IEOCAMEB@colons?5are?5forbidden?5from?5entit@ DB 'colons are fo'
	DB	'rbidden from entities names ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GJOFDJCB@xmlParseEntityDecl?3?5no?5name?6@
CONST	SEGMENT
??_C@_0BN@GJOFDJCB@xmlParseEntityDecl?3?5no?5name?6@ DB 'xmlParseEntityDe'
	DB	'cl: no name', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KGADBCMF@Space?5required?5after?5?8?$CF?$CF?8?6@
CONST	SEGMENT
??_C@_0BL@KGADBCMF@Space?5required?5after?5?8?$CF?$CF?8?6@ DB 'Space requ'
	DB	'ired after ''%%''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NEOBPNBE@Space?5required?5after?5?8?$DM?$CBENTITY?8@
CONST	SEGMENT
??_C@_0CB@NEOBPNBE@Space?5required?5after?5?8?$DM?$CBENTITY?8@ DB 'Space '
	DB	'required after ''<!ENTITY''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@DCHCOJDP@Notation?5declaration?5doesn?8t?5st@
CONST	SEGMENT
??_C@_0EA@DCHCOJDP@Notation?5declaration?5doesn?8t?5st@ DB 'Notation decl'
	DB	'aration doesn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PMDGLIHG@Space?5required?5after?5the?5NOTATI@
CONST	SEGMENT
??_C@_0CJ@PMDGLIHG@Space?5required?5after?5the?5NOTATI@ DB 'Space require'
	DB	'd after the NOTATION name''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BOHPCDLP@colons?5are?5forbidden?5from?5notat@
CONST	SEGMENT
??_C@_0CP@BOHPCDLP@colons?5are?5forbidden?5from?5notat@ DB 'colons are fo'
	DB	'rbidden from notation names ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ILKLDDEI@Space?5required?5after?5?8?$DM?$CBNOTATIO@
CONST	SEGMENT
??_C@_0CD@ILKLDDEI@Space?5required?5after?5?8?$DM?$CBNOTATIO@ DB 'Space r'
	DB	'equired after ''<!NOTATION''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IDENENGP@oasis?9xml?9catalog@
CONST	SEGMENT
??_C@_0BC@IDENENGP@oasis?9xml?9catalog@ DB 'oasis-xml-catalog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OGPJFKEP@ParsePI?3?5PI?5?$CFs?5never?5end?5?4?4?4?6@
CONST	SEGMENT
??_C@_0BO@OGPJFKEP@ParsePI?3?5PI?5?$CFs?5never?5end?5?4?4?4?6@ DB 'ParseP'
	DB	'I: PI %s never end ...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KDNCGJGM@PI?5?$CFs?5too?5big?5found@
CONST	SEGMENT
??_C@_0BE@KDNCGJGM@PI?5?$CFs?5too?5big?5found@ DB 'PI %s too big found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KBNJPEOK@ParsePI?3?5PI?5?$CFs?5space?5expected?6@
CONST	SEGMENT
??_C@_0BP@KBNJPEOK@ParsePI?3?5PI?5?$CFs?5space?5expected?6@ DB 'ParsePI: '
	DB	'PI %s space expected', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@LAKAFNGA@PI?5declaration?5doesn?8t?5start?5an@
CONST	SEGMENT
??_C@_0DK@LAKAFNGA@PI?5declaration?5doesn?8t?5start?5an@ DB 'PI declarati'
	DB	'on doesn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MALFACIE@Catalog?5PI?5syntax?5error?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BN@MALFACIE@Catalog?5PI?5syntax?5error?3?5?$CFs?6@ DB 'Catalog PI '
	DB	'syntax error: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFFOOIHD@catalog@
CONST	SEGMENT
??_C@_07MFFOOIHD@catalog@ DB 'catalog', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KOKAGEDL@colons?5are?5forbidden?5from?5PI?5na@
CONST	SEGMENT
??_C@_0CJ@KOKAGEDL@colons?5are?5forbidden?5from?5PI?5na@ DB 'colons are f'
	DB	'orbidden from PI names ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KJOCGNCM@xmlParsePITarget?3?5invalid?5name?5@
CONST	SEGMENT
??_C@_0CN@KJOCGNCM@xmlParsePITarget?3?5invalid?5name?5@ DB 'xmlParsePITar'
	DB	'get: invalid name prefix ''xml''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@PMHMGOPA@XML?5declaration?5allowed?5only?5at@
CONST	SEGMENT
??_C@_0DL@PMHMGOPA@XML?5declaration?5allowed?5only?5at@ DB 'XML declarati'
	DB	'on allowed only at the start of the document', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PENANJHM@Double?5hyphen?5within?5comment?6@
CONST	SEGMENT
??_C@_0BO@PENANJHM@Double?5hyphen?5within?5comment?6@ DB 'Double hyphen w'
	DB	'ithin comment', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CBOBCJAG@Double?5hyphen?5within?5comment?3?5?$DM@
CONST	SEGMENT
??_C@_0CJ@CBOBCJAG@Double?5hyphen?5within?5comment?3?5?$DM@ DB 'Double hy'
	DB	'phen within comment: <!--%.50s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DDHAOEGP@comment?5doesn?8t?5start?5and?5stop?5@
CONST	SEGMENT
??_C@_0DD@DDHAOEGP@comment?5doesn?8t?5start?5and?5stop?5@ DB 'comment doe'
	DB	'sn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ELKFFAAB@Comment?5not?5terminated?6@
CONST	SEGMENT
??_C@_0BI@ELKFFAAB@Comment?5not?5terminated?6@ DB 'Comment not terminated'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BIJIOHJJ@Comment?5doesn?8t?5start?5and?5stop?5@
CONST	SEGMENT
??_C@_0DD@BIJIOHJJ@Comment?5doesn?8t?5start?5and?5stop?5@ DB 'Comment doe'
	DB	'sn''t start and stop in the same entity', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MHPLKFMN@Comment?5not?5terminated?5?6?$DM?$CB?9?9?$CF?45@
CONST	SEGMENT
??_C@_0CD@MHPLKFMN@Comment?5not?5terminated?5?6?$DM?$CB?9?9?$CF?45@ DB 'C'
	DB	'omment not terminated ', 0aH, '<!--%.50s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BAOBDEOI@Comment?5too?5big?5found@
CONST	SEGMENT
??_C@_0BG@BAOBDEOI@Comment?5too?5big?5found@ DB 'Comment too big found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@
CONST	SEGMENT
??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@ DB 'xmlParseCommen'
	DB	't: invalid xmlChar value %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PJLPICDD@Space?5required?5after?5the?5Public@
CONST	SEGMENT
??_C@_0CM@PJLPICDD@Space?5required?5after?5the?5Public@ DB 'Space require'
	DB	'd after the Public Identifier', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EHONNEAJ@Space?5required?5after?5?8PUBLIC?8?6@
CONST	SEGMENT
??_C@_0BP@EHONNEAJ@Space?5required?5after?5?8PUBLIC?8?6@ DB 'Space requir'
	DB	'ed after ''PUBLIC''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CCMMHADN@Space?5required?5after?5?8SYSTEM?8?6@
CONST	SEGMENT
??_C@_0BP@CCMMHADN@Space?5required?5after?5?8SYSTEM?8?6@ DB 'Space requir'
	DB	'ed after ''SYSTEM''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IODKMKKF@PCDATA?5invalid?5Char?5value?5?$CFd?6@
CONST	SEGMENT
??_C@_0BO@IODKMKKF@PCDATA?5invalid?5Char?5value?5?$CFd?6@ DB 'PCDATA inva'
	DB	'lid Char value %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HLIINGHD@Public?5ID@
CONST	SEGMENT
??_C@_09HLIINGHD@Public?5ID@ DB 'Public ID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CPJEEBHF@SystemLiteral@
CONST	SEGMENT
??_C@_0O@CPJEEBHF@SystemLiteral@ DB 'SystemLiteral', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NKOFEMFC@AttValue?3?5?8?5expected?6@
CONST	SEGMENT
??_C@_0BG@NKOFEMFC@AttValue?3?5?8?5expected?6@ DB 'AttValue: '' expected', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LEIKKIHB@invalid?5character?5in?5attribute?5@
CONST	SEGMENT
??_C@_0CG@LEIKKIHB@invalid?5character?5in?5attribute?5@ DB 'invalid chara'
	DB	'cter in attribute value', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
CONST	SEGMENT
??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@ DB 'AttValue length too'
	DB	' long', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@GJGLHMKL@EntityValue?3?5?8?$CFc?8?5forbidden?5exc@
CONST	SEGMENT
??_C@_0DM@GJGLHMKL@EntityValue?3?5?8?$CFc?8?5forbidden?5exc@ DB 'EntityVa'
	DB	'lue: ''%c'' forbidden except for entities references', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JJJDEIPB@NmToken@
CONST	SEGMENT
??_C@_07JJJDEIPB@NmToken@ DB 'NmToken', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MDLHOHLI@NCName@
CONST	SEGMENT
??_C@_06MDLHOHLI@NCName@ DB 'NCName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JIBKNHBD@unexpected?5change?5of?5input?5buff@
CONST	SEGMENT
??_C@_0CC@JIBKNHBD@unexpected?5change?5of?5input?5buff@ DB 'unexpected ch'
	DB	'ange of input buffer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FABLJDN@Name@
CONST	SEGMENT
??_C@_04FABLJDN@Name@ DB 'Name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GHNHPHHB@Name?5?$CFs?5is?5not?5XML?5Namespace?5co@
CONST	SEGMENT
??_C@_0CI@GHNHPHHB@Name?5?$CFs?5is?5not?5XML?5Namespace?5co@ DB 'Name %s '
	DB	'is not XML Namespace compliant', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IENLJLFO@not?5validating?5will?5not?5read?5co@
CONST	SEGMENT
??_C@_0DH@IENLJLFO@not?5validating?5will?5not?5read?5co@ DB 'not validati'
	DB	'ng will not read content for PE entity %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DIAKJGNK@String?5decoding?5PE?5Reference?3?5?$CF@
CONST	SEGMENT
??_C@_0CF@DIAKJGNK@String?5decoding?5PE?5Reference?3?5?$CF@ DB 'String de'
	DB	'coding PE Reference: %.30s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KGDPFIJL@predefined?5entity?5has?5no?5conten@
CONST	SEGMENT
??_C@_0CC@KGDPFIJL@predefined?5entity?5has?5no?5conten@ DB 'predefined en'
	DB	'tity has no content', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JICBMJMM@String?5decoding?5Entity?5Referenc@
CONST	SEGMENT
??_C@_0CJ@JICBMJMM@String?5decoding?5Entity?5Referenc@ DB 'String decodin'
	DB	'g Entity Reference: %.30s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@EJFBNJEE@xmlParseStringCharRef?3?5invalid?5@
CONST	SEGMENT
??_C@_0DB@EJFBNJEE@xmlParseStringCharRef?3?5invalid?5@ DB 'xmlParseString'
	DB	'CharRef: invalid xmlChar value %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KEGPHPPF@xmlParseCharRef?3?5invalid?5xmlCha@
CONST	SEGMENT
??_C@_0CL@KEGPHPPF@xmlParseCharRef?3?5invalid?5xmlCha@ DB 'xmlParseCharRe'
	DB	'f: invalid xmlChar value %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IPLLKNJK@Pushing?5input?5?$CFd?5?3?5?$CF?430s?6@
CONST	SEGMENT
??_C@_0BK@IPLLKNJK@Pushing?5input?5?$CFd?5?3?5?$CF?430s?6@ DB 'Pushing in'
	DB	'put %d : %.30s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
CONST	SEGMENT
??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@ DB '%s(%d): ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JODEMIEP@Unfinished?5entity?5outside?5the?5D@
CONST	SEGMENT
??_C@_0CC@JODEMIEP@Unfinished?5entity?5outside?5the?5D@ DB 'Unfinished en'
	DB	'tity outside the DTD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LEKDBCEK@Popping?5input?5?$CFd?6@
CONST	SEGMENT
??_C@_0BC@LEKDBCEK@Popping?5input?5?$CFd?6@ DB 'Popping input %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JOKBAJC@cur?5index?5out?5of?5bound@
CONST	SEGMENT
??_C@_0BH@JOKBAJC@cur?5index?5out?5of?5bound@ DB 'cur index out of bound', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BAMNGBKO@Huge?5input?5lookup@
CONST	SEGMENT
??_C@_0BC@BAMNGBKO@Huge?5input?5lookup@ DB 'Huge input lookup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HADOBDDE@Excessive?5depth?5in?5document?3?5?$CFd@
CONST	SEGMENT
??_C@_0DL@HADOBDDE@Excessive?5depth?5in?5document?3?5?$CFd@ DB 'Excessive'
	DB	' depth in document: %d use XML_PARSE_HUGE option', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KIFBOAFI@Pbm?5popping?5?$CFd?5NS?6@
CONST	SEGMENT
??_C@_0BD@KIFBOAFI@Pbm?5popping?5?$CFd?5NS?6@ DB 'Pbm popping %d NS', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08OIBPHJGN@external@
CONST	SEGMENT
??_C@_08OIBPHJGN@external@ DB 'external', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
CONST	SEGMENT
??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@ DB 'http://ww'
	DB	'w.w3.org/XML/1998/namespace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns@ DB 'xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHHNEEI@xml@
CONST	SEGMENT
??_C@_03PJHHNEEI@xml@ DB 'xml', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
CONST	SEGMENT
??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@ DB '%s: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@COECCIID@Unregistered?5error?5message@
CONST	SEGMENT
??_C@_0BL@COECCIID@Unregistered?5error?5message@ DB 'Unregistered error m'
	DB	'essage', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@
CONST	SEGMENT
??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@ DB 'Name too long'
	DB	' use XML_PARSE_HUGE option', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FHFOLBEM@Malformed?5declaration?5expecting@
CONST	SEGMENT
??_C@_0CI@FHFOLBEM@Malformed?5declaration?5expecting@ DB 'Malformed decla'
	DB	'ration expecting version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@
CONST	SEGMENT
??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@ DB 'extra conte'
	DB	'nt at the end of well balanced chunk', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@
CONST	SEGMENT
??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@ DB 'chunk is not well '
	DB	'balanced', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JKANOFNI@Extra?5content?5at?5the?5end?5of?5the@
CONST	SEGMENT
??_C@_0CJ@JKANOFNI@Extra?5content?5at?5the?5end?5of?5the@ DB 'Extra conte'
	DB	'nt at the end of the document', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LDMJLCHP@Document?5is?5empty@
CONST	SEGMENT
??_C@_0BC@LDMJLCHP@Document?5is?5empty@ DB 'Document is empty', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MBLHCBEE@standalone?5accepts?5only?5?8yes?8?5o@
CONST	SEGMENT
??_C@_0CG@MBLHCBEE@standalone?5accepts?5only?5?8yes?8?5o@ DB 'standalone '
	DB	'accepts only ''yes'' or ''no''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CMOJKGNC@Invalid?5XML?5encoding?5name@
CONST	SEGMENT
??_C@_0BK@CMOJKGNC@Invalid?5XML?5encoding?5name@ DB 'Invalid XML encoding'
	DB	' name', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGHHEGNE@String?5not?5started?5expecting?5?8?5@
CONST	SEGMENT
??_C@_0CE@EGHHEGNE@String?5not?5started?5expecting?5?8?5@ DB 'String not '
	DB	'started expecting '' or "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@
CONST	SEGMENT
??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@ DB 'String no'
	DB	't closed expecting " or ''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FLAMKNN@expected?5?8?$DN?8@
CONST	SEGMENT
??_C@_0N@FLAMKNN@expected?5?8?$DN?8@ DB 'expected ''=''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ELMJBAIC@EndTag?3?5?8?$DM?1?8?5not?5found@
CONST	SEGMENT
??_C@_0BH@ELMJBAIC@EndTag?3?5?8?$DM?1?8?5not?5found@ DB 'EndTag: ''</'' n'
	DB	'ot found', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NIFLODD@DOCTYPE?5improperly?5terminated@
CONST	SEGMENT
??_C@_0BO@NIFLODD@DOCTYPE?5improperly?5terminated@ DB 'DOCTYPE improperly'
	DB	' terminated', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KLEMOBLL@EntityRef?3?5expecting?5?8?$DL?8@
CONST	SEGMENT
??_C@_0BJ@KLEMOBLL@EntityRef?3?5expecting?5?8?$DL?8@ DB 'EntityRef: expec'
	DB	'ting '';''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LJALGGHL@external?5parsed?5entities?5cannot@
CONST	SEGMENT
??_C@_0CO@LJALGGHL@external?5parsed?5entities?5cannot@ DB 'external parse'
	DB	'd entities cannot be standalone', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@
CONST	SEGMENT
??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@ DB 'parsi'
	DB	'ng XML declaration: ''?>'' expected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HHECNJCA@Text?5declaration?5?8?$DM?$DPxml?8?5requir@
CONST	SEGMENT
??_C@_0CC@HHECNJCA@Text?5declaration?5?8?$DM?$DPxml?8?5requir@ DB 'Text d'
	DB	'eclaration ''<?xml'' required', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OHPJFFIN@XML?5conditional?5section?5not?5clo@
CONST	SEGMENT
??_C@_0CD@OHPJFFIN@XML?5conditional?5section?5not?5clo@ DB 'XML condition'
	DB	'al section not closed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@JDEKAAA@conditional?5section?5INCLUDE?5or?5@
CONST	SEGMENT
??_C@_0DH@JDEKAAA@conditional?5section?5INCLUDE?5or?5@ DB 'conditional se'
	DB	'ction INCLUDE or IGNORE keyword expected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HHCGNGIK@Content?5error?5in?5the?5external?5s@
CONST	SEGMENT
??_C@_0CF@HHCGNGIK@Content?5error?5in?5the?5external?5s@ DB 'Content erro'
	DB	'r in the external subset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GGBMHDE@XML?5conditional?5section?5?8?$FL?8?5exp@
CONST	SEGMENT
??_C@_0CF@GGBMHDE@XML?5conditional?5section?5?8?$FL?8?5exp@ DB 'XML condi'
	DB	'tional section ''['' expected', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HPGHEIE@expected?5?8?$DO?8@
CONST	SEGMENT
??_C@_0N@HPGHEIE@expected?5?8?$DO?8@ DB 'expected ''>''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CEDHFOGD@PEReference?3?5forbidden?5within?5m@
CONST	SEGMENT
??_C@_0DN@CEDHFOGD@PEReference?3?5forbidden?5within?5m@ DB 'PEReference: '
	DB	'forbidden within markup decl in internal subset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EHNJPHMB@ContentDecl?5?3?5?8?0?8?5?8?$HM?8?5or?5?8?$CJ?8?5ex@
CONST	SEGMENT
??_C@_0CG@EHNJPHMB@ContentDecl?5?3?5?8?0?8?5?8?$HM?8?5or?5?8?$CJ?8?5ex@ DB 'C'
	DB	'ontentDecl : '','' ''|'' or '')'' expected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NHADBOBB@ContentDecl?5?3?5Name?5or?5?8?$CI?8?5expec@
CONST	SEGMENT
??_C@_0CD@NHADBOBB@ContentDecl?5?3?5Name?5or?5?8?$CI?8?5expec@ DB 'Conten'
	DB	'tDecl : Name or ''('' expected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HEHENOGB@MixedContentDecl?5?3?5?8?$CDPCDATA?8?5ex@
CONST	SEGMENT
??_C@_0CG@HEHENOGB@MixedContentDecl?5?3?5?8?$CDPCDATA?8?5ex@ DB 'MixedCon'
	DB	'tentDecl : ''#PCDATA'' expected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LOAMKAA@MixedContentDecl?5?3?5?8?$HM?8?5or?5?8?$CJ?$CK?8?5@
CONST	SEGMENT
??_C@_0CI@LOAMKAA@MixedContentDecl?5?3?5?8?$HM?8?5or?5?8?$CJ?$CK?8?5@ DB 'M'
	DB	'ixedContentDecl : ''|'' or '')*'' expected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KPIIIINI@?8?$CJ?8?5required?5to?5finish?5ATTLIST?5@
CONST	SEGMENT
??_C@_0CL@KPIIIINI@?8?$CJ?8?5required?5to?5finish?5ATTLIST?5@ DB ''')'' r'
	DB	'equired to finish ATTLIST enumeration', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EHCBGKID@NmToken?5expected?5in?5ATTLIST?5enu@
CONST	SEGMENT
??_C@_0CI@EHCBGKID@NmToken?5expected?5in?5ATTLIST?5enu@ DB 'NmToken expec'
	DB	'ted in ATTLIST enumeration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NNFMCGNH@?8?$CI?8?5required?5to?5start?5ATTLIST?5e@
CONST	SEGMENT
??_C@_0CK@NNFMCGNH@?8?$CI?8?5required?5to?5start?5ATTLIST?5e@ DB '''('' r'
	DB	'equired to start ATTLIST enumeration', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DMGJOFPK@Fragment?5not?5allowed@
CONST	SEGMENT
??_C@_0BF@DMGJOFPK@Fragment?5not?5allowed@ DB 'Fragment not allowed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LMNHCPFE@Entity?5value?5required@
CONST	SEGMENT
??_C@_0BG@LMNHCPFE@Entity?5value?5required@ DB 'Entity value required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MHMGOJAD@?8?$DO?8?5required?5to?5close?5NOTATION?5@
CONST	SEGMENT
??_C@_0CL@MHMGOJAD@?8?$DO?8?5required?5to?5close?5NOTATION?5@ DB '''>'' r'
	DB	'equired to close NOTATION declaration', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HECCFNBP@NOTATION?3?5Name?5expected?5here@
CONST	SEGMENT
??_C@_0BN@HECCFNBP@NOTATION?3?5Name?5expected?5here@ DB 'NOTATION: Name e'
	DB	'xpected here', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KMPMBNCM@Invalid?5PI?5name@
CONST	SEGMENT
??_C@_0BA@KMPMBNCM@Invalid?5PI?5name@ DB 'Invalid PI name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HPBPCNCM@xmlParsePI?5?3?5no?5target?5name@
CONST	SEGMENT
??_C@_0BM@HPBPCNCM@xmlParsePI?5?3?5no?5target?5name@ DB 'xmlParsePI : no '
	DB	'target name', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IKEFGBAE@Comment?5must?5not?5contain?5?8?9?9?8?5?$CI@
CONST	SEGMENT
??_C@_0CO@IKEFGBAE@Comment?5must?5not?5contain?5?8?9?9?8?5?$CI@ DB 'Comme'
	DB	'nt must not contain ''--'' (double-hyphen)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ICNPKBIN@PUBLIC?0?5the?5Public?5Identifier?5i@
CONST	SEGMENT
??_C@_0CJ@ICNPKBIN@PUBLIC?0?5the?5Public?5Identifier?5i@ DB 'PUBLIC, the '
	DB	'Public Identifier is missing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GDPMMHJJ@SYSTEM?5or?5PUBLIC?0?5the?5URI?5is?5mi@
CONST	SEGMENT
??_C@_0CF@GDPMMHJJ@SYSTEM?5or?5PUBLIC?0?5the?5URI?5is?5mi@ DB 'SYSTEM or '
	DB	'PUBLIC, the URI is missing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PLPMIKHI@Sequence?5?8?$FN?$FN?$DO?8?5not?5allowed?5in?5c@
CONST	SEGMENT
??_C@_0CG@PLPMIKHI@Sequence?5?8?$FN?$FN?$DO?8?5not?5allowed?5in?5c@ DB 'S'
	DB	'equence '']]>'' not allowed in content', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PIPOCKJD@Unfinished?5System?5or?5Public?5ID?5@
CONST	SEGMENT
??_C@_0CP@PIPOCKJD@Unfinished?5System?5or?5Public?5ID?5@ DB 'Unfinished S'
	DB	'ystem or Public ID " or '' expected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NINNHDOL@SystemLiteral?5?$CC?5or?5?8?5expected@
CONST	SEGMENT
??_C@_0BO@NINNHDOL@SystemLiteral?5?$CC?5or?5?8?5expected@ DB 'SystemLiter'
	DB	'al " or '' expected', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FNIFNHDI@Unescaped?5?8?$DM?8?5not?5allowed?5in?5at@
CONST	SEGMENT
??_C@_0CP@FNIFNHDI@Unescaped?5?8?$DM?8?5not?5allowed?5in?5at@ DB 'Unescap'
	DB	'ed ''<'' not allowed in attributes values', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ELBMECGA@AttValue?3?5?$CC?5or?5?8?5expected@
CONST	SEGMENT
??_C@_0BK@ELBMECGA@AttValue?3?5?$CC?5or?5?8?5expected@ DB 'AttValue: " or'
	DB	' '' expected', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GAJOCPOL@PEReferences?5forbidden?5in?5inter@
CONST	SEGMENT
??_C@_0CK@GAJOCPOL@PEReferences?5forbidden?5in?5inter@ DB 'PEReferences f'
	DB	'orbidden in internal subset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DPACNJHE@EntityValue?3?5?$CC?5or?5?8?5expected@
CONST	SEGMENT
??_C@_0BN@DPACNJHE@EntityValue?3?5?$CC?5or?5?8?5expected@ DB 'EntityValue'
	DB	': " or '' expected', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@
CONST	SEGMENT
??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@ DB 'Detected an e'
	DB	'ntity reference loop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PFALGNCI@PEReference?3?5expecting?5?8?$DL?8@
CONST	SEGMENT
??_C@_0BL@PFALGNCI@PEReference?3?5expecting?5?8?$DL?8@ DB 'PEReference: e'
	DB	'xpecting '';''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DCHKIALM@PEReference?3?5no?5name@
CONST	SEGMENT
??_C@_0BF@DCHKIALM@PEReference?3?5no?5name@ DB 'PEReference: no name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JMKGIIGE@PEReference?5in?5epilog@
CONST	SEGMENT
??_C@_0BG@JMKGIIGE@PEReference?5in?5epilog@ DB 'PEReference in epilog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GLMIGPKG@PEReference?5in?5prolog@
CONST	SEGMENT
??_C@_0BG@GLMIGPKG@PEReference?5in?5prolog@ DB 'PEReference in prolog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MALDLPDI@PEReference?5at?5end?5of?5document@
CONST	SEGMENT
??_C@_0BP@MALDLPDI@PEReference?5at?5end?5of?5document@ DB 'PEReference at'
	DB	' end of document', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LPIEGNHB@internal?5error@
CONST	SEGMENT
??_C@_0P@LPIEGNHB@internal?5error@ DB 'internal error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OCLALBPG@CharRef?3?5invalid?5value@
CONST	SEGMENT
??_C@_0BH@OCLALBPG@CharRef?3?5invalid?5value@ DB 'CharRef: invalid value', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DEJKBBIB@CharRef?3?5invalid?5decimal?5value@
CONST	SEGMENT
??_C@_0BP@DEJKBBIB@CharRef?3?5invalid?5decimal?5value@ DB 'CharRef: inval'
	DB	'id decimal value', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IIBKOMHK@CharRef?3?5invalid?5hexadecimal?5va@
CONST	SEGMENT
??_C@_0CD@IIBKOMHK@CharRef?3?5invalid?5hexadecimal?5va@ DB 'CharRef: inva'
	DB	'lid hexadecimal value', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GJOEMOIC@Attribute?5?$CFs?3?$CFs?5redefined?6@
CONST	SEGMENT
??_C@_0BL@GJOEMOIC@Attribute?5?$CFs?3?$CFs?5redefined?6@ DB 'Attribute %s'
	DB	':%s redefined', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LJKBJNKP@Attribute?5?$CFs?5redefined?6@
CONST	SEGMENT
??_C@_0BI@LJKBJNKP@Attribute?5?$CFs?5redefined?6@ DB 'Attribute %s redefi'
	DB	'ned', 0aH, 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlW3CPIs DD	FLAT:??_C@_0P@HPOCOPDB@xml?9stylesheet@
	DD	FLAT:??_C@_09OBPBGIJC@xml?9model@
	DD	00H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlDoRead
_TEXT	SEGMENT
_hdlr$1 = -8						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_URL$ = 12						; size = 4
_encoding$ = 16						; size = 4
_options$ = 20						; size = 4
_reuse$ = 24						; size = 4
_xmlDoRead PROC						; COMDAT

; 15184: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15185:     xmlDocPtr ret;
; 15186: 
; 15187:     xmlCtxtUseOptionsInternal(ctxt, options, encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtUseOptionsInternal
	add	esp, 12					; 0000000cH

; 15188:     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN2@xmlDoRead

; 15189:         xmlCharEncodingHandlerPtr hdlr;
; 15190: 
; 15191: 	hdlr = xmlFindCharEncodingHandler(encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _hdlr$1[ebp], eax

; 15192: 	if (hdlr != NULL)

	cmp	DWORD PTR _hdlr$1[ebp], 0
	je	SHORT $LN2@xmlDoRead

; 15193: 	    xmlSwitchToEncoding(ctxt, hdlr);

	mov	ecx, DWORD PTR _hdlr$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSwitchToEncoding
	add	esp, 8
$LN2@xmlDoRead:

; 15194:     }
; 15195:     if ((URL != NULL) && (ctxt->input != NULL) &&

	cmp	DWORD PTR _URL$[ebp], 0
	je	SHORT $LN4@xmlDoRead
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN4@xmlDoRead
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN4@xmlDoRead

; 15196:         (ctxt->input->filename == NULL))
; 15197:         ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);

	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+4], eax
$LN4@xmlDoRead:

; 15198:     xmlParseDocument(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseDocument
	add	esp, 4

; 15199:     if ((ctxt->wellFormed) || ctxt->recovery)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN7@xmlDoRead
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+288], 0
	je	SHORT $LN5@xmlDoRead
$LN7@xmlDoRead:

; 15200:         ret = ctxt->myDoc;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ret$[ebp], ecx
	jmp	SHORT $LN6@xmlDoRead
$LN5@xmlDoRead:

; 15201:     else {
; 15202:         ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 15203: 	if (ctxt->myDoc != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN6@xmlDoRead

; 15204: 	    xmlFreeDoc(ctxt->myDoc);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4
$LN6@xmlDoRead:

; 15205: 	}
; 15206:     }
; 15207:     ctxt->myDoc = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 0

; 15208:     if (!reuse) {

	cmp	DWORD PTR _reuse$[ebp], 0
	jne	SHORT $LN9@xmlDoRead

; 15209: 	xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4
$LN9@xmlDoRead:

; 15210:     }
; 15211: 
; 15212:     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]

; 15213: }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDoRead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCheckTransition
_TEXT	SEGMENT
tv147 = -24						; size = 4
tv137 = -20						; size = 4
tv129 = -16						; size = 4
tv89 = -12						; size = 4
tv81 = -8						; size = 4
tv73 = -4						; size = 4
_ctxt$ = 8						; size = 4
_chunk$ = 12						; size = 4
_size$ = 16						; size = 4
_xmlParseCheckTransition PROC				; COMDAT

; 12084: xmlParseCheckTransition(xmlParserCtxtPtr ctxt, const char *chunk, int size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 12085:     if ((ctxt == NULL) || (chunk == NULL) || (size < 0))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlParseCh
	cmp	DWORD PTR _chunk$[ebp], 0
	je	SHORT $LN3@xmlParseCh
	cmp	DWORD PTR _size$[ebp], 0
	jge	SHORT $LN2@xmlParseCh
$LN3@xmlParseCh:

; 12086:         return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseCh
$LN2@xmlParseCh:

; 12087:     if (ctxt->instate == XML_PARSER_START_TAG) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], 6
	jne	SHORT $LN4@xmlParseCh

; 12088:         if (memchr(chunk, '>', size) != NULL)

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	62					; 0000003eH
	mov	edx, DWORD PTR _chunk$[ebp]
	push	edx
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $LN5@xmlParseCh

; 12089:             return(1);

	mov	eax, 1
	jmp	$LN1@xmlParseCh
$LN5@xmlParseCh:

; 12090:         return(0);

	xor	eax, eax
	jmp	$LN1@xmlParseCh
$LN4@xmlParseCh:

; 12091:     }
; 12092:     if (ctxt->progressive == XML_PARSER_COMMENT) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 5
	jne	SHORT $LN6@xmlParseCh

; 12093:         if (memchr(chunk, '>', size) != NULL)

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	62					; 0000003eH
	mov	edx, DWORD PTR _chunk$[ebp]
	push	edx
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv81[ebp], eax
	cmp	DWORD PTR tv81[ebp], 0
	je	SHORT $LN7@xmlParseCh

; 12094:             return(1);

	mov	eax, 1
	jmp	$LN1@xmlParseCh
$LN7@xmlParseCh:

; 12095:         return(0);

	xor	eax, eax
	jmp	$LN1@xmlParseCh
$LN6@xmlParseCh:

; 12096:     }
; 12097:     if (ctxt->instate == XML_PARSER_CDATA_SECTION) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], 8
	jne	SHORT $LN8@xmlParseCh

; 12098:         if (memchr(chunk, '>', size) != NULL)

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	62					; 0000003eH
	mov	edx, DWORD PTR _chunk$[ebp]
	push	edx
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv89[ebp], eax
	cmp	DWORD PTR tv89[ebp], 0
	je	SHORT $LN9@xmlParseCh

; 12099:             return(1);

	mov	eax, 1
	jmp	$LN1@xmlParseCh
$LN9@xmlParseCh:

; 12100:         return(0);

	xor	eax, eax
	jmp	$LN1@xmlParseCh
$LN8@xmlParseCh:

; 12101:     }
; 12102:     if (ctxt->progressive == XML_PARSER_PI) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 2
	jne	SHORT $LN10@xmlParseCh

; 12103:         if (memchr(chunk, '>', size) != NULL)

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	62					; 0000003eH
	mov	edx, DWORD PTR _chunk$[ebp]
	push	edx
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv129[ebp], eax
	cmp	DWORD PTR tv129[ebp], 0
	je	SHORT $LN11@xmlParseCh

; 12104:             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlParseCh
$LN11@xmlParseCh:

; 12105:         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseCh
$LN10@xmlParseCh:

; 12106:     }
; 12107:     if (ctxt->instate == XML_PARSER_END_TAG) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], 9
	jne	SHORT $LN12@xmlParseCh

; 12108:         if (memchr(chunk, '>', size) != NULL)

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	62					; 0000003eH
	mov	edx, DWORD PTR _chunk$[ebp]
	push	edx
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv137[ebp], eax
	cmp	DWORD PTR tv137[ebp], 0
	je	SHORT $LN13@xmlParseCh

; 12109:             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlParseCh
$LN13@xmlParseCh:

; 12110:         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseCh
$LN12@xmlParseCh:

; 12111:     }
; 12112:     if ((ctxt->progressive == XML_PARSER_DTD) ||

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 3
	je	SHORT $LN15@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], 3
	jne	SHORT $LN14@xmlParseCh
$LN15@xmlParseCh:

; 12113:         (ctxt->instate == XML_PARSER_DTD)) {
; 12114:         if (memchr(chunk, '>', size) != NULL)

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	push	62					; 0000003eH
	mov	eax, DWORD PTR _chunk$[ebp]
	push	eax
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv147[ebp], eax
	cmp	DWORD PTR tv147[ebp], 0
	je	SHORT $LN16@xmlParseCh

; 12115:             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlParseCh
$LN16@xmlParseCh:

; 12116:         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseCh
$LN14@xmlParseCh:

; 12117:     }
; 12118:     return(1);

	mov	eax, 1
$LN1@xmlParseCh:

; 12119: }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCheckTransition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseTryOrFinish
_TEXT	SEGMENT
tv180 = -324						; size = 4
_buffer$1 = -316					; size = 150
_found$2 = -160						; size = 4
_use$3 = -156						; size = 4
_quote$4 = -149						; size = 1
_buf$5 = -148						; size = 4
_i$6 = -144						; size = 4
_base$7 = -140						; size = 4
_skipl$8 = -136						; size = 4
_tmp$9 = -132						; size = 4
_skipl$10 = -128					; size = 4
_tmp$11 = -124						; size = 4
_base$12 = -120						; size = 4
_term$13 = -116						; size = 4
_cons$14 = -112						; size = 4
_test$15 = -108						; size = 4
_nsNr$16 = -104						; size = 4
_URI$17 = -96						; size = 4
_prefix$18 = -84					; size = 4
_name$19 = -76						; size = 4
_enc$20 = -72						; size = 4
_start$21 = -64						; size = 4
_current$22 = -56					; size = 4
_base$23 = -52						; size = 4
_lastgt$ = -44						; size = 4
_lastlt$ = -32						; size = 4
_next$ = -22						; size = 1
_cur$ = -21						; size = 1
_tlen$ = -16						; size = 4
_avail$ = -8						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_terminate$ = 12					; size = 4
_xmlParseTryOrFinish PROC				; COMDAT

; 11089: xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-324]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 11090:     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 11091:     int avail, tlen;
; 11092:     xmlChar cur, next;
; 11093:     const xmlChar *lastlt, *lastgt;
; 11094: 
; 11095:     if (ctxt->input == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN33@xmlParseTr

; 11096:         return(0);

	xor	eax, eax
	jmp	$LN1@xmlParseTr
$LN33@xmlParseTr:

; 11097: 
; 11098: #ifdef DEBUG_PUSH
; 11099:     switch (ctxt->instate) {
; 11100: 	case XML_PARSER_EOF:
; 11101: 	    xmlGenericError(xmlGenericErrorContext,
; 11102: 		    "PP: try EOF\n"); break;
; 11103: 	case XML_PARSER_START:
; 11104: 	    xmlGenericError(xmlGenericErrorContext,
; 11105: 		    "PP: try START\n"); break;
; 11106: 	case XML_PARSER_MISC:
; 11107: 	    xmlGenericError(xmlGenericErrorContext,
; 11108: 		    "PP: try MISC\n");break;
; 11109: 	case XML_PARSER_COMMENT:
; 11110: 	    xmlGenericError(xmlGenericErrorContext,
; 11111: 		    "PP: try COMMENT\n");break;
; 11112: 	case XML_PARSER_PROLOG:
; 11113: 	    xmlGenericError(xmlGenericErrorContext,
; 11114: 		    "PP: try PROLOG\n");break;
; 11115: 	case XML_PARSER_START_TAG:
; 11116: 	    xmlGenericError(xmlGenericErrorContext,
; 11117: 		    "PP: try START_TAG\n");break;
; 11118: 	case XML_PARSER_CONTENT:
; 11119: 	    xmlGenericError(xmlGenericErrorContext,
; 11120: 		    "PP: try CONTENT\n");break;
; 11121: 	case XML_PARSER_CDATA_SECTION:
; 11122: 	    xmlGenericError(xmlGenericErrorContext,
; 11123: 		    "PP: try CDATA_SECTION\n");break;
; 11124: 	case XML_PARSER_END_TAG:
; 11125: 	    xmlGenericError(xmlGenericErrorContext,
; 11126: 		    "PP: try END_TAG\n");break;
; 11127: 	case XML_PARSER_ENTITY_DECL:
; 11128: 	    xmlGenericError(xmlGenericErrorContext,
; 11129: 		    "PP: try ENTITY_DECL\n");break;
; 11130: 	case XML_PARSER_ENTITY_VALUE:
; 11131: 	    xmlGenericError(xmlGenericErrorContext,
; 11132: 		    "PP: try ENTITY_VALUE\n");break;
; 11133: 	case XML_PARSER_ATTRIBUTE_VALUE:
; 11134: 	    xmlGenericError(xmlGenericErrorContext,
; 11135: 		    "PP: try ATTRIBUTE_VALUE\n");break;
; 11136: 	case XML_PARSER_DTD:
; 11137: 	    xmlGenericError(xmlGenericErrorContext,
; 11138: 		    "PP: try DTD\n");break;
; 11139: 	case XML_PARSER_EPILOG:
; 11140: 	    xmlGenericError(xmlGenericErrorContext,
; 11141: 		    "PP: try EPILOG\n");break;
; 11142: 	case XML_PARSER_PI:
; 11143: 	    xmlGenericError(xmlGenericErrorContext,
; 11144: 		    "PP: try PI\n");break;
; 11145:         case XML_PARSER_IGNORE:
; 11146:             xmlGenericError(xmlGenericErrorContext,
; 11147: 		    "PP: try IGNORE\n");break;
; 11148:     }
; 11149: #endif
; 11150: 
; 11151:     if ((ctxt->input != NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN34@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 4096				; 00001000H
	jle	SHORT $LN34@xmlParseTr

; 11152:         (ctxt->input->cur - ctxt->input->base > 4096)) {
; 11153: 	xmlSHRINK(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSHRINK
	add	esp, 4

; 11154: 	ctxt->checkIndex = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+204], 0
$LN34@xmlParseTr:

; 11155:     }
; 11156:     xmlParseGetLasts(ctxt, &lastlt, &lastgt);

	lea	eax, DWORD PTR _lastgt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lastlt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseGetLasts
	add	esp, 12					; 0000000cH
$LN2@xmlParseTr:

; 11157: 
; 11158:     while (ctxt->instate != XML_PARSER_EOF) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	je	$done$260

; 11159: 	if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+84], 0
	je	SHORT $LN35@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 1
	jne	SHORT $LN35@xmlParseTr

; 11160: 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlParseTr
$LN35@xmlParseTr:

; 11161: 
; 11162: 	if (ctxt->input == NULL) break;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN36@xmlParseTr
	jmp	$done$260
$LN36@xmlParseTr:

; 11163: 	if (ctxt->input->buf == NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN37@xmlParseTr

; 11164: 	    avail = ctxt->input->length -

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [ecx+24]
	sub	ecx, eax
	mov	DWORD PTR _avail$[ebp], ecx
	jmp	$LN38@xmlParseTr
$LN37@xmlParseTr:

; 11165: 	            (ctxt->input->cur - ctxt->input->base);
; 11166: 	else {
; 11167: 	    /*
; 11168: 	     * If we are operating on converted input, try to flush
; 11169: 	     * remainng chars to avoid them stalling in the non-converted
; 11170: 	     * buffer. But do not do this in document start where
; 11171: 	     * encoding="..." may not have been read and we work on a
; 11172: 	     * guessed encoding.
; 11173: 	     */
; 11174: 	    if ((ctxt->instate != XML_PARSER_START) &&
; 11175: 	        (ctxt->input->buf->raw != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], 0
	je	$LN39@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+20], 0
	je	$LN39@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlBufIsEmpty
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN39@xmlParseTr

; 11176: 		(xmlBufIsEmpty(ctxt->input->buf->raw) == 0)) {
; 11177:                 size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufGetInputBase
	add	esp, 8
	mov	DWORD PTR _base$23[ebp], eax

; 11178:                                                  ctxt->input);
; 11179: 		size_t current = ctxt->input->cur - ctxt->input->base;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _current$22[ebp], edx

; 11180: 
; 11181: 		xmlParserInputBufferPush(ctxt->input->buf, 0, "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlParserInputBufferPush
	add	esp, 12					; 0000000cH

; 11182:                 xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,

	mov	eax, DWORD PTR _current$22[ebp]
	push	eax
	mov	ecx, DWORD PTR _base$23[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufSetInputBaseCur
	add	esp, 16					; 00000010H
$LN39@xmlParseTr:

; 11183:                                       base, current);
; 11184: 	    }
; 11185: 	    avail = xmlBufUse(ctxt->input->buf->buffer) -

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufUse
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	sub	eax, edx
	mov	DWORD PTR _avail$[ebp], eax
$LN38@xmlParseTr:

; 11186: 		    (ctxt->input->cur - ctxt->input->base);
; 11187: 	}
; 11188:         if (avail < 1)

	cmp	DWORD PTR _avail$[ebp], 1
	jge	SHORT $LN40@xmlParseTr

; 11189: 	    goto done;

	jmp	$done$260
$LN40@xmlParseTr:

; 11190:         switch (ctxt->instate) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	mov	DWORD PTR tv180[ebp], ecx
	mov	edx, DWORD PTR tv180[ebp]
	add	edx, 1
	mov	DWORD PTR tv180[ebp], edx
	cmp	DWORD PTR tv180[ebp], 17		; 00000011H
	ja	$LN4@xmlParseTr
	mov	eax, DWORD PTR tv180[ebp]
	jmp	DWORD PTR $LN259@xmlParseTr[eax*4]
$LN41@xmlParseTr:

; 11191:             case XML_PARSER_EOF:
; 11192: 	        /*
; 11193: 		 * Document parsing is done !
; 11194: 		 */
; 11195: 	        goto done;

	jmp	$done$260
$LN42@xmlParseTr:

; 11196:             case XML_PARSER_START:
; 11197: 		if (ctxt->charset == XML_CHAR_ENCODING_NONE) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+256], 0
	jne	$LN43@xmlParseTr

; 11198: 		    xmlChar start[4];
; 11199: 		    xmlCharEncoding enc;
; 11200: 
; 11201: 		    /*
; 11202: 		     * Very first chars read from the document flow.
; 11203: 		     */
; 11204: 		    if (avail < 4)

	cmp	DWORD PTR _avail$[ebp], 4
	jge	SHORT $LN44@xmlParseTr

; 11205: 			goto done;

	jmp	$done$260
$LN44@xmlParseTr:

; 11206: 
; 11207: 		    /*
; 11208: 		     * Get the 4 first bytes and decode the charset
; 11209: 		     * if enc != XML_CHAR_ENCODING_NONE
; 11210: 		     * plug some encoding conversion routines,
; 11211: 		     * else xmlSwitchEncoding will set to (default)
; 11212: 		     * UTF8.
; 11213: 		     */
; 11214: 		    start[0] = RAW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR _start$21[ebp+eax], cl

; 11215: 		    start[1] = NXT(1);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	mov	eax, 1
	shl	eax, 0
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR _start$21[ebp+eax], cl

; 11216: 		    start[2] = NXT(2);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	mov	eax, 1
	shl	eax, 1
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR _start$21[ebp+eax], cl

; 11217: 		    start[3] = NXT(3);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, 1
	imul	ecx, ecx, 3
	mov	dl, BYTE PTR [edx+eax]
	mov	BYTE PTR _start$21[ebp+ecx], dl

; 11218: 		    enc = xmlDetectCharEncoding(start, 4);

	push	4
	lea	eax, DWORD PTR _start$21[ebp]
	push	eax
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$20[ebp], eax

; 11219: 		    xmlSwitchEncoding(ctxt, enc);

	mov	ecx, DWORD PTR _enc$20[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSwitchEncoding
	add	esp, 8

; 11220: 		    break;

	jmp	$LN4@xmlParseTr
$LN43@xmlParseTr:

; 11221: 		}
; 11222: 
; 11223: 		if (avail < 2)

	cmp	DWORD PTR _avail$[ebp], 2
	jge	SHORT $LN45@xmlParseTr

; 11224: 		    goto done;

	jmp	$done$260
$LN45@xmlParseTr:

; 11225: 		cur = ctxt->input->cur[0];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	mov	dl, BYTE PTR [eax+ecx]
	mov	BYTE PTR _cur$[ebp], dl

; 11226: 		next = ctxt->input->cur[1];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR _next$[ebp], cl

; 11227: 		if (cur == 0) {

	movzx	edx, BYTE PTR _cur$[ebp]
	test	edx, edx
	jne	$LN46@xmlParseTr

; 11228: 		    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN47@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN47@xmlParseTr

; 11229: 			ctxt->sax->setDocumentLocator(ctxt->userData,

	call	___xmlDefaultSAXLocator
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN47@xmlParseTr:

; 11230: 						      &xmlDefaultSAXLocator);
; 11231: 		    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);

	push	0
	push	4
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 11232: 		    xmlHaltParser(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlHaltParser
	add	esp, 4

; 11233: #ifdef DEBUG_PUSH
; 11234: 		    xmlGenericError(xmlGenericErrorContext,
; 11235: 			    "PP: entering EOF\n");
; 11236: #endif
; 11237: 		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN48@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN48@xmlParseTr

; 11238: 			ctxt->sax->endDocument(ctxt->userData);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN48@xmlParseTr:

; 11239: 		    goto done;

	jmp	$done$260
$LN46@xmlParseTr:

; 11240: 		}
; 11241: 	        if ((cur == '<') && (next == '?')) {

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 60					; 0000003cH
	jne	$LN49@xmlParseTr
	movzx	ecx, BYTE PTR _next$[ebp]
	cmp	ecx, 63					; 0000003fH
	jne	$LN49@xmlParseTr

; 11242: 		    /* PI or XML decl */
; 11243: 		    if (avail < 5) return(ret);

	cmp	DWORD PTR _avail$[ebp], 5
	jge	SHORT $LN51@xmlParseTr
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParseTr
$LN51@xmlParseTr:

; 11244: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN52@xmlParseTr
	push	0
	push	62					; 0000003eH
	push	63					; 0000003fH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN52@xmlParseTr

; 11245: 		        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))
; 11246: 			return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParseTr
$LN52@xmlParseTr:

; 11247: 		    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN53@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN53@xmlParseTr

; 11248: 			ctxt->sax->setDocumentLocator(ctxt->userData,

	call	___xmlDefaultSAXLocator
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN53@xmlParseTr:

; 11249: 						      &xmlDefaultSAXLocator);
; 11250: 		    if ((ctxt->input->cur[2] == 'x') &&
; 11251: 			(ctxt->input->cur[3] == 'm') &&
; 11252: 			(ctxt->input->cur[4] == 'l') &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 120				; 00000078H
	jne	$LN54@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 109				; 0000006dH
	jne	$LN54@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 108				; 0000006cH
	jne	$LN54@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN56@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 9
	jl	SHORT $LN57@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN56@xmlParseTr
$LN57@xmlParseTr:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 13					; 0000000dH
	jne	$LN54@xmlParseTr
$LN56@xmlParseTr:

; 11253: 			(IS_BLANK_CH(ctxt->input->cur[5]))) {
; 11254: 			ret += 5;

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, 5
	mov	DWORD PTR _ret$[ebp], eax

; 11255: #ifdef DEBUG_PUSH
; 11256: 			xmlGenericError(xmlGenericErrorContext,
; 11257: 				"PP: Parsing XML Decl\n");
; 11258: #endif
; 11259: 			xmlParseXMLDecl(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseXMLDecl
	add	esp, 4

; 11260: 			if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+84], 32			; 00000020H
	jne	SHORT $LN58@xmlParseTr

; 11261: 			    /*
; 11262: 			     * The XML REC instructs us to stop parsing right
; 11263: 			     * here
; 11264: 			     */
; 11265: 			    xmlHaltParser(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlHaltParser
	add	esp, 4

; 11266: 			    return(0);

	xor	eax, eax
	jmp	$LN1@xmlParseTr
$LN58@xmlParseTr:

; 11267: 			}
; 11268: 			ctxt->standalone = ctxt->input->standalone;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	mov	DWORD PTR [eax+28], ecx

; 11269: 			if ((ctxt->encoding == NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN59@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN59@xmlParseTr

; 11270: 			    (ctxt->input->encoding != NULL))
; 11271: 			    ctxt->encoding = xmlStrdup(ctxt->input->encoding);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+24], eax
$LN59@xmlParseTr:

; 11272: 			if ((ctxt->sax) && (ctxt->sax->startDocument) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN60@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN60@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN60@xmlParseTr

; 11273: 			    (!ctxt->disableSAX))
; 11274: 			    ctxt->sax->startDocument(ctxt->userData);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN60@xmlParseTr:

; 11275: 			ctxt->instate = XML_PARSER_MISC;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 1

; 11276: #ifdef DEBUG_PUSH
; 11277: 			xmlGenericError(xmlGenericErrorContext,
; 11278: 				"PP: entering MISC\n");
; 11279: #endif
; 11280: 		    } else {

	jmp	SHORT $LN55@xmlParseTr
$LN54@xmlParseTr:

; 11281: 			ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlCharStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 11282: 			if ((ctxt->sax) && (ctxt->sax->startDocument) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN61@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN61@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN61@xmlParseTr

; 11283: 			    (!ctxt->disableSAX))
; 11284: 			    ctxt->sax->startDocument(ctxt->userData);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN61@xmlParseTr:

; 11285: 			ctxt->instate = XML_PARSER_MISC;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 1
$LN55@xmlParseTr:

; 11286: #ifdef DEBUG_PUSH
; 11287: 			xmlGenericError(xmlGenericErrorContext,
; 11288: 				"PP: entering MISC\n");
; 11289: #endif
; 11290: 		    }
; 11291: 		} else {

	jmp	$LN50@xmlParseTr
$LN49@xmlParseTr:

; 11292: 		    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN62@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN62@xmlParseTr

; 11293: 			ctxt->sax->setDocumentLocator(ctxt->userData,

	call	___xmlDefaultSAXLocator
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN62@xmlParseTr:

; 11294: 						      &xmlDefaultSAXLocator);
; 11295: 		    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlCharStrdup
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+20], eax

; 11296: 		    if (ctxt->version == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN63@xmlParseTr

; 11297: 		        xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 11298: 			break;

	jmp	$LN4@xmlParseTr
$LN63@xmlParseTr:

; 11299: 		    }
; 11300: 		    if ((ctxt->sax) && (ctxt->sax->startDocument) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN64@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN64@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN64@xmlParseTr

; 11301: 		        (!ctxt->disableSAX))
; 11302: 			ctxt->sax->startDocument(ctxt->userData);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN64@xmlParseTr:

; 11303: 		    ctxt->instate = XML_PARSER_MISC;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 1
$LN50@xmlParseTr:

; 11304: #ifdef DEBUG_PUSH
; 11305: 		    xmlGenericError(xmlGenericErrorContext,
; 11306: 			    "PP: entering MISC\n");
; 11307: #endif
; 11308: 		}
; 11309: 		break;

	jmp	$LN4@xmlParseTr
$LN65@xmlParseTr:

; 11310:             case XML_PARSER_START_TAG: {
; 11311: 	        const xmlChar *name;
; 11312: 		const xmlChar *prefix = NULL;

	mov	DWORD PTR _prefix$18[ebp], 0

; 11313: 		const xmlChar *URI = NULL;

	mov	DWORD PTR _URI$17[ebp], 0

; 11314: 		int nsNr = ctxt->nsNr;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	mov	DWORD PTR _nsNr$16[ebp], ecx

; 11315: 
; 11316: 		if ((avail < 2) && (ctxt->inputNr == 1))

	cmp	DWORD PTR _avail$[ebp], 2
	jge	SHORT $LN66@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1
	jne	SHORT $LN66@xmlParseTr

; 11317: 		    goto done;

	jmp	$done$260
$LN66@xmlParseTr:

; 11318: 		cur = ctxt->input->cur[0];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	mov	dl, BYTE PTR [eax+ecx]
	mov	BYTE PTR _cur$[ebp], dl

; 11319: 	        if (cur != '<') {

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN67@xmlParseTr

; 11320: 		    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);

	push	0
	push	4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 11321: 		    xmlHaltParser(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlHaltParser
	add	esp, 4

; 11322: 		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN68@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN68@xmlParseTr

; 11323: 			ctxt->sax->endDocument(ctxt->userData);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+52]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN68@xmlParseTr:

; 11324: 		    goto done;

	jmp	$done$260
$LN67@xmlParseTr:

; 11325: 		}
; 11326: 		if (!terminate) {

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN69@xmlParseTr

; 11327: 		    if (ctxt->progressive) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	je	SHORT $LN70@xmlParseTr

; 11328: 		        /* > can be found unescaped in attribute values */
; 11329: 		        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))

	cmp	DWORD PTR _lastgt$[ebp], 0
	je	SHORT $LN73@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _lastgt$[ebp]
	jb	SHORT $LN72@xmlParseTr
$LN73@xmlParseTr:

; 11330: 			    goto done;

	jmp	$done$260
$LN72@xmlParseTr:

; 11331: 		    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {

	jmp	SHORT $LN69@xmlParseTr
$LN70@xmlParseTr:
	push	0
	push	0
	push	62					; 0000003eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN69@xmlParseTr

; 11332: 			goto done;

	jmp	$done$260
$LN69@xmlParseTr:

; 11333: 		    }
; 11334: 		}
; 11335: 		if (ctxt->spaceNr == 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+236], 0
	jne	SHORT $LN75@xmlParseTr

; 11336: 		    spacePush(ctxt, -1);

	push	-1
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_spacePush
	add	esp, 8
	jmp	SHORT $LN76@xmlParseTr
$LN75@xmlParseTr:

; 11337: 		else if (*ctxt->space == -2)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	cmp	DWORD PTR [ecx], -2			; fffffffeH
	jne	SHORT $LN77@xmlParseTr

; 11338: 		    spacePush(ctxt, -1);

	push	-1
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_spacePush
	add	esp, 8
	jmp	SHORT $LN76@xmlParseTr
$LN77@xmlParseTr:

; 11339: 		else
; 11340: 		    spacePush(ctxt, *ctxt->space);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_spacePush
	add	esp, 8
$LN76@xmlParseTr:

; 11341: #ifdef LIBXML_SAX1_ENABLED
; 11342: 		if (ctxt->sax2)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+324], 0
	je	SHORT $LN79@xmlParseTr

; 11343: #endif /* LIBXML_SAX1_ENABLED */
; 11344: 		    name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);

	lea	edx, DWORD PTR _tlen$[ebp]
	push	edx
	lea	eax, DWORD PTR _URI$17[ebp]
	push	eax
	lea	ecx, DWORD PTR _prefix$18[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseStartTag2
	add	esp, 16					; 00000010H
	mov	DWORD PTR _name$19[ebp], eax
	jmp	SHORT $LN80@xmlParseTr
$LN79@xmlParseTr:

; 11345: #ifdef LIBXML_SAX1_ENABLED
; 11346: 		else
; 11347: 		    name = xmlParseStartTag(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseStartTag
	add	esp, 4
	mov	DWORD PTR _name$19[ebp], eax
$LN80@xmlParseTr:

; 11348: #endif /* LIBXML_SAX1_ENABLED */
; 11349: 		if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN81@xmlParseTr

; 11350: 		    goto done;

	jmp	$done$260
$LN81@xmlParseTr:

; 11351: 		if (name == NULL) {

	cmp	DWORD PTR _name$19[ebp], 0
	jne	SHORT $LN82@xmlParseTr

; 11352: 		    spacePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_spacePop
	add	esp, 4

; 11353: 		    xmlHaltParser(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlHaltParser
	add	esp, 4

; 11354: 		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN83@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN83@xmlParseTr

; 11355: 			ctxt->sax->endDocument(ctxt->userData);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN83@xmlParseTr:

; 11356: 		    goto done;

	jmp	$done$260
$LN82@xmlParseTr:

; 11357: 		}
; 11358: #ifdef LIBXML_VALID_ENABLED
; 11359: 		/*
; 11360: 		 * [ VC: Root Element Type ]
; 11361: 		 * The Name in the document type declaration must match
; 11362: 		 * the element type of the root element.
; 11363: 		 */
; 11364: 		if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
; 11365: 		    ctxt->node && (ctxt->node == ctxt->myDoc->children))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN84@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN84@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN84@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN84@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, DWORD PTR [edx+12]
	jne	SHORT $LN84@xmlParseTr

; 11366: 		    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	ecx, 108				; 0000006cH
	push	ecx
	call	_xmlValidateRoot
	add	esp, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	and	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+100], eax
$LN84@xmlParseTr:

; 11367: #endif /* LIBXML_VALID_ENABLED */
; 11368: 
; 11369: 		/*
; 11370: 		 * Check for an Empty Element.
; 11371: 		 */
; 11372: 		if ((RAW == '/') && (NXT(1) == '>')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	jne	$LN85@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 62					; 0000003eH
	jne	$LN85@xmlParseTr
$LN8@xmlParseTr:

; 11373: 		    SKIP(2);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN6@xmlParseTr
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN6@xmlParseTr:
	xor	eax, eax
	jne	SHORT $LN8@xmlParseTr

; 11374: 
; 11375: 		    if (ctxt->sax2) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+324], 0
	je	SHORT $LN87@xmlParseTr

; 11376: 			if ((ctxt->sax != NULL) &&
; 11377: 			    (ctxt->sax->endElementNs != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN89@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+120], 0
	je	SHORT $LN89@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN89@xmlParseTr

; 11378: 			    (!ctxt->disableSAX))
; 11379: 			    ctxt->sax->endElementNs(ctxt->userData, name,

	mov	esi, esp
	mov	eax, DWORD PTR _URI$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$18[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$19[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+120]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN89@xmlParseTr:

; 11380: 			                            prefix, URI);
; 11381: 			if (ctxt->nsNr - nsNr > 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	sub	eax, DWORD PTR _nsNr$16[ebp]
	test	eax, eax
	jle	SHORT $LN90@xmlParseTr

; 11382: 			    nsPop(ctxt, ctxt->nsNr - nsNr);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	sub	edx, DWORD PTR _nsNr$16[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_nsPop
	add	esp, 8
$LN90@xmlParseTr:

; 11383: #ifdef LIBXML_SAX1_ENABLED
; 11384: 		    } else {

	jmp	SHORT $LN88@xmlParseTr
$LN87@xmlParseTr:

; 11385: 			if ((ctxt->sax != NULL) &&
; 11386: 			    (ctxt->sax->endElement != NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN88@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+60], 0
	je	SHORT $LN88@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN88@xmlParseTr

; 11387: 			    (!ctxt->disableSAX))
; 11388: 			    ctxt->sax->endElement(ctxt->userData, name);

	mov	esi, esp
	mov	edx, DWORD PTR _name$19[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+60]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN88@xmlParseTr:

; 11389: #endif /* LIBXML_SAX1_ENABLED */
; 11390: 		    }
; 11391: 		    if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN92@xmlParseTr

; 11392: 			goto done;

	jmp	$done$260
$LN92@xmlParseTr:

; 11393: 		    spacePop(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_spacePop
	add	esp, 4

; 11394: 		    if (ctxt->nameNr == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+188], 0
	jne	SHORT $LN93@xmlParseTr

; 11395: 			ctxt->instate = XML_PARSER_EPILOG;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 14			; 0000000eH

; 11396: 		    } else {

	jmp	SHORT $LN94@xmlParseTr
$LN93@xmlParseTr:

; 11397: 			ctxt->instate = XML_PARSER_CONTENT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 7
$LN94@xmlParseTr:

; 11398: 		    }
; 11399:                     ctxt->progressive = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+292], 1

; 11400: 		    break;

	jmp	$LN4@xmlParseTr
$LN85@xmlParseTr:

; 11401: 		}
; 11402: 		if (RAW == '>') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	jne	SHORT $LN95@xmlParseTr

; 11403: 		    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 11404: 		} else {

	jmp	SHORT $LN96@xmlParseTr
$LN95@xmlParseTr:

; 11405: 		    xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,

	mov	ecx, DWORD PTR _name$19[ebp]
	push	ecx
	push	OFFSET ??_C@_0CD@HIMAKCPA@Couldn?8t?5find?5end?5of?5Start?5Tag?5@
	push	73					; 00000049H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 11406: 					 "Couldn't find end of Start Tag %s\n",
; 11407: 					 name);
; 11408: 		    nodePop(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_nodePop
	add	esp, 4

; 11409: 		    spacePop(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_spacePop
	add	esp, 4
$LN96@xmlParseTr:

; 11410: 		}
; 11411: 		if (ctxt->sax2)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+324], 0
	je	SHORT $LN97@xmlParseTr

; 11412: 		    nameNsPush(ctxt, name, prefix, URI, ctxt->nsNr - nsNr);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	sub	ecx, DWORD PTR _nsNr$16[ebp]
	push	ecx
	mov	edx, DWORD PTR _URI$17[ebp]
	push	edx
	mov	eax, DWORD PTR _prefix$18[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$19[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_nameNsPush
	add	esp, 20					; 00000014H
	jmp	SHORT $LN98@xmlParseTr
$LN97@xmlParseTr:

; 11413: #ifdef LIBXML_SAX1_ENABLED
; 11414: 		else
; 11415: 		    namePush(ctxt, name);

	mov	eax, DWORD PTR _name$19[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_namePush
	add	esp, 8
$LN98@xmlParseTr:

; 11416: #endif /* LIBXML_SAX1_ENABLED */
; 11417: 
; 11418: 		ctxt->instate = XML_PARSER_CONTENT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 7

; 11419:                 ctxt->progressive = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+292], 1

; 11420:                 break;

	jmp	$LN4@xmlParseTr
$LN99@xmlParseTr:

; 11421: 	    }
; 11422:             case XML_PARSER_CONTENT: {
; 11423: 		const xmlChar *test;
; 11424: 		unsigned int cons;
; 11425: 		if ((avail < 2) && (ctxt->inputNr == 1))

	cmp	DWORD PTR _avail$[ebp], 2
	jge	SHORT $LN100@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 1
	jne	SHORT $LN100@xmlParseTr

; 11426: 		    goto done;

	jmp	$done$260
$LN100@xmlParseTr:

; 11427: 		cur = ctxt->input->cur[0];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR _cur$[ebp], cl

; 11428: 		next = ctxt->input->cur[1];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR _next$[ebp], al

; 11429: 
; 11430: 		test = CUR_PTR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _test$15[ebp], eax

; 11431: 	        cons = ctxt->input->consumed;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _cons$14[ebp], eax

; 11432: 		if ((cur == '<') && (next == '/')) {

	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN101@xmlParseTr
	movzx	edx, BYTE PTR _next$[ebp]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN101@xmlParseTr

; 11433: 		    ctxt->instate = XML_PARSER_END_TAG;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 9

; 11434: 		    break;

	jmp	$LN4@xmlParseTr
	jmp	$LN102@xmlParseTr
$LN101@xmlParseTr:

; 11435: 	        } else if ((cur == '<') && (next == '?')) {

	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN103@xmlParseTr
	movzx	edx, BYTE PTR _next$[ebp]
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN103@xmlParseTr

; 11436: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN105@xmlParseTr
	push	0
	push	62					; 0000003eH
	push	63					; 0000003fH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN105@xmlParseTr

; 11437: 		        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {
; 11438:                         ctxt->progressive = XML_PARSER_PI;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+292], 2

; 11439: 			goto done;

	jmp	$done$260
$LN105@xmlParseTr:

; 11440:                     }
; 11441: 		    xmlParsePI(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParsePI
	add	esp, 4

; 11442: 		    ctxt->instate = XML_PARSER_CONTENT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 7

; 11443:                     ctxt->progressive = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+292], 1
	jmp	$LN102@xmlParseTr
$LN103@xmlParseTr:

; 11444: 		} else if ((cur == '<') && (next != '!')) {

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 60					; 0000003cH
	jne	SHORT $LN106@xmlParseTr
	movzx	eax, BYTE PTR _next$[ebp]
	cmp	eax, 33					; 00000021H
	je	SHORT $LN106@xmlParseTr

; 11445: 		    ctxt->instate = XML_PARSER_START_TAG;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 6

; 11446: 		    break;

	jmp	$LN4@xmlParseTr

; 11447: 		} else if ((cur == '<') && (next == '!') &&

	jmp	$LN102@xmlParseTr
$LN106@xmlParseTr:

; 11448: 		           (ctxt->input->cur[2] == '-') &&

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 60					; 0000003cH
	jne	$LN108@xmlParseTr
	movzx	eax, BYTE PTR _next$[ebp]
	cmp	eax, 33					; 00000021H
	jne	$LN108@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	$LN108@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	$LN108@xmlParseTr

; 11449: 			   (ctxt->input->cur[3] == '-')) {
; 11450: 		    int term;
; 11451: 
; 11452: 	            if (avail < 4)

	cmp	DWORD PTR _avail$[ebp], 4
	jge	SHORT $LN110@xmlParseTr

; 11453: 		        goto done;

	jmp	$done$260
$LN110@xmlParseTr:

; 11454: 		    ctxt->input->cur += 4;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 4
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx

; 11455: 		    term = xmlParseLookupSequence(ctxt, '-', '-', '>');

	push	62					; 0000003eH
	push	45					; 0000002dH
	push	45					; 0000002dH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	mov	DWORD PTR _term$13[ebp], eax

; 11456: 		    ctxt->input->cur -= 4;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, 4
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx

; 11457: 		    if ((!terminate) && (term < 0)) {

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN111@xmlParseTr
	cmp	DWORD PTR _term$13[ebp], 0
	jge	SHORT $LN111@xmlParseTr

; 11458:                         ctxt->progressive = XML_PARSER_COMMENT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+292], 5

; 11459: 			goto done;

	jmp	$done$260
$LN111@xmlParseTr:

; 11460:                     }
; 11461: 		    xmlParseComment(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseComment
	add	esp, 4

; 11462: 		    ctxt->instate = XML_PARSER_CONTENT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 7

; 11463:                     ctxt->progressive = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+292], 1

; 11464: 		} else if ((cur == '<') && (ctxt->input->cur[1] == '!') &&

	jmp	$LN102@xmlParseTr
$LN108@xmlParseTr:

; 11465: 		    (ctxt->input->cur[2] == '[') &&
; 11466: 		    (ctxt->input->cur[3] == 'C') &&
; 11467: 		    (ctxt->input->cur[4] == 'D') &&
; 11468: 		    (ctxt->input->cur[5] == 'A') &&
; 11469: 		    (ctxt->input->cur[6] == 'T') &&
; 11470: 		    (ctxt->input->cur[7] == 'A') &&

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 60					; 0000003cH
	jne	$LN112@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 33					; 00000021H
	jne	$LN112@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 91					; 0000005bH
	jne	$LN112@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 67					; 00000043H
	jne	$LN112@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 68					; 00000044H
	jne	$LN112@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 65					; 00000041H
	jne	$LN112@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 84					; 00000054H
	jne	$LN112@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 65					; 00000041H
	jne	$LN112@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 91					; 0000005bH
	jne	SHORT $LN112@xmlParseTr
$LN11@xmlParseTr:

; 11471: 		    (ctxt->input->cur[8] == '[')) {
; 11472: 		    SKIP(9);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 9
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 9
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 9
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN9@xmlParseTr
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN9@xmlParseTr:
	xor	ecx, ecx
	jne	SHORT $LN11@xmlParseTr

; 11473: 		    ctxt->instate = XML_PARSER_CDATA_SECTION;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 8

; 11474: 		    break;

	jmp	$LN4@xmlParseTr
	jmp	$LN102@xmlParseTr
$LN112@xmlParseTr:

; 11475: 		} else if ((cur == '<') && (next == '!') &&

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN115@xmlParseTr
	movzx	ecx, BYTE PTR _next$[ebp]
	cmp	ecx, 33					; 00000021H
	jne	SHORT $LN115@xmlParseTr
	cmp	DWORD PTR _avail$[ebp], 9
	jge	SHORT $LN115@xmlParseTr

; 11476: 		           (avail < 9)) {
; 11477: 		    goto done;

	jmp	$done$260
	jmp	$LN102@xmlParseTr
$LN115@xmlParseTr:

; 11478: 		} else if (cur == '&') {

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 38					; 00000026H
	jne	SHORT $LN117@xmlParseTr

; 11479: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN119@xmlParseTr
	push	0
	push	0
	push	59					; 0000003bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN119@xmlParseTr

; 11480: 		        (xmlParseLookupSequence(ctxt, ';', 0, 0) < 0))
; 11481: 			goto done;

	jmp	$done$260
$LN119@xmlParseTr:

; 11482: 		    xmlParseReference(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseReference
	add	esp, 4

; 11483: 		} else {

	jmp	SHORT $LN102@xmlParseTr
$LN117@xmlParseTr:

; 11484: 		    /* TODO Avoid the extra copy, handle directly !!! */
; 11485: 		    /*
; 11486: 		     * Goal of the following test is:
; 11487: 		     *  - minimize calls to the SAX 'character' callback
; 11488: 		     *    when they are mergeable
; 11489: 		     *  - handle an problem for isBlank when we only parse
; 11490: 		     *    a sequence of blank chars and the next one is
; 11491: 		     *    not available to check against '<' presence.
; 11492: 		     *  - tries to homogenize the differences in SAX
; 11493: 		     *    callbacks between the push and pull versions
; 11494: 		     *    of the parser.
; 11495: 		     */
; 11496: 		    if ((ctxt->inputNr == 1) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1
	jne	SHORT $LN120@xmlParseTr
	cmp	DWORD PTR _avail$[ebp], 300		; 0000012cH
	jge	SHORT $LN120@xmlParseTr

; 11497: 		        (avail < XML_PARSER_BIG_BUFFER_SIZE)) {
; 11498: 			if (!terminate) {

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN120@xmlParseTr

; 11499: 			    if (ctxt->progressive) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	je	SHORT $LN122@xmlParseTr

; 11500: 				if ((lastlt == NULL) ||

	cmp	DWORD PTR _lastlt$[ebp], 0
	je	SHORT $LN125@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _lastlt$[ebp]
	jbe	SHORT $LN124@xmlParseTr
$LN125@xmlParseTr:

; 11501: 				    (ctxt->input->cur > lastlt))
; 11502: 				    goto done;

	jmp	$done$260
$LN124@xmlParseTr:

; 11503: 			    } else if (xmlParseLookupSequence(ctxt,

	jmp	SHORT $LN120@xmlParseTr
$LN122@xmlParseTr:

; 11504: 			                                      '<', 0, 0) < 0) {

	push	0
	push	0
	push	60					; 0000003cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN120@xmlParseTr

; 11505: 				goto done;

	jmp	$done$260
$LN120@xmlParseTr:

; 11506: 			    }
; 11507: 			}
; 11508:                     }
; 11509: 		    ctxt->checkIndex = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+204], 0

; 11510: 		    xmlParseCharData(ctxt, 0);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseCharData
	add	esp, 8
$LN102@xmlParseTr:

; 11511: 		}
; 11512: 		if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _cons$14[ebp]
	cmp	eax, DWORD PTR [edx+36]
	jne	SHORT $LN127@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _test$15[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jne	SHORT $LN127@xmlParseTr

; 11513: 		    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CG@FCFCBOFE@detected?5an?5error?5in?5element?5co@
	push	1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 11514: 		                "detected an error in element content\n");
; 11515: 		    xmlHaltParser(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlHaltParser
	add	esp, 4

; 11516: 		    break;

	jmp	$LN4@xmlParseTr
$LN127@xmlParseTr:

; 11517: 		}
; 11518: 		break;

	jmp	$LN4@xmlParseTr
$LN128@xmlParseTr:

; 11519: 	    }
; 11520:             case XML_PARSER_END_TAG:
; 11521: 		if (avail < 2)

	cmp	DWORD PTR _avail$[ebp], 2
	jge	SHORT $LN129@xmlParseTr

; 11522: 		    goto done;

	jmp	$done$260
$LN129@xmlParseTr:

; 11523: 		if (!terminate) {

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN130@xmlParseTr

; 11524: 		    if (ctxt->progressive) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	je	SHORT $LN131@xmlParseTr

; 11525: 		        /* > can be found unescaped in attribute values */
; 11526: 		        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))

	cmp	DWORD PTR _lastgt$[ebp], 0
	je	SHORT $LN134@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _lastgt$[ebp]
	jb	SHORT $LN133@xmlParseTr
$LN134@xmlParseTr:

; 11527: 			    goto done;

	jmp	$done$260
$LN133@xmlParseTr:

; 11528: 		    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {

	jmp	SHORT $LN130@xmlParseTr
$LN131@xmlParseTr:
	push	0
	push	0
	push	62					; 0000003eH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN130@xmlParseTr

; 11529: 			goto done;

	jmp	$done$260
$LN130@xmlParseTr:

; 11530: 		    }
; 11531: 		}
; 11532: 		if (ctxt->sax2) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+324], 0
	je	SHORT $LN136@xmlParseTr

; 11533: 		    xmlParseEndTag2(ctxt,

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	imul	ecx, DWORD PTR [eax+188], 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+344]
	mov	ecx, DWORD PTR [eax+ecx*4-4]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	imul	eax, DWORD PTR [edx+188], 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	mov	eax, DWORD PTR [edx+eax*4-8]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	imul	edx, DWORD PTR [ecx+188], 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+344]
	mov	edx, DWORD PTR [ecx+edx*4-12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseEndTag2
	add	esp, 24					; 00000018H

; 11534: 		            (void *) ctxt->pushTab[ctxt->nameNr * 3 - 3],
; 11535: 		            (void *) ctxt->pushTab[ctxt->nameNr * 3 - 2], 0,
; 11536: 		            (int) (ptrdiff_t)
; 11537:                                 ctxt->pushTab[ctxt->nameNr * 3 - 1], 0);
; 11538: 		    nameNsPop(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_nameNsPop
	add	esp, 4

; 11539: 		}

	jmp	SHORT $LN137@xmlParseTr
$LN136@xmlParseTr:

; 11540: #ifdef LIBXML_SAX1_ENABLED
; 11541: 		  else
; 11542: 		    xmlParseEndTag1(ctxt, 0);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseEndTag1
	add	esp, 8
$LN137@xmlParseTr:

; 11543: #endif /* LIBXML_SAX1_ENABLED */
; 11544: 		if (ctxt->instate == XML_PARSER_EOF) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN138@xmlParseTr
	jmp	SHORT $LN139@xmlParseTr
$LN138@xmlParseTr:

; 11545: 		    /* Nothing */
; 11546: 		} else if (ctxt->nameNr == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+188], 0
	jne	SHORT $LN140@xmlParseTr

; 11547: 		    ctxt->instate = XML_PARSER_EPILOG;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 14			; 0000000eH

; 11548: 		} else {

	jmp	SHORT $LN139@xmlParseTr
$LN140@xmlParseTr:

; 11549: 		    ctxt->instate = XML_PARSER_CONTENT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 7
$LN139@xmlParseTr:

; 11550: 		}
; 11551: 		break;

	jmp	$LN4@xmlParseTr
$LN142@xmlParseTr:

; 11552:             case XML_PARSER_CDATA_SECTION: {
; 11553: 	        /*
; 11554: 		 * The Push mode need to have the SAX callback for
; 11555: 		 * cdataBlock merge back contiguous callbacks.
; 11556: 		 */
; 11557: 		int base;
; 11558: 
; 11559: 		base = xmlParseLookupSequence(ctxt, ']', ']', '>');

	push	62					; 0000003eH
	push	93					; 0000005dH
	push	93					; 0000005dH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	mov	DWORD PTR _base$12[ebp], eax

; 11560: 		if (base < 0) {

	cmp	DWORD PTR _base$12[ebp], 0
	jge	$LN143@xmlParseTr

; 11561: 		    if (avail >= XML_PARSER_BIG_BUFFER_SIZE + 2) {

	cmp	DWORD PTR _avail$[ebp], 302		; 0000012eH
	jl	$LN145@xmlParseTr

; 11562: 		        int tmp;
; 11563: 
; 11564: 			tmp = xmlCheckCdataPush(ctxt->input->cur,

	push	0
	push	300					; 0000012cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlCheckCdataPush
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$11[ebp], eax

; 11565: 			                        XML_PARSER_BIG_BUFFER_SIZE, 0);
; 11566: 			if (tmp < 0) {

	cmp	DWORD PTR _tmp$11[ebp], 0
	jge	SHORT $LN146@xmlParseTr

; 11567: 			    tmp = -tmp;

	mov	edx, DWORD PTR _tmp$11[ebp]
	neg	edx
	mov	DWORD PTR _tmp$11[ebp], edx

; 11568: 			    ctxt->input->cur += tmp;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _tmp$11[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx

; 11569: 			    goto encoding_error;

	jmp	$encoding_error$261
$LN146@xmlParseTr:

; 11570: 			}
; 11571: 			if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN147@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN147@xmlParseTr

; 11572: 			    if (ctxt->sax->cdataBlock != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+100], 0
	je	SHORT $LN148@xmlParseTr

; 11573: 				ctxt->sax->cdataBlock(ctxt->userData,

	mov	esi, esp
	mov	eax, DWORD PTR _tmp$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+100]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN147@xmlParseTr
$LN148@xmlParseTr:

; 11574: 				                      ctxt->input->cur, tmp);
; 11575: 			    else if (ctxt->sax->characters != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN147@xmlParseTr

; 11576: 				ctxt->sax->characters(ctxt->userData,

	mov	esi, esp
	mov	edx, DWORD PTR _tmp$11[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+68]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN147@xmlParseTr:

; 11577: 				                      ctxt->input->cur, tmp);
; 11578: 			}
; 11579: 			if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN14@xmlParseTr

; 11580: 			    goto done;

	jmp	$done$260
$LN14@xmlParseTr:

; 11581: 			SKIPL(tmp);

	mov	DWORD PTR _skipl$10[ebp], 0
	jmp	SHORT $LN17@xmlParseTr
$LN15@xmlParseTr:
	mov	eax, DWORD PTR _skipl$10[ebp]
	add	eax, 1
	mov	DWORD PTR _skipl$10[ebp], eax
$LN17@xmlParseTr:
	mov	ecx, DWORD PTR _skipl$10[ebp]
	cmp	ecx, DWORD PTR _tmp$11[ebp]
	jge	SHORT $LN16@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN152@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+28], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN153@xmlParseTr
$LN152@xmlParseTr:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
$LN153@xmlParseTr:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	jmp	$LN15@xmlParseTr
$LN16@xmlParseTr:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN12@xmlParseTr
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN12@xmlParseTr:
	xor	edx, edx
	jne	$LN14@xmlParseTr

; 11582: 			ctxt->checkIndex = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+204], 0
$LN145@xmlParseTr:

; 11583: 		    }
; 11584: 		    goto done;

	jmp	$done$260

; 11585: 		} else {

	jmp	$LN144@xmlParseTr
$LN143@xmlParseTr:

; 11586: 		    int tmp;
; 11587: 
; 11588: 		    tmp = xmlCheckCdataPush(ctxt->input->cur, base, 1);

	push	1
	mov	ecx, DWORD PTR _base$12[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlCheckCdataPush
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmp$9[ebp], eax

; 11589: 		    if ((tmp < 0) || (tmp != base)) {

	cmp	DWORD PTR _tmp$9[ebp], 0
	jl	SHORT $LN156@xmlParseTr
	mov	edx, DWORD PTR _tmp$9[ebp]
	cmp	edx, DWORD PTR _base$12[ebp]
	je	SHORT $LN155@xmlParseTr
$LN156@xmlParseTr:

; 11590: 			tmp = -tmp;

	mov	eax, DWORD PTR _tmp$9[ebp]
	neg	eax
	mov	DWORD PTR _tmp$9[ebp], eax

; 11591: 			ctxt->input->cur += tmp;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _tmp$9[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax

; 11592: 			goto encoding_error;

	jmp	$encoding_error$261
$LN155@xmlParseTr:

; 11593: 		    }
; 11594: 		    if ((ctxt->sax != NULL) && (base == 0) &&
; 11595: 		        (ctxt->sax->cdataBlock != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN157@xmlParseTr
	cmp	DWORD PTR _base$12[ebp], 0
	jne	$LN157@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+100], 0
	je	SHORT $LN157@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN157@xmlParseTr

; 11596: 		        (!ctxt->disableSAX)) {
; 11597: 			/*
; 11598: 			 * Special case to provide identical behaviour
; 11599: 			 * between pull and push parsers on enpty CDATA
; 11600: 			 * sections
; 11601: 			 */
; 11602: 			 if ((ctxt->input->cur - ctxt->input->base >= 9) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	cmp	edx, 9
	jl	SHORT $LN159@xmlParseTr
	mov	esi, esp
	push	9
	push	OFFSET ??_C@_09BLLNCBLF@?$DM?$CB?$FLCDATA?$FL@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, -9
	add	eax, DWORD PTR [ecx+16]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN159@xmlParseTr

; 11603: 			     (!strncmp((const char *)&ctxt->input->cur[-9],
; 11604: 			               "<![CDATA[", 9)))
; 11605: 			     ctxt->sax->cdataBlock(ctxt->userData,

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+100]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN159@xmlParseTr:

; 11606: 			                           BAD_CAST "", 0);
; 11607: 		    } else if ((ctxt->sax != NULL) && (base > 0) &&

	jmp	$LN158@xmlParseTr
$LN157@xmlParseTr:
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN158@xmlParseTr
	cmp	DWORD PTR _base$12[ebp], 0
	jle	SHORT $LN158@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN158@xmlParseTr

; 11608: 			(!ctxt->disableSAX)) {
; 11609: 			if (ctxt->sax->cdataBlock != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+100], 0
	je	SHORT $LN161@xmlParseTr

; 11610: 			    ctxt->sax->cdataBlock(ctxt->userData,

	mov	esi, esp
	mov	ecx, DWORD PTR _base$12[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+100]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN158@xmlParseTr
$LN161@xmlParseTr:

; 11611: 						  ctxt->input->cur, base);
; 11612: 			else if (ctxt->sax->characters != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN158@xmlParseTr

; 11613: 			    ctxt->sax->characters(ctxt->userData,

	mov	esi, esp
	mov	eax, DWORD PTR _base$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+68]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN158@xmlParseTr:

; 11614: 						  ctxt->input->cur, base);
; 11615: 		    }
; 11616: 		    if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN20@xmlParseTr

; 11617: 			goto done;

	jmp	$done$260
$LN20@xmlParseTr:

; 11618: 		    SKIPL(base + 3);

	mov	DWORD PTR _skipl$8[ebp], 0
	jmp	SHORT $LN23@xmlParseTr
$LN21@xmlParseTr:
	mov	ecx, DWORD PTR _skipl$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _skipl$8[ebp], ecx
$LN23@xmlParseTr:
	mov	edx, DWORD PTR _base$12[ebp]
	add	edx, 3
	cmp	DWORD PTR _skipl$8[ebp], edx
	jge	SHORT $LN22@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN165@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
	jmp	SHORT $LN166@xmlParseTr
$LN165@xmlParseTr:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN166@xmlParseTr:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN21@xmlParseTr
$LN22@xmlParseTr:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN18@xmlParseTr
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN18@xmlParseTr:
	xor	eax, eax
	jne	$LN20@xmlParseTr

; 11619: 		    ctxt->checkIndex = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+204], 0

; 11620: 		    ctxt->instate = XML_PARSER_CONTENT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 7
$LN144@xmlParseTr:

; 11621: #ifdef DEBUG_PUSH
; 11622: 		    xmlGenericError(xmlGenericErrorContext,
; 11623: 			    "PP: entering CONTENT\n");
; 11624: #endif
; 11625: 		}
; 11626: 		break;

	jmp	$LN4@xmlParseTr
$LN168@xmlParseTr:

; 11627: 	    }
; 11628:             case XML_PARSER_MISC:
; 11629: 		SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 11630: 		if (ctxt->input->buf == NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN169@xmlParseTr

; 11631: 		    avail = ctxt->input->length -

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [ecx+24]
	sub	ecx, eax
	mov	DWORD PTR _avail$[ebp], ecx
	jmp	SHORT $LN170@xmlParseTr
$LN169@xmlParseTr:

; 11632: 		            (ctxt->input->cur - ctxt->input->base);
; 11633: 		else
; 11634: 		    avail = xmlBufUse(ctxt->input->buf->buffer) -

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufUse
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	sub	eax, edx
	mov	DWORD PTR _avail$[ebp], eax
$LN170@xmlParseTr:

; 11635: 		            (ctxt->input->cur - ctxt->input->base);
; 11636: 		if (avail < 2)

	cmp	DWORD PTR _avail$[ebp], 2
	jge	SHORT $LN171@xmlParseTr

; 11637: 		    goto done;

	jmp	$done$260
$LN171@xmlParseTr:

; 11638: 		cur = ctxt->input->cur[0];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	mov	dl, BYTE PTR [eax+ecx]
	mov	BYTE PTR _cur$[ebp], dl

; 11639: 		next = ctxt->input->cur[1];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR _next$[ebp], cl

; 11640: 	        if ((cur == '<') && (next == '?')) {

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 60					; 0000003cH
	jne	$LN172@xmlParseTr
	movzx	eax, BYTE PTR _next$[ebp]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN172@xmlParseTr

; 11641: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN174@xmlParseTr
	push	0
	push	62					; 0000003eH
	push	63					; 0000003fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN174@xmlParseTr

; 11642: 		        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {
; 11643:                         ctxt->progressive = XML_PARSER_PI;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+292], 2

; 11644: 			goto done;

	jmp	$done$260
$LN174@xmlParseTr:

; 11645:                     }
; 11646: #ifdef DEBUG_PUSH
; 11647: 		    xmlGenericError(xmlGenericErrorContext,
; 11648: 			    "PP: Parsing PI\n");
; 11649: #endif
; 11650: 		    xmlParsePI(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParsePI
	add	esp, 4

; 11651: 		    if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN175@xmlParseTr

; 11652: 			goto done;

	jmp	$done$260
$LN175@xmlParseTr:

; 11653: 		    ctxt->instate = XML_PARSER_MISC;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 1

; 11654:                     ctxt->progressive = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+292], 1

; 11655: 		    ctxt->checkIndex = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+204], 0

; 11656: 		} else if ((cur == '<') && (next == '!') &&

	jmp	$LN173@xmlParseTr
$LN172@xmlParseTr:

; 11657: 		    (ctxt->input->cur[2] == '-') &&

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 60					; 0000003cH
	jne	$LN176@xmlParseTr
	movzx	eax, BYTE PTR _next$[ebp]
	cmp	eax, 33					; 00000021H
	jne	$LN176@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	$LN176@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN176@xmlParseTr

; 11658: 		    (ctxt->input->cur[3] == '-')) {
; 11659: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN178@xmlParseTr
	push	62					; 0000003eH
	push	45					; 0000002dH
	push	45					; 0000002dH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN178@xmlParseTr

; 11660: 		        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {
; 11661:                         ctxt->progressive = XML_PARSER_COMMENT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+292], 5

; 11662: 			goto done;

	jmp	$done$260
$LN178@xmlParseTr:

; 11663:                     }
; 11664: #ifdef DEBUG_PUSH
; 11665: 		    xmlGenericError(xmlGenericErrorContext,
; 11666: 			    "PP: Parsing Comment\n");
; 11667: #endif
; 11668: 		    xmlParseComment(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseComment
	add	esp, 4

; 11669: 		    if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN179@xmlParseTr

; 11670: 			goto done;

	jmp	$done$260
$LN179@xmlParseTr:

; 11671: 		    ctxt->instate = XML_PARSER_MISC;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 1

; 11672:                     ctxt->progressive = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+292], 1

; 11673: 		    ctxt->checkIndex = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+204], 0

; 11674: 		} else if ((cur == '<') && (next == '!') &&

	jmp	$LN173@xmlParseTr
$LN176@xmlParseTr:

; 11675: 		    (ctxt->input->cur[2] == 'D') &&
; 11676: 		    (ctxt->input->cur[3] == 'O') &&
; 11677: 		    (ctxt->input->cur[4] == 'C') &&
; 11678: 		    (ctxt->input->cur[5] == 'T') &&
; 11679: 		    (ctxt->input->cur[6] == 'Y') &&
; 11680: 		    (ctxt->input->cur[7] == 'P') &&

	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 60					; 0000003cH
	jne	$LN180@xmlParseTr
	movzx	edx, BYTE PTR _next$[ebp]
	cmp	edx, 33					; 00000021H
	jne	$LN180@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 68					; 00000044H
	jne	$LN180@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 79					; 0000004fH
	jne	$LN180@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 67					; 00000043H
	jne	$LN180@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 84					; 00000054H
	jne	$LN180@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 89					; 00000059H
	jne	$LN180@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 80					; 00000050H
	jne	$LN180@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 69					; 00000045H
	jne	$LN180@xmlParseTr

; 11681: 		    (ctxt->input->cur[8] == 'E')) {
; 11682: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN182@xmlParseTr
	push	0
	push	0
	push	62					; 0000003eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN182@xmlParseTr

; 11683: 		        (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0)) {
; 11684:                         ctxt->progressive = XML_PARSER_DTD;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+292], 3

; 11685: 			goto done;

	jmp	$done$260
$LN182@xmlParseTr:

; 11686:                     }
; 11687: #ifdef DEBUG_PUSH
; 11688: 		    xmlGenericError(xmlGenericErrorContext,
; 11689: 			    "PP: Parsing internal subset\n");
; 11690: #endif
; 11691: 		    ctxt->inSubset = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+216], 1

; 11692:                     ctxt->progressive = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+292], 0

; 11693: 		    ctxt->checkIndex = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+204], 0

; 11694: 		    xmlParseDocTypeDecl(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseDocTypeDecl
	add	esp, 4

; 11695: 		    if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN183@xmlParseTr

; 11696: 			goto done;

	jmp	$done$260
$LN183@xmlParseTr:

; 11697: 		    if (RAW == '[') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 91					; 0000005bH
	jne	SHORT $LN184@xmlParseTr

; 11698: 			ctxt->instate = XML_PARSER_DTD;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 3

; 11699: #ifdef DEBUG_PUSH
; 11700: 			xmlGenericError(xmlGenericErrorContext,
; 11701: 				"PP: entering DTD\n");
; 11702: #endif
; 11703: 		    } else {

	jmp	$LN185@xmlParseTr
$LN184@xmlParseTr:

; 11704: 			/*
; 11705: 			 * Create and update the external subset.
; 11706: 			 */
; 11707: 			ctxt->inSubset = 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+216], 2

; 11708: 			if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN186@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN186@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+104], 0
	je	SHORT $LN186@xmlParseTr

; 11709: 			    (ctxt->sax->externalSubset != NULL))
; 11710: 			    ctxt->sax->externalSubset(ctxt->userData,

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+104]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN186@xmlParseTr:

; 11711: 				    ctxt->intSubName, ctxt->extSubSystem,
; 11712: 				    ctxt->extSubURI);
; 11713: 			ctxt->inSubset = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+216], 0

; 11714: 			xmlCleanSpecialAttr(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCleanSpecialAttr
	add	esp, 4

; 11715: 			ctxt->instate = XML_PARSER_PROLOG;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 4
$LN185@xmlParseTr:

; 11716: #ifdef DEBUG_PUSH
; 11717: 			xmlGenericError(xmlGenericErrorContext,
; 11718: 				"PP: entering PROLOG\n");
; 11719: #endif
; 11720: 		    }

	jmp	SHORT $LN173@xmlParseTr
$LN180@xmlParseTr:

; 11721: 		} else if ((cur == '<') && (next == '!') &&

	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN187@xmlParseTr
	movzx	edx, BYTE PTR _next$[ebp]
	cmp	edx, 33					; 00000021H
	jne	SHORT $LN187@xmlParseTr
	cmp	DWORD PTR _avail$[ebp], 9
	jge	SHORT $LN187@xmlParseTr

; 11722: 		           (avail < 9)) {
; 11723: 		    goto done;

	jmp	$done$260

; 11724: 		} else {

	jmp	SHORT $LN173@xmlParseTr
$LN187@xmlParseTr:

; 11725: 		    ctxt->instate = XML_PARSER_START_TAG;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 6

; 11726: 		    ctxt->progressive = XML_PARSER_START_TAG;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+292], 6

; 11727: 		    xmlParseGetLasts(ctxt, &lastlt, &lastgt);

	lea	edx, DWORD PTR _lastgt$[ebp]
	push	edx
	lea	eax, DWORD PTR _lastlt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseGetLasts
	add	esp, 12					; 0000000cH
$LN173@xmlParseTr:

; 11728: #ifdef DEBUG_PUSH
; 11729: 		    xmlGenericError(xmlGenericErrorContext,
; 11730: 			    "PP: entering START_TAG\n");
; 11731: #endif
; 11732: 		}
; 11733: 		break;

	jmp	$LN4@xmlParseTr
$LN189@xmlParseTr:

; 11734:             case XML_PARSER_PROLOG:
; 11735: 		SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 11736: 		if (ctxt->input->buf == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN190@xmlParseTr

; 11737: 		    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax+24]
	sub	eax, edx
	mov	DWORD PTR _avail$[ebp], eax
	jmp	SHORT $LN191@xmlParseTr
$LN190@xmlParseTr:

; 11738: 		else
; 11739: 		    avail = xmlBufUse(ctxt->input->buf->buffer) -

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufUse
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [edx+12]
	sub	eax, ecx
	mov	DWORD PTR _avail$[ebp], eax
$LN191@xmlParseTr:

; 11740:                             (ctxt->input->cur - ctxt->input->base);
; 11741: 		if (avail < 2)

	cmp	DWORD PTR _avail$[ebp], 2
	jge	SHORT $LN192@xmlParseTr

; 11742: 		    goto done;

	jmp	$done$260
$LN192@xmlParseTr:

; 11743: 		cur = ctxt->input->cur[0];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR _cur$[ebp], cl

; 11744: 		next = ctxt->input->cur[1];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR _next$[ebp], al

; 11745: 	        if ((cur == '<') && (next == '?')) {

	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN193@xmlParseTr
	movzx	edx, BYTE PTR _next$[ebp]
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN193@xmlParseTr

; 11746: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN195@xmlParseTr
	push	0
	push	62					; 0000003eH
	push	63					; 0000003fH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN195@xmlParseTr

; 11747: 		        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {
; 11748:                         ctxt->progressive = XML_PARSER_PI;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+292], 2

; 11749: 			goto done;

	jmp	$done$260
$LN195@xmlParseTr:

; 11750:                     }
; 11751: #ifdef DEBUG_PUSH
; 11752: 		    xmlGenericError(xmlGenericErrorContext,
; 11753: 			    "PP: Parsing PI\n");
; 11754: #endif
; 11755: 		    xmlParsePI(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParsePI
	add	esp, 4

; 11756: 		    if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN196@xmlParseTr

; 11757: 			goto done;

	jmp	$done$260
$LN196@xmlParseTr:

; 11758: 		    ctxt->instate = XML_PARSER_PROLOG;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 4

; 11759:                     ctxt->progressive = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+292], 1

; 11760: 		} else if ((cur == '<') && (next == '!') &&

	jmp	$LN194@xmlParseTr
$LN193@xmlParseTr:

; 11761: 		    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 60					; 0000003cH
	jne	$LN197@xmlParseTr
	movzx	ecx, BYTE PTR _next$[ebp]
	cmp	ecx, 33					; 00000021H
	jne	$LN197@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	jne	$LN197@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN197@xmlParseTr

; 11762: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN199@xmlParseTr
	push	62					; 0000003eH
	push	45					; 0000002dH
	push	45					; 0000002dH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN199@xmlParseTr

; 11763: 		        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {
; 11764:                         ctxt->progressive = XML_PARSER_COMMENT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+292], 5

; 11765: 			goto done;

	jmp	$done$260
$LN199@xmlParseTr:

; 11766:                     }
; 11767: #ifdef DEBUG_PUSH
; 11768: 		    xmlGenericError(xmlGenericErrorContext,
; 11769: 			    "PP: Parsing Comment\n");
; 11770: #endif
; 11771: 		    xmlParseComment(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseComment
	add	esp, 4

; 11772: 		    if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN200@xmlParseTr

; 11773: 			goto done;

	jmp	$done$260
$LN200@xmlParseTr:

; 11774: 		    ctxt->instate = XML_PARSER_PROLOG;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 4

; 11775:                     ctxt->progressive = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+292], 1
	jmp	SHORT $LN194@xmlParseTr
$LN197@xmlParseTr:

; 11776: 		} else if ((cur == '<') && (next == '!') &&

	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN201@xmlParseTr
	movzx	edx, BYTE PTR _next$[ebp]
	cmp	edx, 33					; 00000021H
	jne	SHORT $LN201@xmlParseTr
	cmp	DWORD PTR _avail$[ebp], 4
	jge	SHORT $LN201@xmlParseTr

; 11777: 		           (avail < 4)) {
; 11778: 		    goto done;

	jmp	$done$260

; 11779: 		} else {

	jmp	SHORT $LN194@xmlParseTr
$LN201@xmlParseTr:

; 11780: 		    ctxt->instate = XML_PARSER_START_TAG;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 6

; 11781: 		    if (ctxt->progressive == 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN203@xmlParseTr

; 11782: 			ctxt->progressive = XML_PARSER_START_TAG;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+292], 6
$LN203@xmlParseTr:

; 11783: 		    xmlParseGetLasts(ctxt, &lastlt, &lastgt);

	lea	eax, DWORD PTR _lastgt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lastlt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseGetLasts
	add	esp, 12					; 0000000cH
$LN194@xmlParseTr:

; 11784: #ifdef DEBUG_PUSH
; 11785: 		    xmlGenericError(xmlGenericErrorContext,
; 11786: 			    "PP: entering START_TAG\n");
; 11787: #endif
; 11788: 		}
; 11789: 		break;

	jmp	$LN4@xmlParseTr
$LN204@xmlParseTr:

; 11790:             case XML_PARSER_EPILOG:
; 11791: 		SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 11792: 		if (ctxt->input->buf == NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN205@xmlParseTr

; 11793: 		    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [ecx+24]
	sub	ecx, eax
	mov	DWORD PTR _avail$[ebp], ecx
	jmp	SHORT $LN206@xmlParseTr
$LN205@xmlParseTr:

; 11794: 		else
; 11795: 		    avail = xmlBufUse(ctxt->input->buf->buffer) -

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufUse
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	sub	eax, edx
	mov	DWORD PTR _avail$[ebp], eax
$LN206@xmlParseTr:

; 11796:                             (ctxt->input->cur - ctxt->input->base);
; 11797: 		if (avail < 2)

	cmp	DWORD PTR _avail$[ebp], 2
	jge	SHORT $LN207@xmlParseTr

; 11798: 		    goto done;

	jmp	$done$260
$LN207@xmlParseTr:

; 11799: 		cur = ctxt->input->cur[0];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	mov	dl, BYTE PTR [eax+ecx]
	mov	BYTE PTR _cur$[ebp], dl

; 11800: 		next = ctxt->input->cur[1];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR _next$[ebp], cl

; 11801: 	        if ((cur == '<') && (next == '?')) {

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 60					; 0000003cH
	jne	SHORT $LN208@xmlParseTr
	movzx	eax, BYTE PTR _next$[ebp]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN208@xmlParseTr

; 11802: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN210@xmlParseTr
	push	0
	push	62					; 0000003eH
	push	63					; 0000003fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN210@xmlParseTr

; 11803: 		        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {
; 11804:                         ctxt->progressive = XML_PARSER_PI;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+292], 2

; 11805: 			goto done;

	jmp	$done$260
$LN210@xmlParseTr:

; 11806:                     }
; 11807: #ifdef DEBUG_PUSH
; 11808: 		    xmlGenericError(xmlGenericErrorContext,
; 11809: 			    "PP: Parsing PI\n");
; 11810: #endif
; 11811: 		    xmlParsePI(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParsePI
	add	esp, 4

; 11812: 		    if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN211@xmlParseTr

; 11813: 			goto done;

	jmp	$done$260
$LN211@xmlParseTr:

; 11814: 		    ctxt->instate = XML_PARSER_EPILOG;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 14			; 0000000eH

; 11815:                     ctxt->progressive = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+292], 1

; 11816: 		} else if ((cur == '<') && (next == '!') &&

	jmp	$LN209@xmlParseTr
$LN208@xmlParseTr:

; 11817: 		    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {

	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 60					; 0000003cH
	jne	$LN212@xmlParseTr
	movzx	edx, BYTE PTR _next$[ebp]
	cmp	edx, 33					; 00000021H
	jne	$LN212@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	jne	$LN212@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN212@xmlParseTr

; 11818: 		    if ((!terminate) &&

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN214@xmlParseTr
	push	62					; 0000003eH
	push	45					; 0000002dH
	push	45					; 0000002dH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseLookupSequence
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN214@xmlParseTr

; 11819: 		        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {
; 11820:                         ctxt->progressive = XML_PARSER_COMMENT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+292], 5

; 11821: 			goto done;

	jmp	$done$260
$LN214@xmlParseTr:

; 11822:                     }
; 11823: #ifdef DEBUG_PUSH
; 11824: 		    xmlGenericError(xmlGenericErrorContext,
; 11825: 			    "PP: Parsing Comment\n");
; 11826: #endif
; 11827: 		    xmlParseComment(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseComment
	add	esp, 4

; 11828: 		    if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN215@xmlParseTr

; 11829: 			goto done;

	jmp	$done$260
$LN215@xmlParseTr:

; 11830: 		    ctxt->instate = XML_PARSER_EPILOG;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 14			; 0000000eH

; 11831:                     ctxt->progressive = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+292], 1
	jmp	SHORT $LN209@xmlParseTr
$LN212@xmlParseTr:

; 11832: 		} else if ((cur == '<') && (next == '!') &&

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 60					; 0000003cH
	jne	SHORT $LN216@xmlParseTr
	movzx	eax, BYTE PTR _next$[ebp]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN216@xmlParseTr
	cmp	DWORD PTR _avail$[ebp], 4
	jge	SHORT $LN216@xmlParseTr

; 11833: 		           (avail < 4)) {
; 11834: 		    goto done;

	jmp	$done$260

; 11835: 		} else {

	jmp	SHORT $LN209@xmlParseTr
$LN216@xmlParseTr:

; 11836: 		    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);

	push	0
	push	5
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 11837: 		    xmlHaltParser(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlHaltParser
	add	esp, 4

; 11838: #ifdef DEBUG_PUSH
; 11839: 		    xmlGenericError(xmlGenericErrorContext,
; 11840: 			    "PP: entering EOF\n");
; 11841: #endif
; 11842: 		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN218@xmlParseTr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN218@xmlParseTr

; 11843: 			ctxt->sax->endDocument(ctxt->userData);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+52]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN218@xmlParseTr:

; 11844: 		    goto done;

	jmp	$done$260
$LN209@xmlParseTr:

; 11845: 		}
; 11846: 		break;

	jmp	$LN4@xmlParseTr
$LN219@xmlParseTr:

; 11847:             case XML_PARSER_DTD: {
; 11848: 	        /*
; 11849: 		 * Sorry but progressive parsing of the internal subset
; 11850: 		 * is not expected to be supported. We first check that
; 11851: 		 * the full content of the internal subset is available and
; 11852: 		 * the parsing is launched only at that point.
; 11853: 		 * Internal subset ends up with "']' S? '>'" in an unescaped
; 11854: 		 * section and not in a ']]>' sequence which are conditional
; 11855: 		 * sections (whoever argued to keep that crap in XML deserve
; 11856: 		 * a place in hell !).
; 11857: 		 */
; 11858: 		int base, i;
; 11859: 		xmlChar *buf;
; 11860: 	        xmlChar quote = 0;

	mov	BYTE PTR _quote$4[ebp], 0

; 11861:                 size_t use;
; 11862: 
; 11863: 		base = ctxt->input->cur - ctxt->input->base;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _base$7[ebp], eax

; 11864: 		if (base < 0) return(0);

	jns	SHORT $LN220@xmlParseTr
	xor	eax, eax
	jmp	$LN1@xmlParseTr
$LN220@xmlParseTr:

; 11865: 		if (ctxt->checkIndex > base)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	cmp	edx, DWORD PTR _base$7[ebp]
	jle	SHORT $LN221@xmlParseTr

; 11866: 		    base = ctxt->checkIndex;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	mov	DWORD PTR _base$7[ebp], ecx
$LN221@xmlParseTr:

; 11867: 		buf = xmlBufContent(ctxt->input->buf->buffer);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufContent
	add	esp, 4
	mov	DWORD PTR _buf$5[ebp], eax

; 11868:                 use = xmlBufUse(ctxt->input->buf->buffer);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufUse
	add	esp, 4
	mov	DWORD PTR _use$3[ebp], eax

; 11869: 		for (;(unsigned int) base < use; base++) {

	jmp	SHORT $LN26@xmlParseTr
$LN24@xmlParseTr:
	mov	ecx, DWORD PTR _base$7[ebp]
	add	ecx, 1
	mov	DWORD PTR _base$7[ebp], ecx
$LN26@xmlParseTr:
	mov	edx, DWORD PTR _base$7[ebp]
	cmp	edx, DWORD PTR _use$3[ebp]
	jae	$LN25@xmlParseTr

; 11870: 		    if (quote != 0) {

	movzx	eax, BYTE PTR _quote$4[ebp]
	test	eax, eax
	je	SHORT $LN222@xmlParseTr

; 11871: 		        if (buf[base] == quote)

	mov	ecx, DWORD PTR _buf$5[ebp]
	add	ecx, DWORD PTR _base$7[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _quote$4[ebp]
	cmp	edx, eax
	jne	SHORT $LN223@xmlParseTr

; 11872: 			    quote = 0;

	mov	BYTE PTR _quote$4[ebp], 0
$LN223@xmlParseTr:

; 11873: 			continue;

	jmp	SHORT $LN24@xmlParseTr
$LN222@xmlParseTr:

; 11874: 		    }
; 11875: 		    if ((quote == 0) && (buf[base] == '<')) {

	movzx	ecx, BYTE PTR _quote$4[ebp]
	test	ecx, ecx
	jne	$LN224@xmlParseTr
	mov	edx, DWORD PTR _buf$5[ebp]
	add	edx, DWORD PTR _base$7[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	$LN224@xmlParseTr

; 11876: 		        int found  = 0;

	mov	DWORD PTR _found$2[ebp], 0

; 11877: 			/* special handling of comments */
; 11878: 		        if (((unsigned int) base + 4 < use) &&
; 11879: 			    (buf[base + 1] == '!') &&
; 11880: 			    (buf[base + 2] == '-') &&

	mov	ecx, DWORD PTR _base$7[ebp]
	add	ecx, 4
	cmp	ecx, DWORD PTR _use$3[ebp]
	jae	$LN224@xmlParseTr
	mov	edx, DWORD PTR _buf$5[ebp]
	add	edx, DWORD PTR _base$7[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 33					; 00000021H
	jne	$LN224@xmlParseTr
	mov	ecx, DWORD PTR _buf$5[ebp]
	add	ecx, DWORD PTR _base$7[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	cmp	edx, 45					; 0000002dH
	jne	$LN224@xmlParseTr
	mov	eax, DWORD PTR _buf$5[ebp]
	add	eax, DWORD PTR _base$7[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	cmp	ecx, 45					; 0000002dH
	jne	$LN224@xmlParseTr

; 11881: 			    (buf[base + 3] == '-')) {
; 11882: 			    for (;(unsigned int) base + 3 < use; base++) {

	jmp	SHORT $LN29@xmlParseTr
$LN27@xmlParseTr:
	mov	edx, DWORD PTR _base$7[ebp]
	add	edx, 1
	mov	DWORD PTR _base$7[ebp], edx
$LN29@xmlParseTr:
	mov	eax, DWORD PTR _base$7[ebp]
	add	eax, 3
	cmp	eax, DWORD PTR _use$3[ebp]
	jae	SHORT $LN28@xmlParseTr

; 11883: 				if ((buf[base] == '-') &&
; 11884: 				    (buf[base + 1] == '-') &&

	mov	ecx, DWORD PTR _buf$5[ebp]
	add	ecx, DWORD PTR _base$7[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN226@xmlParseTr
	mov	eax, DWORD PTR _buf$5[ebp]
	add	eax, DWORD PTR _base$7[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN226@xmlParseTr
	mov	edx, DWORD PTR _buf$5[ebp]
	add	edx, DWORD PTR _base$7[ebp]
	movzx	eax, BYTE PTR [edx+2]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN226@xmlParseTr

; 11885: 				    (buf[base + 2] == '>')) {
; 11886: 				    found = 1;

	mov	DWORD PTR _found$2[ebp], 1

; 11887: 				    base += 2;

	mov	ecx, DWORD PTR _base$7[ebp]
	add	ecx, 2
	mov	DWORD PTR _base$7[ebp], ecx

; 11888: 				    break;

	jmp	SHORT $LN28@xmlParseTr
$LN226@xmlParseTr:

; 11889: 				}
; 11890: 		            }

	jmp	SHORT $LN27@xmlParseTr
$LN28@xmlParseTr:

; 11891: 			    if (!found) {

	cmp	DWORD PTR _found$2[ebp], 0
	jne	SHORT $LN227@xmlParseTr

; 11892: #if 0
; 11893: 			        fprintf(stderr, "unfinished comment\n");
; 11894: #endif
; 11895: 			        break; /* for */

	jmp	$LN25@xmlParseTr
$LN227@xmlParseTr:

; 11896: 		            }
; 11897: 		            continue;

	jmp	$LN24@xmlParseTr
$LN224@xmlParseTr:

; 11898: 			}
; 11899: 		    }
; 11900: 		    if (buf[base] == '"') {

	mov	edx, DWORD PTR _buf$5[ebp]
	add	edx, DWORD PTR _base$7[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN228@xmlParseTr

; 11901: 		        quote = '"';

	mov	BYTE PTR _quote$4[ebp], 34		; 00000022H

; 11902: 			continue;

	jmp	$LN24@xmlParseTr
$LN228@xmlParseTr:

; 11903: 		    }
; 11904: 		    if (buf[base] == '\'') {

	mov	ecx, DWORD PTR _buf$5[ebp]
	add	ecx, DWORD PTR _base$7[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 39					; 00000027H
	jne	SHORT $LN229@xmlParseTr

; 11905: 		        quote = '\'';

	mov	BYTE PTR _quote$4[ebp], 39		; 00000027H

; 11906: 			continue;

	jmp	$LN24@xmlParseTr
$LN229@xmlParseTr:

; 11907: 		    }
; 11908: 		    if (buf[base] == ']') {

	mov	eax, DWORD PTR _buf$5[ebp]
	add	eax, DWORD PTR _base$7[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	jne	$not_end_of_int_subset$262

; 11909: #if 0
; 11910: 		        fprintf(stderr, "%c%c%c%c: ", buf[base],
; 11911: 			        buf[base + 1], buf[base + 2], buf[base + 3]);
; 11912: #endif
; 11913: 		        if ((unsigned int) base +1 >= use)

	mov	edx, DWORD PTR _base$7[ebp]
	add	edx, 1
	cmp	edx, DWORD PTR _use$3[ebp]
	jb	SHORT $LN231@xmlParseTr

; 11914: 			    break;

	jmp	$LN25@xmlParseTr
$LN231@xmlParseTr:

; 11915: 			if (buf[base + 1] == ']') {

	mov	eax, DWORD PTR _buf$5[ebp]
	add	eax, DWORD PTR _base$7[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 93					; 0000005dH
	jne	SHORT $LN232@xmlParseTr

; 11916: 			    /* conditional crap, skip both ']' ! */
; 11917: 			    base++;

	mov	edx, DWORD PTR _base$7[ebp]
	add	edx, 1
	mov	DWORD PTR _base$7[ebp], edx

; 11918: 			    continue;

	jmp	$LN24@xmlParseTr
$LN232@xmlParseTr:

; 11919: 			}
; 11920: 		        for (i = 1; (unsigned int) base + i < use; i++) {

	mov	DWORD PTR _i$6[ebp], 1
	jmp	SHORT $LN32@xmlParseTr
$LN30@xmlParseTr:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN32@xmlParseTr:
	mov	ecx, DWORD PTR _base$7[ebp]
	add	ecx, DWORD PTR _i$6[ebp]
	cmp	ecx, DWORD PTR _use$3[ebp]
	jae	$LN31@xmlParseTr

; 11921: 			    if (buf[base + i] == '>') {

	mov	edx, DWORD PTR _base$7[ebp]
	add	edx, DWORD PTR _i$6[ebp]
	mov	eax, DWORD PTR _buf$5[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 62					; 0000003eH
	jne	SHORT $LN233@xmlParseTr

; 11922: #if 0
; 11923: 			        fprintf(stderr, "found\n");
; 11924: #endif
; 11925: 			        goto found_end_int_subset;

	jmp	$found_end_int_subset$263
$LN233@xmlParseTr:

; 11926: 			    }
; 11927: 			    if (!IS_BLANK_CH(buf[base + i])) {

	mov	edx, DWORD PTR _base$7[ebp]
	add	edx, DWORD PTR _i$6[ebp]
	mov	eax, DWORD PTR _buf$5[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN234@xmlParseTr
	mov	edx, DWORD PTR _base$7[ebp]
	add	edx, DWORD PTR _i$6[ebp]
	mov	eax, DWORD PTR _buf$5[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 9
	jl	SHORT $LN235@xmlParseTr
	mov	edx, DWORD PTR _base$7[ebp]
	add	edx, DWORD PTR _i$6[ebp]
	mov	eax, DWORD PTR _buf$5[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN234@xmlParseTr
$LN235@xmlParseTr:
	mov	edx, DWORD PTR _base$7[ebp]
	add	edx, DWORD PTR _i$6[ebp]
	mov	eax, DWORD PTR _buf$5[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN234@xmlParseTr

; 11928: #if 0
; 11929: 			        fprintf(stderr, "not found\n");
; 11930: #endif
; 11931: 			        goto not_end_of_int_subset;

	jmp	SHORT $not_end_of_int_subset$262
$LN234@xmlParseTr:

; 11932: 			    }
; 11933: 			}

	jmp	$LN30@xmlParseTr
$LN31@xmlParseTr:

; 11934: #if 0
; 11935: 			fprintf(stderr, "end of stream\n");
; 11936: #endif
; 11937: 		        break;

	jmp	SHORT $LN25@xmlParseTr
$not_end_of_int_subset$262:

; 11938: 
; 11939: 		    }
; 11940: not_end_of_int_subset:
; 11941:                     continue; /* for */

	jmp	$LN24@xmlParseTr

; 11942: 		}

	jmp	$LN24@xmlParseTr
$LN25@xmlParseTr:

; 11943: 		/*
; 11944: 		 * We didn't found the end of the Internal subset
; 11945: 		 */
; 11946:                 if (quote == 0)

	movzx	edx, BYTE PTR _quote$4[ebp]
	test	edx, edx
	jne	SHORT $LN236@xmlParseTr

; 11947:                     ctxt->checkIndex = base;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _base$7[ebp]
	mov	DWORD PTR [eax+204], ecx
	jmp	SHORT $LN237@xmlParseTr
$LN236@xmlParseTr:

; 11948:                 else
; 11949:                     ctxt->checkIndex = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+204], 0
$LN237@xmlParseTr:

; 11950: #ifdef DEBUG_PUSH
; 11951: 		if (next == 0)
; 11952: 		    xmlGenericError(xmlGenericErrorContext,
; 11953: 			    "PP: lookup of int subset end filed\n");
; 11954: #endif
; 11955: 	        goto done;

	jmp	$done$260
$found_end_int_subset$263:

; 11956: 
; 11957: found_end_int_subset:
; 11958:                 ctxt->checkIndex = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+204], 0

; 11959: 		xmlParseInternalSubset(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseInternalSubset
	add	esp, 4

; 11960: 		if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN238@xmlParseTr

; 11961: 		    goto done;

	jmp	$done$260
$LN238@xmlParseTr:

; 11962: 		ctxt->inSubset = 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+216], 2

; 11963: 		if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN239@xmlParseTr
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN239@xmlParseTr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+104], 0
	je	SHORT $LN239@xmlParseTr

; 11964: 		    (ctxt->sax->externalSubset != NULL))
; 11965: 		    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+104]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN239@xmlParseTr:

; 11966: 			    ctxt->extSubSystem, ctxt->extSubURI);
; 11967: 		ctxt->inSubset = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+216], 0

; 11968: 		xmlCleanSpecialAttr(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCleanSpecialAttr
	add	esp, 4

; 11969: 		if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN240@xmlParseTr

; 11970: 		    goto done;

	jmp	$done$260
$LN240@xmlParseTr:

; 11971: 		ctxt->instate = XML_PARSER_PROLOG;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 4

; 11972: 		ctxt->checkIndex = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+204], 0

; 11973: #ifdef DEBUG_PUSH
; 11974: 		xmlGenericError(xmlGenericErrorContext,
; 11975: 			"PP: entering PROLOG\n");
; 11976: #endif
; 11977:                 break;

	jmp	$LN4@xmlParseTr
$LN241@xmlParseTr:

; 11978: 	    }
; 11979:             case XML_PARSER_COMMENT:
; 11980: 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CG@PHGFCMFA@PP?3?5internal?5error?0?5state?5?$DN?$DN?5CO@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 11981: 			"PP: internal error, state == COMMENT\n");
; 11982: 		ctxt->instate = XML_PARSER_CONTENT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 7

; 11983: #ifdef DEBUG_PUSH
; 11984: 		xmlGenericError(xmlGenericErrorContext,
; 11985: 			"PP: entering CONTENT\n");
; 11986: #endif
; 11987: 		break;

	jmp	$LN4@xmlParseTr
$LN242@xmlParseTr:

; 11988:             case XML_PARSER_IGNORE:
; 11989: 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CE@CFNIBLKF@PP?3?5internal?5error?0?5state?5?$DN?$DN?5IG@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 11990: 			"PP: internal error, state == IGNORE");
; 11991: 	        ctxt->instate = XML_PARSER_DTD;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 3

; 11992: #ifdef DEBUG_PUSH
; 11993: 		xmlGenericError(xmlGenericErrorContext,
; 11994: 			"PP: entering DTD\n");
; 11995: #endif
; 11996: 	        break;

	jmp	$LN4@xmlParseTr
$LN243@xmlParseTr:

; 11997:             case XML_PARSER_PI:
; 11998: 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CB@LNKCECMO@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PI@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 11999: 			"PP: internal error, state == PI\n");
; 12000: 		ctxt->instate = XML_PARSER_CONTENT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 7

; 12001: #ifdef DEBUG_PUSH
; 12002: 		xmlGenericError(xmlGenericErrorContext,
; 12003: 			"PP: entering CONTENT\n");
; 12004: #endif
; 12005: 		break;

	jmp	$LN4@xmlParseTr
$LN244@xmlParseTr:

; 12006:             case XML_PARSER_ENTITY_DECL:
; 12007: 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CK@EGFEGMNP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12008: 			"PP: internal error, state == ENTITY_DECL\n");
; 12009: 		ctxt->instate = XML_PARSER_DTD;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 3

; 12010: #ifdef DEBUG_PUSH
; 12011: 		xmlGenericError(xmlGenericErrorContext,
; 12012: 			"PP: entering DTD\n");
; 12013: #endif
; 12014: 		break;

	jmp	$LN4@xmlParseTr
$LN245@xmlParseTr:

; 12015:             case XML_PARSER_ENTITY_VALUE:
; 12016: 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CL@FDJCPJGL@PP?3?5internal?5error?0?5state?5?$DN?$DN?5EN@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12017: 			"PP: internal error, state == ENTITY_VALUE\n");
; 12018: 		ctxt->instate = XML_PARSER_CONTENT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 7

; 12019: #ifdef DEBUG_PUSH
; 12020: 		xmlGenericError(xmlGenericErrorContext,
; 12021: 			"PP: entering DTD\n");
; 12022: #endif
; 12023: 		break;

	jmp	$LN4@xmlParseTr
$LN246@xmlParseTr:

; 12024:             case XML_PARSER_ATTRIBUTE_VALUE:
; 12025: 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CO@BNGPOFIK@PP?3?5internal?5error?0?5state?5?$DN?$DN?5AT@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12026: 			"PP: internal error, state == ATTRIBUTE_VALUE\n");
; 12027: 		ctxt->instate = XML_PARSER_START_TAG;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 6

; 12028: #ifdef DEBUG_PUSH
; 12029: 		xmlGenericError(xmlGenericErrorContext,
; 12030: 			"PP: entering START_TAG\n");
; 12031: #endif
; 12032: 		break;

	jmp	SHORT $LN4@xmlParseTr
$LN247@xmlParseTr:

; 12033:             case XML_PARSER_SYSTEM_LITERAL:
; 12034: 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CN@JHJPBNDP@PP?3?5internal?5error?0?5state?5?$DN?$DN?5SY@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12035: 			"PP: internal error, state == SYSTEM_LITERAL\n");
; 12036: 		ctxt->instate = XML_PARSER_START_TAG;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 6

; 12037: #ifdef DEBUG_PUSH
; 12038: 		xmlGenericError(xmlGenericErrorContext,
; 12039: 			"PP: entering START_TAG\n");
; 12040: #endif
; 12041: 		break;

	jmp	SHORT $LN4@xmlParseTr
$LN248@xmlParseTr:

; 12042:             case XML_PARSER_PUBLIC_LITERAL:
; 12043: 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CN@LJGHMOAD@PP?3?5internal?5error?0?5state?5?$DN?$DN?5PU@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12044: 			"PP: internal error, state == PUBLIC_LITERAL\n");
; 12045: 		ctxt->instate = XML_PARSER_START_TAG;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 6
$LN4@xmlParseTr:

; 12046: #ifdef DEBUG_PUSH
; 12047: 		xmlGenericError(xmlGenericErrorContext,
; 12048: 			"PP: entering START_TAG\n");
; 12049: #endif
; 12050: 		break;
; 12051: 	}
; 12052:     }

	jmp	$LN2@xmlParseTr
$done$260:

; 12053: done:
; 12054: #ifdef DEBUG_PUSH
; 12055:     xmlGenericError(xmlGenericErrorContext, "PP: done %d\n", ret);
; 12056: #endif
; 12057:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParseTr
$encoding_error$261:

; 12058: encoding_error:
; 12059:     {
; 12060:         char buffer[150];
; 12061: 
; 12062: 	snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0CE@KHMCMEAC@Bytes?3?50x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF@
	push	149					; 00000095H
	lea	ecx, DWORD PTR _buffer$1[ebp]
	push	ecx
	call	_snprintf
	add	esp, 28					; 0000001cH

; 12063: 			ctxt->input->cur[0], ctxt->input->cur[1],
; 12064: 			ctxt->input->cur[2], ctxt->input->cur[3]);
; 12065: 	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,

	push	0
	lea	edx, DWORD PTR _buffer$1[ebp]
	push	edx
	push	OFFSET ??_C@_0DC@POFOFIG@Input?5is?5not?5proper?5UTF?98?0?5indi@
	push	9
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	___xmlErrEncoding
	add	esp, 20					; 00000014H

; 12066: 		     "Input is not proper UTF-8, indicate encoding !\n%s",
; 12067: 		     BAD_CAST buffer, NULL);
; 12068:     }
; 12069:     return(0);

	xor	eax, eax
$LN1@xmlParseTr:

; 12070: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN258@xmlParseTr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN258@xmlParseTr:
	DD	7
	DD	$LN257@xmlParseTr
$LN257@xmlParseTr:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN250@xmlParseTr
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN251@xmlParseTr
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN252@xmlParseTr
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN253@xmlParseTr
	DD	-84					; ffffffacH
	DD	4
	DD	$LN254@xmlParseTr
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN255@xmlParseTr
	DD	-316					; fffffec4H
	DD	150					; 00000096H
	DD	$LN256@xmlParseTr
$LN256@xmlParseTr:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN255@xmlParseTr:
	DB	85					; 00000055H
	DB	82					; 00000052H
	DB	73					; 00000049H
	DB	0
$LN254@xmlParseTr:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	0
$LN253@xmlParseTr:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$LN252@xmlParseTr:
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	0
$LN251@xmlParseTr:
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN250@xmlParseTr:
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
	npad	1
$LN259@xmlParseTr:
	DD	$LN41@xmlParseTr
	DD	$LN42@xmlParseTr
	DD	$LN168@xmlParseTr
	DD	$LN243@xmlParseTr
	DD	$LN219@xmlParseTr
	DD	$LN189@xmlParseTr
	DD	$LN241@xmlParseTr
	DD	$LN65@xmlParseTr
	DD	$LN99@xmlParseTr
	DD	$LN142@xmlParseTr
	DD	$LN128@xmlParseTr
	DD	$LN244@xmlParseTr
	DD	$LN245@xmlParseTr
	DD	$LN246@xmlParseTr
	DD	$LN247@xmlParseTr
	DD	$LN204@xmlParseTr
	DD	$LN242@xmlParseTr
	DD	$LN248@xmlParseTr
_xmlParseTryOrFinish ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCheckCdataPush
_TEXT	SEGMENT
tv277 = -60						; size = 4
tv279 = -56						; size = 4
tv278 = -52						; size = 4
tv221 = -48						; size = 4
tv208 = -44						; size = 4
tv210 = -40						; size = 4
tv209 = -36						; size = 4
tv165 = -32						; size = 4
tv152 = -28						; size = 4
tv154 = -24						; size = 4
tv153 = -20						; size = 4
tv90 = -16						; size = 4
_codepoint$ = -12					; size = 4
_c$ = -5						; size = 1
_ix$ = -4						; size = 4
_utf$ = 8						; size = 4
_len$ = 12						; size = 4
_complete$ = 16						; size = 4
_xmlCheckCdataPush PROC					; COMDAT

; 11023: xmlCheckCdataPush(const xmlChar *utf, int len, int complete) {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 11024:     int ix;
; 11025:     unsigned char c;
; 11026:     int codepoint;
; 11027: 
; 11028:     if ((utf == NULL) || (len <= 0))

	cmp	DWORD PTR _utf$[ebp], 0
	je	SHORT $LN6@xmlCheckCd
	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN5@xmlCheckCd
$LN6@xmlCheckCd:

; 11029:         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckCd
$LN5@xmlCheckCd:

; 11030: 
; 11031:     for (ix = 0; ix < len;) {      /* string is 0-terminated */

	mov	DWORD PTR _ix$[ebp], 0
$LN4@xmlCheckCd:
	mov	eax, DWORD PTR _ix$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jge	$LN3@xmlCheckCd

; 11032:         c = utf[ix];

	mov	ecx, DWORD PTR _utf$[ebp]
	add	ecx, DWORD PTR _ix$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl

; 11033:         if ((c & 0x80) == 0x00) {	/* 1-byte code, starts with 10 */

	movzx	eax, BYTE PTR _c$[ebp]
	and	eax, 128				; 00000080H
	jne	SHORT $LN7@xmlCheckCd

; 11034: 	    if (c >= 0x20)

	movzx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN9@xmlCheckCd

; 11035: 		ix++;

	mov	edx, DWORD PTR _ix$[ebp]
	add	edx, 1
	mov	DWORD PTR _ix$[ebp], edx
	jmp	SHORT $LN10@xmlCheckCd
$LN9@xmlCheckCd:

; 11036: 	    else if ((c == 0xA) || (c == 0xD) || (c == 0x9))

	movzx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN13@xmlCheckCd
	movzx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN13@xmlCheckCd
	movzx	edx, BYTE PTR _c$[ebp]
	cmp	edx, 9
	jne	SHORT $LN11@xmlCheckCd
$LN13@xmlCheckCd:

; 11037: 	        ix++;

	mov	eax, DWORD PTR _ix$[ebp]
	add	eax, 1
	mov	DWORD PTR _ix$[ebp], eax
	jmp	SHORT $LN10@xmlCheckCd
$LN11@xmlCheckCd:

; 11038: 	    else
; 11039: 	        return(-ix);

	mov	eax, DWORD PTR _ix$[ebp]
	neg	eax
	jmp	$LN1@xmlCheckCd
$LN10@xmlCheckCd:

; 11040: 	} else if ((c & 0xe0) == 0xc0) {/* 2-byte code, starts with 110 */

	jmp	$LN8@xmlCheckCd
$LN7@xmlCheckCd:
	movzx	ecx, BYTE PTR _c$[ebp]
	and	ecx, 224				; 000000e0H
	cmp	ecx, 192				; 000000c0H
	jne	$LN14@xmlCheckCd

; 11041: 	    if (ix + 2 > len) return(complete ? -ix : ix);

	mov	edx, DWORD PTR _ix$[ebp]
	add	edx, 2
	cmp	edx, DWORD PTR _len$[ebp]
	jle	SHORT $LN16@xmlCheckCd
	cmp	DWORD PTR _complete$[ebp], 0
	je	SHORT $LN32@xmlCheckCd
	mov	eax, DWORD PTR _ix$[ebp]
	neg	eax
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN33@xmlCheckCd
$LN32@xmlCheckCd:
	mov	ecx, DWORD PTR _ix$[ebp]
	mov	DWORD PTR tv90[ebp], ecx
$LN33@xmlCheckCd:
	mov	eax, DWORD PTR tv90[ebp]
	jmp	$LN1@xmlCheckCd
$LN16@xmlCheckCd:

; 11042: 	    if ((utf[ix+1] & 0xc0 ) != 0x80)

	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, DWORD PTR _ix$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN17@xmlCheckCd

; 11043: 	        return(-ix);

	mov	eax, DWORD PTR _ix$[ebp]
	neg	eax
	jmp	$LN1@xmlCheckCd
$LN17@xmlCheckCd:

; 11044: 	    codepoint = (utf[ix] & 0x1f) << 6;

	mov	ecx, DWORD PTR _utf$[ebp]
	add	ecx, DWORD PTR _ix$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 31					; 0000001fH
	shl	edx, 6
	mov	DWORD PTR _codepoint$[ebp], edx

; 11045: 	    codepoint |= utf[ix+1] & 0x3f;

	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, DWORD PTR _ix$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _codepoint$[ebp]
	mov	DWORD PTR _codepoint$[ebp], ecx

; 11046: 	    if (!xmlIsCharQ(codepoint))

	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jge	SHORT $LN42@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 9
	jl	SHORT $LN34@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 10		; 0000000aH
	jle	SHORT $LN35@xmlCheckCd
$LN34@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 13		; 0000000dH
	je	SHORT $LN35@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 32		; 00000020H
	jge	SHORT $LN35@xmlCheckCd
	mov	DWORD PTR tv153[ebp], 0
	jmp	SHORT $LN41@xmlCheckCd
$LN35@xmlCheckCd:
	mov	DWORD PTR tv153[ebp], 1
$LN41@xmlCheckCd:
	mov	edx, DWORD PTR tv153[ebp]
	mov	DWORD PTR tv154[ebp], edx
	jmp	SHORT $LN43@xmlCheckCd
$LN42@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jl	SHORT $LN36@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 55295	; 0000d7ffH
	jle	SHORT $LN38@xmlCheckCd
$LN36@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 57344	; 0000e000H
	jl	SHORT $LN37@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 65533	; 0000fffdH
	jle	SHORT $LN38@xmlCheckCd
$LN37@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 65536	; 00010000H
	jl	SHORT $LN39@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 1114111	; 0010ffffH
	jle	SHORT $LN38@xmlCheckCd
$LN39@xmlCheckCd:
	mov	DWORD PTR tv152[ebp], 0
	jmp	SHORT $LN40@xmlCheckCd
$LN38@xmlCheckCd:
	mov	DWORD PTR tv152[ebp], 1
$LN40@xmlCheckCd:
	mov	eax, DWORD PTR tv152[ebp]
	mov	DWORD PTR tv154[ebp], eax
$LN43@xmlCheckCd:
	cmp	DWORD PTR tv154[ebp], 0
	jne	SHORT $LN18@xmlCheckCd

; 11047: 	        return(-ix);

	mov	eax, DWORD PTR _ix$[ebp]
	neg	eax
	jmp	$LN1@xmlCheckCd
$LN18@xmlCheckCd:

; 11048: 	    ix += 2;

	mov	ecx, DWORD PTR _ix$[ebp]
	add	ecx, 2
	mov	DWORD PTR _ix$[ebp], ecx
	jmp	$LN8@xmlCheckCd
$LN14@xmlCheckCd:

; 11049: 	} else if ((c & 0xf0) == 0xe0) {/* 3-byte code, starts with 1110 */

	movzx	edx, BYTE PTR _c$[ebp]
	and	edx, 240				; 000000f0H
	cmp	edx, 224				; 000000e0H
	jne	$LN19@xmlCheckCd

; 11050: 	    if (ix + 3 > len) return(complete ? -ix : ix);

	mov	eax, DWORD PTR _ix$[ebp]
	add	eax, 3
	cmp	eax, DWORD PTR _len$[ebp]
	jle	SHORT $LN21@xmlCheckCd
	cmp	DWORD PTR _complete$[ebp], 0
	je	SHORT $LN44@xmlCheckCd
	mov	ecx, DWORD PTR _ix$[ebp]
	neg	ecx
	mov	DWORD PTR tv165[ebp], ecx
	jmp	SHORT $LN45@xmlCheckCd
$LN44@xmlCheckCd:
	mov	edx, DWORD PTR _ix$[ebp]
	mov	DWORD PTR tv165[ebp], edx
$LN45@xmlCheckCd:
	mov	eax, DWORD PTR tv165[ebp]
	jmp	$LN1@xmlCheckCd
$LN21@xmlCheckCd:

; 11051: 	    if (((utf[ix+1] & 0xc0) != 0x80) ||

	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, DWORD PTR _ix$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 128				; 00000080H
	jne	SHORT $LN23@xmlCheckCd
	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, DWORD PTR _ix$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN22@xmlCheckCd
$LN23@xmlCheckCd:

; 11052: 	        ((utf[ix+2] & 0xc0) != 0x80))
; 11053: 		    return(-ix);

	mov	eax, DWORD PTR _ix$[ebp]
	neg	eax
	jmp	$LN1@xmlCheckCd
$LN22@xmlCheckCd:

; 11054: 	    codepoint = (utf[ix] & 0xf) << 12;

	mov	ecx, DWORD PTR _utf$[ebp]
	add	ecx, DWORD PTR _ix$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 15					; 0000000fH
	shl	edx, 12					; 0000000cH
	mov	DWORD PTR _codepoint$[ebp], edx

; 11055: 	    codepoint |= (utf[ix+1] & 0x3f) << 6;

	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, DWORD PTR _ix$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, DWORD PTR _codepoint$[ebp]
	mov	DWORD PTR _codepoint$[ebp], ecx

; 11056: 	    codepoint |= utf[ix+2] & 0x3f;

	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, DWORD PTR _ix$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _codepoint$[ebp]
	mov	DWORD PTR _codepoint$[ebp], eax

; 11057: 	    if (!xmlIsCharQ(codepoint))

	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jge	SHORT $LN54@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 9
	jl	SHORT $LN46@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 10		; 0000000aH
	jle	SHORT $LN47@xmlCheckCd
$LN46@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 13		; 0000000dH
	je	SHORT $LN47@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 32		; 00000020H
	jge	SHORT $LN47@xmlCheckCd
	mov	DWORD PTR tv209[ebp], 0
	jmp	SHORT $LN53@xmlCheckCd
$LN47@xmlCheckCd:
	mov	DWORD PTR tv209[ebp], 1
$LN53@xmlCheckCd:
	mov	ecx, DWORD PTR tv209[ebp]
	mov	DWORD PTR tv210[ebp], ecx
	jmp	SHORT $LN55@xmlCheckCd
$LN54@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jl	SHORT $LN48@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 55295	; 0000d7ffH
	jle	SHORT $LN50@xmlCheckCd
$LN48@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 57344	; 0000e000H
	jl	SHORT $LN49@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 65533	; 0000fffdH
	jle	SHORT $LN50@xmlCheckCd
$LN49@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 65536	; 00010000H
	jl	SHORT $LN51@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 1114111	; 0010ffffH
	jle	SHORT $LN50@xmlCheckCd
$LN51@xmlCheckCd:
	mov	DWORD PTR tv208[ebp], 0
	jmp	SHORT $LN52@xmlCheckCd
$LN50@xmlCheckCd:
	mov	DWORD PTR tv208[ebp], 1
$LN52@xmlCheckCd:
	mov	edx, DWORD PTR tv208[ebp]
	mov	DWORD PTR tv210[ebp], edx
$LN55@xmlCheckCd:
	cmp	DWORD PTR tv210[ebp], 0
	jne	SHORT $LN24@xmlCheckCd

; 11058: 	        return(-ix);

	mov	eax, DWORD PTR _ix$[ebp]
	neg	eax
	jmp	$LN1@xmlCheckCd
$LN24@xmlCheckCd:

; 11059: 	    ix += 3;

	mov	eax, DWORD PTR _ix$[ebp]
	add	eax, 3
	mov	DWORD PTR _ix$[ebp], eax
	jmp	$LN8@xmlCheckCd
$LN19@xmlCheckCd:

; 11060: 	} else if ((c & 0xf8) == 0xf0) {/* 4-byte code, starts with 11110 */

	movzx	ecx, BYTE PTR _c$[ebp]
	and	ecx, 248				; 000000f8H
	cmp	ecx, 240				; 000000f0H
	jne	$LN25@xmlCheckCd

; 11061: 	    if (ix + 4 > len) return(complete ? -ix : ix);

	mov	edx, DWORD PTR _ix$[ebp]
	add	edx, 4
	cmp	edx, DWORD PTR _len$[ebp]
	jle	SHORT $LN27@xmlCheckCd
	cmp	DWORD PTR _complete$[ebp], 0
	je	SHORT $LN56@xmlCheckCd
	mov	eax, DWORD PTR _ix$[ebp]
	neg	eax
	mov	DWORD PTR tv221[ebp], eax
	jmp	SHORT $LN57@xmlCheckCd
$LN56@xmlCheckCd:
	mov	ecx, DWORD PTR _ix$[ebp]
	mov	DWORD PTR tv221[ebp], ecx
$LN57@xmlCheckCd:
	mov	eax, DWORD PTR tv221[ebp]
	jmp	$LN1@xmlCheckCd
$LN27@xmlCheckCd:

; 11062: 	    if (((utf[ix+1] & 0xc0) != 0x80) ||
; 11063: 	        ((utf[ix+2] & 0xc0) != 0x80) ||

	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, DWORD PTR _ix$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN29@xmlCheckCd
	mov	ecx, DWORD PTR _utf$[ebp]
	add	ecx, DWORD PTR _ix$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	and	edx, 192				; 000000c0H
	cmp	edx, 128				; 00000080H
	jne	SHORT $LN29@xmlCheckCd
	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, DWORD PTR _ix$[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 128				; 00000080H
	je	SHORT $LN28@xmlCheckCd
$LN29@xmlCheckCd:

; 11064: 		((utf[ix+3] & 0xc0) != 0x80))
; 11065: 		    return(-ix);

	mov	eax, DWORD PTR _ix$[ebp]
	neg	eax
	jmp	$LN1@xmlCheckCd
$LN28@xmlCheckCd:

; 11066: 	    codepoint = (utf[ix] & 0x7) << 18;

	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, DWORD PTR _ix$[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, 7
	shl	eax, 18					; 00000012H
	mov	DWORD PTR _codepoint$[ebp], eax

; 11067: 	    codepoint |= (utf[ix+1] & 0x3f) << 12;

	mov	ecx, DWORD PTR _utf$[ebp]
	add	ecx, DWORD PTR _ix$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	and	edx, 63					; 0000003fH
	shl	edx, 12					; 0000000cH
	or	edx, DWORD PTR _codepoint$[ebp]
	mov	DWORD PTR _codepoint$[ebp], edx

; 11068: 	    codepoint |= (utf[ix+2] & 0x3f) << 6;

	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, DWORD PTR _ix$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 63					; 0000003fH
	shl	ecx, 6
	or	ecx, DWORD PTR _codepoint$[ebp]
	mov	DWORD PTR _codepoint$[ebp], ecx

; 11069: 	    codepoint |= utf[ix+3] & 0x3f;

	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, DWORD PTR _ix$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _codepoint$[ebp]
	mov	DWORD PTR _codepoint$[ebp], eax

; 11070: 	    if (!xmlIsCharQ(codepoint))

	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jge	SHORT $LN66@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 9
	jl	SHORT $LN58@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 10		; 0000000aH
	jle	SHORT $LN59@xmlCheckCd
$LN58@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 13		; 0000000dH
	je	SHORT $LN59@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 32		; 00000020H
	jge	SHORT $LN59@xmlCheckCd
	mov	DWORD PTR tv278[ebp], 0
	jmp	SHORT $LN65@xmlCheckCd
$LN59@xmlCheckCd:
	mov	DWORD PTR tv278[ebp], 1
$LN65@xmlCheckCd:
	mov	ecx, DWORD PTR tv278[ebp]
	mov	DWORD PTR tv279[ebp], ecx
	jmp	SHORT $LN67@xmlCheckCd
$LN66@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 256		; 00000100H
	jl	SHORT $LN60@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 55295	; 0000d7ffH
	jle	SHORT $LN62@xmlCheckCd
$LN60@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 57344	; 0000e000H
	jl	SHORT $LN61@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 65533	; 0000fffdH
	jle	SHORT $LN62@xmlCheckCd
$LN61@xmlCheckCd:
	cmp	DWORD PTR _codepoint$[ebp], 65536	; 00010000H
	jl	SHORT $LN63@xmlCheckCd
	cmp	DWORD PTR _codepoint$[ebp], 1114111	; 0010ffffH
	jle	SHORT $LN62@xmlCheckCd
$LN63@xmlCheckCd:
	mov	DWORD PTR tv277[ebp], 0
	jmp	SHORT $LN64@xmlCheckCd
$LN62@xmlCheckCd:
	mov	DWORD PTR tv277[ebp], 1
$LN64@xmlCheckCd:
	mov	edx, DWORD PTR tv277[ebp]
	mov	DWORD PTR tv279[ebp], edx
$LN67@xmlCheckCd:
	cmp	DWORD PTR tv279[ebp], 0
	jne	SHORT $LN30@xmlCheckCd

; 11071: 	        return(-ix);

	mov	eax, DWORD PTR _ix$[ebp]
	neg	eax
	jmp	SHORT $LN1@xmlCheckCd
$LN30@xmlCheckCd:

; 11072: 	    ix += 4;

	mov	eax, DWORD PTR _ix$[ebp]
	add	eax, 4
	mov	DWORD PTR _ix$[ebp], eax

; 11073: 	} else				/* unknown encoding */

	jmp	SHORT $LN8@xmlCheckCd
$LN25@xmlCheckCd:

; 11074: 	    return(-ix);

	mov	eax, DWORD PTR _ix$[ebp]
	neg	eax
	jmp	SHORT $LN1@xmlCheckCd
$LN8@xmlCheckCd:

; 11075:       }

	jmp	$LN4@xmlCheckCd
$LN3@xmlCheckCd:

; 11076:       return(ix);

	mov	eax, DWORD PTR _ix$[ebp]
$LN1@xmlCheckCd:

; 11077: }

	pop	edi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCheckCdataPush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseGetLasts
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_lastlt$ = 12						; size = 4
_lastgt$ = 16						; size = 4
_xmlParseGetLasts PROC					; COMDAT

; 10964:                  const xmlChar **lastgt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 10965:     const xmlChar *tmp;
; 10966: 
; 10967:     if ((ctxt == NULL) || (lastlt == NULL) || (lastgt == NULL)) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN13@xmlParseGe
	cmp	DWORD PTR _lastlt$[ebp], 0
	je	SHORT $LN13@xmlParseGe
	cmp	DWORD PTR _lastgt$[ebp], 0
	jne	SHORT $LN12@xmlParseGe
$LN13@xmlParseGe:

; 10968: 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CC@HDEJLGKL@Internal?5error?3?5xmlParseGetLast@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10969: 		    "Internal error: xmlParseGetLasts\n");
; 10970: 	return;

	jmp	$LN1@xmlParseGe
$LN12@xmlParseGe:

; 10971:     }
; 10972:     if ((ctxt->progressive != 0) && (ctxt->inputNr == 1)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	je	$LN14@xmlParseGe
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+40], 1
	jne	$LN14@xmlParseGe

; 10973:         tmp = ctxt->input->end;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _tmp$[ebp], eax

; 10974: 	tmp--;

	mov	ecx, DWORD PTR _tmp$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _tmp$[ebp], ecx
$LN2@xmlParseGe:

; 10975: 	while ((tmp >= ctxt->input->base) && (*tmp != '<')) tmp--;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _tmp$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jb	SHORT $LN3@xmlParseGe
	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN3@xmlParseGe
	mov	ecx, DWORD PTR _tmp$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _tmp$[ebp], ecx
	jmp	SHORT $LN2@xmlParseGe
$LN3@xmlParseGe:

; 10976: 	if (tmp < ctxt->input->base) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _tmp$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN16@xmlParseGe

; 10977: 	    *lastlt = NULL;

	mov	edx, DWORD PTR _lastlt$[ebp]
	mov	DWORD PTR [edx], 0

; 10978: 	    *lastgt = NULL;

	mov	eax, DWORD PTR _lastgt$[ebp]
	mov	DWORD PTR [eax], 0

; 10979: 	} else {

	jmp	$LN17@xmlParseGe
$LN16@xmlParseGe:

; 10980: 	    *lastlt = tmp;

	mov	ecx, DWORD PTR _lastlt$[ebp]
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [ecx], edx

; 10981: 	    tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$[ebp], eax
$LN4@xmlParseGe:

; 10982: 	    while ((tmp < ctxt->input->end) && (*tmp != '>')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jae	$LN5@xmlParseGe
	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	je	$LN5@xmlParseGe

; 10983: 	        if (*tmp == '\'') {

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $LN18@xmlParseGe

; 10984: 		    tmp++;

	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx
$LN6@xmlParseGe:

; 10985: 		    while ((tmp < ctxt->input->end) && (*tmp != '\'')) tmp++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _tmp$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jae	SHORT $LN7@xmlParseGe
	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	je	SHORT $LN7@xmlParseGe
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx
	jmp	SHORT $LN6@xmlParseGe
$LN7@xmlParseGe:

; 10986: 		    if (tmp < ctxt->input->end) tmp++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _tmp$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jae	SHORT $LN20@xmlParseGe
	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$[ebp], eax
$LN20@xmlParseGe:

; 10987: 		} else if (*tmp == '"') {

	jmp	SHORT $LN19@xmlParseGe
$LN18@xmlParseGe:
	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN21@xmlParseGe

; 10988: 		    tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$[ebp], eax
$LN8@xmlParseGe:

; 10989: 		    while ((tmp < ctxt->input->end) && (*tmp != '"')) tmp++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jae	SHORT $LN9@xmlParseGe
	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	je	SHORT $LN9@xmlParseGe
	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$[ebp], eax
	jmp	SHORT $LN8@xmlParseGe
$LN9@xmlParseGe:

; 10990: 		    if (tmp < ctxt->input->end) tmp++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jae	SHORT $LN23@xmlParseGe
	mov	ecx, DWORD PTR _tmp$[ebp]
	add	ecx, 1
	mov	DWORD PTR _tmp$[ebp], ecx
$LN23@xmlParseGe:

; 10991: 		} else

	jmp	SHORT $LN19@xmlParseGe
$LN21@xmlParseGe:

; 10992: 		    tmp++;

	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx
$LN19@xmlParseGe:

; 10993: 	    }

	jmp	$LN4@xmlParseGe
$LN5@xmlParseGe:

; 10994: 	    if (tmp < ctxt->input->end)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _tmp$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jae	SHORT $LN24@xmlParseGe

; 10995: 	        *lastgt = tmp;

	mov	eax, DWORD PTR _lastgt$[ebp]
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN17@xmlParseGe
$LN24@xmlParseGe:

; 10996: 	    else {
; 10997: 	        tmp = *lastlt;

	mov	edx, DWORD PTR _lastlt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _tmp$[ebp], eax

; 10998: 		tmp--;

	mov	ecx, DWORD PTR _tmp$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _tmp$[ebp], ecx
$LN10@xmlParseGe:

; 10999: 		while ((tmp >= ctxt->input->base) && (*tmp != '>')) tmp--;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _tmp$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jb	SHORT $LN11@xmlParseGe
	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN11@xmlParseGe
	mov	ecx, DWORD PTR _tmp$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _tmp$[ebp], ecx
	jmp	SHORT $LN10@xmlParseGe
$LN11@xmlParseGe:

; 11000: 		if (tmp >= ctxt->input->base)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _tmp$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jb	SHORT $LN26@xmlParseGe

; 11001: 		    *lastgt = tmp;

	mov	edx, DWORD PTR _lastgt$[ebp]
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN17@xmlParseGe
$LN26@xmlParseGe:

; 11002: 		else
; 11003: 		    *lastgt = NULL;

	mov	ecx, DWORD PTR _lastgt$[ebp]
	mov	DWORD PTR [ecx], 0
$LN17@xmlParseGe:

; 11004: 	    }
; 11005: 	}
; 11006:     } else {

	jmp	SHORT $LN1@xmlParseGe
$LN14@xmlParseGe:

; 11007:         *lastlt = NULL;

	mov	edx, DWORD PTR _lastlt$[ebp]
	mov	DWORD PTR [edx], 0

; 11008: 	*lastgt = NULL;

	mov	eax, DWORD PTR _lastgt$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@xmlParseGe:

; 11009:     }
; 11010: }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseGetLasts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseLookupSequence
_TEXT	SEGMENT
_buf$ = -16						; size = 4
_in$ = -12						; size = 4
_len$ = -8						; size = 4
_base$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_first$ = 12						; size = 1
_next$ = 16						; size = 1
_third$ = 20						; size = 1
_xmlParseLookupSequence PROC				; COMDAT

; 10892:                        xmlChar next, xmlChar third) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 10893:     int base, len;
; 10894:     xmlParserInputPtr in;
; 10895:     const xmlChar *buf;
; 10896: 
; 10897:     in = ctxt->input;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _in$[ebp], ecx

; 10898:     if (in == NULL) return(-1);

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN5@xmlParseLo
	or	eax, -1
	jmp	$LN1@xmlParseLo
$LN5@xmlParseLo:

; 10899:     base = in->cur - in->base;

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _base$[ebp], ecx

; 10900:     if (base < 0) return(-1);

	jns	SHORT $LN6@xmlParseLo
	or	eax, -1
	jmp	$LN1@xmlParseLo
$LN6@xmlParseLo:

; 10901:     if (ctxt->checkIndex > base)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+204]
	cmp	eax, DWORD PTR _base$[ebp]
	jle	SHORT $LN7@xmlParseLo

; 10902:         base = ctxt->checkIndex;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	DWORD PTR _base$[ebp], edx
$LN7@xmlParseLo:

; 10903:     if (in->buf == NULL) {

	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@xmlParseLo

; 10904: 	buf = in->base;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _buf$[ebp], edx

; 10905: 	len = in->length;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _len$[ebp], ecx

; 10906:     } else {

	jmp	SHORT $LN9@xmlParseLo
$LN8@xmlParseLo:

; 10907: 	buf = xmlBufContent(in->buf->buffer);

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufContent
	add	esp, 4
	mov	DWORD PTR _buf$[ebp], eax

; 10908: 	len = xmlBufUse(in->buf->buffer);

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufUse
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN9@xmlParseLo:

; 10909:     }
; 10910:     /* take into account the sequence length */
; 10911:     if (third) len -= 2;

	movzx	edx, BYTE PTR _third$[ebp]
	test	edx, edx
	je	SHORT $LN10@xmlParseLo
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 2
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN11@xmlParseLo
$LN10@xmlParseLo:

; 10912:     else if (next) len --;

	movzx	ecx, BYTE PTR _next$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@xmlParseLo
	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, 1
	mov	DWORD PTR _len$[ebp], edx
$LN11@xmlParseLo:

; 10913:     for (;base < len;base++) {

	jmp	SHORT $LN4@xmlParseLo
$LN2@xmlParseLo:
	mov	eax, DWORD PTR _base$[ebp]
	add	eax, 1
	mov	DWORD PTR _base$[ebp], eax
$LN4@xmlParseLo:
	mov	ecx, DWORD PTR _base$[ebp]
	cmp	ecx, DWORD PTR _len$[ebp]
	jge	$LN3@xmlParseLo

; 10914:         if (buf[base] == first) {

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _base$[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _first$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN13@xmlParseLo

; 10915: 	    if (third != 0) {

	movzx	edx, BYTE PTR _third$[ebp]
	test	edx, edx
	je	SHORT $LN14@xmlParseLo

; 10916: 		if ((buf[base + 1] != next) ||

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _base$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	movzx	edx, BYTE PTR _next$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN17@xmlParseLo
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _base$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	movzx	edx, BYTE PTR _third$[ebp]
	cmp	ecx, edx
	je	SHORT $LN16@xmlParseLo
$LN17@xmlParseLo:

; 10917: 		    (buf[base + 2] != third)) continue;

	jmp	SHORT $LN2@xmlParseLo
$LN16@xmlParseLo:

; 10918: 	    } else if (next != 0) {

	jmp	SHORT $LN15@xmlParseLo
$LN14@xmlParseLo:
	movzx	eax, BYTE PTR _next$[ebp]
	test	eax, eax
	je	SHORT $LN15@xmlParseLo

; 10919: 		if (buf[base + 1] != next) continue;

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _base$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	movzx	eax, BYTE PTR _next$[ebp]
	cmp	edx, eax
	je	SHORT $LN15@xmlParseLo
	jmp	SHORT $LN2@xmlParseLo
$LN15@xmlParseLo:

; 10920: 	    }
; 10921: 	    ctxt->checkIndex = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+204], 0

; 10922: #ifdef DEBUG_PUSH
; 10923: 	    if (next == 0)
; 10924: 		xmlGenericError(xmlGenericErrorContext,
; 10925: 			"PP: lookup '%c' found at %d\n",
; 10926: 			first, base);
; 10927: 	    else if (third == 0)
; 10928: 		xmlGenericError(xmlGenericErrorContext,
; 10929: 			"PP: lookup '%c%c' found at %d\n",
; 10930: 			first, next, base);
; 10931: 	    else
; 10932: 		xmlGenericError(xmlGenericErrorContext,
; 10933: 			"PP: lookup '%c%c%c' found at %d\n",
; 10934: 			first, next, third, base);
; 10935: #endif
; 10936: 	    return(base - (in->cur - in->base));

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _base$[ebp]
	sub	eax, ecx
	jmp	SHORT $LN1@xmlParseLo
$LN13@xmlParseLo:

; 10937: 	}
; 10938:     }

	jmp	$LN2@xmlParseLo
$LN3@xmlParseLo:

; 10939:     ctxt->checkIndex = base;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _base$[ebp]
	mov	DWORD PTR [edx+204], eax

; 10940: #ifdef DEBUG_PUSH
; 10941:     if (next == 0)
; 10942: 	xmlGenericError(xmlGenericErrorContext,
; 10943: 		"PP: lookup '%c' failed\n", first);
; 10944:     else if (third == 0)
; 10945: 	xmlGenericError(xmlGenericErrorContext,
; 10946: 		"PP: lookup '%c%c' failed\n", first, next);
; 10947:     else
; 10948: 	xmlGenericError(xmlGenericErrorContext,
; 10949: 		"PP: lookup '%c%c%c' failed\n", first, next, third);
; 10950: #endif
; 10951:     return(-1);

	or	eax, -1
$LN1@xmlParseLo:

; 10952: }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseLookupSequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEndTag2
_TEXT	SEGMENT
_curLength$ = -8					; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_URI$ = 16						; size = 4
_line$ = 20						; size = 4
_nsNr$ = 24						; size = 4
_tlen$ = 28						; size = 4
_xmlParseEndTag2 PROC					; COMDAT

; 9619 :                 const xmlChar *URI, int line, int nsNr, int tlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 9620 :     const xmlChar *name;
; 9621 :     size_t curLength;
; 9622 : 
; 9623 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN5@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN5@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN5@xmlParseEn:

; 9624 :     if ((RAW != '<') || (NXT(1) != '/')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN7@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN4@xmlParseEn
$LN7@xmlParseEn:

; 9625 : 	xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);

	push	0
	push	74					; 0000004aH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 9626 : 	return;

	jmp	$LN1@xmlParseEn
$LN4@xmlParseEn:

; 9627 :     }
; 9628 :     SKIP(2);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN2@xmlParseEn
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEn:
	xor	eax, eax
	jne	SHORT $LN4@xmlParseEn

; 9629 : 
; 9630 :     curLength = ctxt->input->end - ctxt->input->cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _curLength$[ebp], edx

; 9631 :     if ((tlen > 0) && (curLength >= (size_t)tlen) &&

	cmp	DWORD PTR _tlen$[ebp], 0
	jle	$LN9@xmlParseEn
	mov	eax, DWORD PTR _curLength$[ebp]
	cmp	eax, DWORD PTR _tlen$[ebp]
	jb	$LN9@xmlParseEn
	mov	ecx, DWORD PTR _tlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+184]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN9@xmlParseEn

; 9632 :         (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
; 9633 :         if ((curLength >= (size_t)(tlen + 1)) &&

	mov	ecx, DWORD PTR _tlen$[ebp]
	add	ecx, 1
	cmp	DWORD PTR _curLength$[ebp], ecx
	jb	SHORT $LN11@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _tlen$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN11@xmlParseEn

; 9634 : 	    (ctxt->input->cur[tlen] == '>')) {
; 9635 : 	    ctxt->input->cur += tlen + 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _tlen$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx

; 9636 : 	    ctxt->input->col += tlen + 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _tlen$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax

; 9637 : 	    goto done;

	jmp	$done$28
$LN11@xmlParseEn:

; 9638 : 	}
; 9639 : 	ctxt->input->cur += tlen;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _tlen$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx

; 9640 : 	ctxt->input->col += tlen;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, DWORD PTR _tlen$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx

; 9641 : 	name = (xmlChar*)1;

	mov	DWORD PTR _name$[ebp], 1

; 9642 :     } else {

	jmp	SHORT $LN10@xmlParseEn
$LN9@xmlParseEn:

; 9643 : 	if (prefix == NULL)

	cmp	DWORD PTR _prefix$[ebp], 0
	jne	SHORT $LN12@xmlParseEn

; 9644 : 	    name = xmlParseNameAndCompare(ctxt, ctxt->name);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseNameAndCompare
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax
	jmp	SHORT $LN10@xmlParseEn
$LN12@xmlParseEn:

; 9645 : 	else
; 9646 : 	    name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);

	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+184]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseQNameAndCompare
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name$[ebp], eax
$LN10@xmlParseEn:

; 9647 :     }
; 9648 : 
; 9649 :     /*
; 9650 :      * We should definitely be at the ending "S? '>'" part
; 9651 :      */
; 9652 :     GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN14@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN14@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN14@xmlParseEn:

; 9653 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN15@xmlParseEn

; 9654 :         return;

	jmp	$LN1@xmlParseEn
$LN15@xmlParseEn:

; 9655 :     SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 9656 :     if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN20@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN19@xmlParseEn
$LN20@xmlParseEn:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN19@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jl	SHORT $LN18@xmlParseEn
$LN19@xmlParseEn:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN16@xmlParseEn
$LN18@xmlParseEn:

; 9657 : 	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);

	push	0
	push	73					; 00000049H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 9658 :     } else

	jmp	SHORT $LN17@xmlParseEn
$LN16@xmlParseEn:

; 9659 : 	NEXT1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN17@xmlParseEn
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN17@xmlParseEn:

; 9660 : 
; 9661 :     /*
; 9662 :      * [ WFC: Element Type Match ]
; 9663 :      * The Name in an element's end-tag must match the element type in the
; 9664 :      * start-tag.
; 9665 :      *
; 9666 :      */
; 9667 :     if (name != (xmlChar*)1) {

	cmp	DWORD PTR _name$[ebp], 1
	je	SHORT $done$28

; 9668 :         if (name == NULL) name = BAD_CAST "unparseable";

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN23@xmlParseEn
	mov	DWORD PTR _name$[ebp], OFFSET ??_C@_0M@IAMGGMFE@unparseable@
$LN23@xmlParseEn:

; 9669 :         if ((line == 0) && (ctxt->node != NULL))

	cmp	DWORD PTR _line$[ebp], 0
	jne	SHORT $LN24@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN24@xmlParseEn

; 9670 :             line = ctxt->node->line;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	movzx	eax, WORD PTR [edx+56]
	mov	DWORD PTR _line$[ebp], eax
$LN24@xmlParseEn:

; 9671 :         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _line$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	push	OFFSET ??_C@_0DE@OCMDIBAP@Opening?5and?5ending?5tag?5mismatch@
	push	76					; 0000004cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStrIntStr
	add	esp, 24					; 00000018H
$done$28:

; 9672 : 		     "Opening and ending tag mismatch: %s line %d and %s\n",
; 9673 : 		                ctxt->name, line, name);
; 9674 :     }
; 9675 : 
; 9676 :     /*
; 9677 :      * SAX: End of Tag
; 9678 :      */
; 9679 : done:
; 9680 :     if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN25@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+120], 0
	je	SHORT $LN25@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN25@xmlParseEn

; 9681 : 	(!ctxt->disableSAX))
; 9682 : 	ctxt->sax->endElementNs(ctxt->userData, ctxt->name, prefix, URI);

	mov	esi, esp
	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+120]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN25@xmlParseEn:

; 9683 : 
; 9684 :     spacePop(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_spacePop
	add	esp, 4

; 9685 :     if (nsNr != 0)

	cmp	DWORD PTR _nsNr$[ebp], 0
	je	SHORT $LN1@xmlParseEn

; 9686 : 	nsPop(ctxt, nsNr);

	mov	edx, DWORD PTR _nsNr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_nsPop
	add	esp, 8
$LN1@xmlParseEn:

; 9687 :     return;
; 9688 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseEndTag2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStartTag2
_TEXT	SEGMENT
_defaults$1 = -152					; size = 4
_offset$2 = -148					; size = 4
_uri$3 = -144						; size = 4
_URL$4 = -140						; size = 4
_uri$5 = -136						; size = 4
_URL$6 = -132						; size = 4
_alloc$7 = -124						; size = 4
_len$8 = -112						; size = 4
_cons$9 = -104						; size = 4
_q$10 = -100						; size = 4
_nsNr$ = -96						; size = 4
_cur$ = -92						; size = 4
_attval$ = -88						; size = 4
_nbNs$ = -84						; size = 4
_j$ = -80						; size = 4
_i$ = -76						; size = 4
_inputid$ = -72						; size = 4
_nbdef$ = -68						; size = 4
_nbatts$ = -64						; size = 4
_nratts$ = -60						; size = 4
_maxatts$ = -56						; size = 4
_atts$ = -52						; size = 4
_attvalue$ = -44					; size = 4
_nsname$ = -36						; size = 4
_aprefix$ = -28						; size = 4
_attname$ = -20						; size = 4
_prefix$ = -12						; size = 4
_localname$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_pref$ = 12						; size = 4
_URI$ = 16						; size = 4
_tlen$ = 20						; size = 4
_xmlParseStartTag2 PROC					; COMDAT

; 9180 :                   const xmlChar **URI, int *tlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-152]
	mov	ecx, 38					; 00000026H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 9181 :     const xmlChar *localname;
; 9182 :     const xmlChar *prefix;
; 9183 :     const xmlChar *attname;
; 9184 :     const xmlChar *aprefix;
; 9185 :     const xmlChar *nsname;
; 9186 :     xmlChar *attvalue;
; 9187 :     const xmlChar **atts = ctxt->atts;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	mov	DWORD PTR _atts$[ebp], ecx

; 9188 :     int maxatts = ctxt->maxatts;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+304]
	mov	DWORD PTR _maxatts$[ebp], eax

; 9189 :     int nratts, nbatts, nbdef, inputid;
; 9190 :     int i, j, nbNs, attval;
; 9191 :     unsigned long cur;
; 9192 :     int nsNr = ctxt->nsNr;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	mov	DWORD PTR _nsNr$[ebp], edx

; 9193 : 
; 9194 :     if (RAW != '<') return(NULL);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN34@xmlParseSt
	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN34@xmlParseSt:

; 9195 :     NEXT1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN35@xmlParseSt
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN35@xmlParseSt:

; 9196 : 
; 9197 :     /*
; 9198 :      * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that
; 9199 :      *       point since the attribute values may be stored as pointers to
; 9200 :      *       the buffer and calling SHRINK would destroy them !
; 9201 :      *       The Shrinking is only possible once the full set of attribute
; 9202 :      *       callbacks have been done.
; 9203 :      */
; 9204 :     SHRINK;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN36@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	cmp	ecx, 500				; 000001f4H
	jle	SHORT $LN36@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN36@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSHRINK
	add	esp, 4
$LN36@xmlParseSt:

; 9205 :     cur = ctxt->input->cur - ctxt->input->base;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax

; 9206 :     inputid = ctxt->input->id;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR _inputid$[ebp], eax

; 9207 :     nbatts = 0;

	mov	DWORD PTR _nbatts$[ebp], 0

; 9208 :     nratts = 0;

	mov	DWORD PTR _nratts$[ebp], 0

; 9209 :     nbdef = 0;

	mov	DWORD PTR _nbdef$[ebp], 0

; 9210 :     nbNs = 0;

	mov	DWORD PTR _nbNs$[ebp], 0

; 9211 :     attval = 0;

	mov	DWORD PTR _attval$[ebp], 0

; 9212 :     /* Forget any namespaces added during an earlier parse of this element. */
; 9213 :     ctxt->nsNr = nsNr;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _nsNr$[ebp]
	mov	DWORD PTR [ecx+328], edx

; 9214 : 
; 9215 :     localname = xmlParseQName(ctxt, &prefix);

	lea	eax, DWORD PTR _prefix$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseQName
	add	esp, 8
	mov	DWORD PTR _localname$[ebp], eax

; 9216 :     if (localname == NULL) {

	cmp	DWORD PTR _localname$[ebp], 0
	jne	SHORT $LN37@xmlParseSt

; 9217 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CA@LKOHNLNN@StartTag?3?5invalid?5element?5name?6@
	push	68					; 00000044H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 9218 : 		       "StartTag: invalid element name\n");
; 9219 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN37@xmlParseSt:

; 9220 :     }
; 9221 :     *tlen = ctxt->input->cur - ctxt->input->base - cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _tlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 9222 : 
; 9223 :     /*
; 9224 :      * Now parse the attributes, it ends up with the ending
; 9225 :      *
; 9226 :      * (S Attribute)* S?
; 9227 :      */
; 9228 :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 9229 :     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN2@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN2@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN2@xmlParseSt:

; 9230 : 
; 9231 :     while (((RAW != '>') &&
; 9232 : 	   ((RAW != '/') || (NXT(1) != '>')) &&
; 9233 : 	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	je	$LN3@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN39@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 62					; 0000003eH
	je	$LN3@xmlParseSt
$LN39@xmlParseSt:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN41@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN40@xmlParseSt
$LN41@xmlParseSt:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN40@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jl	$LN3@xmlParseSt
$LN40@xmlParseSt:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	je	$LN3@xmlParseSt

; 9234 : 	const xmlChar *q = CUR_PTR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _q$10[ebp], ecx

; 9235 : 	unsigned int cons = ctxt->input->consumed;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _cons$9[ebp], ecx

; 9236 : 	int len = -1, alloc = 0;

	mov	DWORD PTR _len$8[ebp], -1
	mov	DWORD PTR _alloc$7[ebp], 0

; 9237 : 
; 9238 : 	attname = xmlParseAttribute2(ctxt, prefix, localname,

	lea	edx, DWORD PTR _alloc$7[ebp]
	push	edx
	lea	eax, DWORD PTR _len$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _attvalue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _aprefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _localname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseAttribute2
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _attname$[ebp], eax

; 9239 : 	                             &aprefix, &attvalue, &len, &alloc);
; 9240 :         if ((attname == NULL) || (attvalue == NULL))

	cmp	DWORD PTR _attname$[ebp], 0
	je	SHORT $LN43@xmlParseSt
	cmp	DWORD PTR _attvalue$[ebp], 0
	jne	SHORT $LN42@xmlParseSt
$LN43@xmlParseSt:

; 9241 :             goto next_attr;

	jmp	$next_attr$136
$LN42@xmlParseSt:

; 9242 : 	if (len < 0) len = xmlStrlen(attvalue);

	cmp	DWORD PTR _len$8[ebp], 0
	jge	SHORT $LN44@xmlParseSt
	mov	eax, DWORD PTR _attvalue$[ebp]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$8[ebp], eax
$LN44@xmlParseSt:

; 9243 : 
; 9244 :         if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _attname$[ebp]
	cmp	edx, DWORD PTR [ecx+316]
	jne	$LN45@xmlParseSt
	cmp	DWORD PTR _aprefix$[ebp], 0
	jne	$LN45@xmlParseSt

; 9245 :             const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);

	mov	eax, DWORD PTR _len$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _attvalue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URL$6[ebp], eax

; 9246 :             xmlURIPtr uri;
; 9247 : 
; 9248 :             if (URL == NULL) {

	cmp	DWORD PTR _URL$6[ebp], 0
	jne	SHORT $LN47@xmlParseSt

; 9249 :                 xmlErrMemory(ctxt, "dictionary allocation failure");

	push	OFFSET ??_C@_0BO@NHFMDAKF@dictionary?5allocation?5failure@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 9250 :                 if ((attvalue != NULL) && (alloc != 0))

	cmp	DWORD PTR _attvalue$[ebp], 0
	je	SHORT $LN48@xmlParseSt
	cmp	DWORD PTR _alloc$7[ebp], 0
	je	SHORT $LN48@xmlParseSt

; 9251 :                     xmlFree(attvalue);

	mov	esi, esp
	mov	edx, DWORD PTR _attvalue$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN48@xmlParseSt:

; 9252 :                 return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN47@xmlParseSt:

; 9253 :             }
; 9254 :             if (*URL != 0) {

	mov	eax, DWORD PTR _URL$6[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN49@xmlParseSt

; 9255 :                 uri = xmlParseURI((const char *) URL);

	mov	edx, DWORD PTR _URL$6[ebp]
	push	edx
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$5[ebp], eax

; 9256 :                 if (uri == NULL) {

	cmp	DWORD PTR _uri$5[ebp], 0
	jne	SHORT $LN50@xmlParseSt

; 9257 :                     xmlNsErr(ctxt, XML_WAR_NS_URI,

	push	0
	push	0
	mov	eax, DWORD PTR _URL$6[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@IPMJMNFH@xmlns?3?5?8?$CFs?8?5is?5not?5a?5valid?5URI?6@
	push	99					; 00000063H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 9258 :                              "xmlns: '%s' is not a valid URI\n",
; 9259 :                                        URL, NULL, NULL);
; 9260 :                 } else {

	jmp	SHORT $LN51@xmlParseSt
$LN50@xmlParseSt:

; 9261 :                     if (uri->scheme == NULL) {

	mov	edx, DWORD PTR _uri$5[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN52@xmlParseSt

; 9262 :                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,

	push	0
	push	0
	mov	eax, DWORD PTR _URL$6[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@JFBGAFGI@xmlns?3?5URI?5?$CFs?5is?5not?5absolute?6@
	push	100					; 00000064H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNsWarn
	add	esp, 24					; 00000018H
$LN52@xmlParseSt:

; 9263 :                                   "xmlns: URI %s is not absolute\n",
; 9264 :                                   URL, NULL, NULL);
; 9265 :                     }
; 9266 :                     xmlFreeURI(uri);

	mov	edx, DWORD PTR _uri$5[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4
$LN51@xmlParseSt:

; 9267 :                 }
; 9268 :                 if (URL == ctxt->str_xml_ns) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _URL$6[ebp]
	cmp	ecx, DWORD PTR [eax+320]
	jne	SHORT $LN53@xmlParseSt

; 9269 :                     if (attname != ctxt->str_xml) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _attname$[ebp]
	cmp	eax, DWORD PTR [edx+312]
	je	SHORT $LN54@xmlParseSt

; 9270 :                         xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0DD@IPHAILAA@xml?5namespace?5URI?5cannot?5be?5the@
	push	200					; 000000c8H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN54@xmlParseSt:

; 9271 :                      "xml namespace URI cannot be the default namespace\n",
; 9272 :                                  NULL, NULL, NULL);
; 9273 :                     }
; 9274 :                     goto next_attr;

	jmp	$next_attr$136
$LN53@xmlParseSt:

; 9275 :                 }
; 9276 :                 if ((len == 29) &&

	cmp	DWORD PTR _len$8[ebp], 29		; 0000001dH
	jne	SHORT $LN49@xmlParseSt
	push	OFFSET ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
	mov	edx, DWORD PTR _URL$6[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@xmlParseSt

; 9277 :                     (xmlStrEqual(URL,
; 9278 :                              BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
; 9279 :                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0DA@DPCHHACL@reuse?5of?5the?5xmlns?5namespace?5na@
	push	200					; 000000c8H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 9280 :                          "reuse of the xmlns namespace name is forbidden\n",
; 9281 :                              NULL, NULL, NULL);
; 9282 :                     goto next_attr;

	jmp	$next_attr$136
$LN49@xmlParseSt:

; 9283 :                 }
; 9284 :             }
; 9285 :             /*
; 9286 :              * check that it's not a defined namespace
; 9287 :              */
; 9288 :             for (j = 1;j <= nbNs;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN6@xmlParseSt
$LN4@xmlParseSt:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN6@xmlParseSt:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _nbNs$[ebp]
	jg	SHORT $LN5@xmlParseSt

; 9289 :                 if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	sub	edx, eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+336]
	cmp	DWORD PTR [ecx+edx*4], 0
	jne	SHORT $LN56@xmlParseSt

; 9290 :                     break;

	jmp	SHORT $LN5@xmlParseSt
$LN56@xmlParseSt:
	jmp	SHORT $LN4@xmlParseSt
$LN5@xmlParseSt:

; 9291 :             if (j <= nbNs)

	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _nbNs$[ebp]
	jg	SHORT $LN57@xmlParseSt

; 9292 :                 xmlErrAttributeDup(ctxt, NULL, attname);

	mov	eax, DWORD PTR _attname$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrAttributeDup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN58@xmlParseSt
$LN57@xmlParseSt:

; 9293 :             else
; 9294 :                 if (nsPush(ctxt, NULL, URL) > 0) nbNs++;

	mov	edx, DWORD PTR _URL$6[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_nsPush
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	SHORT $LN58@xmlParseSt
	mov	ecx, DWORD PTR _nbNs$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbNs$[ebp], ecx
$LN58@xmlParseSt:

; 9295 : 
; 9296 :         } else if (aprefix == ctxt->str_xmlns) {

	jmp	$next_attr$136
$LN45@xmlParseSt:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _aprefix$[ebp]
	cmp	eax, DWORD PTR [edx+316]
	jne	$LN60@xmlParseSt

; 9297 :             const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);

	mov	ecx, DWORD PTR _len$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _attvalue$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URL$4[ebp], eax

; 9298 :             xmlURIPtr uri;
; 9299 : 
; 9300 :             if (attname == ctxt->str_xml) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _attname$[ebp]
	cmp	eax, DWORD PTR [edx+312]
	jne	SHORT $LN62@xmlParseSt

; 9301 :                 if (URL != ctxt->str_xml_ns) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _URL$4[ebp]
	cmp	edx, DWORD PTR [ecx+320]
	je	SHORT $LN63@xmlParseSt

; 9302 :                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CK@HOGKMNCM@xml?5namespace?5prefix?5mapped?5to?5@
	push	200					; 000000c8H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN63@xmlParseSt:

; 9303 :                              "xml namespace prefix mapped to wrong URI\n",
; 9304 :                              NULL, NULL, NULL);
; 9305 :                 }
; 9306 :                 /*
; 9307 :                  * Do not keep a namespace definition node
; 9308 :                  */
; 9309 :                 goto next_attr;

	jmp	$next_attr$136
$LN62@xmlParseSt:

; 9310 :             }
; 9311 :             if (URL == ctxt->str_xml_ns) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _URL$4[ebp]
	cmp	edx, DWORD PTR [ecx+320]
	jne	SHORT $LN64@xmlParseSt

; 9312 :                 if (attname != ctxt->str_xml) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _attname$[ebp]
	cmp	ecx, DWORD PTR [eax+312]
	je	SHORT $LN65@xmlParseSt

; 9313 :                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CK@HFNNIPGF@xml?5namespace?5URI?5mapped?5to?5wro@
	push	200					; 000000c8H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN65@xmlParseSt:

; 9314 :                              "xml namespace URI mapped to wrong prefix\n",
; 9315 :                              NULL, NULL, NULL);
; 9316 :                 }
; 9317 :                 goto next_attr;

	jmp	$next_attr$136
$LN64@xmlParseSt:

; 9318 :             }
; 9319 :             if (attname == ctxt->str_xmlns) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _attname$[ebp]
	cmp	ecx, DWORD PTR [eax+316]
	jne	SHORT $LN66@xmlParseSt

; 9320 :                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CP@FCHEBDCM@redefinition?5of?5the?5xmlns?5prefi@
	push	200					; 000000c8H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 9321 :                          "redefinition of the xmlns prefix is forbidden\n",
; 9322 :                          NULL, NULL, NULL);
; 9323 :                 goto next_attr;

	jmp	$next_attr$136
$LN66@xmlParseSt:

; 9324 :             }
; 9325 :             if ((len == 29) &&

	cmp	DWORD PTR _len$8[ebp], 29		; 0000001dH
	jne	SHORT $LN67@xmlParseSt
	push	OFFSET ??_C@_0BO@GBJIDPIB@http?3?1?1www?4w3?4org?12000?1xmlns?1@
	mov	eax, DWORD PTR _URL$4[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN67@xmlParseSt

; 9326 :                 (xmlStrEqual(URL,
; 9327 :                              BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
; 9328 :                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0DA@DPCHHACL@reuse?5of?5the?5xmlns?5namespace?5na@
	push	200					; 000000c8H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 9329 :                          "reuse of the xmlns namespace name is forbidden\n",
; 9330 :                          NULL, NULL, NULL);
; 9331 :                 goto next_attr;

	jmp	$next_attr$136
$LN67@xmlParseSt:

; 9332 :             }
; 9333 :             if ((URL == NULL) || (URL[0] == 0)) {

	cmp	DWORD PTR _URL$4[ebp], 0
	je	SHORT $LN70@xmlParseSt
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _URL$4[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN68@xmlParseSt
$LN70@xmlParseSt:

; 9334 :                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,

	push	0
	push	0
	mov	eax, DWORD PTR _attname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CO@JLGJJKB@xmlns?3?$CFs?3?5Empty?5XML?5namespace?5i@
	push	200					; 000000c8H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 9335 :                          "xmlns:%s: Empty XML namespace is not allowed\n",
; 9336 :                               attname, NULL, NULL);
; 9337 :                 goto next_attr;

	jmp	$next_attr$136

; 9338 :             } else {

	jmp	$LN69@xmlParseSt
$LN68@xmlParseSt:

; 9339 :                 uri = xmlParseURI((const char *) URL);

	mov	edx, DWORD PTR _URL$4[ebp]
	push	edx
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$3[ebp], eax

; 9340 :                 if (uri == NULL) {

	cmp	DWORD PTR _uri$3[ebp], 0
	jne	SHORT $LN71@xmlParseSt

; 9341 :                     xmlNsErr(ctxt, XML_WAR_NS_URI,

	push	0
	mov	eax, DWORD PTR _URL$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _attname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CD@IMLPGLBN@xmlns?3?$CFs?3?5?8?$CFs?8?5is?5not?5a?5valid?5U@
	push	99					; 00000063H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 9342 :                          "xmlns:%s: '%s' is not a valid URI\n",
; 9343 :                                        attname, URL, NULL);
; 9344 :                 } else {

	jmp	SHORT $LN69@xmlParseSt
$LN71@xmlParseSt:

; 9345 :                     if ((ctxt->pedantic) && (uri->scheme == NULL)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+268], 0
	je	SHORT $LN73@xmlParseSt
	mov	ecx, DWORD PTR _uri$3[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN73@xmlParseSt

; 9346 :                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,

	push	0
	mov	edx, DWORD PTR _URL$4[ebp]
	push	edx
	mov	eax, DWORD PTR _attname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@FFFCEDOK@xmlns?3?$CFs?3?5URI?5?$CFs?5is?5not?5absolut@
	push	100					; 00000064H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNsWarn
	add	esp, 24					; 00000018H
$LN73@xmlParseSt:

; 9347 :                                   "xmlns:%s: URI %s is not absolute\n",
; 9348 :                                   attname, URL, NULL);
; 9349 :                     }
; 9350 :                     xmlFreeURI(uri);

	mov	edx, DWORD PTR _uri$3[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4
$LN69@xmlParseSt:

; 9351 :                 }
; 9352 :             }
; 9353 : 
; 9354 :             /*
; 9355 :              * check that it's not a defined namespace
; 9356 :              */
; 9357 :             for (j = 1;j <= nbNs;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN9@xmlParseSt
$LN7@xmlParseSt:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN9@xmlParseSt:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _nbNs$[ebp]
	jg	SHORT $LN8@xmlParseSt

; 9358 :                 if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	sub	ecx, edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+336]
	mov	ecx, DWORD PTR [eax+ecx*4]
	cmp	ecx, DWORD PTR _attname$[ebp]
	jne	SHORT $LN74@xmlParseSt

; 9359 :                     break;

	jmp	SHORT $LN8@xmlParseSt
$LN74@xmlParseSt:
	jmp	SHORT $LN7@xmlParseSt
$LN8@xmlParseSt:

; 9360 :             if (j <= nbNs)

	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _nbNs$[ebp]
	jg	SHORT $LN75@xmlParseSt

; 9361 :                 xmlErrAttributeDup(ctxt, aprefix, attname);

	mov	eax, DWORD PTR _attname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aprefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrAttributeDup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN76@xmlParseSt
$LN75@xmlParseSt:

; 9362 :             else
; 9363 :                 if (nsPush(ctxt, attname, URL) > 0) nbNs++;

	mov	eax, DWORD PTR _URL$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _attname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_nsPush
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	SHORT $LN76@xmlParseSt
	mov	eax, DWORD PTR _nbNs$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbNs$[ebp], eax
$LN76@xmlParseSt:

; 9364 : 
; 9365 :         } else {

	jmp	$next_attr$136
$LN60@xmlParseSt:

; 9366 :             /*
; 9367 :              * Add the pair to atts
; 9368 :              */
; 9369 :             if ((atts == NULL) || (nbatts + 5 > maxatts)) {

	cmp	DWORD PTR _atts$[ebp], 0
	je	SHORT $LN79@xmlParseSt
	mov	ecx, DWORD PTR _nbatts$[ebp]
	add	ecx, 5
	cmp	ecx, DWORD PTR _maxatts$[ebp]
	jle	SHORT $LN78@xmlParseSt
$LN79@xmlParseSt:

; 9370 :                 if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {

	mov	edx, DWORD PTR _nbatts$[ebp]
	add	edx, 5
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtGrowAttrs
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN80@xmlParseSt

; 9371 :                     goto next_attr;

	jmp	$next_attr$136
$LN80@xmlParseSt:

; 9372 :                 }
; 9373 :                 maxatts = ctxt->maxatts;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	mov	DWORD PTR _maxatts$[ebp], edx

; 9374 :                 atts = ctxt->atts;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	mov	DWORD PTR _atts$[ebp], ecx
$LN78@xmlParseSt:

; 9375 :             }
; 9376 :             ctxt->attallocs[nratts++] = alloc;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+340]
	mov	ecx, DWORD PTR _nratts$[ebp]
	mov	edx, DWORD PTR _alloc$7[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _nratts$[ebp]
	add	eax, 1
	mov	DWORD PTR _nratts$[ebp], eax

; 9377 :             atts[nbatts++] = attname;

	mov	ecx, DWORD PTR _nbatts$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR _attname$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _nbatts$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbatts$[ebp], ecx

; 9378 :             atts[nbatts++] = aprefix;

	mov	edx, DWORD PTR _nbatts$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	ecx, DWORD PTR _aprefix$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR _nbatts$[ebp]
	add	edx, 1
	mov	DWORD PTR _nbatts$[ebp], edx

; 9379 :             /*
; 9380 :              * The namespace URI field is used temporarily to point at the
; 9381 :              * base of the current input buffer for non-alloced attributes.
; 9382 :              * When the input buffer is reallocated, all the pointers become
; 9383 :              * invalid, but they can be reconstructed later.
; 9384 :              */
; 9385 :             if (alloc)

	cmp	DWORD PTR _alloc$7[ebp], 0
	je	SHORT $LN81@xmlParseSt

; 9386 :                 atts[nbatts++] = NULL;

	mov	eax, DWORD PTR _nbatts$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0
	mov	edx, DWORD PTR _nbatts$[ebp]
	add	edx, 1
	mov	DWORD PTR _nbatts$[ebp], edx
	jmp	SHORT $LN82@xmlParseSt
$LN81@xmlParseSt:

; 9387 :             else
; 9388 :                 atts[nbatts++] = ctxt->input->base;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _nbatts$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR _nbatts$[ebp]
	add	edx, 1
	mov	DWORD PTR _nbatts$[ebp], edx
$LN82@xmlParseSt:

; 9389 :             atts[nbatts++] = attvalue;

	mov	eax, DWORD PTR _nbatts$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	edx, DWORD PTR _attvalue$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _nbatts$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbatts$[ebp], eax

; 9390 :             attvalue += len;

	mov	ecx, DWORD PTR _attvalue$[ebp]
	add	ecx, DWORD PTR _len$8[ebp]
	mov	DWORD PTR _attvalue$[ebp], ecx

; 9391 :             atts[nbatts++] = attvalue;

	mov	edx, DWORD PTR _nbatts$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	ecx, DWORD PTR _attvalue$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR _nbatts$[ebp]
	add	edx, 1
	mov	DWORD PTR _nbatts$[ebp], edx

; 9392 :             /*
; 9393 :              * tag if some deallocation is needed
; 9394 :              */
; 9395 :             if (alloc != 0) attval = 1;

	cmp	DWORD PTR _alloc$7[ebp], 0
	je	SHORT $LN83@xmlParseSt
	mov	DWORD PTR _attval$[ebp], 1
$LN83@xmlParseSt:

; 9396 :             attvalue = NULL; /* moved into atts */

	mov	DWORD PTR _attvalue$[ebp], 0
$next_attr$136:

; 9397 :         }
; 9398 : 
; 9399 : next_attr:
; 9400 :         if ((attvalue != NULL) && (alloc != 0)) {

	cmp	DWORD PTR _attvalue$[ebp], 0
	je	SHORT $LN84@xmlParseSt
	cmp	DWORD PTR _alloc$7[ebp], 0
	je	SHORT $LN84@xmlParseSt

; 9401 :             xmlFree(attvalue);

	mov	esi, esp
	mov	eax, DWORD PTR _attvalue$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9402 :             attvalue = NULL;

	mov	DWORD PTR _attvalue$[ebp], 0
$LN84@xmlParseSt:

; 9403 :         }
; 9404 : 
; 9405 : 	GROW

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN85@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN85@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN85@xmlParseSt:

; 9406 :         if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN86@xmlParseSt

; 9407 :             break;

	jmp	$LN3@xmlParseSt
$LN86@xmlParseSt:

; 9408 : 	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN88@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN87@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN87@xmlParseSt
$LN88@xmlParseSt:

; 9409 : 	    break;

	jmp	$LN3@xmlParseSt
$LN87@xmlParseSt:

; 9410 : 	if (SKIP_BLANKS == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN89@xmlParseSt

; 9411 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BM@FKPAGOOK@attributes?5construct?5error?6@
	push	65					; 00000041H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 9412 : 			   "attributes construct error\n");
; 9413 : 	    break;

	jmp	SHORT $LN3@xmlParseSt
$LN89@xmlParseSt:

; 9414 : 	}
; 9415 :         if ((cons == ctxt->input->consumed) && (q == CUR_PTR) &&
; 9416 :             (attname == NULL) && (attvalue == NULL)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _cons$9[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jne	SHORT $LN90@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _q$10[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN90@xmlParseSt
	cmp	DWORD PTR _attname$[ebp], 0
	jne	SHORT $LN90@xmlParseSt
	cmp	DWORD PTR _attvalue$[ebp], 0
	jne	SHORT $LN90@xmlParseSt

; 9417 : 	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CO@KAECIKGE@xmlParseStartTag?3?5problem?5parsi@
	push	1
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 9418 : 	         "xmlParseStartTag: problem parsing attributes\n");
; 9419 : 	    break;

	jmp	SHORT $LN3@xmlParseSt
$LN90@xmlParseSt:

; 9420 : 	}
; 9421 :         GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN91@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN91@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN91@xmlParseSt:

; 9422 :     }

	jmp	$LN2@xmlParseSt
$LN3@xmlParseSt:

; 9423 : 
; 9424 :     if (ctxt->input->id != inputid) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+56]
	cmp	ecx, DWORD PTR _inputid$[ebp]
	je	SHORT $LN92@xmlParseSt

; 9425 :         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0BM@HDEBIHCG@Unexpected?5change?5of?5input?6@
	push	1
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 9426 :                     "Unexpected change of input\n");
; 9427 :         localname = NULL;

	mov	DWORD PTR _localname$[ebp], 0

; 9428 :         goto done;

	jmp	$done$137
$LN92@xmlParseSt:

; 9429 :     }
; 9430 : 
; 9431 :     /* Reconstruct attribute value pointers. */
; 9432 :     for (i = 0, j = 0; j < nratts; i += 5, j++) {

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN12@xmlParseSt
$LN10@xmlParseSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 5
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN12@xmlParseSt:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _nratts$[ebp]
	jge	SHORT $LN11@xmlParseSt

; 9433 :         if (atts[i+2] != NULL) {

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	cmp	DWORD PTR [ecx+eax*4+8], 0
	je	SHORT $LN93@xmlParseSt

; 9434 :             /*
; 9435 :              * Arithmetic on dangling pointers is technically undefined
; 9436 :              * behavior, but well...
; 9437 :              */
; 9438 :             ptrdiff_t offset = ctxt->input->base - atts[i+2];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [edx+ecx*4+8]
	mov	DWORD PTR _offset$2[ebp], eax

; 9439 :             atts[i+2]  = NULL;    /* Reset repurposed namespace URI */

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], 0

; 9440 :             atts[i+3] += offset;  /* value */

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+12]
	add	edx, DWORD PTR _offset$2[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [ecx+eax*4+12], edx

; 9441 :             atts[i+4] += offset;  /* valuend */

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+16]
	add	ecx, DWORD PTR _offset$2[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [eax+edx*4+16], ecx
$LN93@xmlParseSt:

; 9442 :         }
; 9443 :     }

	jmp	$LN10@xmlParseSt
$LN11@xmlParseSt:

; 9444 : 
; 9445 :     /*
; 9446 :      * The attributes defaulting
; 9447 :      */
; 9448 :     if (ctxt->attsDefault != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+348], 0
	je	$LN94@xmlParseSt

; 9449 :         xmlDefAttrsPtr defaults;
; 9450 : 
; 9451 : 	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);

	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _localname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+348]
	push	edx
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _defaults$1[ebp], eax

; 9452 : 	if (defaults != NULL) {

	cmp	DWORD PTR _defaults$1[ebp], 0
	je	$LN94@xmlParseSt

; 9453 : 	    for (i = 0;i < defaults->nbAttrs;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@xmlParseSt
$LN13@xmlParseSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@xmlParseSt:
	mov	ecx, DWORD PTR _defaults$1[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	$LN94@xmlParseSt

; 9454 : 	        attname = defaults->values[5 * i];

	imul	eax, DWORD PTR _i$[ebp], 5
	mov	ecx, DWORD PTR _defaults$1[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	mov	DWORD PTR _attname$[ebp], edx

; 9455 : 		aprefix = defaults->values[5 * i + 1];

	imul	eax, DWORD PTR _i$[ebp], 5
	mov	ecx, DWORD PTR _defaults$1[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+12]
	mov	DWORD PTR _aprefix$[ebp], edx

; 9456 : 
; 9457 :                 /*
; 9458 : 		 * special work for namespaces defaulted defs
; 9459 : 		 */
; 9460 : 		if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _attname$[ebp]
	cmp	ecx, DWORD PTR [eax+316]
	jne	$LN96@xmlParseSt
	cmp	DWORD PTR _aprefix$[ebp], 0
	jne	$LN96@xmlParseSt

; 9461 : 		    /*
; 9462 : 		     * check that it's not a defined namespace
; 9463 : 		     */
; 9464 : 		    for (j = 1;j <= nbNs;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN18@xmlParseSt
$LN16@xmlParseSt:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN18@xmlParseSt:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _nbNs$[ebp]
	jg	SHORT $LN17@xmlParseSt

; 9465 : 		        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)

	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	sub	eax, ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+336]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	SHORT $LN98@xmlParseSt

; 9466 : 			    break;

	jmp	SHORT $LN17@xmlParseSt
$LN98@xmlParseSt:
	jmp	SHORT $LN16@xmlParseSt
$LN17@xmlParseSt:

; 9467 : 	            if (j <= nbNs) continue;

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _nbNs$[ebp]
	jg	SHORT $LN99@xmlParseSt
	jmp	$LN13@xmlParseSt
$LN99@xmlParseSt:

; 9468 : 
; 9469 : 		    nsname = xmlGetNamespace(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGetNamespace
	add	esp, 8
	mov	DWORD PTR _nsname$[ebp], eax

; 9470 : 		    if (nsname != defaults->values[5 * i + 2]) {

	imul	edx, DWORD PTR _i$[ebp], 5
	mov	eax, DWORD PTR _defaults$1[ebp]
	mov	ecx, DWORD PTR _nsname$[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4+16]
	je	SHORT $LN100@xmlParseSt

; 9471 : 			if (nsPush(ctxt, NULL,
; 9472 : 			           defaults->values[5 * i + 2]) > 0)

	imul	edx, DWORD PTR _i$[ebp], 5
	mov	eax, DWORD PTR _defaults$1[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+16]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_nsPush
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	SHORT $LN100@xmlParseSt

; 9473 : 			    nbNs++;

	mov	eax, DWORD PTR _nbNs$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbNs$[ebp], eax
$LN100@xmlParseSt:

; 9474 : 		    }

	jmp	$LN97@xmlParseSt
$LN96@xmlParseSt:

; 9475 : 		} else if (aprefix == ctxt->str_xmlns) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _aprefix$[ebp]
	cmp	edx, DWORD PTR [ecx+316]
	jne	$LN102@xmlParseSt

; 9476 : 		    /*
; 9477 : 		     * check that it's not a defined namespace
; 9478 : 		     */
; 9479 : 		    for (j = 1;j <= nbNs;j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN21@xmlParseSt
$LN19@xmlParseSt:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN21@xmlParseSt:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _nbNs$[ebp]
	jg	SHORT $LN20@xmlParseSt

; 9480 : 		        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	sub	ecx, edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+336]
	mov	ecx, DWORD PTR [eax+ecx*4]
	cmp	ecx, DWORD PTR _attname$[ebp]
	jne	SHORT $LN104@xmlParseSt

; 9481 : 			    break;

	jmp	SHORT $LN20@xmlParseSt
$LN104@xmlParseSt:
	jmp	SHORT $LN19@xmlParseSt
$LN20@xmlParseSt:

; 9482 : 	            if (j <= nbNs) continue;

	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _nbNs$[ebp]
	jg	SHORT $LN105@xmlParseSt
	jmp	$LN13@xmlParseSt
$LN105@xmlParseSt:

; 9483 : 
; 9484 : 		    nsname = xmlGetNamespace(ctxt, attname);

	mov	eax, DWORD PTR _attname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGetNamespace
	add	esp, 8
	mov	DWORD PTR _nsname$[ebp], eax

; 9485 : 		    if (nsname != defaults->values[2]) {

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _defaults$1[ebp]
	mov	ecx, DWORD PTR _nsname$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+8]
	je	SHORT $LN106@xmlParseSt

; 9486 : 			if (nsPush(ctxt, attname,
; 9487 : 			           defaults->values[5 * i + 2]) > 0)

	imul	edx, DWORD PTR _i$[ebp], 5
	mov	eax, DWORD PTR _defaults$1[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+16]
	push	ecx
	mov	edx, DWORD PTR _attname$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_nsPush
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	SHORT $LN106@xmlParseSt

; 9488 : 			    nbNs++;

	mov	ecx, DWORD PTR _nbNs$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbNs$[ebp], ecx
$LN106@xmlParseSt:

; 9489 : 		    }
; 9490 : 		} else {

	jmp	$LN97@xmlParseSt
$LN102@xmlParseSt:

; 9491 : 		    /*
; 9492 : 		     * check that it's not a defined attribute
; 9493 : 		     */
; 9494 : 		    for (j = 0;j < nbatts;j+=5) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN24@xmlParseSt
$LN22@xmlParseSt:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 5
	mov	DWORD PTR _j$[ebp], edx
$LN24@xmlParseSt:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _nbatts$[ebp]
	jge	SHORT $LN23@xmlParseSt

; 9495 : 			if ((attname == atts[j]) && (aprefix == atts[j+1]))

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR _attname$[ebp]
	cmp	eax, DWORD PTR [edx+ecx*4]
	jne	SHORT $LN108@xmlParseSt
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR _aprefix$[ebp]
	cmp	eax, DWORD PTR [edx+ecx*4+4]
	jne	SHORT $LN108@xmlParseSt

; 9496 : 			    break;

	jmp	SHORT $LN23@xmlParseSt
$LN108@xmlParseSt:

; 9497 : 		    }

	jmp	SHORT $LN22@xmlParseSt
$LN23@xmlParseSt:

; 9498 : 		    if (j < nbatts) continue;

	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _nbatts$[ebp]
	jge	SHORT $LN109@xmlParseSt
	jmp	$LN13@xmlParseSt
$LN109@xmlParseSt:

; 9499 : 
; 9500 : 		    if ((atts == NULL) || (nbatts + 5 > maxatts)) {

	cmp	DWORD PTR _atts$[ebp], 0
	je	SHORT $LN111@xmlParseSt
	mov	edx, DWORD PTR _nbatts$[ebp]
	add	edx, 5
	cmp	edx, DWORD PTR _maxatts$[ebp]
	jle	SHORT $LN110@xmlParseSt
$LN111@xmlParseSt:

; 9501 : 			if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {

	mov	eax, DWORD PTR _nbatts$[ebp]
	add	eax, 5
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtGrowAttrs
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN112@xmlParseSt

; 9502 : 			    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN112@xmlParseSt:

; 9503 : 			}
; 9504 : 			maxatts = ctxt->maxatts;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+304]
	mov	DWORD PTR _maxatts$[ebp], eax

; 9505 : 			atts = ctxt->atts;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	mov	DWORD PTR _atts$[ebp], edx
$LN110@xmlParseSt:

; 9506 : 		    }
; 9507 : 		    atts[nbatts++] = attname;

	mov	eax, DWORD PTR _nbatts$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	edx, DWORD PTR _attname$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _nbatts$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbatts$[ebp], eax

; 9508 : 		    atts[nbatts++] = aprefix;

	mov	ecx, DWORD PTR _nbatts$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR _aprefix$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _nbatts$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbatts$[ebp], ecx

; 9509 : 		    if (aprefix == NULL)

	cmp	DWORD PTR _aprefix$[ebp], 0
	jne	SHORT $LN113@xmlParseSt

; 9510 : 			atts[nbatts++] = NULL;

	mov	edx, DWORD PTR _nbatts$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [eax+edx*4], 0
	mov	ecx, DWORD PTR _nbatts$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbatts$[ebp], ecx
	jmp	SHORT $LN114@xmlParseSt
$LN113@xmlParseSt:

; 9511 : 		    else
; 9512 : 		        atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);

	mov	edx, DWORD PTR _aprefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGetNamespace
	add	esp, 8
	mov	ecx, DWORD PTR _nbatts$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _nbatts$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbatts$[ebp], eax
$LN114@xmlParseSt:

; 9513 : 		    atts[nbatts++] = defaults->values[5 * i + 2];

	imul	ecx, DWORD PTR _i$[ebp], 5
	mov	edx, DWORD PTR _nbatts$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	esi, DWORD PTR _defaults$1[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+16]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR _nbatts$[ebp]
	add	edx, 1
	mov	DWORD PTR _nbatts$[ebp], edx

; 9514 : 		    atts[nbatts++] = defaults->values[5 * i + 3];

	imul	eax, DWORD PTR _i$[ebp], 5
	mov	ecx, DWORD PTR _nbatts$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	esi, DWORD PTR _defaults$1[ebp]
	mov	eax, DWORD PTR [esi+eax*4+20]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _nbatts$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbatts$[ebp], ecx

; 9515 : 		    if ((ctxt->standalone == 1) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+28], 1
	jne	SHORT $LN115@xmlParseSt
	imul	eax, DWORD PTR _i$[ebp], 5
	mov	ecx, DWORD PTR _defaults$1[ebp]
	cmp	DWORD PTR [ecx+eax*4+24], 0
	je	SHORT $LN115@xmlParseSt

; 9516 : 		        (defaults->values[5 * i + 4] != NULL)) {
; 9517 : 			xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,

	mov	edx, DWORD PTR _localname$[ebp]
	push	edx
	mov	eax, DWORD PTR _attname$[ebp]
	push	eax
	push	OFFSET ??_C@_0DP@KFNFGALP@standalone?3?5attribute?5?$CFs?5on?5?$CFs?5@
	push	538					; 0000021aH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlValidityError
	add	esp, 20					; 00000014H
$LN115@xmlParseSt:

; 9518 : 	  "standalone: attribute %s on %s defaulted from external subset\n",
; 9519 : 	                                 attname, localname);
; 9520 : 		    }
; 9521 : 		    nbdef++;

	mov	edx, DWORD PTR _nbdef$[ebp]
	add	edx, 1
	mov	DWORD PTR _nbdef$[ebp], edx
$LN97@xmlParseSt:

; 9522 : 		}
; 9523 : 	    }

	jmp	$LN13@xmlParseSt
$LN94@xmlParseSt:

; 9524 : 	}
; 9525 :     }
; 9526 : 
; 9527 :     /*
; 9528 :      * The attributes checkings
; 9529 :      */
; 9530 :     for (i = 0; i < nbatts;i += 5) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN27@xmlParseSt
$LN25@xmlParseSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 5
	mov	DWORD PTR _i$[ebp], eax
$LN27@xmlParseSt:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _nbatts$[ebp]
	jge	$LN26@xmlParseSt

; 9531 :         /*
; 9532 : 	* The default namespace does not apply to attribute names.
; 9533 : 	*/
; 9534 : 	if (atts[i + 1] != NULL) {

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	cmp	DWORD PTR [eax+edx*4+4], 0
	je	SHORT $LN116@xmlParseSt

; 9535 : 	    nsname = xmlGetNamespace(ctxt, atts[i + 1]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGetNamespace
	add	esp, 8
	mov	DWORD PTR _nsname$[ebp], eax

; 9536 : 	    if (nsname == NULL) {

	cmp	DWORD PTR _nsname$[ebp], 0
	jne	SHORT $LN118@xmlParseSt

; 9537 : 		xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,

	mov	edx, DWORD PTR _localname$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	push	edx
	push	OFFSET ??_C@_0DB@GMKAHOEK@Namespace?5prefix?5?$CFs?5for?5?$CFs?5on?5?$CF@
	push	201					; 000000c9H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN118@xmlParseSt:

; 9538 : 		    "Namespace prefix %s for %s on %s is not defined\n",
; 9539 : 		    atts[i + 1], atts[i], localname);
; 9540 : 	    }
; 9541 : 	    atts[i + 2] = nsname;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR _nsname$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 9542 : 	} else

	jmp	SHORT $LN117@xmlParseSt
$LN116@xmlParseSt:

; 9543 : 	    nsname = NULL;

	mov	DWORD PTR _nsname$[ebp], 0
$LN117@xmlParseSt:

; 9544 : 	/*
; 9545 : 	 * [ WFC: Unique Att Spec ]
; 9546 : 	 * No attribute name may appear more than once in the same
; 9547 : 	 * start-tag or empty-element tag.
; 9548 : 	 * As extended by the Namespace in XML REC.
; 9549 : 	 */
; 9550 :         for (j = 0; j < i;j += 5) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN30@xmlParseSt
$LN28@xmlParseSt:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 5
	mov	DWORD PTR _j$[ebp], ecx
$LN30@xmlParseSt:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _i$[ebp]
	jge	$LN29@xmlParseSt

; 9551 : 	    if (atts[i] == atts[j]) {

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jne	SHORT $LN119@xmlParseSt

; 9552 : 	        if (atts[i+1] == atts[j+1]) {

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _atts$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+4]
	cmp	ecx, DWORD PTR [esi+eax*4+4]
	jne	SHORT $LN120@xmlParseSt

; 9553 : 		    xmlErrAttributeDup(ctxt, atts[i+1], atts[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrAttributeDup
	add	esp, 12					; 0000000cH

; 9554 : 		    break;

	jmp	SHORT $LN29@xmlParseSt
$LN120@xmlParseSt:

; 9555 : 		}
; 9556 : 		if ((nsname != NULL) && (atts[j + 2] == nsname)) {

	cmp	DWORD PTR _nsname$[ebp], 0
	je	SHORT $LN119@xmlParseSt
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	cmp	edx, DWORD PTR _nsname$[ebp]
	jne	SHORT $LN119@xmlParseSt

; 9557 : 		    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,

	push	0
	mov	eax, DWORD PTR _nsname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	OFFSET ??_C@_0CL@BDHHCEFP@Namespaced?5Attribute?5?$CFs?5in?5?8?$CFs?8@
	push	203					; 000000cbH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 9558 : 			     "Namespaced Attribute %s in '%s' redefined\n",
; 9559 : 			     atts[i], nsname, NULL);
; 9560 : 		    break;

	jmp	SHORT $LN29@xmlParseSt
$LN119@xmlParseSt:

; 9561 : 		}
; 9562 : 	    }
; 9563 : 	}

	jmp	$LN28@xmlParseSt
$LN29@xmlParseSt:

; 9564 :     }

	jmp	$LN25@xmlParseSt
$LN26@xmlParseSt:

; 9565 : 
; 9566 :     nsname = xmlGetNamespace(ctxt, prefix);

	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGetNamespace
	add	esp, 8
	mov	DWORD PTR _nsname$[ebp], eax

; 9567 :     if ((prefix != NULL) && (nsname == NULL)) {

	cmp	DWORD PTR _prefix$[ebp], 0
	je	SHORT $LN122@xmlParseSt
	cmp	DWORD PTR _nsname$[ebp], 0
	jne	SHORT $LN122@xmlParseSt

; 9568 : 	xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,

	push	0
	mov	ecx, DWORD PTR _localname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	push	OFFSET ??_C@_0CK@EJLCFGPG@Namespace?5prefix?5?$CFs?5on?5?$CFs?5is?5no@
	push	201					; 000000c9H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN122@xmlParseSt:

; 9569 : 	         "Namespace prefix %s on %s is not defined\n",
; 9570 : 		 prefix, localname, NULL);
; 9571 :     }
; 9572 :     *pref = prefix;

	mov	ecx, DWORD PTR _pref$[ebp]
	mov	edx, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [ecx], edx

; 9573 :     *URI = nsname;

	mov	eax, DWORD PTR _URI$[ebp]
	mov	ecx, DWORD PTR _nsname$[ebp]
	mov	DWORD PTR [eax], ecx

; 9574 : 
; 9575 :     /*
; 9576 :      * SAX: Start of Element !
; 9577 :      */
; 9578 :     if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$done$137
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+116], 0
	je	$done$137
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	$done$137

; 9579 : 	(!ctxt->disableSAX)) {
; 9580 : 	if (nbNs > 0)

	cmp	DWORD PTR _nbNs$[ebp], 0
	jle	SHORT $LN124@xmlParseSt

; 9581 : 	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix,

	mov	esi, esp
	mov	eax, DWORD PTR _atts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nbdef$[ebp]
	push	ecx
	mov	eax, DWORD PTR _nbatts$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _nbNs$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	sub	ecx, edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+336]
	lea	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	mov	edx, DWORD PTR _nbNs$[ebp]
	push	edx
	mov	eax, DWORD PTR _nsname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _localname$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+116]
	call	ecx
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $done$137
$LN124@xmlParseSt:

; 9582 : 			  nsname, nbNs, &ctxt->nsTab[ctxt->nsNr - 2 * nbNs],
; 9583 : 			  nbatts / 5, nbdef, atts);
; 9584 : 	else
; 9585 : 	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix,

	mov	esi, esp
	mov	edx, DWORD PTR _atts$[ebp]
	push	edx
	mov	eax, DWORD PTR _nbdef$[ebp]
	push	eax
	mov	eax, DWORD PTR _nbatts$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	push	eax
	push	0
	push	0
	mov	edx, DWORD PTR _nsname$[ebp]
	push	edx
	mov	eax, DWORD PTR _prefix$[ebp]
	push	eax
	mov	ecx, DWORD PTR _localname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp
$done$137:

; 9586 : 	                  nsname, 0, NULL, nbatts / 5, nbdef, atts);
; 9587 :     }
; 9588 : 
; 9589 : done:
; 9590 :     /*
; 9591 :      * Free up attribute allocated strings if needed
; 9592 :      */
; 9593 :     if (attval != 0) {

	cmp	DWORD PTR _attval$[ebp], 0
	je	SHORT $LN126@xmlParseSt

; 9594 : 	for (i = 3,j = 0; j < nratts;i += 5,j++)

	mov	DWORD PTR _i$[ebp], 3
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN33@xmlParseSt
$LN31@xmlParseSt:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 5
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN33@xmlParseSt:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _nratts$[ebp]
	jge	SHORT $LN126@xmlParseSt

; 9595 : 	    if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+340]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN127@xmlParseSt
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $LN127@xmlParseSt

; 9596 : 	        xmlFree((xmlChar *) atts[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN127@xmlParseSt:
	jmp	SHORT $LN31@xmlParseSt
$LN126@xmlParseSt:

; 9597 :     }
; 9598 : 
; 9599 :     return(localname);

	mov	eax, DWORD PTR _localname$[ebp]
$LN1@xmlParseSt:

; 9600 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN135@xmlParseSt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 152				; 00000098H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN135@xmlParseSt:
	DD	5
	DD	$LN134@xmlParseSt
$LN134@xmlParseSt:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN129@xmlParseSt
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN130@xmlParseSt
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN131@xmlParseSt
	DD	-112					; ffffff90H
	DD	4
	DD	$LN132@xmlParseSt
	DD	-124					; ffffff84H
	DD	4
	DD	$LN133@xmlParseSt
$LN133@xmlParseSt:
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	0
$LN132@xmlParseSt:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN131@xmlParseSt:
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN130@xmlParseSt:
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	0
$LN129@xmlParseSt:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	0
_xmlParseStartTag2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttribute2
_TEXT	SEGMENT
_val2$1 = -24						; size = 4
_type$2 = -20						; size = 4
_normalize$ = -16					; size = 4
_internal_val$ = -12					; size = 4
_val$ = -8						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_pref$ = 12						; size = 4
_elem$ = 16						; size = 4
_prefix$ = 20						; size = 4
_value$ = 24						; size = 4
_len$ = 28						; size = 4
_alloc$ = 32						; size = 4
_xmlParseAttribute2 PROC				; COMDAT

; 9052 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 9053 :     const xmlChar *name;
; 9054 :     xmlChar *val, *internal_val = NULL;

	mov	DWORD PTR _internal_val$[ebp], 0

; 9055 :     int normalize = 0;

	mov	DWORD PTR _normalize$[ebp], 0

; 9056 : 
; 9057 :     *value = NULL;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], 0

; 9058 :     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN2@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN2@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN2@xmlParseAt:

; 9059 :     name = xmlParseQName(ctxt, prefix);

	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseQName
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax

; 9060 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN3@xmlParseAt

; 9061 :         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0BO@BHLKDNI@error?5parsing?5attribute?5name?6@
	push	68					; 00000044H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 9062 :                        "error parsing attribute name\n");
; 9063 :         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN3@xmlParseAt:

; 9064 :     }
; 9065 : 
; 9066 :     /*
; 9067 :      * get the type if needed
; 9068 :      */
; 9069 :     if (ctxt->attsSpecial != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+352], 0
	je	SHORT $LN4@xmlParseAt

; 9070 :         int type;
; 9071 : 
; 9072 :         type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt->attsSpecial,

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pref$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+352]
	push	eax
	call	_xmlHashQLookup2
	add	esp, 20					; 00000014H
	mov	DWORD PTR _type$2[ebp], eax

; 9073 :                                                  pref, elem, *prefix, name);
; 9074 :         if (type != 0)

	cmp	DWORD PTR _type$2[ebp], 0
	je	SHORT $LN4@xmlParseAt

; 9075 :             normalize = 1;

	mov	DWORD PTR _normalize$[ebp], 1
$LN4@xmlParseAt:

; 9076 :     }
; 9077 : 
; 9078 :     /*
; 9079 :      * read the value
; 9080 :      */
; 9081 :     SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 9082 :     if (RAW == '=') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 61					; 0000003dH
	jne	$LN6@xmlParseAt

; 9083 :         NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 9084 :         SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 9085 :         val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);

	mov	edx, DWORD PTR _normalize$[ebp]
	push	edx
	mov	eax, DWORD PTR _alloc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseAttValueInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _val$[ebp], eax

; 9086 : 	if (normalize) {

	cmp	DWORD PTR _normalize$[ebp], 0
	je	SHORT $LN8@xmlParseAt

; 9087 : 	    /*
; 9088 : 	     * Sometimes a second normalisation pass for spaces is needed
; 9089 : 	     * but that only happens if charrefs or entities refernces
; 9090 : 	     * have been used in the attribute value, i.e. the attribute
; 9091 : 	     * value have been extracted in an allocated string already.
; 9092 : 	     */
; 9093 : 	    if (*alloc) {

	mov	eax, DWORD PTR _alloc$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@xmlParseAt

; 9094 : 	        const xmlChar *val2;
; 9095 : 
; 9096 : 	        val2 = xmlAttrNormalizeSpace2(ctxt, val, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlAttrNormalizeSpace2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _val2$1[ebp], eax

; 9097 : 		if ((val2 != NULL) && (val2 != val)) {

	cmp	DWORD PTR _val2$1[ebp], 0
	je	SHORT $LN8@xmlParseAt
	mov	ecx, DWORD PTR _val2$1[ebp]
	cmp	ecx, DWORD PTR _val$[ebp]
	je	SHORT $LN8@xmlParseAt

; 9098 : 		    xmlFree(val);

	mov	esi, esp
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9099 : 		    val = (xmlChar *) val2;

	mov	eax, DWORD PTR _val2$1[ebp]
	mov	DWORD PTR _val$[ebp], eax
$LN8@xmlParseAt:

; 9100 : 		}
; 9101 : 	    }
; 9102 : 	}
; 9103 :         ctxt->instate = XML_PARSER_CONTENT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 7

; 9104 :     } else {

	jmp	SHORT $LN7@xmlParseAt
$LN6@xmlParseAt:

; 9105 :         xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0CP@LHHGCLP@Specification?5mandates?5value?5fo@
	push	41					; 00000029H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 9106 :                           "Specification mandates value for attribute %s\n",
; 9107 :                           name);
; 9108 :         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN7@xmlParseAt:

; 9109 :     }
; 9110 : 
; 9111 :     if (*prefix == ctxt->str_xml) {

	mov	ecx, DWORD PTR _prefix$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+312]
	jne	$LN11@xmlParseAt

; 9112 :         /*
; 9113 :          * Check that xml:lang conforms to the specification
; 9114 :          * No more registered as an error, just generate a warning now
; 9115 :          * since this was deprecated in XML second edition
; 9116 :          */
; 9117 :         if ((ctxt->pedantic) && (xmlStrEqual(name, BAD_CAST "lang"))) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+268], 0
	je	SHORT $LN12@xmlParseAt
	push	OFFSET ??_C@_04IOHABJIC@lang@
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlParseAt

; 9118 :             internal_val = xmlStrndup(val, *len);

	mov	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _internal_val$[ebp], eax

; 9119 :             if (!xmlCheckLanguageID(internal_val)) {

	mov	eax, DWORD PTR _internal_val$[ebp]
	push	eax
	call	_xmlCheckLanguageID
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@xmlParseAt

; 9120 :                 xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,

	push	0
	mov	ecx, DWORD PTR _internal_val$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CD@OAOAJGL@Malformed?5value?5for?5xml?3lang?5?3?5@
	push	98					; 00000062H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN12@xmlParseAt:

; 9121 :                               "Malformed value for xml:lang : %s\n",
; 9122 :                               internal_val, NULL);
; 9123 :             }
; 9124 :         }
; 9125 : 
; 9126 :         /*
; 9127 :          * Check that xml:space conforms to the specification
; 9128 :          */
; 9129 :         if (xmlStrEqual(name, BAD_CAST "space")) {

	push	OFFSET ??_C@_05OLNILLAB@space@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlParseAt

; 9130 :             internal_val = xmlStrndup(val, *len);

	mov	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _internal_val$[ebp], eax

; 9131 :             if (xmlStrEqual(internal_val, BAD_CAST "default"))

	push	OFFSET ??_C@_07DLHCIBDH@default@
	mov	ecx, DWORD PTR _internal_val$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlParseAt

; 9132 :                 *(ctxt->space) = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+232]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN14@xmlParseAt
$LN15@xmlParseAt:

; 9133 :             else if (xmlStrEqual(internal_val, BAD_CAST "preserve"))

	push	OFFSET ??_C@_08ILAKLJGO@preserve@
	mov	ecx, DWORD PTR _internal_val$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@xmlParseAt

; 9134 :                 *(ctxt->space) = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+232]
	mov	DWORD PTR [eax], 1
	jmp	SHORT $LN14@xmlParseAt
$LN17@xmlParseAt:

; 9135 :             else {
; 9136 :                 xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,

	push	0
	mov	ecx, DWORD PTR _internal_val$[ebp]
	push	ecx
	push	OFFSET ??_C@_0EF@GNALPKCP@Invalid?5value?5?$CC?$CFs?$CC?5for?5xml?3spac@
	push	102					; 00000066H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN14@xmlParseAt:

; 9137 :                               "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
; 9138 :                               internal_val, NULL);
; 9139 :             }
; 9140 :         }
; 9141 :         if (internal_val) {

	cmp	DWORD PTR _internal_val$[ebp], 0
	je	SHORT $LN11@xmlParseAt

; 9142 :             xmlFree(internal_val);

	mov	esi, esp
	mov	eax, DWORD PTR _internal_val$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlParseAt:

; 9143 :         }
; 9144 :     }
; 9145 : 
; 9146 :     *value = val;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [ecx], edx

; 9147 :     return (name);

	mov	eax, DWORD PTR _name$[ebp]
$LN1@xmlParseAt:

; 9148 : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseAttribute2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseQNameAndCompare
_TEXT	SEGMENT
_prefix2$ = -20						; size = 4
_ret$ = -12						; size = 4
_in$ = -8						; size = 4
_cmp$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_prefix$ = 16						; size = 4
_xmlParseQNameAndCompare PROC				; COMDAT

; 8773 :                         xmlChar const *prefix) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 8774 :     const xmlChar *cmp;
; 8775 :     const xmlChar *in;
; 8776 :     const xmlChar *ret;
; 8777 :     const xmlChar *prefix2;
; 8778 : 
; 8779 :     if (prefix == NULL) return(xmlParseNameAndCompare(ctxt, name));

	cmp	DWORD PTR _prefix$[ebp], 0
	jne	SHORT $LN6@xmlParseQN
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseNameAndCompare
	add	esp, 8
	jmp	$LN1@xmlParseQN
$LN6@xmlParseQN:

; 8780 : 
; 8781 :     GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN7@xmlParseQN
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN7@xmlParseQN
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN7@xmlParseQN:

; 8782 :     in = ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _in$[ebp], edx

; 8783 : 
; 8784 :     cmp = prefix;

	mov	eax, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR _cmp$[ebp], eax
$LN2@xmlParseQN:

; 8785 :     while (*in != 0 && *in == *cmp) {

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@xmlParseQN
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _cmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN3@xmlParseQN

; 8786 : 	++in;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 8787 : 	++cmp;

	mov	edx, DWORD PTR _cmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _cmp$[ebp], edx

; 8788 :     }

	jmp	SHORT $LN2@xmlParseQN
$LN3@xmlParseQN:

; 8789 :     if ((*cmp == 0) && (*in == ':')) {

	mov	eax, DWORD PTR _cmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN8@xmlParseQN
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	jne	$LN8@xmlParseQN

; 8790 :         in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 8791 : 	cmp = name;

	mov	edx, DWORD PTR _name$[ebp]
	mov	DWORD PTR _cmp$[ebp], edx
$LN4@xmlParseQN:

; 8792 : 	while (*in != 0 && *in == *cmp) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@xmlParseQN
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _cmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN5@xmlParseQN

; 8793 : 	    ++in;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 8794 : 	    ++cmp;

	mov	ecx, DWORD PTR _cmp$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cmp$[ebp], ecx

; 8795 : 	}

	jmp	SHORT $LN4@xmlParseQN
$LN5@xmlParseQN:

; 8796 : 	if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {

	mov	edx, DWORD PTR _cmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN8@xmlParseQN
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	je	SHORT $LN10@xmlParseQN
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN10@xmlParseQN
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN12@xmlParseQN
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN10@xmlParseQN
$LN12@xmlParseQN:
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN8@xmlParseQN
$LN10@xmlParseQN:

; 8797 : 	    /* success */
; 8798 : 	    ctxt->input->cur = in;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 8799 : 	    return((const xmlChar*) 1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlParseQN
$LN8@xmlParseQN:

; 8800 : 	}
; 8801 :     }
; 8802 :     /*
; 8803 :      * all strings coms from the dictionary, equality can be done directly
; 8804 :      */
; 8805 :     ret = xmlParseQName (ctxt, &prefix2);

	lea	edx, DWORD PTR _prefix2$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseQName
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 8806 :     if ((ret == name) && (prefix == prefix2))

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	ecx, DWORD PTR _name$[ebp]
	jne	SHORT $LN13@xmlParseQN
	mov	edx, DWORD PTR _prefix$[ebp]
	cmp	edx, DWORD PTR _prefix2$[ebp]
	jne	SHORT $LN13@xmlParseQN

; 8807 : 	return((const xmlChar*) 1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlParseQN
$LN13@xmlParseQN:

; 8808 :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseQN:

; 8809 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@xmlParseQN
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN17@xmlParseQN:
	DD	1
	DD	$LN16@xmlParseQN
$LN16@xmlParseQN:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN15@xmlParseQN
$LN15@xmlParseQN:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	50					; 00000032H
	DB	0
_xmlParseQNameAndCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseQName
_TEXT	SEGMENT
_tmp$1 = -16						; size = 4
_tmp$2 = -12						; size = 4
_p$ = -8						; size = 4
_l$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_xmlParseQName PROC					; COMDAT

; 8693 : xmlParseQName(xmlParserCtxtPtr ctxt, const xmlChar **prefix) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 8694 :     const xmlChar *l, *p;
; 8695 : 
; 8696 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN2@xmlParseQN
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN2@xmlParseQN
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN2@xmlParseQN:

; 8697 : 
; 8698 :     l = xmlParseNCName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseNCName
	add	esp, 4
	mov	DWORD PTR _l$[ebp], eax

; 8699 :     if (l == NULL) {

	cmp	DWORD PTR _l$[ebp], 0
	jne	SHORT $LN3@xmlParseQN

; 8700 :         if (CUR == ':') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	jne	SHORT $LN4@xmlParseQN

; 8701 : 	    l = xmlParseName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _l$[ebp], eax

; 8702 : 	    if (l != NULL) {

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $LN4@xmlParseQN

; 8703 : 	        xmlNsErr(ctxt, XML_NS_ERR_QNAME,

	push	0
	push	0
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BM@DBJGDKCH@Failed?5to?5parse?5QName?5?8?$CFs?8?6@
	push	202					; 000000caH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 8704 : 		         "Failed to parse QName '%s'\n", l, NULL, NULL);
; 8705 : 		*prefix = NULL;

	mov	eax, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [eax], 0

; 8706 : 		return(l);

	mov	eax, DWORD PTR _l$[ebp]
	jmp	$LN1@xmlParseQN
$LN4@xmlParseQN:

; 8707 : 	    }
; 8708 : 	}
; 8709 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseQN
$LN3@xmlParseQN:

; 8710 :     }
; 8711 :     if (CUR == ':') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	$LN6@xmlParseQN

; 8712 :         NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 8713 : 	p = l;

	mov	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 8714 : 	l = xmlParseNCName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseNCName
	add	esp, 4
	mov	DWORD PTR _l$[ebp], eax

; 8715 : 	if (l == NULL) {

	cmp	DWORD PTR _l$[ebp], 0
	jne	$LN8@xmlParseQN

; 8716 : 	    xmlChar *tmp;
; 8717 : 
; 8718 :             xmlNsErr(ctxt, XML_NS_ERR_QNAME,

	push	0
	push	0
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	push	OFFSET ??_C@_0BN@MNDCJBCK@Failed?5to?5parse?5QName?5?8?$CFs?3?8?6@
	push	202					; 000000caH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 8719 : 	             "Failed to parse QName '%s:'\n", p, NULL, NULL);
; 8720 : 	    l = xmlParseNmtoken(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseNmtoken
	add	esp, 4
	mov	DWORD PTR _l$[ebp], eax

; 8721 : 	    if (l == NULL)

	cmp	DWORD PTR _l$[ebp], 0
	jne	SHORT $LN9@xmlParseQN

; 8722 : 		tmp = xmlBuildQName(BAD_CAST "", p, NULL, 0);

	push	0
	push	0
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlBuildQName
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tmp$2[ebp], eax
	jmp	SHORT $LN10@xmlParseQN
$LN9@xmlParseQN:

; 8723 : 	    else {
; 8724 : 		tmp = xmlBuildQName(l, p, NULL, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	call	_xmlBuildQName
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tmp$2[ebp], eax

; 8725 : 		xmlFree((char *)l);

	mov	esi, esp
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlParseQN:

; 8726 : 	    }
; 8727 : 	    p = xmlDictLookup(ctxt->dict, tmp, -1);

	push	-1
	mov	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _p$[ebp], eax

; 8728 : 	    if (tmp != NULL) xmlFree(tmp);

	cmp	DWORD PTR _tmp$2[ebp], 0
	je	SHORT $LN11@xmlParseQN
	mov	esi, esp
	mov	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlParseQN:

; 8729 : 	    *prefix = NULL;

	mov	ecx, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [ecx], 0

; 8730 : 	    return(p);

	mov	eax, DWORD PTR _p$[ebp]
	jmp	$LN1@xmlParseQN
$LN8@xmlParseQN:

; 8731 : 	}
; 8732 : 	if (CUR == ':') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	jne	$LN12@xmlParseQN

; 8733 : 	    xmlChar *tmp;
; 8734 : 
; 8735 :             xmlNsErr(ctxt, XML_NS_ERR_QNAME,

	push	0
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CA@HECGKKLP@Failed?5to?5parse?5QName?5?8?$CFs?3?$CFs?3?8?6@
	push	202					; 000000caH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNsErr
	add	esp, 24					; 00000018H

; 8736 : 	             "Failed to parse QName '%s:%s:'\n", p, l, NULL);
; 8737 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 8738 : 	    tmp = (xmlChar *) xmlParseName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _tmp$1[ebp], eax

; 8739 : 	    if (tmp != NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	je	SHORT $LN13@xmlParseQN

; 8740 : 	        tmp = xmlBuildQName(tmp, l, NULL, 0);

	push	0
	push	0
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	call	_xmlBuildQName
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tmp$1[ebp], eax

; 8741 : 		l = xmlDictLookup(ctxt->dict, tmp, -1);

	push	-1
	mov	ecx, DWORD PTR _tmp$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _l$[ebp], eax

; 8742 : 		if (tmp != NULL) xmlFree(tmp);

	cmp	DWORD PTR _tmp$1[ebp], 0
	je	SHORT $LN14@xmlParseQN
	mov	esi, esp
	mov	ecx, DWORD PTR _tmp$1[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlParseQN:

; 8743 : 		*prefix = p;

	mov	edx, DWORD PTR _prefix$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], eax

; 8744 : 		return(l);

	mov	eax, DWORD PTR _l$[ebp]
	jmp	SHORT $LN1@xmlParseQN
$LN13@xmlParseQN:

; 8745 : 	    }
; 8746 : 	    tmp = xmlBuildQName(BAD_CAST "", l, NULL, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlBuildQName
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tmp$1[ebp], eax

; 8747 : 	    l = xmlDictLookup(ctxt->dict, tmp, -1);

	push	-1
	mov	edx, DWORD PTR _tmp$1[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _l$[ebp], eax

; 8748 : 	    if (tmp != NULL) xmlFree(tmp);

	cmp	DWORD PTR _tmp$1[ebp], 0
	je	SHORT $LN15@xmlParseQN
	mov	esi, esp
	mov	edx, DWORD PTR _tmp$1[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlParseQN:

; 8749 : 	    *prefix = p;

	mov	eax, DWORD PTR _prefix$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], ecx

; 8750 : 	    return(l);

	mov	eax, DWORD PTR _l$[ebp]
	jmp	SHORT $LN1@xmlParseQN
$LN12@xmlParseQN:

; 8751 : 	}
; 8752 : 	*prefix = p;

	mov	edx, DWORD PTR _prefix$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], eax

; 8753 :     } else

	jmp	SHORT $LN7@xmlParseQN
$LN6@xmlParseQN:

; 8754 :         *prefix = NULL;

	mov	ecx, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [ecx], 0
$LN7@xmlParseQN:

; 8755 :     return(l);

	mov	eax, DWORD PTR _l$[ebp]
$LN1@xmlParseQN:

; 8756 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseQName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlGetNamespace
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_xmlGetNamespace PROC					; COMDAT

; 8665 : xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 8666 :     int i;
; 8667 : 
; 8668 :     if (prefix == ctxt->str_xml) return(ctxt->str_xml_ns);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _prefix$[ebp]
	cmp	ecx, DWORD PTR [eax+312]
	jne	SHORT $LN5@xmlGetName
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+320]
	jmp	SHORT $LN1@xmlGetName
$LN5@xmlGetName:

; 8669 :     for (i = ctxt->nsNr - 2;i >= 0;i-=2)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	sub	ecx, 2
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN4@xmlGetName
$LN2@xmlGetName:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 2
	mov	DWORD PTR _i$[ebp], edx
$LN4@xmlGetName:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@xmlGetName

; 8670 :         if (ctxt->nsTab[i] == prefix) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+336]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _prefix$[ebp]
	jne	SHORT $LN6@xmlGetName

; 8671 : 	    if ((prefix == NULL) && (*ctxt->nsTab[i + 1] == 0))

	cmp	DWORD PTR _prefix$[ebp], 0
	jne	SHORT $LN7@xmlGetName
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+336]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+4]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN7@xmlGetName

; 8672 : 	        return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlGetName
$LN7@xmlGetName:

; 8673 : 	    return(ctxt->nsTab[i + 1]);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+336]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	jmp	SHORT $LN1@xmlGetName
$LN6@xmlGetName:

; 8674 : 	}

	jmp	SHORT $LN2@xmlGetName
$LN3@xmlGetName:

; 8675 :     return(NULL);

	xor	eax, eax
$LN1@xmlGetName:

; 8676 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEndTag1
_TEXT	SEGMENT
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_line$ = 12						; size = 4
_xmlParseEndTag1 PROC					; COMDAT

; 8581 : xmlParseEndTag1(xmlParserCtxtPtr ctxt, int line) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 8582 :     const xmlChar *name;
; 8583 : 
; 8584 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN5@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN5@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN5@xmlParseEn:

; 8585 :     if ((RAW != '<') || (NXT(1) != '/')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN7@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN4@xmlParseEn
$LN7@xmlParseEn:

; 8586 : 	xmlFatalErrMsg(ctxt, XML_ERR_LTSLASH_REQUIRED,

	push	OFFSET ??_C@_0CA@PJGJPBIH@xmlParseEndTag?3?5?8?$DM?1?8?5not?5found?6@
	push	74					; 0000004aH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 8587 : 		       "xmlParseEndTag: '</' not found\n");
; 8588 : 	return;

	jmp	$LN1@xmlParseEn
$LN4@xmlParseEn:

; 8589 :     }
; 8590 :     SKIP(2);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN2@xmlParseEn
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEn:
	xor	eax, eax
	jne	SHORT $LN4@xmlParseEn

; 8591 : 
; 8592 :     name = xmlParseNameAndCompare(ctxt,ctxt->name);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseNameAndCompare
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax

; 8593 : 
; 8594 :     /*
; 8595 :      * We should definitely be at the ending "S? '>'" part
; 8596 :      */
; 8597 :     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN9@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN9@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN9@xmlParseEn:

; 8598 :     SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 8599 :     if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN14@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN13@xmlParseEn
$LN14@xmlParseEn:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN13@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN12@xmlParseEn
$LN13@xmlParseEn:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 62					; 0000003eH
	je	SHORT $LN10@xmlParseEn
$LN12@xmlParseEn:

; 8600 : 	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);

	push	0
	push	73					; 00000049H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 8601 :     } else

	jmp	SHORT $LN11@xmlParseEn
$LN10@xmlParseEn:

; 8602 : 	NEXT1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN11@xmlParseEn
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN11@xmlParseEn:

; 8603 : 
; 8604 :     /*
; 8605 :      * [ WFC: Element Type Match ]
; 8606 :      * The Name in an element's end-tag must match the element type in the
; 8607 :      * start-tag.
; 8608 :      *
; 8609 :      */
; 8610 :     if (name != (xmlChar*)1) {

	cmp	DWORD PTR _name$[ebp], 1
	je	SHORT $LN16@xmlParseEn

; 8611 :         if (name == NULL) name = BAD_CAST "unparseable";

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN17@xmlParseEn
	mov	DWORD PTR _name$[ebp], OFFSET ??_C@_0M@IAMGGMFE@unparseable@
$LN17@xmlParseEn:

; 8612 :         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _line$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	push	OFFSET ??_C@_0DE@OCMDIBAP@Opening?5and?5ending?5tag?5mismatch@
	push	76					; 0000004cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStrIntStr
	add	esp, 24					; 00000018H
$LN16@xmlParseEn:

; 8613 : 		     "Opening and ending tag mismatch: %s line %d and %s\n",
; 8614 : 		                ctxt->name, line, name);
; 8615 :     }
; 8616 : 
; 8617 :     /*
; 8618 :      * SAX: End of Tag
; 8619 :      */
; 8620 :     if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN18@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+60], 0
	je	SHORT $LN18@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN18@xmlParseEn

; 8621 : 	(!ctxt->disableSAX))
; 8622 :         ctxt->sax->endElement(ctxt->userData, ctxt->name);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+60]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@xmlParseEn:

; 8623 : 
; 8624 :     namePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_namePop
	add	esp, 4

; 8625 :     spacePop(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_spacePop
	add	esp, 4
$LN1@xmlParseEn:

; 8626 :     return;
; 8627 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseEndTag1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseInternalSubset
_TEXT	SEGMENT
_cons$1 = -12						; size = 4
_check$2 = -8						; size = 4
_baseInputNr$3 = -4					; size = 4
_ctxt$ = 8						; size = 4
_xmlParseInternalSubset PROC				; COMDAT

; 8268 : xmlParseInternalSubset(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 8269 :     /*
; 8270 :      * Is there any DTD definition ?
; 8271 :      */
; 8272 :     if (RAW == '[') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 91					; 0000005bH
	jne	$LN4@xmlParseIn

; 8273 :         int baseInputNr = ctxt->inputNr;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _baseInputNr$3[ebp], edx

; 8274 :         ctxt->instate = XML_PARSER_DTD;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 3

; 8275 :         NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4
$LN2@xmlParseIn:

; 8276 : 	/*
; 8277 : 	 * Parse the succession of Markup declarations and
; 8278 : 	 * PEReferences.
; 8279 : 	 * Subsequence (markupdecl | PEReference | S)*
; 8280 : 	 */
; 8281 : 	while (((RAW != ']') || (ctxt->inputNr > baseInputNr)) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 93					; 0000005dH
	jne	SHORT $LN5@xmlParseIn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	cmp	ecx, DWORD PTR _baseInputNr$3[ebp]
	jle	$LN3@xmlParseIn
$LN5@xmlParseIn:
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	je	$LN3@xmlParseIn

; 8282 :                (ctxt->instate != XML_PARSER_EOF)) {
; 8283 : 	    const xmlChar *check = CUR_PTR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _check$2[ebp], edx

; 8284 : 	    unsigned int cons = ctxt->input->consumed;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _cons$1[ebp], edx

; 8285 : 
; 8286 : 	    SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 8287 : 	    xmlParseMarkupDecl(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseMarkupDecl
	add	esp, 4

; 8288 : 	    xmlParsePEReference(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParsePEReference
	add	esp, 4

; 8289 : 
; 8290 : 	    if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _check$2[ebp]
	jne	SHORT $LN6@xmlParseIn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _cons$1[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jne	SHORT $LN6@xmlParseIn

; 8291 : 		xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0DO@IJLBCNCA@xmlParseInternalSubset?3?5error?5d@
	push	1
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 8292 : 	     "xmlParseInternalSubset: error detected in Markup declaration\n");
; 8293 :                 if (ctxt->inputNr > baseInputNr)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	cmp	edx, DWORD PTR _baseInputNr$3[ebp]
	jle	SHORT $LN7@xmlParseIn

; 8294 :                     xmlPopInput(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlPopInput
	add	esp, 4
	jmp	SHORT $LN6@xmlParseIn
$LN7@xmlParseIn:

; 8295 :                 else
; 8296 : 		    break;

	jmp	SHORT $LN3@xmlParseIn
$LN6@xmlParseIn:

; 8297 : 	    }
; 8298 : 	}

	jmp	$LN2@xmlParseIn
$LN3@xmlParseIn:

; 8299 : 	if (RAW == ']') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	jne	SHORT $LN4@xmlParseIn

; 8300 : 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 8301 : 	    SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4
$LN4@xmlParseIn:

; 8302 : 	}
; 8303 :     }
; 8304 : 
; 8305 :     /*
; 8306 :      * We should be at the end of the DOCTYPE declaration.
; 8307 :      */
; 8308 :     if (RAW != '>') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 62					; 0000003eH
	je	SHORT $LN10@xmlParseIn

; 8309 : 	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);

	push	0
	push	61					; 0000003dH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 8310 : 	return;

	jmp	SHORT $LN1@xmlParseIn
$LN10@xmlParseIn:

; 8311 :     }
; 8312 :     NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4
$LN1@xmlParseIn:

; 8313 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseInternalSubset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseConditionalSections
_TEXT	SEGMENT
_depth$1 = -24						; size = 4
_instate$2 = -20					; size = 4
_state$3 = -16						; size = 4
_cons$4 = -12						; size = 4
_check$5 = -8						; size = 4
_id$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseConditionalSections PROC			; COMDAT

; 6615 : xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 6616 :     int id = ctxt->input->id;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _id$[ebp], edx
$LN4@xmlParseCo:

; 6617 : 
; 6618 :     SKIP(3);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@xmlParseCo
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseCo:
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseCo

; 6619 :     SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6620 :     if (CMP7(CUR_PTR, 'I', 'N', 'C', 'L', 'U', 'D', 'E')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	$LN25@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 78					; 0000004eH
	jne	$LN25@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 67					; 00000043H
	jne	$LN25@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 76					; 0000004cH
	jne	$LN25@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 85					; 00000055H
	jne	$LN25@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 68					; 00000044H
	jne	$LN25@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 69					; 00000045H
	jne	$LN25@xmlParseCo
$LN7@xmlParseCo:

; 6621 : 	SKIP(7);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 7
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 7
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 7
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@xmlParseCo
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseCo:
	xor	ecx, ecx
	jne	SHORT $LN7@xmlParseCo

; 6622 : 	SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6623 : 	if (RAW != '[') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 91					; 0000005bH
	je	SHORT $LN28@xmlParseCo

; 6624 : 	    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);

	push	0
	push	83					; 00000053H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6625 : 	    xmlHaltParser(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlHaltParser
	add	esp, 4

; 6626 : 	    return;

	jmp	$LN1@xmlParseCo

; 6627 : 	} else {

	jmp	SHORT $LN29@xmlParseCo
$LN28@xmlParseCo:

; 6628 : 	    if (ctxt->input->id != id) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+56]
	cmp	edx, DWORD PTR _id$[ebp]
	je	SHORT $LN30@xmlParseCo

; 6629 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@
	push	90					; 0000005aH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN30@xmlParseCo:

; 6630 : 	                       "All markup of the conditional section is not"
; 6631 :                                " in the same entity\n");
; 6632 : 	    }
; 6633 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4
$LN29@xmlParseCo:

; 6634 : 	}
; 6635 : 	if (xmlParserDebugEntities) {

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN31@xmlParseCo

; 6636 : 	    if ((ctxt->input != NULL) && (ctxt->input->filename))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN32@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN32@xmlParseCo

; 6637 : 		xmlGenericError(xmlGenericErrorContext,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN32@xmlParseCo:

; 6638 : 			"%s(%d): ", ctxt->input->filename,
; 6639 : 			ctxt->input->line);
; 6640 : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CG@FMCBAD@Entering?5INCLUDE?5Conditional?5Se@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN31@xmlParseCo:

; 6641 : 		    "Entering INCLUDE Conditional Section\n");
; 6642 : 	}
; 6643 : 
; 6644 :         SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 6645 :         GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN8@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN8@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN8@xmlParseCo:

; 6646 : 	while (((RAW != 0) && ((RAW != ']') || (NXT(1) != ']') ||
; 6647 : 	        (NXT(2) != '>'))) && (ctxt->instate != XML_PARSER_EOF)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN9@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN34@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 93					; 0000005dH
	jne	SHORT $LN34@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 62					; 0000003eH
	je	$LN9@xmlParseCo
$LN34@xmlParseCo:
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	je	$LN9@xmlParseCo

; 6648 : 	    const xmlChar *check = CUR_PTR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _check$5[ebp], edx

; 6649 : 	    unsigned int cons = ctxt->input->consumed;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _cons$4[ebp], edx

; 6650 : 
; 6651 : 	    if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN35@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 33					; 00000021H
	jne	SHORT $LN35@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 91					; 0000005bH
	jne	SHORT $LN35@xmlParseCo

; 6652 : 		xmlParseConditionalSections(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseConditionalSections
	add	esp, 4

; 6653 : 	    } else

	jmp	SHORT $LN36@xmlParseCo
$LN35@xmlParseCo:

; 6654 : 		xmlParseMarkupDecl(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseMarkupDecl
	add	esp, 4
$LN36@xmlParseCo:

; 6655 : 
; 6656 :             SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6657 :             GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN37@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN37@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN37@xmlParseCo:

; 6658 : 
; 6659 : 	    if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _check$5[ebp]
	jne	SHORT $LN38@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _cons$4[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jne	SHORT $LN38@xmlParseCo

; 6660 : 		xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);

	push	0
	push	60					; 0000003cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6661 : 		xmlHaltParser(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlHaltParser
	add	esp, 4

; 6662 : 		break;

	jmp	SHORT $LN9@xmlParseCo
$LN38@xmlParseCo:

; 6663 : 	    }
; 6664 : 	}

	jmp	$LN8@xmlParseCo
$LN9@xmlParseCo:

; 6665 : 	if (xmlParserDebugEntities) {

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN39@xmlParseCo

; 6666 : 	    if ((ctxt->input != NULL) && (ctxt->input->filename))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN40@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN40@xmlParseCo

; 6667 : 		xmlGenericError(xmlGenericErrorContext,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN40@xmlParseCo:

; 6668 : 			"%s(%d): ", ctxt->input->filename,
; 6669 : 			ctxt->input->line);
; 6670 : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CF@KBFPDCLM@Leaving?5INCLUDE?5Conditional?5Sec@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN39@xmlParseCo:

; 6671 : 		    "Leaving INCLUDE Conditional Section\n");
; 6672 : 	}

	jmp	$LN26@xmlParseCo
$LN25@xmlParseCo:

; 6673 : 
; 6674 :     } else if (CMP6(CUR_PTR, 'I', 'G', 'N', 'O', 'R', 'E')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	$LN41@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 71					; 00000047H
	jne	$LN41@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 78					; 0000004eH
	jne	$LN41@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 79					; 0000004fH
	jne	$LN41@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 82					; 00000052H
	jne	$LN41@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 69					; 00000045H
	jne	$LN41@xmlParseCo

; 6675 : 	int state;
; 6676 : 	xmlParserInputState instate;
; 6677 : 	int depth = 0;

	mov	DWORD PTR _depth$1[ebp], 0
$LN12@xmlParseCo:

; 6678 : 
; 6679 : 	SKIP(6);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 6
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 6
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 6
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN10@xmlParseCo
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN10@xmlParseCo:
	xor	ecx, ecx
	jne	SHORT $LN12@xmlParseCo

; 6680 : 	SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6681 : 	if (RAW != '[') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 91					; 0000005bH
	je	SHORT $LN44@xmlParseCo

; 6682 : 	    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);

	push	0
	push	83					; 00000053H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6683 : 	    xmlHaltParser(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlHaltParser
	add	esp, 4

; 6684 : 	    return;

	jmp	$LN1@xmlParseCo

; 6685 : 	} else {

	jmp	SHORT $LN45@xmlParseCo
$LN44@xmlParseCo:

; 6686 : 	    if (ctxt->input->id != id) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+56]
	cmp	edx, DWORD PTR _id$[ebp]
	je	SHORT $LN46@xmlParseCo

; 6687 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@
	push	90					; 0000005aH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN46@xmlParseCo:

; 6688 : 	                       "All markup of the conditional section is not"
; 6689 :                                " in the same entity\n");
; 6690 : 	    }
; 6691 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4
$LN45@xmlParseCo:

; 6692 : 	}
; 6693 : 	if (xmlParserDebugEntities) {

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN47@xmlParseCo

; 6694 : 	    if ((ctxt->input != NULL) && (ctxt->input->filename))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN48@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN48@xmlParseCo

; 6695 : 		xmlGenericError(xmlGenericErrorContext,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN48@xmlParseCo:

; 6696 : 			"%s(%d): ", ctxt->input->filename,
; 6697 : 			ctxt->input->line);
; 6698 : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CF@BNLECKJM@Entering?5IGNORE?5Conditional?5Sec@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN47@xmlParseCo:

; 6699 : 		    "Entering IGNORE Conditional Section\n");
; 6700 : 	}
; 6701 : 
; 6702 : 	/*
; 6703 : 	 * Parse up to the end of the conditional section
; 6704 : 	 * But disable SAX event generating DTD building in the meantime
; 6705 : 	 */
; 6706 : 	state = ctxt->disableSAX;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR _state$3[ebp], ecx

; 6707 : 	instate = ctxt->instate;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+172]
	mov	DWORD PTR _instate$2[ebp], eax

; 6708 : 	if (ctxt->recovery == 0) ctxt->disableSAX = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+288], 0
	jne	SHORT $LN49@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+212], 1
$LN49@xmlParseCo:

; 6709 : 	ctxt->instate = XML_PARSER_IGNORE;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 15			; 0000000fH
$LL13@xmlParseCo:

; 6710 : 
; 6711 : 	while (((depth >= 0) && (RAW != 0)) &&

	cmp	DWORD PTR _depth$1[ebp], 0
	jl	$LN14@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN14@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	je	$LN14@xmlParseCo

; 6712 :                (ctxt->instate != XML_PARSER_EOF)) {
; 6713 : 	  if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	$LN50@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 33					; 00000021H
	jne	$LN50@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 91					; 0000005bH
	jne	SHORT $LN50@xmlParseCo

; 6714 : 	    depth++;

	mov	edx, DWORD PTR _depth$1[ebp]
	add	edx, 1
	mov	DWORD PTR _depth$1[ebp], edx
$LL17@xmlParseCo:

; 6715 : 	    SKIP(3);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN15@xmlParseCo
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN15@xmlParseCo:
	xor	ecx, ecx
	jne	SHORT $LL17@xmlParseCo

; 6716 : 	    continue;

	jmp	$LL13@xmlParseCo
$LN50@xmlParseCo:

; 6717 : 	  }
; 6718 : 	  if ((RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 93					; 0000005dH
	jne	$LN52@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 93					; 0000005dH
	jne	$LN52@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN52@xmlParseCo

; 6719 : 	    if (--depth >= 0) SKIP(3);

	mov	ecx, DWORD PTR _depth$1[ebp]
	sub	ecx, 1
	mov	DWORD PTR _depth$1[ebp], ecx
	js	SHORT $LN53@xmlParseCo
$LL20@xmlParseCo:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN18@xmlParseCo
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN18@xmlParseCo:
	xor	eax, eax
	jne	SHORT $LL20@xmlParseCo
$LN53@xmlParseCo:

; 6720 : 	    continue;

	jmp	$LL13@xmlParseCo
$LN52@xmlParseCo:

; 6721 : 	  }
; 6722 : 	  NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 6723 : 	  continue;

	jmp	$LL13@xmlParseCo

; 6724 : 	}

	jmp	$LL13@xmlParseCo
$LN14@xmlParseCo:

; 6725 : 
; 6726 : 	ctxt->disableSAX = state;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _state$3[ebp]
	mov	DWORD PTR [edx+212], eax

; 6727 : 	ctxt->instate = instate;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _instate$2[ebp]
	mov	DWORD PTR [ecx+172], edx

; 6728 : 
; 6729 : 	if (xmlParserDebugEntities) {

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN55@xmlParseCo

; 6730 : 	    if ((ctxt->input != NULL) && (ctxt->input->filename))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN56@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN56@xmlParseCo

; 6731 : 		xmlGenericError(xmlGenericErrorContext,

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN56@xmlParseCo:

; 6732 : 			"%s(%d): ", ctxt->input->filename,
; 6733 : 			ctxt->input->line);
; 6734 : 	    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CE@MPDEOLDN@Leaving?5IGNORE?5Conditional?5Sect@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN55@xmlParseCo:

; 6735 : 		    "Leaving IGNORE Conditional Section\n");
; 6736 : 	}
; 6737 : 
; 6738 :     } else {

	jmp	SHORT $LN26@xmlParseCo
$LN41@xmlParseCo:

; 6739 : 	xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);

	push	0
	push	95					; 0000005fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6740 : 	xmlHaltParser(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlHaltParser
	add	esp, 4

; 6741 : 	return;

	jmp	$LN1@xmlParseCo
$LN26@xmlParseCo:

; 6742 :     }
; 6743 : 
; 6744 :     if (RAW == 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN57@xmlParseCo

; 6745 :         SHRINK;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN57@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN57@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 500				; 000001f4H
	jge	SHORT $LN57@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSHRINK
	add	esp, 4
$LN57@xmlParseCo:

; 6746 : 
; 6747 :     if (RAW == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN59@xmlParseCo

; 6748 : 	xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);

	push	0
	push	59					; 0000003bH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6749 :     } else {

	jmp	$LN1@xmlParseCo
$LN59@xmlParseCo:

; 6750 : 	if (ctxt->input->id != id) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+56]
	cmp	edx, DWORD PTR _id$[ebp]
	je	SHORT $LN61@xmlParseCo

; 6751 : 	    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EB@LPINKGGA@All?5markup?5of?5the?5conditional?5s@
	push	90					; 0000005aH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN61@xmlParseCo:

; 6752 : 	                   "All markup of the conditional section is not in"
; 6753 :                            " the same entity\n");
; 6754 : 	}
; 6755 : 	if ((ctxt-> instate != XML_PARSER_EOF) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	je	SHORT $LN1@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	ecx, DWORD PTR [eax+20]
	ja	SHORT $LN1@xmlParseCo
$LL23@xmlParseCo:

; 6756 : 	    ((ctxt->input->cur + 3) <= ctxt->input->end))
; 6757 : 	    SKIP(3);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN21@xmlParseCo
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN21@xmlParseCo:
	xor	edx, edx
	jne	SHORT $LL23@xmlParseCo
$LN1@xmlParseCo:

; 6758 :     }
; 6759 : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseConditionalSections ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElementChildrenContentDeclPriv
_TEXT	SEGMENT
_found$1 = -36						; size = 4
_inputid$2 = -32					; size = 4
_inputid$3 = -28					; size = 4
_type$ = -21						; size = 1
_elem$ = -20						; size = 4
_op$ = -16						; size = 4
_last$ = -12						; size = 4
_cur$ = -8						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_inputchk$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlParseElementChildrenContentDeclPriv PROC		; COMDAT

; 6150 :                                        int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 6151 :     xmlElementContentPtr ret = NULL, cur = NULL, last = NULL, op = NULL;

	mov	DWORD PTR _ret$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _last$[ebp], 0
	mov	DWORD PTR _op$[ebp], 0

; 6152 :     const xmlChar *elem;
; 6153 :     xmlChar type = 0;

	mov	BYTE PTR _type$[ebp], 0

; 6154 : 
; 6155 :     if (((depth > 128) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||

	cmp	DWORD PTR _depth$[ebp], 128		; 00000080H
	jle	SHORT $LN10@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	je	SHORT $LN9@xmlParseEl
$LN10@xmlParseEl:
	cmp	DWORD PTR _depth$[ebp], 2048		; 00000800H
	jle	SHORT $LN8@xmlParseEl
$LN9@xmlParseEl:

; 6156 :         (depth >  2048)) {
; 6157 :         xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,

	mov	edx, DWORD PTR _depth$[ebp]
	push	edx
	push	OFFSET ??_C@_0EM@OINCFINP@xmlParseElementChildrenContentD@
	push	55					; 00000037H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 6158 : "xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n",
; 6159 :                           depth);
; 6160 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN8@xmlParseEl:

; 6161 :     }
; 6162 :     SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6163 :     GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN11@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN11@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN11@xmlParseEl:

; 6164 :     if (RAW == '(') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	jne	$LN12@xmlParseEl

; 6165 : 	int inputid = ctxt->input->id;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR _inputid$3[ebp], eax

; 6166 : 
; 6167 :         /* Recurse on first child */
; 6168 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 6169 : 	SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6170 :         cur = ret = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,

	mov	eax, DWORD PTR _depth$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _inputid$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseElementChildrenContentDeclPriv
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 6171 :                                                            depth + 1);
; 6172 : 	SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6173 : 	GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN14@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN14@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN14@xmlParseEl:

; 6174 :     } else {

	jmp	$LN13@xmlParseEl
$LN12@xmlParseEl:

; 6175 : 	elem = xmlParseName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _elem$[ebp], eax

; 6176 : 	if (elem == NULL) {

	cmp	DWORD PTR _elem$[ebp], 0
	jne	SHORT $LN15@xmlParseEl

; 6177 : 	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);

	push	0
	push	54					; 00000036H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6178 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN15@xmlParseEl:

; 6179 : 	}
; 6180 :         cur = ret = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);

	push	2
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 6181 : 	if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN16@xmlParseEl

; 6182 : 	    xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 6183 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN16@xmlParseEl:

; 6184 : 	}
; 6185 : 	GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN17@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN17@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN17@xmlParseEl:

; 6186 : 	if (RAW == '?') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN18@xmlParseEl

; 6187 : 	    cur->ocur = XML_ELEMENT_CONTENT_OPT;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4], 2

; 6188 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4
	jmp	SHORT $LN19@xmlParseEl
$LN18@xmlParseEl:

; 6189 : 	} else if (RAW == '*') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	jne	SHORT $LN20@xmlParseEl

; 6190 : 	    cur->ocur = XML_ELEMENT_CONTENT_MULT;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4], 3

; 6191 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4
	jmp	SHORT $LN19@xmlParseEl
$LN20@xmlParseEl:

; 6192 : 	} else if (RAW == '+') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN22@xmlParseEl

; 6193 : 	    cur->ocur = XML_ELEMENT_CONTENT_PLUS;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4], 4

; 6194 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 6195 : 	} else {

	jmp	SHORT $LN19@xmlParseEl
$LN22@xmlParseEl:

; 6196 : 	    cur->ocur = XML_ELEMENT_CONTENT_ONCE;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+4], 1
$LN19@xmlParseEl:

; 6197 : 	}
; 6198 : 	GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN13@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN13@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN13@xmlParseEl:

; 6199 :     }
; 6200 :     SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6201 :     SHRINK;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN2@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	cmp	ecx, 500				; 000001f4H
	jle	SHORT $LN2@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN2@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSHRINK
	add	esp, 4
$LN2@xmlParseEl:

; 6202 :     while ((RAW != ')') && (ctxt->instate != XML_PARSER_EOF)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	je	$LN3@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	je	$LN3@xmlParseEl

; 6203 :         /*
; 6204 : 	 * Each loop we parse one separator and one element.
; 6205 : 	 */
; 6206 :         if (RAW == ',') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	jne	$LN26@xmlParseEl

; 6207 : 	    if (type == 0) type = CUR;

	movzx	edx, BYTE PTR _type$[ebp]
	test	edx, edx
	jne	SHORT $LN28@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _type$[ebp], al
	jmp	SHORT $LN29@xmlParseEl
$LN28@xmlParseEl:

; 6208 : 
; 6209 : 	    /*
; 6210 : 	     * Detect "Name | Name , Name" error
; 6211 : 	     */
; 6212 : 	    else if (type != CUR) {

	movzx	ecx, BYTE PTR _type$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	je	SHORT $LN29@xmlParseEl

; 6213 : 		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,

	movzx	ecx, BYTE PTR _type$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DE@IJONAOBP@xmlParseElementChildrenContentD@
	push	66					; 00000042H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 6214 : 		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
; 6215 : 		                  type);
; 6216 : 		if ((last != NULL) && (last != ret))

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN31@xmlParseEl
	mov	eax, DWORD PTR _last$[ebp]
	cmp	eax, DWORD PTR _ret$[ebp]
	je	SHORT $LN31@xmlParseEl

; 6217 : 		    xmlFreeDocElementContent(ctxt->myDoc, last);

	mov	ecx, DWORD PTR _last$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN31@xmlParseEl:

; 6218 : 		if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN32@xmlParseEl

; 6219 : 		    xmlFreeDocElementContent(ctxt->myDoc, ret);

	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN32@xmlParseEl:

; 6220 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN29@xmlParseEl:

; 6221 : 	    }
; 6222 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 6223 : 
; 6224 : 	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);

	push	3
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _op$[ebp], eax

; 6225 : 	    if (op == NULL) {

	cmp	DWORD PTR _op$[ebp], 0
	jne	SHORT $LN33@xmlParseEl

; 6226 : 		if ((last != NULL) && (last != ret))

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN34@xmlParseEl
	mov	ecx, DWORD PTR _last$[ebp]
	cmp	ecx, DWORD PTR _ret$[ebp]
	je	SHORT $LN34@xmlParseEl

; 6227 : 		    xmlFreeDocElementContent(ctxt->myDoc, last);

	mov	edx, DWORD PTR _last$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN34@xmlParseEl:

; 6228 : 	        xmlFreeDocElementContent(ctxt->myDoc, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8

; 6229 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN33@xmlParseEl:

; 6230 : 	    }
; 6231 : 	    if (last == NULL) {

	cmp	DWORD PTR _last$[ebp], 0
	jne	SHORT $LN35@xmlParseEl

; 6232 : 		op->c1 = ret;

	mov	edx, DWORD PTR _op$[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+12], eax

; 6233 : 		if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN37@xmlParseEl

; 6234 : 		    ret->parent = op;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _op$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN37@xmlParseEl:

; 6235 : 		ret = cur = op;

	mov	eax, DWORD PTR _op$[ebp]
	mov	DWORD PTR _cur$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx

; 6236 : 	    } else {

	jmp	SHORT $LN36@xmlParseEl
$LN35@xmlParseEl:

; 6237 : 	        cur->c2 = op;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _op$[ebp]
	mov	DWORD PTR [edx+16], eax

; 6238 : 		if (op != NULL)

	cmp	DWORD PTR _op$[ebp], 0
	je	SHORT $LN38@xmlParseEl

; 6239 : 		    op->parent = cur;

	mov	ecx, DWORD PTR _op$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN38@xmlParseEl:

; 6240 : 		op->c1 = last;

	mov	eax, DWORD PTR _op$[ebp]
	mov	ecx, DWORD PTR _last$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 6241 : 		if (last != NULL)

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN39@xmlParseEl

; 6242 : 		    last->parent = op;

	mov	edx, DWORD PTR _last$[ebp]
	mov	eax, DWORD PTR _op$[ebp]
	mov	DWORD PTR [edx+20], eax
$LN39@xmlParseEl:

; 6243 : 		cur =op;

	mov	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 6244 : 		last = NULL;

	mov	DWORD PTR _last$[ebp], 0
$LN36@xmlParseEl:

; 6245 : 	    }

	jmp	$LN27@xmlParseEl
$LN26@xmlParseEl:

; 6246 : 	} else if (RAW == '|') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 124				; 0000007cH
	jne	$LN40@xmlParseEl

; 6247 : 	    if (type == 0) type = CUR;

	movzx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	jne	SHORT $LN42@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _type$[ebp], cl
	jmp	SHORT $LN43@xmlParseEl
$LN42@xmlParseEl:

; 6248 : 
; 6249 : 	    /*
; 6250 : 	     * Detect "Name , Name | Name" error
; 6251 : 	     */
; 6252 : 	    else if (type != CUR) {

	movzx	edx, BYTE PTR _type$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	je	SHORT $LN43@xmlParseEl

; 6253 : 		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,

	movzx	edx, BYTE PTR _type$[ebp]
	push	edx
	push	OFFSET ??_C@_0DE@IJONAOBP@xmlParseElementChildrenContentD@
	push	66					; 00000042H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 6254 : 		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
; 6255 : 				  type);
; 6256 : 		if ((last != NULL) && (last != ret))

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN45@xmlParseEl
	mov	ecx, DWORD PTR _last$[ebp]
	cmp	ecx, DWORD PTR _ret$[ebp]
	je	SHORT $LN45@xmlParseEl

; 6257 : 		    xmlFreeDocElementContent(ctxt->myDoc, last);

	mov	edx, DWORD PTR _last$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN45@xmlParseEl:

; 6258 : 		if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN46@xmlParseEl

; 6259 : 		    xmlFreeDocElementContent(ctxt->myDoc, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN46@xmlParseEl:

; 6260 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN43@xmlParseEl:

; 6261 : 	    }
; 6262 : 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 6263 : 
; 6264 : 	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);

	push	4
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _op$[ebp], eax

; 6265 : 	    if (op == NULL) {

	cmp	DWORD PTR _op$[ebp], 0
	jne	SHORT $LN47@xmlParseEl

; 6266 : 		if ((last != NULL) && (last != ret))

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN48@xmlParseEl
	mov	edx, DWORD PTR _last$[ebp]
	cmp	edx, DWORD PTR _ret$[ebp]
	je	SHORT $LN48@xmlParseEl

; 6267 : 		    xmlFreeDocElementContent(ctxt->myDoc, last);

	mov	eax, DWORD PTR _last$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN48@xmlParseEl:

; 6268 : 		if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN49@xmlParseEl

; 6269 : 		    xmlFreeDocElementContent(ctxt->myDoc, ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN49@xmlParseEl:

; 6270 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN47@xmlParseEl:

; 6271 : 	    }
; 6272 : 	    if (last == NULL) {

	cmp	DWORD PTR _last$[ebp], 0
	jne	SHORT $LN50@xmlParseEl

; 6273 : 		op->c1 = ret;

	mov	eax, DWORD PTR _op$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 6274 : 		if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN52@xmlParseEl

; 6275 : 		    ret->parent = op;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _op$[ebp]
	mov	DWORD PTR [edx+20], eax
$LN52@xmlParseEl:

; 6276 : 		ret = cur = op;

	mov	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _ret$[ebp], edx

; 6277 : 	    } else {

	jmp	SHORT $LN51@xmlParseEl
$LN50@xmlParseEl:

; 6278 : 	        cur->c2 = op;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 6279 : 		if (op != NULL)

	cmp	DWORD PTR _op$[ebp], 0
	je	SHORT $LN53@xmlParseEl

; 6280 : 		    op->parent = cur;

	mov	edx, DWORD PTR _op$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+20], eax
$LN53@xmlParseEl:

; 6281 : 		op->c1 = last;

	mov	ecx, DWORD PTR _op$[ebp]
	mov	edx, DWORD PTR _last$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 6282 : 		if (last != NULL)

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN54@xmlParseEl

; 6283 : 		    last->parent = op;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN54@xmlParseEl:

; 6284 : 		cur =op;

	mov	edx, DWORD PTR _op$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 6285 : 		last = NULL;

	mov	DWORD PTR _last$[ebp], 0
$LN51@xmlParseEl:

; 6286 : 	    }
; 6287 : 	} else {

	jmp	SHORT $LN27@xmlParseEl
$LN40@xmlParseEl:

; 6288 : 	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);

	push	0
	push	55					; 00000037H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6289 : 	    if ((last != NULL) && (last != ret))

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN55@xmlParseEl
	mov	ecx, DWORD PTR _last$[ebp]
	cmp	ecx, DWORD PTR _ret$[ebp]
	je	SHORT $LN55@xmlParseEl

; 6290 : 	        xmlFreeDocElementContent(ctxt->myDoc, last);

	mov	edx, DWORD PTR _last$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN55@xmlParseEl:

; 6291 : 	    if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN56@xmlParseEl

; 6292 : 		xmlFreeDocElementContent(ctxt->myDoc, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN56@xmlParseEl:

; 6293 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN27@xmlParseEl:

; 6294 : 	}
; 6295 : 	GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN57@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN57@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN57@xmlParseEl:

; 6296 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 6297 : 	GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN58@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN58@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN58@xmlParseEl:

; 6298 : 	if (RAW == '(') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 40					; 00000028H
	jne	SHORT $LN59@xmlParseEl

; 6299 : 	    int inputid = ctxt->input->id;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _inputid$2[ebp], edx

; 6300 : 	    /* Recurse on second child */
; 6301 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 6302 : 	    SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6303 : 	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,

	mov	edx, DWORD PTR _depth$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _inputid$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseElementChildrenContentDeclPriv
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _last$[ebp], eax

; 6304 :                                                           depth + 1);
; 6305 : 	    SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6306 : 	} else {

	jmp	$LN60@xmlParseEl
$LN59@xmlParseEl:

; 6307 : 	    elem = xmlParseName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _elem$[ebp], eax

; 6308 : 	    if (elem == NULL) {

	cmp	DWORD PTR _elem$[ebp], 0
	jne	SHORT $LN61@xmlParseEl

; 6309 : 		xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);

	push	0
	push	54					; 00000036H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6310 : 		if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN62@xmlParseEl

; 6311 : 		    xmlFreeDocElementContent(ctxt->myDoc, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN62@xmlParseEl:

; 6312 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN61@xmlParseEl:

; 6313 : 	    }
; 6314 : 	    last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);

	push	2
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _last$[ebp], eax

; 6315 : 	    if (last == NULL) {

	cmp	DWORD PTR _last$[ebp], 0
	jne	SHORT $LN63@xmlParseEl

; 6316 : 		if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN64@xmlParseEl

; 6317 : 		    xmlFreeDocElementContent(ctxt->myDoc, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN64@xmlParseEl:

; 6318 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN63@xmlParseEl:

; 6319 : 	    }
; 6320 : 	    if (RAW == '?') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN65@xmlParseEl

; 6321 : 		last->ocur = XML_ELEMENT_CONTENT_OPT;

	mov	eax, DWORD PTR _last$[ebp]
	mov	DWORD PTR [eax+4], 2

; 6322 : 		NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4
	jmp	SHORT $LN60@xmlParseEl
$LN65@xmlParseEl:

; 6323 : 	    } else if (RAW == '*') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	jne	SHORT $LN67@xmlParseEl

; 6324 : 		last->ocur = XML_ELEMENT_CONTENT_MULT;

	mov	eax, DWORD PTR _last$[ebp]
	mov	DWORD PTR [eax+4], 3

; 6325 : 		NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4
	jmp	SHORT $LN60@xmlParseEl
$LN67@xmlParseEl:

; 6326 : 	    } else if (RAW == '+') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN69@xmlParseEl

; 6327 : 		last->ocur = XML_ELEMENT_CONTENT_PLUS;

	mov	eax, DWORD PTR _last$[ebp]
	mov	DWORD PTR [eax+4], 4

; 6328 : 		NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 6329 : 	    } else {

	jmp	SHORT $LN60@xmlParseEl
$LN69@xmlParseEl:

; 6330 : 		last->ocur = XML_ELEMENT_CONTENT_ONCE;

	mov	edx, DWORD PTR _last$[ebp]
	mov	DWORD PTR [edx+4], 1
$LN60@xmlParseEl:

; 6331 : 	    }
; 6332 : 	}
; 6333 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 6334 : 	GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN71@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN71@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN71@xmlParseEl:

; 6335 :     }

	jmp	$LN2@xmlParseEl
$LN3@xmlParseEl:

; 6336 :     if ((cur != NULL) && (last != NULL)) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN72@xmlParseEl
	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN72@xmlParseEl

; 6337 :         cur->c2 = last;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _last$[ebp]
	mov	DWORD PTR [edx+16], eax

; 6338 : 	if (last != NULL)

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN72@xmlParseEl

; 6339 : 	    last->parent = cur;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN72@xmlParseEl:

; 6340 :     }
; 6341 :     if (ctxt->input->id != inputchk) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+56]
	cmp	edx, DWORD PTR _inputchk$[ebp]
	je	SHORT $LN74@xmlParseEl

; 6342 : 	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@
	push	90					; 0000005aH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN74@xmlParseEl:

; 6343 :                        "Element content declaration doesn't start and stop in"
; 6344 :                        " the same entity\n");
; 6345 :     }
; 6346 :     NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 6347 :     if (RAW == '?') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN75@xmlParseEl

; 6348 : 	if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN77@xmlParseEl

; 6349 : 	    if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||

	mov	eax, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [eax+4], 4
	je	SHORT $LN80@xmlParseEl
	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN78@xmlParseEl
$LN80@xmlParseEl:

; 6350 : 	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
; 6351 : 	        ret->ocur = XML_ELEMENT_CONTENT_MULT;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+4], 3
	jmp	SHORT $LN77@xmlParseEl
$LN78@xmlParseEl:

; 6352 : 	    else
; 6353 : 	        ret->ocur = XML_ELEMENT_CONTENT_OPT;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+4], 2
$LN77@xmlParseEl:

; 6354 : 	}
; 6355 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4
	jmp	$LN76@xmlParseEl
$LN75@xmlParseEl:

; 6356 :     } else if (RAW == '*') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	jne	$LN81@xmlParseEl

; 6357 : 	if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	$LN83@xmlParseEl

; 6358 : 	    ret->ocur = XML_ELEMENT_CONTENT_MULT;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+4], 3

; 6359 : 	    cur = ret;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@xmlParseEl:

; 6360 : 	    /*
; 6361 : 	     * Some normalization:
; 6362 : 	     * (a | b* | c?)* == (a | b | c)*
; 6363 : 	     */
; 6364 : 	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN83@xmlParseEl
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx], 4
	jne	SHORT $LN83@xmlParseEl

; 6365 : 		if ((cur->c1 != NULL) &&

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN84@xmlParseEl
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	DWORD PTR [edx+4], 2
	je	SHORT $LN85@xmlParseEl
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN84@xmlParseEl
$LN85@xmlParseEl:

; 6366 : 	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
; 6367 : 		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))
; 6368 : 		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+4], 1
$LN84@xmlParseEl:

; 6369 : 		if ((cur->c2 != NULL) &&

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN86@xmlParseEl
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+4], 2
	je	SHORT $LN87@xmlParseEl
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [edx+4], 3
	jne	SHORT $LN86@xmlParseEl
$LN87@xmlParseEl:

; 6370 : 	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
; 6371 : 		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))
; 6372 : 		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], 1
$LN86@xmlParseEl:

; 6373 : 		cur = cur->c2;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _cur$[ebp], eax

; 6374 : 	    }

	jmp	SHORT $LN4@xmlParseEl
$LN83@xmlParseEl:

; 6375 : 	}
; 6376 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4
	jmp	$LN76@xmlParseEl
$LN81@xmlParseEl:

; 6377 :     } else if (RAW == '+') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	jne	$LN76@xmlParseEl

; 6378 : 	if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	$LN89@xmlParseEl

; 6379 : 	    int found = 0;

	mov	DWORD PTR _found$1[ebp], 0

; 6380 : 
; 6381 : 	    if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||

	mov	eax, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [eax+4], 2
	je	SHORT $LN92@xmlParseEl
	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN90@xmlParseEl
$LN92@xmlParseEl:

; 6382 : 	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
; 6383 : 	        ret->ocur = XML_ELEMENT_CONTENT_MULT;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+4], 3
	jmp	SHORT $LN6@xmlParseEl
$LN90@xmlParseEl:

; 6384 : 	    else
; 6385 : 	        ret->ocur = XML_ELEMENT_CONTENT_PLUS;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+4], 4
$LN6@xmlParseEl:

; 6386 : 	    /*
; 6387 : 	     * Some normalization:
; 6388 : 	     * (a | b*)+ == (a | b)*
; 6389 : 	     * (a | b?)+ == (a | b)*
; 6390 : 	     */
; 6391 : 	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN7@xmlParseEl
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx], 4
	jne	SHORT $LN7@xmlParseEl

; 6392 : 		if ((cur->c1 != NULL) &&

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN93@xmlParseEl
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx+4], 2
	je	SHORT $LN94@xmlParseEl
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN93@xmlParseEl
$LN94@xmlParseEl:

; 6393 : 	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
; 6394 : 		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {
; 6395 : 		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+4], 1

; 6396 : 		    found = 1;

	mov	DWORD PTR _found$1[ebp], 1
$LN93@xmlParseEl:

; 6397 : 		}
; 6398 : 		if ((cur->c2 != NULL) &&

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN95@xmlParseEl
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [edx+4], 2
	je	SHORT $LN96@xmlParseEl
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN95@xmlParseEl
$LN96@xmlParseEl:

; 6399 : 	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
; 6400 : 		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {
; 6401 : 		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+4], 1

; 6402 : 		    found = 1;

	mov	DWORD PTR _found$1[ebp], 1
$LN95@xmlParseEl:

; 6403 : 		}
; 6404 : 		cur = cur->c2;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _cur$[ebp], edx

; 6405 : 	    }

	jmp	$LN6@xmlParseEl
$LN7@xmlParseEl:

; 6406 : 	    if (found)

	cmp	DWORD PTR _found$1[ebp], 0
	je	SHORT $LN89@xmlParseEl

; 6407 : 		ret->ocur = XML_ELEMENT_CONTENT_MULT;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+4], 3
$LN89@xmlParseEl:

; 6408 : 	}
; 6409 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4
$LN76@xmlParseEl:

; 6410 :     }
; 6411 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseEl:

; 6412 : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseElementChildrenContentDeclPriv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCatalogPI
_TEXT	SEGMENT
_marker$ = -13						; size = 1
_base$ = -12						; size = 4
_tmp$ = -8						; size = 4
_URL$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_catalog$ = 12						; size = 4
_xmlParseCatalogPI PROC					; COMDAT

; 5037 : xmlParseCatalogPI(xmlParserCtxtPtr ctxt, const xmlChar *catalog) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 5038 :     xmlChar *URL = NULL;

	mov	DWORD PTR _URL$[ebp], 0

; 5039 :     const xmlChar *tmp, *base;
; 5040 :     xmlChar marker;
; 5041 : 
; 5042 :     tmp = catalog;

	mov	eax, DWORD PTR _catalog$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax
$LN2@xmlParseCa:

; 5043 :     while (IS_BLANK_CH(*tmp)) tmp++;

	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN12@xmlParseCa
	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN13@xmlParseCa
	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN12@xmlParseCa
$LN13@xmlParseCa:
	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@xmlParseCa
$LN12@xmlParseCa:
	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$[ebp], eax
	jmp	SHORT $LN2@xmlParseCa
$LN3@xmlParseCa:

; 5044 :     if (xmlStrncmp(tmp, BAD_CAST"catalog", 7))

	push	7
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@xmlParseCa

; 5045 : 	goto error;

	jmp	$error$28
$LN14@xmlParseCa:

; 5046 :     tmp += 7;

	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 7
	mov	DWORD PTR _tmp$[ebp], edx
$LN4@xmlParseCa:

; 5047 :     while (IS_BLANK_CH(*tmp)) tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN15@xmlParseCa
	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN16@xmlParseCa
	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN15@xmlParseCa
$LN16@xmlParseCa:
	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN5@xmlParseCa
$LN15@xmlParseCa:
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx
	jmp	SHORT $LN4@xmlParseCa
$LN5@xmlParseCa:

; 5048 :     if (*tmp != '=') {

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $LN17@xmlParseCa

; 5049 : 	return;

	jmp	$LN1@xmlParseCa
$LN17@xmlParseCa:

; 5050 :     }
; 5051 :     tmp++;

	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx
$LN6@xmlParseCa:

; 5052 :     while (IS_BLANK_CH(*tmp)) tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN18@xmlParseCa
	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN19@xmlParseCa
	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN18@xmlParseCa
$LN19@xmlParseCa:
	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN7@xmlParseCa
$LN18@xmlParseCa:
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx
	jmp	SHORT $LN6@xmlParseCa
$LN7@xmlParseCa:

; 5053 :     marker = *tmp;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _marker$[ebp], cl

; 5054 :     if ((marker != '\'') && (marker != '"'))

	movzx	edx, BYTE PTR _marker$[ebp]
	cmp	edx, 39					; 00000027H
	je	SHORT $LN20@xmlParseCa
	movzx	eax, BYTE PTR _marker$[ebp]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN20@xmlParseCa

; 5055 : 	goto error;

	jmp	$error$28
$LN20@xmlParseCa:

; 5056 :     tmp++;

	mov	ecx, DWORD PTR _tmp$[ebp]
	add	ecx, 1
	mov	DWORD PTR _tmp$[ebp], ecx

; 5057 :     base = tmp;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _base$[ebp], edx
$LN8@xmlParseCa:

; 5058 :     while ((*tmp != 0) && (*tmp != marker)) tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN9@xmlParseCa
	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _marker$[ebp]
	cmp	eax, ecx
	je	SHORT $LN9@xmlParseCa
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx
	jmp	SHORT $LN8@xmlParseCa
$LN9@xmlParseCa:

; 5059 :     if (*tmp == 0)

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN21@xmlParseCa

; 5060 : 	goto error;

	jmp	$error$28
$LN21@xmlParseCa:

; 5061 :     URL = xmlStrndup(base, tmp - base);

	mov	edx, DWORD PTR _tmp$[ebp]
	sub	edx, DWORD PTR _base$[ebp]
	push	edx
	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _URL$[ebp], eax

; 5062 :     tmp++;

	mov	ecx, DWORD PTR _tmp$[ebp]
	add	ecx, 1
	mov	DWORD PTR _tmp$[ebp], ecx
$LN10@xmlParseCa:

; 5063 :     while (IS_BLANK_CH(*tmp)) tmp++;

	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN22@xmlParseCa
	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN23@xmlParseCa
	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN22@xmlParseCa
$LN23@xmlParseCa:
	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN11@xmlParseCa
$LN22@xmlParseCa:
	mov	ecx, DWORD PTR _tmp$[ebp]
	add	ecx, 1
	mov	DWORD PTR _tmp$[ebp], ecx
	jmp	SHORT $LN10@xmlParseCa
$LN11@xmlParseCa:

; 5064 :     if (*tmp != 0)

	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN24@xmlParseCa

; 5065 : 	goto error;

	jmp	SHORT $error$28
$LN24@xmlParseCa:

; 5066 : 
; 5067 :     if (URL != NULL) {

	cmp	DWORD PTR _URL$[ebp], 0
	je	SHORT $LN25@xmlParseCa

; 5068 : 	ctxt->catalogs = xmlCatalogAddLocal(ctxt->catalogs, URL);

	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+284]
	push	eax
	call	_xmlCatalogAddLocal
	add	esp, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+284], eax

; 5069 : 	xmlFree(URL);

	mov	esi, esp
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN25@xmlParseCa:

; 5070 :     }
; 5071 :     return;

	jmp	SHORT $LN1@xmlParseCa
$error$28:

; 5072 : 
; 5073 : error:
; 5074 :     xmlWarningMsg(ctxt, XML_WAR_CATALOG_PI,

	push	0
	mov	eax, DWORD PTR _catalog$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@MALFACIE@Catalog?5PI?5syntax?5error?3?5?$CFs?6@
	push	93					; 0000005dH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H

; 5075 : 	          "Catalog PI syntax error: %s\n",
; 5076 : 		  catalog, NULL);
; 5077 :     if (URL != NULL)

	cmp	DWORD PTR _URL$[ebp], 0
	je	SHORT $LN1@xmlParseCa

; 5078 : 	xmlFree(URL);

	mov	esi, esp
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlParseCa:

; 5079 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCatalogPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCommentComplex
_TEXT	SEGMENT
tv361 = -112						; size = 4
tv363 = -108						; size = 4
tv362 = -104						; size = 4
tv230 = -100						; size = 4
tv232 = -96						; size = 4
tv231 = -92						; size = 4
tv179 = -88						; size = 4
tv181 = -84						; size = 4
tv180 = -80						; size = 4
tv128 = -76						; size = 4
tv130 = -72						; size = 4
tv129 = -68						; size = 4
_new_size$1 = -64					; size = 4
_new_buf$2 = -60					; size = 4
_inputid$ = -56						; size = 4
_count$ = -52						; size = 4
_l$ = -44						; size = 4
_cur$ = -36						; size = 4
_rl$ = -28						; size = 4
_r$ = -20						; size = 4
_ql$ = -12						; size = 4
_q$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_size$ = 20						; size = 4
_xmlParseCommentComplex PROC				; COMDAT

; 4681 :                        size_t len, size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 4682 :     int q, ql;
; 4683 :     int r, rl;
; 4684 :     int cur, l;
; 4685 :     size_t count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 4686 :     int inputid;
; 4687 : 
; 4688 :     inputid = ctxt->input->id;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _inputid$[ebp], edx

; 4689 : 
; 4690 :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN13@xmlParseCo

; 4691 :         len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 4692 : 	size = XML_PARSER_BUFFER_SIZE;

	mov	DWORD PTR _size$[ebp], 100		; 00000064H

; 4693 : 	buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$[ebp], eax

; 4694 : 	if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN13@xmlParseCo

; 4695 : 	    xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 4696 : 	    return;

	jmp	$LN1@xmlParseCo
$LN13@xmlParseCo:

; 4697 : 	}
; 4698 :     }
; 4699 :     GROW;	/* Assure there's enough input data */

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN15@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN15@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN15@xmlParseCo:

; 4700 :     q = CUR_CHAR(ql);

	lea	eax, DWORD PTR _ql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _q$[ebp], eax

; 4701 :     if (q == 0)

	cmp	DWORD PTR _q$[ebp], 0
	jne	SHORT $LN16@xmlParseCo

; 4702 :         goto not_terminated;

	jmp	$not_terminated$92
$LN16@xmlParseCo:

; 4703 :     if (!IS_CHAR(q)) {

	cmp	DWORD PTR _q$[ebp], 256			; 00000100H
	jge	SHORT $LN55@xmlParseCo
	cmp	DWORD PTR _q$[ebp], 9
	jl	SHORT $LN47@xmlParseCo
	cmp	DWORD PTR _q$[ebp], 10			; 0000000aH
	jle	SHORT $LN48@xmlParseCo
$LN47@xmlParseCo:
	cmp	DWORD PTR _q$[ebp], 13			; 0000000dH
	je	SHORT $LN48@xmlParseCo
	cmp	DWORD PTR _q$[ebp], 32			; 00000020H
	jge	SHORT $LN48@xmlParseCo
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN54@xmlParseCo
$LN48@xmlParseCo:
	mov	DWORD PTR tv129[ebp], 1
$LN54@xmlParseCo:
	mov	edx, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv130[ebp], edx
	jmp	SHORT $LN56@xmlParseCo
$LN55@xmlParseCo:
	cmp	DWORD PTR _q$[ebp], 256			; 00000100H
	jl	SHORT $LN49@xmlParseCo
	cmp	DWORD PTR _q$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN51@xmlParseCo
$LN49@xmlParseCo:
	cmp	DWORD PTR _q$[ebp], 57344		; 0000e000H
	jl	SHORT $LN50@xmlParseCo
	cmp	DWORD PTR _q$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN51@xmlParseCo
$LN50@xmlParseCo:
	cmp	DWORD PTR _q$[ebp], 65536		; 00010000H
	jl	SHORT $LN52@xmlParseCo
	cmp	DWORD PTR _q$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN51@xmlParseCo
$LN52@xmlParseCo:
	mov	DWORD PTR tv128[ebp], 0
	jmp	SHORT $LN53@xmlParseCo
$LN51@xmlParseCo:
	mov	DWORD PTR tv128[ebp], 1
$LN53@xmlParseCo:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR tv130[ebp], eax
$LN56@xmlParseCo:
	cmp	DWORD PTR tv130[ebp], 0
	jne	SHORT $LN4@xmlParseCo

; 4704 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@
	push	9
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 4705 :                           "xmlParseComment: invalid xmlChar value %d\n",
; 4706 : 	                  q);
; 4707 : 	xmlFree (buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4708 : 	return;

	jmp	$LN1@xmlParseCo
$LN4@xmlParseCo:

; 4709 :     }
; 4710 :     NEXTL(ql);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN18@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], 1
	jmp	SHORT $LN19@xmlParseCo
$LN18@xmlParseCo:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
$LN19@xmlParseCo:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _ql$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseCo

; 4711 :     r = CUR_CHAR(rl);

	lea	edx, DWORD PTR _rl$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _r$[ebp], eax

; 4712 :     if (r == 0)

	cmp	DWORD PTR _r$[ebp], 0
	jne	SHORT $LN20@xmlParseCo

; 4713 :         goto not_terminated;

	jmp	$not_terminated$92
$LN20@xmlParseCo:

; 4714 :     if (!IS_CHAR(r)) {

	cmp	DWORD PTR _r$[ebp], 256			; 00000100H
	jge	SHORT $LN65@xmlParseCo
	cmp	DWORD PTR _r$[ebp], 9
	jl	SHORT $LN57@xmlParseCo
	cmp	DWORD PTR _r$[ebp], 10			; 0000000aH
	jle	SHORT $LN58@xmlParseCo
$LN57@xmlParseCo:
	cmp	DWORD PTR _r$[ebp], 13			; 0000000dH
	je	SHORT $LN58@xmlParseCo
	cmp	DWORD PTR _r$[ebp], 32			; 00000020H
	jge	SHORT $LN58@xmlParseCo
	mov	DWORD PTR tv180[ebp], 0
	jmp	SHORT $LN64@xmlParseCo
$LN58@xmlParseCo:
	mov	DWORD PTR tv180[ebp], 1
$LN64@xmlParseCo:
	mov	ecx, DWORD PTR tv180[ebp]
	mov	DWORD PTR tv181[ebp], ecx
	jmp	SHORT $LN66@xmlParseCo
$LN65@xmlParseCo:
	cmp	DWORD PTR _r$[ebp], 256			; 00000100H
	jl	SHORT $LN59@xmlParseCo
	cmp	DWORD PTR _r$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN61@xmlParseCo
$LN59@xmlParseCo:
	cmp	DWORD PTR _r$[ebp], 57344		; 0000e000H
	jl	SHORT $LN60@xmlParseCo
	cmp	DWORD PTR _r$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN61@xmlParseCo
$LN60@xmlParseCo:
	cmp	DWORD PTR _r$[ebp], 65536		; 00010000H
	jl	SHORT $LN62@xmlParseCo
	cmp	DWORD PTR _r$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN61@xmlParseCo
$LN62@xmlParseCo:
	mov	DWORD PTR tv179[ebp], 0
	jmp	SHORT $LN63@xmlParseCo
$LN61@xmlParseCo:
	mov	DWORD PTR tv179[ebp], 1
$LN63@xmlParseCo:
	mov	edx, DWORD PTR tv179[ebp]
	mov	DWORD PTR tv181[ebp], edx
$LN66@xmlParseCo:
	cmp	DWORD PTR tv181[ebp], 0
	jne	SHORT $LN7@xmlParseCo

; 4715 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@
	push	9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 4716 :                           "xmlParseComment: invalid xmlChar value %d\n",
; 4717 : 	                  q);
; 4718 : 	xmlFree (buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4719 : 	return;

	jmp	$LN1@xmlParseCo
$LN7@xmlParseCo:

; 4720 :     }
; 4721 :     NEXTL(rl);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN22@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
	jmp	SHORT $LN23@xmlParseCo
$LN22@xmlParseCo:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN23@xmlParseCo:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _rl$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	xor	eax, eax
	jne	SHORT $LN7@xmlParseCo

; 4722 :     cur = CUR_CHAR(l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4723 :     if (cur == 0)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN8@xmlParseCo

; 4724 :         goto not_terminated;

	jmp	$not_terminated$92
$LN8@xmlParseCo:

; 4725 :     while (IS_CHAR(cur) && /* checked */

	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jge	SHORT $LN75@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 9
	jl	SHORT $LN67@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 10		; 0000000aH
	jle	SHORT $LN68@xmlParseCo
$LN67@xmlParseCo:
	cmp	DWORD PTR _cur$[ebp], 13		; 0000000dH
	je	SHORT $LN68@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 32		; 00000020H
	jge	SHORT $LN68@xmlParseCo
	mov	DWORD PTR tv231[ebp], 0
	jmp	SHORT $LN74@xmlParseCo
$LN68@xmlParseCo:
	mov	DWORD PTR tv231[ebp], 1
$LN74@xmlParseCo:
	mov	eax, DWORD PTR tv231[ebp]
	mov	DWORD PTR tv232[ebp], eax
	jmp	SHORT $LN76@xmlParseCo
$LN75@xmlParseCo:
	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jl	SHORT $LN69@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN71@xmlParseCo
$LN69@xmlParseCo:
	cmp	DWORD PTR _cur$[ebp], 57344		; 0000e000H
	jl	SHORT $LN70@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN71@xmlParseCo
$LN70@xmlParseCo:
	cmp	DWORD PTR _cur$[ebp], 65536		; 00010000H
	jl	SHORT $LN72@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN71@xmlParseCo
$LN72@xmlParseCo:
	mov	DWORD PTR tv230[ebp], 0
	jmp	SHORT $LN73@xmlParseCo
$LN71@xmlParseCo:
	mov	DWORD PTR tv230[ebp], 1
$LN73@xmlParseCo:
	mov	ecx, DWORD PTR tv230[ebp]
	mov	DWORD PTR tv232[ebp], ecx
$LN76@xmlParseCo:
	cmp	DWORD PTR tv232[ebp], 0
	je	$LN9@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 62		; 0000003eH
	jne	SHORT $LN25@xmlParseCo
	cmp	DWORD PTR _r$[ebp], 45			; 0000002dH
	jne	SHORT $LN25@xmlParseCo
	cmp	DWORD PTR _q$[ebp], 45			; 0000002dH
	je	$LN9@xmlParseCo
$LN25@xmlParseCo:

; 4726 :            ((cur != '>') ||
; 4727 : 	    (r != '-') || (q != '-'))) {
; 4728 : 	if ((r == '-') && (q == '-')) {

	cmp	DWORD PTR _r$[ebp], 45			; 0000002dH
	jne	SHORT $LN26@xmlParseCo
	cmp	DWORD PTR _q$[ebp], 45			; 0000002dH
	jne	SHORT $LN26@xmlParseCo

; 4729 : 	    xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);

	push	0
	push	80					; 00000050H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN26@xmlParseCo:

; 4730 : 	}
; 4731 :         if ((len > XML_MAX_TEXT_LENGTH) &&

	cmp	DWORD PTR _len$[ebp], 10000000		; 00989680H
	jbe	SHORT $LN27@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	jne	SHORT $LN27@xmlParseCo

; 4732 :             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 4733 :             xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,

	push	0
	push	OFFSET ??_C@_0BG@BAOBDEOI@Comment?5too?5big?5found@
	push	45					; 0000002dH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 4734 :                          "Comment too big found", NULL);
; 4735 :             xmlFree (buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4736 :             return;

	jmp	$LN1@xmlParseCo
$LN27@xmlParseCo:

; 4737 :         }
; 4738 : 	if (len + 5 >= size) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 5
	cmp	ecx, DWORD PTR _size$[ebp]
	jb	SHORT $LN28@xmlParseCo

; 4739 : 	    xmlChar *new_buf;
; 4740 :             size_t new_size;
; 4741 : 
; 4742 : 	    new_size = size * 2;

	mov	edx, DWORD PTR _size$[ebp]
	shl	edx, 1
	mov	DWORD PTR _new_size$1[ebp], edx

; 4743 : 	    new_buf = (xmlChar *) xmlRealloc(buf, new_size);

	mov	esi, esp
	mov	eax, DWORD PTR _new_size$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _new_buf$2[ebp], eax

; 4744 : 	    if (new_buf == NULL) {

	cmp	DWORD PTR _new_buf$2[ebp], 0
	jne	SHORT $LN29@xmlParseCo

; 4745 : 		xmlFree (buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4746 : 		xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 4747 : 		return;

	jmp	$LN1@xmlParseCo
$LN29@xmlParseCo:

; 4748 : 	    }
; 4749 : 	    buf = new_buf;

	mov	ecx, DWORD PTR _new_buf$2[ebp]
	mov	DWORD PTR _buf$[ebp], ecx

; 4750 :             size = new_size;

	mov	edx, DWORD PTR _new_size$1[ebp]
	mov	DWORD PTR _size$[ebp], edx
$LN28@xmlParseCo:

; 4751 : 	}
; 4752 : 	COPY_BUF(ql,buf,len,q);

	cmp	DWORD PTR _ql$[ebp], 1
	jne	SHORT $LN30@xmlParseCo
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _q$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
	jmp	SHORT $LN31@xmlParseCo
$LN30@xmlParseCo:
	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	push	ecx
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN31@xmlParseCo:

; 4753 : 	q = r;

	mov	edx, DWORD PTR _r$[ebp]
	mov	DWORD PTR _q$[ebp], edx

; 4754 : 	ql = rl;

	mov	eax, DWORD PTR _rl$[ebp]
	mov	DWORD PTR _ql$[ebp], eax

; 4755 : 	r = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _r$[ebp], ecx

; 4756 : 	rl = l;

	mov	edx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _rl$[ebp], edx

; 4757 : 
; 4758 : 	count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 4759 : 	if (count > 50) {

	cmp	DWORD PTR _count$[ebp], 50		; 00000032H
	jbe	SHORT $LN12@xmlParseCo

; 4760 : 	    GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN33@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN33@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN33@xmlParseCo:

; 4761 : 	    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 4762 :             if (ctxt->instate == XML_PARSER_EOF) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN12@xmlParseCo

; 4763 : 		xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4764 : 		return;

	jmp	$LN1@xmlParseCo
$LN12@xmlParseCo:

; 4765 :             }
; 4766 : 	}
; 4767 : 	NEXTL(l);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN35@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], 1
	jmp	SHORT $LN36@xmlParseCo
$LN35@xmlParseCo:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
$LN36@xmlParseCo:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	xor	ecx, ecx
	jne	SHORT $LN12@xmlParseCo

; 4768 : 	cur = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4769 : 	if (cur == 0) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	$LN37@xmlParseCo

; 4770 : 	    SHRINK;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN38@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN38@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 500				; 000001f4H
	jge	SHORT $LN38@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSHRINK
	add	esp, 4
$LN38@xmlParseCo:

; 4771 : 	    GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN39@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN39@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN39@xmlParseCo:

; 4772 : 	    cur = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$LN37@xmlParseCo:

; 4773 : 	}
; 4774 :     }

	jmp	$LN8@xmlParseCo
$LN9@xmlParseCo:

; 4775 :     buf[len] = 0;

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 0

; 4776 :     if (cur == 0) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN40@xmlParseCo

; 4777 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	push	OFFSET ??_C@_0CD@MHPLKFMN@Comment?5not?5terminated?5?6?$DM?$CB?9?9?$CF?45@
	push	45					; 0000002dH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
	jmp	$LN41@xmlParseCo
$LN40@xmlParseCo:

; 4778 : 	                     "Comment not terminated \n<!--%.50s\n", buf);
; 4779 :     } else if (!IS_CHAR(cur)) {

	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jge	SHORT $LN85@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 9
	jl	SHORT $LN77@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 10		; 0000000aH
	jle	SHORT $LN78@xmlParseCo
$LN77@xmlParseCo:
	cmp	DWORD PTR _cur$[ebp], 13		; 0000000dH
	je	SHORT $LN78@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 32		; 00000020H
	jge	SHORT $LN78@xmlParseCo
	mov	DWORD PTR tv362[ebp], 0
	jmp	SHORT $LN84@xmlParseCo
$LN78@xmlParseCo:
	mov	DWORD PTR tv362[ebp], 1
$LN84@xmlParseCo:
	mov	ecx, DWORD PTR tv362[ebp]
	mov	DWORD PTR tv363[ebp], ecx
	jmp	SHORT $LN86@xmlParseCo
$LN85@xmlParseCo:
	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jl	SHORT $LN79@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN81@xmlParseCo
$LN79@xmlParseCo:
	cmp	DWORD PTR _cur$[ebp], 57344		; 0000e000H
	jl	SHORT $LN80@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN81@xmlParseCo
$LN80@xmlParseCo:
	cmp	DWORD PTR _cur$[ebp], 65536		; 00010000H
	jl	SHORT $LN82@xmlParseCo
	cmp	DWORD PTR _cur$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN81@xmlParseCo
$LN82@xmlParseCo:
	mov	DWORD PTR tv361[ebp], 0
	jmp	SHORT $LN83@xmlParseCo
$LN81@xmlParseCo:
	mov	DWORD PTR tv361[ebp], 1
$LN83@xmlParseCo:
	mov	edx, DWORD PTR tv361[ebp]
	mov	DWORD PTR tv363[ebp], edx
$LN86@xmlParseCo:
	cmp	DWORD PTR tv363[ebp], 0
	jne	SHORT $LN42@xmlParseCo

; 4780 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@FHECENFI@xmlParseComment?3?5invalid?5xmlCha@
	push	9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 4781 :                           "xmlParseComment: invalid xmlChar value %d\n",
; 4782 : 	                  cur);
; 4783 :     } else {

	jmp	SHORT $LN41@xmlParseCo
$LN42@xmlParseCo:

; 4784 : 	if (inputid != ctxt->input->id) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _inputid$[ebp]
	cmp	ecx, DWORD PTR [eax+56]
	je	SHORT $LN44@xmlParseCo

; 4785 : 	    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DD@BIJIOHJJ@Comment?5doesn?8t?5start?5and?5stop?5@
	push	90					; 0000005aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN44@xmlParseCo:

; 4786 : 		           "Comment doesn't start and stop in the same"
; 4787 :                            " entity\n");
; 4788 : 	}
; 4789 :         NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 4790 : 	if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN41@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN41@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN41@xmlParseCo

; 4791 : 	    (!ctxt->disableSAX))
; 4792 : 	    ctxt->sax->comment(ctxt->userData, buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+80]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN41@xmlParseCo:

; 4793 :     }
; 4794 :     xmlFree(buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4795 :     return;

	jmp	SHORT $LN1@xmlParseCo
$not_terminated$92:

; 4796 : not_terminated:
; 4797 :     xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,

	push	0
	push	OFFSET ??_C@_0BI@ELKFFAAB@Comment?5not?5terminated?6@
	push	45					; 0000002dH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 4798 : 			 "Comment not terminated\n", NULL);
; 4799 :     xmlFree(buf);

	mov	esi, esp
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlParseCo:

; 4800 :     return;
; 4801 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN91@xmlParseCo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 112				; 00000070H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN91@xmlParseCo:
	DD	3
	DD	$LN90@xmlParseCo
$LN90@xmlParseCo:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN87@xmlParseCo
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN88@xmlParseCo
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN89@xmlParseCo
$LN89@xmlParseCo:
	DB	108					; 0000006cH
	DB	0
$LN88@xmlParseCo:
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	0
$LN87@xmlParseCo:
	DB	113					; 00000071H
	DB	108					; 0000006cH
	DB	0
_xmlParseCommentComplex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCharDataComplex
_TEXT	SEGMENT
tv306 = -364						; size = 4
tv308 = -360						; size = 4
tv307 = -356						; size = 4
tv136 = -352						; size = 4
tv138 = -348						; size = 4
tv137 = -344						; size = 4
_count$ = -340						; size = 4
_l$ = -332						; size = 4
_cur$ = -324						; size = 4
_nbchar$ = -320						; size = 4
_buf$ = -312						; size = 305
_ctxt$ = 8						; size = 4
_cdata$ = 12						; size = 4
_xmlParseCharDataComplex PROC				; COMDAT

; 4508 : xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int cdata) {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-364]
	mov	ecx, 91					; 0000005bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 4509 :     xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];
; 4510 :     int nbchar = 0;

	mov	DWORD PTR _nbchar$[ebp], 0

; 4511 :     int cur, l;
; 4512 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 4513 : 
; 4514 :     SHRINK;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN10@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	cmp	edx, 500				; 000001f4H
	jle	SHORT $LN10@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 500				; 000001f4H
	jge	SHORT $LN10@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSHRINK
	add	esp, 4
$LN10@xmlParseCh:

; 4515 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN11@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN11@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN11@xmlParseCh:

; 4516 :     cur = CUR_CHAR(l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$LN2@xmlParseCh:

; 4517 :     while ((cur != '<') && /* checked */
; 4518 :            (cur != '&') &&

	cmp	DWORD PTR _cur$[ebp], 60		; 0000003cH
	je	$LN3@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 38		; 00000026H
	je	$LN3@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jge	SHORT $LN49@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 9
	jl	SHORT $LN41@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 10		; 0000000aH
	jle	SHORT $LN42@xmlParseCh
$LN41@xmlParseCh:
	cmp	DWORD PTR _cur$[ebp], 13		; 0000000dH
	je	SHORT $LN42@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 32		; 00000020H
	jge	SHORT $LN42@xmlParseCh
	mov	DWORD PTR tv137[ebp], 0
	jmp	SHORT $LN48@xmlParseCh
$LN42@xmlParseCh:
	mov	DWORD PTR tv137[ebp], 1
$LN48@xmlParseCh:
	mov	eax, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $LN50@xmlParseCh
$LN49@xmlParseCh:
	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jl	SHORT $LN43@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN45@xmlParseCh
$LN43@xmlParseCh:
	cmp	DWORD PTR _cur$[ebp], 57344		; 0000e000H
	jl	SHORT $LN44@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN45@xmlParseCh
$LN44@xmlParseCh:
	cmp	DWORD PTR _cur$[ebp], 65536		; 00010000H
	jl	SHORT $LN46@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN45@xmlParseCh
$LN46@xmlParseCh:
	mov	DWORD PTR tv136[ebp], 0
	jmp	SHORT $LN47@xmlParseCh
$LN45@xmlParseCh:
	mov	DWORD PTR tv136[ebp], 1
$LN47@xmlParseCh:
	mov	ecx, DWORD PTR tv136[ebp]
	mov	DWORD PTR tv138[ebp], ecx
$LN50@xmlParseCh:
	cmp	DWORD PTR tv138[ebp], 0
	je	$LN3@xmlParseCh

; 4519 : 	   (IS_CHAR(cur))) /* test also done in xmlCurrentChar() */ {
; 4520 : 	if ((cur == ']') && (NXT(1) == ']') &&

	cmp	DWORD PTR _cur$[ebp], 93		; 0000005dH
	jne	SHORT $LN12@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN12@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 62					; 0000003eH
	jne	SHORT $LN12@xmlParseCh

; 4521 : 	    (NXT(2) == '>')) {
; 4522 : 	    if (cdata) break;

	cmp	DWORD PTR _cdata$[ebp], 0
	je	SHORT $LN13@xmlParseCh
	jmp	$LN3@xmlParseCh
	jmp	SHORT $LN12@xmlParseCh
$LN13@xmlParseCh:

; 4523 : 	    else {
; 4524 : 		xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);

	push	0
	push	62					; 0000003eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN12@xmlParseCh:

; 4525 : 	    }
; 4526 : 	}
; 4527 : 	COPY_BUF(l,buf,nbchar,cur);

	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN15@xmlParseCh
	mov	ecx, DWORD PTR _nbchar$[ebp]
	mov	dl, BYTE PTR _cur$[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], dl
	mov	eax, DWORD PTR _nbchar$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbchar$[ebp], eax
	jmp	SHORT $LN16@xmlParseCh
$LN15@xmlParseCh:
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nbchar$[ebp]
	lea	eax, DWORD PTR _buf$[ebp+edx]
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _nbchar$[ebp]
	mov	DWORD PTR _nbchar$[ebp], eax
$LN16@xmlParseCh:

; 4528 : 	if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {

	cmp	DWORD PTR _nbchar$[ebp], 300		; 0000012cH
	jl	$LN17@xmlParseCh

; 4529 : 	    buf[nbchar] = 0;

	mov	ecx, DWORD PTR _nbchar$[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], 0

; 4530 : 
; 4531 : 	    /*
; 4532 : 	     * OK the segment is to be consumed as chars.
; 4533 : 	     */
; 4534 : 	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN18@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	$LN18@xmlParseCh

; 4535 : 		if (areBlanks(ctxt, buf, nbchar, 0)) {

	push	0
	mov	ecx, DWORD PTR _nbchar$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_areBlanks
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN19@xmlParseCh

; 4536 : 		    if (ctxt->sax->ignorableWhitespace != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+72], 0
	je	SHORT $LN21@xmlParseCh

; 4537 : 			ctxt->sax->ignorableWhitespace(ctxt->userData,

	mov	esi, esp
	mov	eax, DWORD PTR _nbchar$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+72]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@xmlParseCh:

; 4538 : 			                               buf, nbchar);
; 4539 : 		} else {

	jmp	SHORT $LN18@xmlParseCh
$LN19@xmlParseCh:

; 4540 : 		    if (ctxt->sax->characters != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN22@xmlParseCh

; 4541 : 			ctxt->sax->characters(ctxt->userData, buf, nbchar);

	mov	esi, esp
	mov	eax, DWORD PTR _nbchar$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+68]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@xmlParseCh:

; 4542 : 		    if ((ctxt->sax->characters !=
; 4543 : 		         ctxt->sax->ignorableWhitespace) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+68]
	cmp	edx, DWORD PTR [ecx+72]
	je	SHORT $LN18@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	cmp	DWORD PTR [ecx], -1
	jne	SHORT $LN18@xmlParseCh

; 4544 : 			(*ctxt->space == -1))
; 4545 : 			*ctxt->space = -2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+232]
	mov	DWORD PTR [eax], -2			; fffffffeH
$LN18@xmlParseCh:

; 4546 : 		}
; 4547 : 	    }
; 4548 : 	    nbchar = 0;

	mov	DWORD PTR _nbchar$[ebp], 0

; 4549 :             /* something really bad happened in the SAX callback */
; 4550 :             if (ctxt->instate != XML_PARSER_CONTENT)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], 7
	je	SHORT $LN17@xmlParseCh

; 4551 :                 return;

	jmp	$LN1@xmlParseCh
$LN17@xmlParseCh:

; 4552 : 	}
; 4553 : 	count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 4554 : 	if (count > 50) {

	cmp	DWORD PTR _count$[ebp], 50		; 00000032H
	jle	SHORT $LN6@xmlParseCh

; 4555 : 	    GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN26@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN26@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN26@xmlParseCh:

; 4556 : 	    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 4557 :             if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN6@xmlParseCh

; 4558 : 		return;

	jmp	$LN1@xmlParseCh
$LN6@xmlParseCh:

; 4559 : 	}
; 4560 : 	NEXTL(l);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN28@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+28], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN29@xmlParseCh
$LN28@xmlParseCh:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
$LN29@xmlParseCh:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	xor	edx, edx
	jne	SHORT $LN6@xmlParseCh

; 4561 : 	cur = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4562 :     }

	jmp	$LN2@xmlParseCh
$LN3@xmlParseCh:

; 4563 :     if (nbchar != 0) {

	cmp	DWORD PTR _nbchar$[ebp], 0
	je	$LN30@xmlParseCh

; 4564 :         buf[nbchar] = 0;

	mov	edx, DWORD PTR _nbchar$[ebp]
	mov	BYTE PTR _buf$[ebp+edx], 0

; 4565 : 	/*
; 4566 : 	 * OK the segment is to be consumed as chars.
; 4567 : 	 */
; 4568 : 	if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN30@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	$LN30@xmlParseCh

; 4569 : 	    if (areBlanks(ctxt, buf, nbchar, 0)) {

	push	0
	mov	edx, DWORD PTR _nbchar$[ebp]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_areBlanks
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN32@xmlParseCh

; 4570 : 		if (ctxt->sax->ignorableWhitespace != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $LN34@xmlParseCh

; 4571 : 		    ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);

	mov	esi, esp
	mov	ecx, DWORD PTR _nbchar$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+72]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN34@xmlParseCh:

; 4572 : 	    } else {

	jmp	SHORT $LN30@xmlParseCh
$LN32@xmlParseCh:

; 4573 : 		if (ctxt->sax->characters != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN35@xmlParseCh

; 4574 : 		    ctxt->sax->characters(ctxt->userData, buf, nbchar);

	mov	esi, esp
	mov	ecx, DWORD PTR _nbchar$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+68]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN35@xmlParseCh:

; 4575 : 		if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+68]
	cmp	eax, DWORD PTR [edx+72]
	je	SHORT $LN30@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN30@xmlParseCh

; 4576 : 		    (*ctxt->space == -1))
; 4577 : 		    *ctxt->space = -2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	mov	DWORD PTR [ecx], -2			; fffffffeH
$LN30@xmlParseCh:

; 4578 : 	    }
; 4579 : 	}
; 4580 :     }
; 4581 :     if ((cur != 0) && (!IS_CHAR(cur))) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN1@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jge	SHORT $LN59@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 9
	jl	SHORT $LN51@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 10		; 0000000aH
	jle	SHORT $LN52@xmlParseCh
$LN51@xmlParseCh:
	cmp	DWORD PTR _cur$[ebp], 13		; 0000000dH
	je	SHORT $LN52@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 32		; 00000020H
	jge	SHORT $LN52@xmlParseCh
	mov	DWORD PTR tv307[ebp], 0
	jmp	SHORT $LN58@xmlParseCh
$LN52@xmlParseCh:
	mov	DWORD PTR tv307[ebp], 1
$LN58@xmlParseCh:
	mov	edx, DWORD PTR tv307[ebp]
	mov	DWORD PTR tv308[ebp], edx
	jmp	SHORT $LN60@xmlParseCh
$LN59@xmlParseCh:
	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jl	SHORT $LN53@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN55@xmlParseCh
$LN53@xmlParseCh:
	cmp	DWORD PTR _cur$[ebp], 57344		; 0000e000H
	jl	SHORT $LN54@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN55@xmlParseCh
$LN54@xmlParseCh:
	cmp	DWORD PTR _cur$[ebp], 65536		; 00010000H
	jl	SHORT $LN56@xmlParseCh
	cmp	DWORD PTR _cur$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN55@xmlParseCh
$LN56@xmlParseCh:
	mov	DWORD PTR tv306[ebp], 0
	jmp	SHORT $LN57@xmlParseCh
$LN55@xmlParseCh:
	mov	DWORD PTR tv306[ebp], 1
$LN57@xmlParseCh:
	mov	eax, DWORD PTR tv306[ebp]
	mov	DWORD PTR tv308[ebp], eax
$LN60@xmlParseCh:
	cmp	DWORD PTR tv308[ebp], 0
	jne	$LN1@xmlParseCh

; 4582 : 	/* Generate the error and skip the offending character */
; 4583 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BO@IODKMKKF@PCDATA?5invalid?5Char?5value?5?$CFd?6@
	push	9
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H
$LN9@xmlParseCh:

; 4584 :                           "PCDATA invalid Char value %d\n",
; 4585 : 	                  cur);
; 4586 : 	NEXTL(l);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN38@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
	jmp	SHORT $LN39@xmlParseCh
$LN38@xmlParseCh:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN39@xmlParseCh:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	xor	eax, eax
	jne	SHORT $LN9@xmlParseCh
$LN1@xmlParseCh:

; 4587 :     }
; 4588 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN64@xmlParseCh
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 364				; 0000016cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN64@xmlParseCh:
	DD	2
	DD	$LN63@xmlParseCh
$LN63@xmlParseCh:
	DD	-312					; fffffec8H
	DD	305					; 00000131H
	DD	$LN61@xmlParseCh
	DD	-332					; fffffeb4H
	DD	4
	DD	$LN62@xmlParseCh
$LN62@xmlParseCh:
	DB	108					; 0000006cH
	DB	0
$LN61@xmlParseCh:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlParseCharDataComplex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttValueComplex
_TEXT	SEGMENT
tv555 = -160						; size = 4
tv557 = -156						; size = 4
tv556 = -152						; size = 4
tv139 = -148						; size = 4
tv141 = -144						; size = 4
tv140 = -140						; size = 4
_new_size$1 = -136					; size = 4
_tmp$2 = -132						; size = 4
_new_size$3 = -128					; size = 4
_tmp$4 = -124						; size = 4
_new_size$5 = -120					; size = 4
_tmp$6 = -116						; size = 4
_oldnbent$7 = -112					; size = 4
_cur$8 = -108						; size = 4
_i$9 = -104						; size = 4
_new_size$10 = -100					; size = 4
_tmp$11 = -96						; size = 4
_new_size$12 = -92					; size = 4
_tmp$13 = -88						; size = 4
_new_size$14 = -84					; size = 4
_tmp$15 = -80						; size = 4
_new_size$16 = -76					; size = 4
_tmp$17 = -72						; size = 4
_new_size$18 = -68					; size = 4
_tmp$19 = -64						; size = 4
_new_size$20 = -60					; size = 4
_tmp$21 = -56						; size = 4
_val$22 = -52						; size = 4
_ent$ = -48						; size = 4
_current$ = -44						; size = 4
_in_space$ = -40					; size = 4
_l$ = -32						; size = 4
_c$ = -24						; size = 4
_buf_size$ = -20					; size = 4
_len$ = -16						; size = 4
_rep$ = -12						; size = 4
_buf$ = -8						; size = 4
_limit$ = -1						; size = 1
_ctxt$ = 8						; size = 4
_attlen$ = 12						; size = 4
_normalize$ = 16					; size = 4
_xmlParseAttValueComplex PROC				; COMDAT

; 3849 : xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-160]
	mov	ecx, 40					; 00000028H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 3850 :     xmlChar limit = 0;

	mov	BYTE PTR _limit$[ebp], 0

; 3851 :     xmlChar *buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 3852 :     xmlChar *rep = NULL;

	mov	DWORD PTR _rep$[ebp], 0

; 3853 :     size_t len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 3854 :     size_t buf_size = 0;

	mov	DWORD PTR _buf_size$[ebp], 0

; 3855 :     int c, l, in_space = 0;

	mov	DWORD PTR _in_space$[ebp], 0

; 3856 :     xmlChar *current = NULL;

	mov	DWORD PTR _current$[ebp], 0

; 3857 :     xmlEntityPtr ent;
; 3858 : 
; 3859 :     if (NXT(0) == '"') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN18@xmlParseAt

; 3860 : 	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 12			; 0000000cH

; 3861 : 	limit = '"';

	mov	BYTE PTR _limit$[ebp], 34		; 00000022H

; 3862 :         NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4
	jmp	SHORT $LN19@xmlParseAt
$LN18@xmlParseAt:

; 3863 :     } else if (NXT(0) == '\'') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $LN20@xmlParseAt

; 3864 : 	limit = '\'';

	mov	BYTE PTR _limit$[ebp], 39		; 00000027H

; 3865 : 	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 12			; 0000000cH

; 3866 :         NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 3867 :     } else {

	jmp	SHORT $LN19@xmlParseAt
$LN20@xmlParseAt:

; 3868 : 	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);

	push	0
	push	39					; 00000027H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3869 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN19@xmlParseAt:

; 3870 :     }
; 3871 : 
; 3872 :     /*
; 3873 :      * allocate a translation buffer.
; 3874 :      */
; 3875 :     buf_size = XML_PARSER_BUFFER_SIZE;

	mov	DWORD PTR _buf_size$[ebp], 100		; 00000064H

; 3876 :     buf = (xmlChar *) xmlMallocAtomic(buf_size);

	mov	esi, esp
	mov	edx, DWORD PTR _buf_size$[ebp]
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$[ebp], eax

; 3877 :     if (buf == NULL) goto mem_error;

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN22@xmlParseAt
	jmp	$mem_error$128
$LN22@xmlParseAt:

; 3878 : 
; 3879 :     /*
; 3880 :      * OK loop until we reach one of the ending char or a size limit.
; 3881 :      */
; 3882 :     c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
$LN2@xmlParseAt:

; 3883 :     while (((NXT(0) != limit) && /* checked */
; 3884 :             (IS_CHAR(c)) && (c != '<')) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	movzx	edx, BYTE PTR _limit$[ebp]
	cmp	ecx, edx
	je	$LN3@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN113@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 9
	jl	SHORT $LN105@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	jle	SHORT $LN106@xmlParseAt
$LN105@xmlParseAt:
	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $LN106@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jge	SHORT $LN106@xmlParseAt
	mov	DWORD PTR tv140[ebp], 0
	jmp	SHORT $LN112@xmlParseAt
$LN106@xmlParseAt:
	mov	DWORD PTR tv140[ebp], 1
$LN112@xmlParseAt:
	mov	eax, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv141[ebp], eax
	jmp	SHORT $LN114@xmlParseAt
$LN113@xmlParseAt:
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jl	SHORT $LN107@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN109@xmlParseAt
$LN107@xmlParseAt:
	cmp	DWORD PTR _c$[ebp], 57344		; 0000e000H
	jl	SHORT $LN108@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN109@xmlParseAt
$LN108@xmlParseAt:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jl	SHORT $LN110@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN109@xmlParseAt
$LN110@xmlParseAt:
	mov	DWORD PTR tv139[ebp], 0
	jmp	SHORT $LN111@xmlParseAt
$LN109@xmlParseAt:
	mov	DWORD PTR tv139[ebp], 1
$LN111@xmlParseAt:
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR tv141[ebp], ecx
$LN114@xmlParseAt:
	cmp	DWORD PTR tv141[ebp], 0
	je	$LN3@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 60			; 0000003cH
	je	$LN3@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	je	$LN3@xmlParseAt

; 3885 :             (ctxt->instate != XML_PARSER_EOF)) {
; 3886 :         /*
; 3887 :          * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE
; 3888 :          * special option is given
; 3889 :          */
; 3890 :         if ((len > XML_MAX_TEXT_LENGTH) &&

	cmp	DWORD PTR _len$[ebp], 10000000		; 00989680H
	jbe	SHORT $LN23@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	jne	SHORT $LN23@xmlParseAt

; 3891 :             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3892 :             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,

	push	OFFSET ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
	push	40					; 00000028H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 3893 :                            "AttValue length too long\n");
; 3894 :             goto mem_error;

	jmp	$mem_error$128
$LN23@xmlParseAt:

; 3895 :         }
; 3896 : 	if (c == 0) break;

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN24@xmlParseAt
	jmp	$LN3@xmlParseAt
$LN24@xmlParseAt:

; 3897 : 	if (c == '&') {

	cmp	DWORD PTR _c$[ebp], 38			; 00000026H
	jne	$LN25@xmlParseAt

; 3898 : 	    in_space = 0;

	mov	DWORD PTR _in_space$[ebp], 0

; 3899 : 	    if (NXT(1) == '#') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 35					; 00000023H
	jne	$LN27@xmlParseAt

; 3900 : 		int val = xmlParseCharRef(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseCharRef
	add	esp, 4
	mov	DWORD PTR _val$22[ebp], eax

; 3901 : 
; 3902 : 		if (val == '&') {

	cmp	DWORD PTR _val$22[ebp], 38		; 00000026H
	jne	$LN29@xmlParseAt

; 3903 : 		    if (ctxt->replaceEntities) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN31@xmlParseAt

; 3904 : 			if (len + 10 > buf_size) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 10					; 0000000aH
	cmp	ecx, DWORD PTR _buf_size$[ebp]
	jbe	SHORT $LN33@xmlParseAt

; 3905 : 			    growBuffer(buf, 10);

	mov	edx, DWORD PTR _buf_size$[ebp]
	lea	eax, DWORD PTR [edx+edx+10]
	mov	DWORD PTR _new_size$20[ebp], eax
	mov	ecx, DWORD PTR _new_size$20[ebp]
	cmp	ecx, DWORD PTR _buf_size$[ebp]
	jae	SHORT $LN34@xmlParseAt
	jmp	$mem_error$128
$LN34@xmlParseAt:
	mov	esi, esp
	mov	edx, DWORD PTR _new_size$20[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$21[ebp], eax
	cmp	DWORD PTR _tmp$21[ebp], 0
	jne	SHORT $LN35@xmlParseAt
	jmp	$mem_error$128
$LN35@xmlParseAt:
	mov	ecx, DWORD PTR _tmp$21[ebp]
	mov	DWORD PTR _buf$[ebp], ecx
	mov	edx, DWORD PTR _new_size$20[ebp]
	mov	DWORD PTR _buf_size$[ebp], edx
$LN33@xmlParseAt:

; 3906 : 			}
; 3907 : 			buf[len++] = '&';

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 3908 : 		    } else {

	jmp	$LN32@xmlParseAt
$LN31@xmlParseAt:

; 3909 : 			/*
; 3910 : 			 * The reparsing will be done in xmlStringGetNodeList()
; 3911 : 			 * called by the attribute() function in SAX.c
; 3912 : 			 */
; 3913 : 			if (len + 10 > buf_size) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 10					; 0000000aH
	cmp	edx, DWORD PTR _buf_size$[ebp]
	jbe	SHORT $LN36@xmlParseAt

; 3914 : 			    growBuffer(buf, 10);

	mov	eax, DWORD PTR _buf_size$[ebp]
	lea	ecx, DWORD PTR [eax+eax+10]
	mov	DWORD PTR _new_size$18[ebp], ecx
	mov	edx, DWORD PTR _new_size$18[ebp]
	cmp	edx, DWORD PTR _buf_size$[ebp]
	jae	SHORT $LN37@xmlParseAt
	jmp	$mem_error$128
$LN37@xmlParseAt:
	mov	esi, esp
	mov	eax, DWORD PTR _new_size$18[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$19[ebp], eax
	cmp	DWORD PTR _tmp$19[ebp], 0
	jne	SHORT $LN38@xmlParseAt
	jmp	$mem_error$128
$LN38@xmlParseAt:
	mov	edx, DWORD PTR _tmp$19[ebp]
	mov	DWORD PTR _buf$[ebp], edx
	mov	eax, DWORD PTR _new_size$18[ebp]
	mov	DWORD PTR _buf_size$[ebp], eax
$LN36@xmlParseAt:

; 3915 : 			}
; 3916 : 			buf[len++] = '&';

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 38			; 00000026H
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 3917 : 			buf[len++] = '#';

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 35			; 00000023H
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 3918 : 			buf[len++] = '3';

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 51			; 00000033H
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 3919 : 			buf[len++] = '8';

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 56			; 00000038H
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 3920 : 			buf[len++] = ';';

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 59			; 0000003bH
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
$LN32@xmlParseAt:

; 3921 : 		    }

	jmp	SHORT $LN30@xmlParseAt
$LN29@xmlParseAt:

; 3922 : 		} else if (val != 0) {

	cmp	DWORD PTR _val$22[ebp], 0
	je	SHORT $LN30@xmlParseAt

; 3923 : 		    if (len + 10 > buf_size) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 10					; 0000000aH
	cmp	edx, DWORD PTR _buf_size$[ebp]
	jbe	SHORT $LN40@xmlParseAt

; 3924 : 			growBuffer(buf, 10);

	mov	eax, DWORD PTR _buf_size$[ebp]
	lea	ecx, DWORD PTR [eax+eax+10]
	mov	DWORD PTR _new_size$16[ebp], ecx
	mov	edx, DWORD PTR _new_size$16[ebp]
	cmp	edx, DWORD PTR _buf_size$[ebp]
	jae	SHORT $LN41@xmlParseAt
	jmp	$mem_error$128
$LN41@xmlParseAt:
	mov	esi, esp
	mov	eax, DWORD PTR _new_size$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$17[ebp], eax
	cmp	DWORD PTR _tmp$17[ebp], 0
	jne	SHORT $LN42@xmlParseAt
	jmp	$mem_error$128
$LN42@xmlParseAt:
	mov	edx, DWORD PTR _tmp$17[ebp]
	mov	DWORD PTR _buf$[ebp], edx
	mov	eax, DWORD PTR _new_size$16[ebp]
	mov	DWORD PTR _buf_size$[ebp], eax
$LN40@xmlParseAt:

; 3925 : 		    }
; 3926 : 		    len += xmlCopyChar(0, &buf[len], val);

	mov	ecx, DWORD PTR _val$22[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	push	edx
	push	0
	call	_xmlCopyChar
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN30@xmlParseAt:

; 3927 : 		}
; 3928 : 	    } else {

	jmp	$LN28@xmlParseAt
$LN27@xmlParseAt:

; 3929 : 		ent = xmlParseEntityRef(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseEntityRef
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 3930 : 		ctxt->nbentities++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+440]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+440], edx

; 3931 : 		if (ent != NULL)

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN43@xmlParseAt

; 3932 : 		    ctxt->nbentities += ent->owner;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+440]
	mov	eax, DWORD PTR _ent$[ebp]
	add	edx, DWORD PTR [eax+68]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+440], edx
$LN43@xmlParseAt:

; 3933 : 		if ((ent != NULL) &&

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN44@xmlParseAt
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+48], 6
	jne	$LN44@xmlParseAt

; 3934 : 		    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
; 3935 : 		    if (len + 10 > buf_size) {

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 10					; 0000000aH
	cmp	eax, DWORD PTR _buf_size$[ebp]
	jbe	SHORT $LN46@xmlParseAt

; 3936 : 			growBuffer(buf, 10);

	mov	ecx, DWORD PTR _buf_size$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+10]
	mov	DWORD PTR _new_size$14[ebp], edx
	mov	eax, DWORD PTR _new_size$14[ebp]
	cmp	eax, DWORD PTR _buf_size$[ebp]
	jae	SHORT $LN47@xmlParseAt
	jmp	$mem_error$128
$LN47@xmlParseAt:
	mov	esi, esp
	mov	ecx, DWORD PTR _new_size$14[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$15[ebp], eax
	cmp	DWORD PTR _tmp$15[ebp], 0
	jne	SHORT $LN48@xmlParseAt
	jmp	$mem_error$128
$LN48@xmlParseAt:
	mov	eax, DWORD PTR _tmp$15[ebp]
	mov	DWORD PTR _buf$[ebp], eax
	mov	ecx, DWORD PTR _new_size$14[ebp]
	mov	DWORD PTR _buf_size$[ebp], ecx
$LN46@xmlParseAt:

; 3937 : 		    }
; 3938 : 		    if ((ctxt->replaceEntities == 0) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN49@xmlParseAt
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 38					; 00000026H
	jne	SHORT $LN49@xmlParseAt

; 3939 : 		        (ent->content[0] == '&')) {
; 3940 : 			buf[len++] = '&';

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 3941 : 			buf[len++] = '#';

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 35			; 00000023H
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 3942 : 			buf[len++] = '3';

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 51			; 00000033H
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 3943 : 			buf[len++] = '8';

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 56			; 00000038H
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 3944 : 			buf[len++] = ';';

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 3945 : 		    } else {

	jmp	SHORT $LN50@xmlParseAt
$LN49@xmlParseAt:

; 3946 : 			buf[len++] = ent->content[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
$LN50@xmlParseAt:

; 3947 : 		    }

	jmp	$LN28@xmlParseAt
$LN44@xmlParseAt:

; 3948 : 		} else if ((ent != NULL) &&

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN51@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	$LN51@xmlParseAt

; 3949 : 		           (ctxt->replaceEntities != 0)) {
; 3950 : 		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+48], 6
	je	$LN53@xmlParseAt

; 3951 : 			++ctxt->depth;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+248]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+248], edx

; 3952 : 			rep = xmlStringDecodeEntities(ctxt, ent->content,

	push	0
	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlStringDecodeEntities
	add	esp, 24					; 00000018H
	mov	DWORD PTR _rep$[ebp], eax

; 3953 : 						      XML_SUBSTITUTE_REF,
; 3954 : 						      0, 0, 0);
; 3955 : 			--ctxt->depth;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+248]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+248], edx

; 3956 : 			if (rep != NULL) {

	cmp	DWORD PTR _rep$[ebp], 0
	je	$LN55@xmlParseAt

; 3957 : 			    current = rep;

	mov	ecx, DWORD PTR _rep$[ebp]
	mov	DWORD PTR _current$[ebp], ecx
$LN4@xmlParseAt:

; 3958 : 			    while (*current != 0) { /* non input consuming */

	mov	edx, DWORD PTR _current$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN5@xmlParseAt

; 3959 :                                 if ((*current == 0xD) || (*current == 0xA) ||

	mov	ecx, DWORD PTR _current$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN58@xmlParseAt
	mov	eax, DWORD PTR _current$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN58@xmlParseAt
	mov	edx, DWORD PTR _current$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jne	SHORT $LN56@xmlParseAt
$LN58@xmlParseAt:

; 3960 :                                     (*current == 0x9)) {
; 3961 :                                     buf[len++] = 0x20;

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 32			; 00000020H
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 3962 :                                     current++;

	mov	eax, DWORD PTR _current$[ebp]
	add	eax, 1
	mov	DWORD PTR _current$[ebp], eax

; 3963 :                                 } else

	jmp	SHORT $LN57@xmlParseAt
$LN56@xmlParseAt:

; 3964 :                                     buf[len++] = *current++;

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _current$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	mov	edx, DWORD PTR _current$[ebp]
	add	edx, 1
	mov	DWORD PTR _current$[ebp], edx
$LN57@xmlParseAt:

; 3965 : 				if (len + 10 > buf_size) {

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 10					; 0000000aH
	cmp	eax, DWORD PTR _buf_size$[ebp]
	jbe	SHORT $LN59@xmlParseAt

; 3966 : 				    growBuffer(buf, 10);

	mov	ecx, DWORD PTR _buf_size$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+10]
	mov	DWORD PTR _new_size$12[ebp], edx
	mov	eax, DWORD PTR _new_size$12[ebp]
	cmp	eax, DWORD PTR _buf_size$[ebp]
	jae	SHORT $LN60@xmlParseAt
	jmp	$mem_error$128
$LN60@xmlParseAt:
	mov	esi, esp
	mov	ecx, DWORD PTR _new_size$12[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$13[ebp], eax
	cmp	DWORD PTR _tmp$13[ebp], 0
	jne	SHORT $LN61@xmlParseAt
	jmp	$mem_error$128
$LN61@xmlParseAt:
	mov	eax, DWORD PTR _tmp$13[ebp]
	mov	DWORD PTR _buf$[ebp], eax
	mov	ecx, DWORD PTR _new_size$12[ebp]
	mov	DWORD PTR _buf_size$[ebp], ecx
$LN59@xmlParseAt:

; 3967 : 				}
; 3968 : 			    }

	jmp	$LN4@xmlParseAt
$LN5@xmlParseAt:

; 3969 : 			    xmlFree(rep);

	mov	esi, esp
	mov	edx, DWORD PTR _rep$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3970 : 			    rep = NULL;

	mov	DWORD PTR _rep$[ebp], 0
$LN55@xmlParseAt:

; 3971 : 			}
; 3972 : 		    } else {

	jmp	$LN54@xmlParseAt
$LN53@xmlParseAt:

; 3973 : 			if (len + 10 > buf_size) {

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 10					; 0000000aH
	cmp	eax, DWORD PTR _buf_size$[ebp]
	jbe	SHORT $LN62@xmlParseAt

; 3974 : 			    growBuffer(buf, 10);

	mov	ecx, DWORD PTR _buf_size$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+10]
	mov	DWORD PTR _new_size$10[ebp], edx
	mov	eax, DWORD PTR _new_size$10[ebp]
	cmp	eax, DWORD PTR _buf_size$[ebp]
	jae	SHORT $LN63@xmlParseAt
	jmp	$mem_error$128
$LN63@xmlParseAt:
	mov	esi, esp
	mov	ecx, DWORD PTR _new_size$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$11[ebp], eax
	cmp	DWORD PTR _tmp$11[ebp], 0
	jne	SHORT $LN64@xmlParseAt
	jmp	$mem_error$128
$LN64@xmlParseAt:
	mov	eax, DWORD PTR _tmp$11[ebp]
	mov	DWORD PTR _buf$[ebp], eax
	mov	ecx, DWORD PTR _new_size$10[ebp]
	mov	DWORD PTR _buf_size$[ebp], ecx
$LN62@xmlParseAt:

; 3975 : 			}
; 3976 : 			if (ent->content != NULL)

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN54@xmlParseAt

; 3977 : 			    buf[len++] = ent->content[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
$LN54@xmlParseAt:

; 3978 : 		    }

	jmp	$LN28@xmlParseAt
$LN51@xmlParseAt:

; 3979 : 		} else if (ent != NULL) {

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN28@xmlParseAt

; 3980 : 		    int i = xmlStrlen(ent->name);

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _i$9[ebp], eax

; 3981 : 		    const xmlChar *cur = ent->name;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$8[ebp], edx

; 3982 : 
; 3983 : 		    /*
; 3984 : 		     * This may look absurd but is needed to detect
; 3985 : 		     * entities problems
; 3986 : 		     */
; 3987 : 		    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
; 3988 : 			(ent->content != NULL) && (ent->checked == 0)) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+48], 6
	je	$LN67@xmlParseAt
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	$LN67@xmlParseAt
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+72], 0
	jne	$LN67@xmlParseAt

; 3989 : 			unsigned long oldnbent = ctxt->nbentities;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+440]
	mov	DWORD PTR _oldnbent$7[ebp], ecx

; 3990 : 
; 3991 : 			++ctxt->depth;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+248], eax

; 3992 : 			rep = xmlStringDecodeEntities(ctxt, ent->content,

	push	0
	push	0
	push	0
	push	1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlStringDecodeEntities
	add	esp, 24					; 00000018H
	mov	DWORD PTR _rep$[ebp], eax

; 3993 : 						  XML_SUBSTITUTE_REF, 0, 0, 0);
; 3994 : 			--ctxt->depth;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	sub	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+248], eax

; 3995 : 
; 3996 : 			ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+440]
	sub	eax, DWORD PTR _oldnbent$7[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 3997 : 			if (rep != NULL) {

	cmp	DWORD PTR _rep$[ebp], 0
	je	SHORT $LN68@xmlParseAt

; 3998 : 			    if (xmlStrchr(rep, '<'))

	push	60					; 0000003cH
	mov	eax, DWORD PTR _rep$[ebp]
	push	eax
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN70@xmlParseAt

; 3999 : 			        ent->checked |= 1;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	or	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+72], edx
$LN70@xmlParseAt:

; 4000 : 			    xmlFree(rep);

	mov	esi, esp
	mov	ecx, DWORD PTR _rep$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4001 : 			    rep = NULL;

	mov	DWORD PTR _rep$[ebp], 0

; 4002 : 			} else {

	jmp	SHORT $LN67@xmlParseAt
$LN68@xmlParseAt:

; 4003 :                             ent->content[0] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	BYTE PTR [eax+edx], 0
$LN67@xmlParseAt:

; 4004 :                         }
; 4005 : 		    }
; 4006 : 
; 4007 : 		    /*
; 4008 : 		     * Just output the reference
; 4009 : 		     */
; 4010 : 		    buf[len++] = '&';

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
$LN6@xmlParseAt:

; 4011 : 		    while (len + i + 10 > buf_size) {

	mov	edx, DWORD PTR _i$9[ebp]
	mov	eax, DWORD PTR _len$[ebp]
	lea	ecx, DWORD PTR [eax+edx+10]
	cmp	ecx, DWORD PTR _buf_size$[ebp]
	jbe	SHORT $LN7@xmlParseAt

; 4012 : 			growBuffer(buf, i + 10);

	mov	edx, DWORD PTR _buf_size$[ebp]
	mov	eax, DWORD PTR _i$9[ebp]
	lea	ecx, DWORD PTR [eax+edx*2+10]
	mov	DWORD PTR _new_size$5[ebp], ecx
	mov	edx, DWORD PTR _new_size$5[ebp]
	cmp	edx, DWORD PTR _buf_size$[ebp]
	jae	SHORT $LN71@xmlParseAt
	jmp	$mem_error$128
$LN71@xmlParseAt:
	mov	esi, esp
	mov	eax, DWORD PTR _new_size$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$6[ebp], eax
	cmp	DWORD PTR _tmp$6[ebp], 0
	jne	SHORT $LN72@xmlParseAt
	jmp	$mem_error$128
$LN72@xmlParseAt:
	mov	edx, DWORD PTR _tmp$6[ebp]
	mov	DWORD PTR _buf$[ebp], edx
	mov	eax, DWORD PTR _new_size$5[ebp]
	mov	DWORD PTR _buf_size$[ebp], eax

; 4013 : 		    }

	jmp	SHORT $LN6@xmlParseAt
$LN7@xmlParseAt:

; 4014 : 		    for (;i > 0;i--)

	jmp	SHORT $LN10@xmlParseAt
$LN8@xmlParseAt:
	mov	ecx, DWORD PTR _i$9[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$9[ebp], ecx
$LN10@xmlParseAt:
	cmp	DWORD PTR _i$9[ebp], 0
	jle	SHORT $LN9@xmlParseAt

; 4015 : 			buf[len++] = *cur++;

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _cur$8[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
	mov	eax, DWORD PTR _cur$8[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$8[ebp], eax
	jmp	SHORT $LN8@xmlParseAt
$LN9@xmlParseAt:

; 4016 : 		    buf[len++] = ';';

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
$LN28@xmlParseAt:

; 4017 : 		}
; 4018 : 	    }
; 4019 : 	} else {

	jmp	$LN26@xmlParseAt
$LN25@xmlParseAt:

; 4020 : 	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	SHORT $LN75@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $LN75@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $LN75@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 9
	jne	$LN73@xmlParseAt
$LN75@xmlParseAt:

; 4021 : 	        if ((len != 0) || (!normalize)) {

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN77@xmlParseAt
	cmp	DWORD PTR _normalize$[ebp], 0
	jne	$LN76@xmlParseAt
$LN77@xmlParseAt:

; 4022 : 		    if ((!normalize) || (!in_space)) {

	cmp	DWORD PTR _normalize$[ebp], 0
	je	SHORT $LN79@xmlParseAt
	cmp	DWORD PTR _in_space$[ebp], 0
	jne	$LN78@xmlParseAt
$LN79@xmlParseAt:

; 4023 : 			COPY_BUF(l,buf,len,0x20);

	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN80@xmlParseAt
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	jmp	SHORT $LN11@xmlParseAt
$LN80@xmlParseAt:
	push	32					; 00000020H
	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	push	edx
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN11@xmlParseAt:

; 4024 : 			while (len + 10 > buf_size) {

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 10					; 0000000aH
	cmp	eax, DWORD PTR _buf_size$[ebp]
	jbe	SHORT $LN78@xmlParseAt

; 4025 : 			    growBuffer(buf, 10);

	mov	ecx, DWORD PTR _buf_size$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+10]
	mov	DWORD PTR _new_size$3[ebp], edx
	mov	eax, DWORD PTR _new_size$3[ebp]
	cmp	eax, DWORD PTR _buf_size$[ebp]
	jae	SHORT $LN82@xmlParseAt
	jmp	$mem_error$128
$LN82@xmlParseAt:
	mov	esi, esp
	mov	ecx, DWORD PTR _new_size$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$4[ebp], eax
	cmp	DWORD PTR _tmp$4[ebp], 0
	jne	SHORT $LN83@xmlParseAt
	jmp	$mem_error$128
$LN83@xmlParseAt:
	mov	eax, DWORD PTR _tmp$4[ebp]
	mov	DWORD PTR _buf$[ebp], eax
	mov	ecx, DWORD PTR _new_size$3[ebp]
	mov	DWORD PTR _buf_size$[ebp], ecx

; 4026 : 			}

	jmp	SHORT $LN11@xmlParseAt
$LN78@xmlParseAt:

; 4027 : 		    }
; 4028 : 		    in_space = 1;

	mov	DWORD PTR _in_space$[ebp], 1
$LN76@xmlParseAt:

; 4029 : 		}
; 4030 : 	    } else {

	jmp	$LN15@xmlParseAt
$LN73@xmlParseAt:

; 4031 : 	        in_space = 0;

	mov	DWORD PTR _in_space$[ebp], 0

; 4032 : 		COPY_BUF(l,buf,len,c);

	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN84@xmlParseAt
	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	jmp	SHORT $LN85@xmlParseAt
$LN84@xmlParseAt:
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN85@xmlParseAt:

; 4033 : 		if (len + 10 > buf_size) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 10					; 0000000aH
	cmp	ecx, DWORD PTR _buf_size$[ebp]
	jbe	SHORT $LN15@xmlParseAt

; 4034 : 		    growBuffer(buf, 10);

	mov	edx, DWORD PTR _buf_size$[ebp]
	lea	eax, DWORD PTR [edx+edx+10]
	mov	DWORD PTR _new_size$1[ebp], eax
	mov	ecx, DWORD PTR _new_size$1[ebp]
	cmp	ecx, DWORD PTR _buf_size$[ebp]
	jae	SHORT $LN87@xmlParseAt
	jmp	$mem_error$128
$LN87@xmlParseAt:
	mov	esi, esp
	mov	edx, DWORD PTR _new_size$1[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$2[ebp], eax
	cmp	DWORD PTR _tmp$2[ebp], 0
	jne	SHORT $LN88@xmlParseAt
	jmp	$mem_error$128
$LN88@xmlParseAt:
	mov	ecx, DWORD PTR _tmp$2[ebp]
	mov	DWORD PTR _buf$[ebp], ecx
	mov	edx, DWORD PTR _new_size$1[ebp]
	mov	DWORD PTR _buf_size$[ebp], edx
$LN15@xmlParseAt:

; 4035 : 		}
; 4036 : 	    }
; 4037 : 	    NEXTL(l);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN89@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
	jmp	SHORT $LN90@xmlParseAt
$LN89@xmlParseAt:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN90@xmlParseAt:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	xor	eax, eax
	jne	SHORT $LN15@xmlParseAt
$LN26@xmlParseAt:

; 4038 : 	}
; 4039 : 	GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN91@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN91@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN91@xmlParseAt:

; 4040 : 	c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 4041 :     }

	jmp	$LN2@xmlParseAt
$LN3@xmlParseAt:

; 4042 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN92@xmlParseAt

; 4043 :         goto error;

	jmp	$error$129
$LN92@xmlParseAt:

; 4044 : 
; 4045 :     if ((in_space) && (normalize)) {

	cmp	DWORD PTR _in_space$[ebp], 0
	je	SHORT $LN93@xmlParseAt
	cmp	DWORD PTR _normalize$[ebp], 0
	je	SHORT $LN93@xmlParseAt
$LN16@xmlParseAt:

; 4046 :         while ((len > 0) && (buf[len - 1] == 0x20)) len--;

	cmp	DWORD PTR _len$[ebp], 0
	jbe	SHORT $LN93@xmlParseAt
	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	movzx	eax, BYTE PTR [edx-1]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN93@xmlParseAt
	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	jmp	SHORT $LN16@xmlParseAt
$LN93@xmlParseAt:

; 4047 :     }
; 4048 :     buf[len] = 0;

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 0

; 4049 :     if (RAW == '<') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN94@xmlParseAt

; 4050 : 	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);

	push	0
	push	38					; 00000026H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
	jmp	$LN95@xmlParseAt
$LN94@xmlParseAt:

; 4051 :     } else if (RAW != limit) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _limit$[ebp]
	cmp	edx, eax
	je	$LN96@xmlParseAt

; 4052 : 	if ((c != 0) && (!IS_CHAR(c))) {

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN98@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN123@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 9
	jl	SHORT $LN115@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	jle	SHORT $LN116@xmlParseAt
$LN115@xmlParseAt:
	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $LN116@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jge	SHORT $LN116@xmlParseAt
	mov	DWORD PTR tv556[ebp], 0
	jmp	SHORT $LN122@xmlParseAt
$LN116@xmlParseAt:
	mov	DWORD PTR tv556[ebp], 1
$LN122@xmlParseAt:
	mov	ecx, DWORD PTR tv556[ebp]
	mov	DWORD PTR tv557[ebp], ecx
	jmp	SHORT $LN124@xmlParseAt
$LN123@xmlParseAt:
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jl	SHORT $LN117@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN119@xmlParseAt
$LN117@xmlParseAt:
	cmp	DWORD PTR _c$[ebp], 57344		; 0000e000H
	jl	SHORT $LN118@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN119@xmlParseAt
$LN118@xmlParseAt:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jl	SHORT $LN120@xmlParseAt
	cmp	DWORD PTR _c$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN119@xmlParseAt
$LN120@xmlParseAt:
	mov	DWORD PTR tv555[ebp], 0
	jmp	SHORT $LN121@xmlParseAt
$LN119@xmlParseAt:
	mov	DWORD PTR tv555[ebp], 1
$LN121@xmlParseAt:
	mov	edx, DWORD PTR tv555[ebp]
	mov	DWORD PTR tv557[ebp], edx
$LN124@xmlParseAt:
	cmp	DWORD PTR tv557[ebp], 0
	jne	SHORT $LN98@xmlParseAt

; 4053 : 	    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,

	push	OFFSET ??_C@_0CG@LEIKKIHB@invalid?5character?5in?5attribute?5@
	push	9
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 4054 : 			   "invalid character in attribute value\n");
; 4055 : 	} else {

	jmp	SHORT $LN99@xmlParseAt
$LN98@xmlParseAt:

; 4056 : 	    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,

	push	OFFSET ??_C@_0BG@NKOFEMFC@AttValue?3?5?8?5expected?6@
	push	40					; 00000028H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN99@xmlParseAt:

; 4057 : 			   "AttValue: ' expected\n");
; 4058 :         }
; 4059 :     } else

	jmp	SHORT $LN95@xmlParseAt
$LN96@xmlParseAt:

; 4060 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4
$LN95@xmlParseAt:

; 4061 : 
; 4062 :     /*
; 4063 :      * There we potentially risk an overflow, don't allow attribute value of
; 4064 :      * length more than INT_MAX it is a very reasonnable assumption !
; 4065 :      */
; 4066 :     if (len >= INT_MAX) {

	cmp	DWORD PTR _len$[ebp], 2147483647	; 7fffffffH
	jb	SHORT $LN100@xmlParseAt

; 4067 :         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,

	push	OFFSET ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
	push	40					; 00000028H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 4068 :                        "AttValue length too long\n");
; 4069 :         goto mem_error;

	jmp	SHORT $mem_error$128
$LN100@xmlParseAt:

; 4070 :     }
; 4071 : 
; 4072 :     if (attlen != NULL) *attlen = (int) len;

	cmp	DWORD PTR _attlen$[ebp], 0
	je	SHORT $LN101@xmlParseAt
	mov	ecx, DWORD PTR _attlen$[ebp]
	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], edx
$LN101@xmlParseAt:

; 4073 :     return(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	jmp	SHORT $LN1@xmlParseAt
$mem_error$128:

; 4074 : 
; 4075 : mem_error:
; 4076 :     xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8
$error$129:

; 4077 : error:
; 4078 :     if (buf != NULL)

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN102@xmlParseAt

; 4079 :         xmlFree(buf);

	mov	esi, esp
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN102@xmlParseAt:

; 4080 :     if (rep != NULL)

	cmp	DWORD PTR _rep$[ebp], 0
	je	SHORT $LN103@xmlParseAt

; 4081 :         xmlFree(rep);

	mov	esi, esp
	mov	edx, DWORD PTR _rep$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN103@xmlParseAt:

; 4082 :     return(NULL);

	xor	eax, eax
$LN1@xmlParseAt:

; 4083 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN127@xmlParseAt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 160				; 000000a0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN127@xmlParseAt:
	DD	1
	DD	$LN126@xmlParseAt
$LN126@xmlParseAt:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN125@xmlParseAt
$LN125@xmlParseAt:
	DB	108					; 0000006cH
	DB	0
_xmlParseAttValueComplex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStringName
_TEXT	SEGMENT
_tmp$1 = -152						; size = 4
_max$2 = -148						; size = 4
_buffer$3 = -144					; size = 4
_c$ = -140						; size = 4
_l$ = -132						; size = 4
_len$ = -124						; size = 4
_cur$ = -120						; size = 4
_buf$ = -112						; size = 105
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParseStringName PROC				; COMDAT

; 3512 : xmlParseStringName(xmlParserCtxtPtr ctxt, const xmlChar** str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-152]
	mov	ecx, 38					; 00000026H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 3513 :     xmlChar buf[XML_MAX_NAMELEN + 5];
; 3514 :     const xmlChar *cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 3515 :     int len = 0, l;

	mov	DWORD PTR _len$[ebp], 0

; 3516 :     int c;
; 3517 : 
; 3518 : #ifdef DEBUG
; 3519 :     nbParseStringName++;
; 3520 : #endif
; 3521 : 
; 3522 :     c = CUR_SCHAR(cur, l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _c$[ebp], eax

; 3523 :     if (!xmlIsNameStartChar(ctxt, c)) {

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlIsNameStartChar
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@xmlParseSt

; 3524 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN6@xmlParseSt:

; 3525 :     }
; 3526 : 
; 3527 :     COPY_BUF(l,buf,len,c);

	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN7@xmlParseSt
	mov	ecx, DWORD PTR _len$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN8@xmlParseSt
$LN7@xmlParseSt:
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _len$[ebp]
	lea	eax, DWORD PTR _buf$[ebp+edx]
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN8@xmlParseSt:

; 3528 :     cur += l;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 3529 :     c = CUR_SCHAR(cur, l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _c$[ebp], eax
$LN2@xmlParseSt:

; 3530 :     while (xmlIsNameChar(ctxt, c)) {

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlIsNameChar
	add	esp, 8
	test	eax, eax
	je	$LN3@xmlParseSt

; 3531 : 	COPY_BUF(l,buf,len,c);

	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN9@xmlParseSt
	mov	ecx, DWORD PTR _len$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN10@xmlParseSt
$LN9@xmlParseSt:
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _len$[ebp]
	lea	eax, DWORD PTR _buf$[ebp+edx]
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN10@xmlParseSt:

; 3532 : 	cur += l;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 3533 : 	c = CUR_SCHAR(cur, l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _c$[ebp], eax

; 3534 : 	if (len >= XML_MAX_NAMELEN) { /* test bigentname.xml */

	cmp	DWORD PTR _len$[ebp], 100		; 00000064H
	jl	$LN11@xmlParseSt

; 3535 : 	    /*
; 3536 : 	     * Okay someone managed to make a huge name, so he's ready to pay
; 3537 : 	     * for the processing speed.
; 3538 : 	     */
; 3539 : 	    xmlChar *buffer;
; 3540 : 	    int max = len * 2;

	mov	edx, DWORD PTR _len$[ebp]
	shl	edx, 1
	mov	DWORD PTR _max$2[ebp], edx

; 3541 : 
; 3542 : 	    buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));

	mov	esi, esp
	mov	eax, DWORD PTR _max$2[ebp]
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buffer$3[ebp], eax

; 3543 : 	    if (buffer == NULL) {

	cmp	DWORD PTR _buffer$3[ebp], 0
	jne	SHORT $LN12@xmlParseSt

; 3544 : 	        xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 3545 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN12@xmlParseSt:

; 3546 : 	    }
; 3547 : 	    memcpy(buffer, buf, len);

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN4@xmlParseSt:

; 3548 : 	    while (xmlIsNameChar(ctxt, c)) {

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlIsNameChar
	add	esp, 8
	test	eax, eax
	je	$LN5@xmlParseSt

; 3549 : 		if (len + 10 > max) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 10					; 0000000aH
	cmp	ecx, DWORD PTR _max$2[ebp]
	jle	$LN13@xmlParseSt

; 3550 : 		    xmlChar *tmp;
; 3551 : 
; 3552 :                     if ((len > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _len$[ebp], 50000		; 0000c350H
	jle	SHORT $LN14@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	and	eax, 524288				; 00080000H
	jne	SHORT $LN14@xmlParseSt

; 3553 :                         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3554 :                         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");

	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	110					; 0000006eH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3555 : 			xmlFree(buffer);

	mov	esi, esp
	mov	edx, DWORD PTR _buffer$3[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3556 :                         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN14@xmlParseSt:

; 3557 :                     }
; 3558 : 		    max *= 2;

	mov	eax, DWORD PTR _max$2[ebp]
	shl	eax, 1
	mov	DWORD PTR _max$2[ebp], eax

; 3559 : 		    tmp = (xmlChar *) xmlRealloc(buffer,

	mov	esi, esp
	mov	ecx, DWORD PTR _max$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$3[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 3560 : 			                            max * sizeof(xmlChar));
; 3561 : 		    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN15@xmlParseSt

; 3562 : 			xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 3563 : 			xmlFree(buffer);

	mov	esi, esp
	mov	ecx, DWORD PTR _buffer$3[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3564 : 			return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN15@xmlParseSt:

; 3565 : 		    }
; 3566 : 		    buffer = tmp;

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _buffer$3[ebp], edx
$LN13@xmlParseSt:

; 3567 : 		}
; 3568 : 		COPY_BUF(l,buffer,len,c);

	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN16@xmlParseSt
	mov	eax, DWORD PTR _buffer$3[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
	jmp	SHORT $LN17@xmlParseSt
$LN16@xmlParseSt:
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$3[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	push	ecx
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN17@xmlParseSt:

; 3569 : 		cur += l;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 3570 : 		c = CUR_SCHAR(cur, l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _c$[ebp], eax

; 3571 : 	    }

	jmp	$LN4@xmlParseSt
$LN5@xmlParseSt:

; 3572 : 	    buffer[len] = 0;

	mov	eax, DWORD PTR _buffer$3[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0

; 3573 : 	    *str = cur;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 3574 : 	    return(buffer);

	mov	eax, DWORD PTR _buffer$3[ebp]
	jmp	SHORT $LN1@xmlParseSt
$LN11@xmlParseSt:

; 3575 : 	}
; 3576 :     }

	jmp	$LN2@xmlParseSt
$LN3@xmlParseSt:

; 3577 :     if ((len > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _len$[ebp], 50000		; 0000c350H
	jle	SHORT $LN18@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	jne	SHORT $LN18@xmlParseSt

; 3578 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3579 :         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");

	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	110					; 0000006eH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3580 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseSt
$LN18@xmlParseSt:

; 3581 :     }
; 3582 :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 3583 :     return(xmlStrndup(buf, len));

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
$LN1@xmlParseSt:

; 3584 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@xmlParseSt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 152				; 00000098H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN23@xmlParseSt:
	DD	2
	DD	$LN22@xmlParseSt
$LN22@xmlParseSt:
	DD	-112					; ffffff90H
	DD	105					; 00000069H
	DD	$LN20@xmlParseSt
	DD	-132					; ffffff7cH
	DD	4
	DD	$LN21@xmlParseSt
$LN21@xmlParseSt:
	DB	108					; 0000006cH
	DB	0
$LN20@xmlParseSt:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlParseStringName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNameAndCompare
_TEXT	SEGMENT
_ret$ = -12						; size = 4
_in$ = -8						; size = 4
_cmp$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_other$ = 12						; size = 4
_xmlParseNameAndCompare PROC				; COMDAT

; 3464 : xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 3465 :     register const xmlChar *cmp = other;

	mov	eax, DWORD PTR _other$[ebp]
	mov	DWORD PTR _cmp$[ebp], eax

; 3466 :     register const xmlChar *in;
; 3467 :     const xmlChar *ret;
; 3468 : 
; 3469 :     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN4@xmlParseNa
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN4@xmlParseNa
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseNa:

; 3470 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN5@xmlParseNa

; 3471 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNa
$LN5@xmlParseNa:

; 3472 : 
; 3473 :     in = ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _in$[ebp], edx
$LN2@xmlParseNa:

; 3474 :     while (*in != 0 && *in == *cmp) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@xmlParseNa
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _cmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN3@xmlParseNa

; 3475 : 	++in;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 3476 : 	++cmp;

	mov	ecx, DWORD PTR _cmp$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cmp$[ebp], ecx

; 3477 : 	ctxt->input->col++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx

; 3478 :     }

	jmp	SHORT $LN2@xmlParseNa
$LN3@xmlParseNa:

; 3479 :     if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {

	mov	ecx, DWORD PTR _cmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN6@xmlParseNa
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 62					; 0000003eH
	je	SHORT $LN7@xmlParseNa
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN7@xmlParseNa
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN9@xmlParseNa
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN7@xmlParseNa
$LN9@xmlParseNa:
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN6@xmlParseNa
$LN7@xmlParseNa:

; 3480 : 	/* success */
; 3481 : 	ctxt->input->cur = in;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR [edx+16], eax

; 3482 : 	return (const xmlChar*) 1;

	mov	eax, 1
	jmp	SHORT $LN1@xmlParseNa
$LN6@xmlParseNa:

; 3483 :     }
; 3484 :     /* failure (or end of input buffer), check with full function */
; 3485 :     ret = xmlParseName (ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 3486 :     /* strings coming from the dictionary direct compare possible */
; 3487 :     if (ret == other) {

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	edx, DWORD PTR _other$[ebp]
	jne	SHORT $LN10@xmlParseNa

; 3488 : 	return (const xmlChar*) 1;

	mov	eax, 1
	jmp	SHORT $LN1@xmlParseNa
$LN10@xmlParseNa:

; 3489 :     }
; 3490 :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseNa:

; 3491 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseNameAndCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNCName
_TEXT	SEGMENT
_count$ = -16						; size = 4
_ret$ = -12						; size = 4
_e$ = -8						; size = 4
_in$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseNCName PROC					; COMDAT

; 3405 : xmlParseNCName(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 3406 :     const xmlChar *in, *e;
; 3407 :     const xmlChar *ret;
; 3408 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3409 : 
; 3410 : #ifdef DEBUG
; 3411 :     nbParseNCName++;
; 3412 : #endif
; 3413 : 
; 3414 :     /*
; 3415 :      * Accelerator for simple ASCII names
; 3416 :      */
; 3417 :     in = ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _in$[ebp], edx

; 3418 :     e = ctxt->input->end;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _e$[ebp], edx

; 3419 :     if ((((*in >= 0x61) && (*in <= 0x7A)) ||
; 3420 : 	 ((*in >= 0x41) && (*in <= 0x5A)) ||
; 3421 : 	 (*in == '_')) && (in < e)) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN6@xmlParseNC
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 122				; 0000007aH
	jle	SHORT $LN5@xmlParseNC
$LN6@xmlParseNC:
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN7@xmlParseNC
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	jle	SHORT $LN5@xmlParseNC
$LN7@xmlParseNC:
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	jne	$_complex$17
$LN5@xmlParseNC:
	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _e$[ebp]
	jae	$_complex$17

; 3422 : 	in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx
$LN2@xmlParseNC:

; 3423 : 	while ((((*in >= 0x61) && (*in <= 0x7A)) ||
; 3424 : 	        ((*in >= 0x41) && (*in <= 0x5A)) ||
; 3425 : 	        ((*in >= 0x30) && (*in <= 0x39)) ||
; 3426 : 	        (*in == '_') || (*in == '-') ||
; 3427 : 	        (*in == '.')) && (in < e))

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN9@xmlParseNC
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 122				; 0000007aH
	jle	SHORT $LN8@xmlParseNC
$LN9@xmlParseNC:
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN10@xmlParseNC
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	jle	SHORT $LN8@xmlParseNC
$LN10@xmlParseNC:
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN11@xmlParseNC
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN8@xmlParseNC
$LN11@xmlParseNC:
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	je	SHORT $LN8@xmlParseNC
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN8@xmlParseNC
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN3@xmlParseNC
$LN8@xmlParseNC:
	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _e$[ebp]
	jae	SHORT $LN3@xmlParseNC

; 3428 : 	    in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	jmp	SHORT $LN2@xmlParseNC
$LN3@xmlParseNC:

; 3429 : 	if (in >= e)

	mov	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _e$[ebp]
	jb	SHORT $LN12@xmlParseNC

; 3430 : 	    goto complex;

	jmp	$_complex$17
$LN12@xmlParseNC:

; 3431 : 	if ((*in > 0) && (*in < 0x80)) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jle	$_complex$17
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 128				; 00000080H
	jge	$_complex$17

; 3432 : 	    count = in - ctxt->input->cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _in$[ebp]
	sub	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _count$[ebp], eax

; 3433 :             if ((count > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _count$[ebp], 50000		; 0000c350H
	jle	SHORT $LN14@xmlParseNC
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN14@xmlParseNC

; 3434 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3435 :                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");

	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	110					; 0000006eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3436 :                 return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseNC
$LN14@xmlParseNC:

; 3437 :             }
; 3438 : 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);

	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 3439 : 	    ctxt->input->cur = in;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR [edx+16], eax

; 3440 : 	    ctxt->nbChars += count;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx

; 3441 : 	    ctxt->input->col += count;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax

; 3442 : 	    if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN15@xmlParseNC

; 3443 : 	        xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8
$LN15@xmlParseNC:

; 3444 : 	    }
; 3445 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParseNC
$_complex$17:

; 3446 : 	}
; 3447 :     }
; 3448 : complex:
; 3449 :     return(xmlParseNCNameComplex(ctxt));

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseNCNameComplex
	add	esp, 4
$LN1@xmlParseNC:

; 3450 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseNCName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNCNameComplex
_TEXT	SEGMENT
tv132 = -36						; size = 4
tv131 = -32						; size = 4
_startPosition$ = -28					; size = 4
_count$ = -24						; size = 4
_c$ = -20						; size = 4
_l$ = -12						; size = 4
_len$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseNCNameComplex PROC				; COMDAT

; 3329 : xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 3330 :     int len = 0, l;

	mov	DWORD PTR _len$[ebp], 0

; 3331 :     int c;
; 3332 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3333 :     size_t startPosition = 0;

	mov	DWORD PTR _startPosition$[ebp], 0

; 3334 : 
; 3335 : #ifdef DEBUG
; 3336 :     nbParseNCNameComplex++;
; 3337 : #endif
; 3338 : 
; 3339 :     /*
; 3340 :      * Handler for more complex cases
; 3341 :      */
; 3342 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN7@xmlParseNC
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN7@xmlParseNC
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN7@xmlParseNC:

; 3343 :     startPosition = CUR_PTR - BASE_PTR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _startPosition$[ebp], edx

; 3344 :     c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 3345 :     if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	SHORT $LN9@xmlParseNC
	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	je	SHORT $LN9@xmlParseNC
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	je	SHORT $LN9@xmlParseNC
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlIsNameStartChar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlParseNC
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	jne	SHORT $LN2@xmlParseNC
$LN9@xmlParseNC:

; 3346 : 	(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {
; 3347 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNC
$LN2@xmlParseNC:

; 3348 :     }
; 3349 : 
; 3350 :     while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	$LN3@xmlParseNC
	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	je	$LN3@xmlParseNC
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	je	$LN3@xmlParseNC
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlIsNameChar
	add	esp, 8
	test	eax, eax
	je	$LN3@xmlParseNC
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	$LN3@xmlParseNC

; 3351 : 	   (xmlIsNameChar(ctxt, c) && (c != ':'))) {
; 3352 : 	if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv131[ebp], eax
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	cmp	DWORD PTR tv131[ebp], 100		; 00000064H
	jle	SHORT $LN22@xmlParseNC
	mov	DWORD PTR tv132[ebp], 1
	jmp	SHORT $LN23@xmlParseNC
$LN22@xmlParseNC:
	mov	DWORD PTR tv132[ebp], 0
$LN23@xmlParseNC:
	cmp	DWORD PTR tv132[ebp], 0
	je	SHORT $LN11@xmlParseNC

; 3353 :             if ((len > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _len$[ebp], 50000		; 0000c350H
	jle	SHORT $LN12@xmlParseNC
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	and	eax, 524288				; 00080000H
	jne	SHORT $LN12@xmlParseNC

; 3354 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3355 :                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");

	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	110					; 0000006eH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3356 :                 return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNC
$LN12@xmlParseNC:

; 3357 :             }
; 3358 : 	    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3359 : 	    GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN13@xmlParseNC
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN13@xmlParseNC
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN13@xmlParseNC:

; 3360 :             if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN11@xmlParseNC

; 3361 :                 return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNC
$LN11@xmlParseNC:

; 3362 : 	}
; 3363 : 	len += l;

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _len$[ebp], ecx
$LN6@xmlParseNC:

; 3364 : 	NEXTL(l);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN15@xmlParseNC
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+28], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN16@xmlParseNC
$LN15@xmlParseNC:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
$LN16@xmlParseNC:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	xor	edx, edx
	jne	SHORT $LN6@xmlParseNC

; 3365 : 	c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 3366 : 	if (c == 0) {

	cmp	DWORD PTR _c$[ebp], 0
	jne	$LN17@xmlParseNC

; 3367 : 	    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3368 : 	    /*
; 3369 : 	     * when shrinking to extend the buffer we really need to preserve
; 3370 : 	     * the part of the name we already parsed. Hence rolling back
; 3371 : 	     * by current lenght.
; 3372 : 	     */
; 3373 : 	    ctxt->input->cur -= l;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx

; 3374 : 	    GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN18@xmlParseNC
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN18@xmlParseNC
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN18@xmlParseNC:

; 3375 :             if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN19@xmlParseNC

; 3376 :                 return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNC
$LN19@xmlParseNC:

; 3377 : 	    ctxt->input->cur += l;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx

; 3378 : 	    c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
$LN17@xmlParseNC:

; 3379 : 	}
; 3380 :     }

	jmp	$LN2@xmlParseNC
$LN3@xmlParseNC:

; 3381 :     if ((len > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _len$[ebp], 50000		; 0000c350H
	jle	SHORT $LN20@xmlParseNC
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN20@xmlParseNC

; 3382 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3383 :         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");

	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	push	110					; 0000006eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3384 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseNC
$LN20@xmlParseNC:

; 3385 :     }
; 3386 :     return(xmlDictLookup(ctxt->dict, (BASE_PTR + startPosition), len));

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _startPosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
$LN1@xmlParseNC:

; 3387 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN26@xmlParseNC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN26@xmlParseNC:
	DD	1
	DD	$LN25@xmlParseNC
$LN25@xmlParseNC:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN24@xmlParseNC
$LN24@xmlParseNC:
	DB	108					; 0000006cH
	DB	0
_xmlParseNCNameComplex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNameComplex
_TEXT	SEGMENT
tv385 = -92						; size = 4
tv384 = -88						; size = 4
tv380 = -84						; size = 4
tv379 = -80						; size = 4
tv372 = -76						; size = 4
tv362 = -72						; size = 4
tv361 = -68						; size = 4
tv352 = -64						; size = 4
tv353 = -60						; size = 4
tv344 = -56						; size = 4
tv343 = -52						; size = 4
tv291 = -48						; size = 4
tv292 = -44						; size = 4
tv283 = -40						; size = 4
tv282 = -36						; size = 4
tv222 = -32						; size = 4
tv221 = -28						; size = 4
_count$ = -24						; size = 4
_c$ = -20						; size = 4
_l$ = -12						; size = 4
_len$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseNameComplex PROC				; COMDAT

; 3146 : xmlParseNameComplex(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	edi
	lea	edi, DWORD PTR [ebp-92]
	mov	ecx, 23					; 00000017H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 3147 :     int len = 0, l;

	mov	DWORD PTR _len$[ebp], 0

; 3148 :     int c;
; 3149 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3150 : 
; 3151 : #ifdef DEBUG
; 3152 :     nbParseNameComplex++;
; 3153 : #endif
; 3154 : 
; 3155 :     /*
; 3156 :      * Handler for more complex cases
; 3157 :      */
; 3158 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN18@xmlParseNa
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN18@xmlParseNa
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN18@xmlParseNa:

; 3159 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN19@xmlParseNa

; 3160 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNa
$LN19@xmlParseNa:

; 3161 :     c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 3162 :     if ((ctxt->options & XML_PARSE_OLD10) == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 131072				; 00020000H
	jne	$LN20@xmlParseNa

; 3163 :         /*
; 3164 : 	 * Use the new checks of production [4] [4a] amd [5] of the
; 3165 : 	 * Update 5 of XML-1.0
; 3166 : 	 */
; 3167 : 	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	$LN23@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	je	$LN23@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	je	$LN23@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN24@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	$LN22@xmlParseNa
$LN24@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN25@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	$LN22@xmlParseNa
$LN25@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	je	$LN22@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	$LN22@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 192			; 000000c0H
	jl	SHORT $LN26@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 214			; 000000d6H
	jle	$LN22@xmlParseNa
$LN26@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 216			; 000000d8H
	jl	SHORT $LN27@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 246			; 000000f6H
	jle	$LN22@xmlParseNa
$LN27@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jl	SHORT $LN28@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 767			; 000002ffH
	jle	$LN22@xmlParseNa
$LN28@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 880			; 00000370H
	jl	SHORT $LN29@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 893			; 0000037dH
	jle	$LN22@xmlParseNa
$LN29@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 895			; 0000037fH
	jl	SHORT $LN30@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 8191		; 00001fffH
	jle	$LN22@xmlParseNa
$LN30@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 8204		; 0000200cH
	jl	SHORT $LN31@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 8205		; 0000200dH
	jle	SHORT $LN22@xmlParseNa
$LN31@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 8304		; 00002070H
	jl	SHORT $LN32@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 8591		; 0000218fH
	jle	SHORT $LN22@xmlParseNa
$LN32@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 11264		; 00002c00H
	jl	SHORT $LN33@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 12271		; 00002fefH
	jle	SHORT $LN22@xmlParseNa
$LN33@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 12289		; 00003001H
	jl	SHORT $LN34@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN22@xmlParseNa
$LN34@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 63744		; 0000f900H
	jl	SHORT $LN35@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 64975		; 0000fdcfH
	jle	SHORT $LN22@xmlParseNa
$LN35@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 65008		; 0000fdf0H
	jl	SHORT $LN36@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN22@xmlParseNa
$LN36@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jl	SHORT $LN23@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 983039		; 000effffH
	jle	SHORT $LN22@xmlParseNa
$LN23@xmlParseNa:

; 3168 : 	    (!(((c >= 'a') && (c <= 'z')) ||
; 3169 : 	       ((c >= 'A') && (c <= 'Z')) ||
; 3170 : 	       (c == '_') || (c == ':') ||
; 3171 : 	       ((c >= 0xC0) && (c <= 0xD6)) ||
; 3172 : 	       ((c >= 0xD8) && (c <= 0xF6)) ||
; 3173 : 	       ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3174 : 	       ((c >= 0x370) && (c <= 0x37D)) ||
; 3175 : 	       ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3176 : 	       ((c >= 0x200C) && (c <= 0x200D)) ||
; 3177 : 	       ((c >= 0x2070) && (c <= 0x218F)) ||
; 3178 : 	       ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3179 : 	       ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3180 : 	       ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3181 : 	       ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
; 3182 : 	       ((c >= 0x10000) && (c <= 0xEFFFF))))) {
; 3183 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNa
$LN22@xmlParseNa:

; 3184 : 	}
; 3185 : 	len += l;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN4@xmlParseNa:

; 3186 : 	NEXTL(l);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN38@xmlParseNa
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], 1
	jmp	SHORT $LN39@xmlParseNa
$LN38@xmlParseNa:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
$LN39@xmlParseNa:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseNa

; 3187 : 	c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
$LN5@xmlParseNa:

; 3188 : 	while ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	$LN6@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	je	$LN6@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	je	$LN6@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN41@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	$LN40@xmlParseNa
$LN41@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN42@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	$LN40@xmlParseNa
$LN42@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN43@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jle	$LN40@xmlParseNa
$LN43@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	je	$LN40@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	$LN40@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 45			; 0000002dH
	je	$LN40@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 46			; 0000002eH
	je	$LN40@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 183			; 000000b7H
	je	$LN40@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 192			; 000000c0H
	jl	SHORT $LN44@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 214			; 000000d6H
	jle	$LN40@xmlParseNa
$LN44@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 216			; 000000d8H
	jl	SHORT $LN45@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 246			; 000000f6H
	jle	$LN40@xmlParseNa
$LN45@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jl	SHORT $LN46@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 767			; 000002ffH
	jle	$LN40@xmlParseNa
$LN46@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 768			; 00000300H
	jl	SHORT $LN47@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 879			; 0000036fH
	jle	$LN40@xmlParseNa
$LN47@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 880			; 00000370H
	jl	SHORT $LN48@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 893			; 0000037dH
	jle	$LN40@xmlParseNa
$LN48@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 895			; 0000037fH
	jl	SHORT $LN49@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 8191		; 00001fffH
	jle	$LN40@xmlParseNa
$LN49@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 8204		; 0000200cH
	jl	SHORT $LN50@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 8205		; 0000200dH
	jle	$LN40@xmlParseNa
$LN50@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 8255		; 0000203fH
	jl	SHORT $LN51@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 8256		; 00002040H
	jle	SHORT $LN40@xmlParseNa
$LN51@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 8304		; 00002070H
	jl	SHORT $LN52@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 8591		; 0000218fH
	jle	SHORT $LN40@xmlParseNa
$LN52@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 11264		; 00002c00H
	jl	SHORT $LN53@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 12271		; 00002fefH
	jle	SHORT $LN40@xmlParseNa
$LN53@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 12289		; 00003001H
	jl	SHORT $LN54@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN40@xmlParseNa
$LN54@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 63744		; 0000f900H
	jl	SHORT $LN55@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 64975		; 0000fdcfH
	jle	SHORT $LN40@xmlParseNa
$LN55@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 65008		; 0000fdf0H
	jl	SHORT $LN56@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN40@xmlParseNa
$LN56@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jl	$LN6@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 983039		; 000effffH
	jg	$LN6@xmlParseNa
$LN40@xmlParseNa:

; 3189 : 	       (((c >= 'a') && (c <= 'z')) ||
; 3190 : 	        ((c >= 'A') && (c <= 'Z')) ||
; 3191 : 	        ((c >= '0') && (c <= '9')) || /* !start */
; 3192 : 	        (c == '_') || (c == ':') ||
; 3193 : 	        (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
; 3194 : 	        ((c >= 0xC0) && (c <= 0xD6)) ||
; 3195 : 	        ((c >= 0xD8) && (c <= 0xF6)) ||
; 3196 : 	        ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3197 : 	        ((c >= 0x300) && (c <= 0x36F)) || /* !start */
; 3198 : 	        ((c >= 0x370) && (c <= 0x37D)) ||
; 3199 : 	        ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3200 : 	        ((c >= 0x200C) && (c <= 0x200D)) ||
; 3201 : 	        ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
; 3202 : 	        ((c >= 0x2070) && (c <= 0x218F)) ||
; 3203 : 	        ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3204 : 	        ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3205 : 	        ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3206 : 	        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
; 3207 : 	        ((c >= 0x10000) && (c <= 0xEFFFF))
; 3208 : 		)) {
; 3209 : 	    if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv221[ebp], ecx
	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx
	cmp	DWORD PTR tv221[ebp], 100		; 00000064H
	jle	SHORT $LN76@xmlParseNa
	mov	DWORD PTR tv222[ebp], 1
	jmp	SHORT $LN77@xmlParseNa
$LN76@xmlParseNa:
	mov	DWORD PTR tv222[ebp], 0
$LN77@xmlParseNa:
	cmp	DWORD PTR tv222[ebp], 0
	je	SHORT $LN57@xmlParseNa

; 3210 : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3211 : 		GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN58@xmlParseNa
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN58@xmlParseNa
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN58@xmlParseNa:

; 3212 :                 if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN57@xmlParseNa

; 3213 :                     return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNa
$LN57@xmlParseNa:

; 3214 : 	    }
; 3215 : 	    len += l;

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _len$[ebp], edx
$LN9@xmlParseNa:

; 3216 : 	    NEXTL(l);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN60@xmlParseNa
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
	jmp	SHORT $LN61@xmlParseNa
$LN60@xmlParseNa:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN61@xmlParseNa:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	xor	eax, eax
	jne	SHORT $LN9@xmlParseNa

; 3217 : 	    c = CUR_CHAR(l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 3218 : 	}

	jmp	$LN5@xmlParseNa
$LN6@xmlParseNa:

; 3219 :     } else {

	jmp	$LN21@xmlParseNa
$LN20@xmlParseNa:

; 3220 : 	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	$LN63@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	je	$LN63@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	je	$LN63@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN84@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN78@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	SHORT $LN80@xmlParseNa
$LN78@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN79@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	SHORT $LN80@xmlParseNa
$LN79@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 192			; 000000c0H
	jl	SHORT $LN81@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 214			; 000000d6H
	jle	SHORT $LN80@xmlParseNa
$LN81@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 216			; 000000d8H
	jl	SHORT $LN82@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 246			; 000000f6H
	jle	SHORT $LN80@xmlParseNa
$LN82@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jge	SHORT $LN80@xmlParseNa
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN83@xmlParseNa
$LN80@xmlParseNa:
	mov	DWORD PTR tv282[ebp], 1
$LN83@xmlParseNa:
	mov	eax, DWORD PTR tv282[ebp]
	mov	DWORD PTR tv283[ebp], eax
	jmp	SHORT $LN85@xmlParseNa
$LN84@xmlParseNa:
	push	OFFSET _xmlIsBaseCharGroup
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv283[ebp], eax
$LN85@xmlParseNa:
	cmp	DWORD PTR tv283[ebp], 0
	jne	SHORT $LN62@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN90@xmlParseNa
	mov	DWORD PTR tv292[ebp], 0
	jmp	SHORT $LN91@xmlParseNa
$LN90@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 19968		; 00004e00H
	jl	SHORT $LN86@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 40869		; 00009fa5H
	jle	SHORT $LN87@xmlParseNa
$LN86@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 12295		; 00003007H
	je	SHORT $LN87@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 12321		; 00003021H
	jl	SHORT $LN88@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 12329		; 00003029H
	jle	SHORT $LN87@xmlParseNa
$LN88@xmlParseNa:
	mov	DWORD PTR tv291[ebp], 0
	jmp	SHORT $LN89@xmlParseNa
$LN87@xmlParseNa:
	mov	DWORD PTR tv291[ebp], 1
$LN89@xmlParseNa:
	mov	edx, DWORD PTR tv291[ebp]
	mov	DWORD PTR tv292[ebp], edx
$LN91@xmlParseNa:
	cmp	DWORD PTR tv292[ebp], 0
	jne	SHORT $LN62@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	je	SHORT $LN62@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	SHORT $LN62@xmlParseNa
$LN63@xmlParseNa:

; 3221 : 	    (!IS_LETTER(c) && (c != '_') &&
; 3222 : 	     (c != ':'))) {
; 3223 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNa
$LN62@xmlParseNa:

; 3224 : 	}
; 3225 : 	len += l;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN12@xmlParseNa:

; 3226 : 	NEXTL(l);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN64@xmlParseNa
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], 1
	jmp	SHORT $LN65@xmlParseNa
$LN64@xmlParseNa:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
$LN65@xmlParseNa:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	xor	ecx, ecx
	jne	SHORT $LN12@xmlParseNa

; 3227 : 	c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
$LN13@xmlParseNa:

; 3228 : 
; 3229 : 	while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	$LN21@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	je	$LN21@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	je	$LN21@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN98@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN92@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	SHORT $LN94@xmlParseNa
$LN92@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN93@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	SHORT $LN94@xmlParseNa
$LN93@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 192			; 000000c0H
	jl	SHORT $LN95@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 214			; 000000d6H
	jle	SHORT $LN94@xmlParseNa
$LN95@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 216			; 000000d8H
	jl	SHORT $LN96@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 246			; 000000f6H
	jle	SHORT $LN94@xmlParseNa
$LN96@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jge	SHORT $LN94@xmlParseNa
	mov	DWORD PTR tv343[ebp], 0
	jmp	SHORT $LN97@xmlParseNa
$LN94@xmlParseNa:
	mov	DWORD PTR tv343[ebp], 1
$LN97@xmlParseNa:
	mov	ecx, DWORD PTR tv343[ebp]
	mov	DWORD PTR tv344[ebp], ecx
	jmp	SHORT $LN99@xmlParseNa
$LN98@xmlParseNa:
	push	OFFSET _xmlIsBaseCharGroup
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv344[ebp], eax
$LN99@xmlParseNa:
	cmp	DWORD PTR tv344[ebp], 0
	jne	$LN66@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN104@xmlParseNa
	mov	DWORD PTR tv353[ebp], 0
	jmp	SHORT $LN105@xmlParseNa
$LN104@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 19968		; 00004e00H
	jl	SHORT $LN100@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 40869		; 00009fa5H
	jle	SHORT $LN101@xmlParseNa
$LN100@xmlParseNa:
	cmp	DWORD PTR _c$[ebp], 12295		; 00003007H
	je	SHORT $LN101@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 12321		; 00003021H
	jl	SHORT $LN102@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 12329		; 00003029H
	jle	SHORT $LN101@xmlParseNa
$LN102@xmlParseNa:
	mov	DWORD PTR tv352[ebp], 0
	jmp	SHORT $LN103@xmlParseNa
$LN101@xmlParseNa:
	mov	DWORD PTR tv352[ebp], 1
$LN103@xmlParseNa:
	mov	eax, DWORD PTR tv352[ebp]
	mov	DWORD PTR tv353[ebp], eax
$LN105@xmlParseNa:
	cmp	DWORD PTR tv353[ebp], 0
	jne	$LN66@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN108@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN106@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jg	SHORT $LN106@xmlParseNa
	mov	DWORD PTR tv361[ebp], 1
	jmp	SHORT $LN107@xmlParseNa
$LN106@xmlParseNa:
	mov	DWORD PTR tv361[ebp], 0
$LN107@xmlParseNa:
	mov	ecx, DWORD PTR tv361[ebp]
	mov	DWORD PTR tv362[ebp], ecx
	jmp	SHORT $LN109@xmlParseNa
$LN108@xmlParseNa:
	push	OFFSET _xmlIsDigitGroup
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv362[ebp], eax
$LN109@xmlParseNa:
	cmp	DWORD PTR tv362[ebp], 0
	jne	$LN66@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 46			; 0000002eH
	je	$LN66@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 45			; 0000002dH
	je	$LN66@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	je	SHORT $LN66@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	SHORT $LN66@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN110@xmlParseNa
	mov	DWORD PTR tv372[ebp], 0
	jmp	SHORT $LN111@xmlParseNa
$LN110@xmlParseNa:
	push	OFFSET _xmlIsCombiningGroup
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv372[ebp], eax
$LN111@xmlParseNa:
	cmp	DWORD PTR tv372[ebp], 0
	jne	SHORT $LN66@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN114@xmlParseNa
	cmp	DWORD PTR _c$[ebp], 183			; 000000b7H
	jne	SHORT $LN112@xmlParseNa
	mov	DWORD PTR tv379[ebp], 1
	jmp	SHORT $LN113@xmlParseNa
$LN112@xmlParseNa:
	mov	DWORD PTR tv379[ebp], 0
$LN113@xmlParseNa:
	mov	ecx, DWORD PTR tv379[ebp]
	mov	DWORD PTR tv380[ebp], ecx
	jmp	SHORT $LN115@xmlParseNa
$LN114@xmlParseNa:
	push	OFFSET _xmlIsExtenderGroup
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv380[ebp], eax
$LN115@xmlParseNa:
	cmp	DWORD PTR tv380[ebp], 0
	je	$LN21@xmlParseNa
$LN66@xmlParseNa:

; 3230 : 	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 3231 : 		(c == '.') || (c == '-') ||
; 3232 : 		(c == '_') || (c == ':') ||
; 3233 : 		(IS_COMBINING(c)) ||
; 3234 : 		(IS_EXTENDER(c)))) {
; 3235 : 	    if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv384[ebp], eax
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	cmp	DWORD PTR tv384[ebp], 100		; 00000064H
	jle	SHORT $LN116@xmlParseNa
	mov	DWORD PTR tv385[ebp], 1
	jmp	SHORT $LN117@xmlParseNa
$LN116@xmlParseNa:
	mov	DWORD PTR tv385[ebp], 0
$LN117@xmlParseNa:
	cmp	DWORD PTR tv385[ebp], 0
	je	SHORT $LN67@xmlParseNa

; 3236 : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3237 : 		GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN68@xmlParseNa
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN68@xmlParseNa
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN68@xmlParseNa:

; 3238 :                 if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN67@xmlParseNa

; 3239 :                     return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNa
$LN67@xmlParseNa:

; 3240 : 	    }
; 3241 : 	    len += l;

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _len$[ebp], ecx
$LN17@xmlParseNa:

; 3242 : 	    NEXTL(l);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN70@xmlParseNa
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+28], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN71@xmlParseNa
$LN70@xmlParseNa:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
$LN71@xmlParseNa:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	xor	edx, edx
	jne	SHORT $LN17@xmlParseNa

; 3243 : 	    c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 3244 : 	}

	jmp	$LN13@xmlParseNa
$LN21@xmlParseNa:

; 3245 :     }
; 3246 :     if ((len > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _len$[ebp], 50000		; 0000c350H
	jle	SHORT $LN72@xmlParseNa
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	and	eax, 524288				; 00080000H
	jne	SHORT $LN72@xmlParseNa

; 3247 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3248 :         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");

	push	OFFSET ??_C@_04FABLJDN@Name@
	push	110					; 0000006eH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3249 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNa
$LN72@xmlParseNa:

; 3250 :     }
; 3251 :     if (ctxt->input->cur - ctxt->input->base < len) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _len$[ebp]
	jge	SHORT $LN73@xmlParseNa

; 3252 :         /*
; 3253 :          * There were a couple of bugs where PERefs lead to to a change
; 3254 :          * of the buffer. Check the buffer size to avoid passing an invalid
; 3255 :          * pointer to xmlDictLookup.
; 3256 :          */
; 3257 :         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CC@JIBKNHBD@unexpected?5change?5of?5input?5buff@
	push	1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3258 :                     "unexpected change of input buffer");
; 3259 :         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseNa
$LN73@xmlParseNa:

; 3260 :     }
; 3261 :     if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r'))

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN74@xmlParseNa
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, -1
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN74@xmlParseNa

; 3262 :         return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@xmlParseNa
$LN74@xmlParseNa:

; 3263 :     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
$LN1@xmlParseNa:

; 3264 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN120@xmlParseNa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 92					; 0000005cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN120@xmlParseNa:
	DD	1
	DD	$LN119@xmlParseNa
$LN119@xmlParseNa:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN118@xmlParseNa
$LN118@xmlParseNa:
	DB	108					; 0000006cH
	DB	0
_xmlParseNameComplex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttValueInternal
_TEXT	SEGMENT
tv212 = -80						; size = 4
tv211 = -76						; size = 4
_delta$1 = -72						; size = 4
_oldbase$2 = -68					; size = 4
_delta$3 = -64						; size = 4
_oldbase$4 = -60					; size = 4
_delta$5 = -56						; size = 4
_oldbase$6 = -52					; size = 4
_delta$7 = -48						; size = 4
_oldbase$8 = -44					; size = 4
_delta$9 = -40						; size = 4
_oldbase$10 = -36					; size = 4
_col$ = -32						; size = 4
_line$ = -28						; size = 4
_ret$ = -24						; size = 4
_last$ = -20						; size = 4
_end$ = -16						; size = 4
_start$ = -12						; size = 4
_in$ = -8						; size = 4
_limit$ = -1						; size = 1
_ctxt$ = 8						; size = 4
_len$ = 12						; size = 4
_alloc$ = 16						; size = 4
_normalize$ = 20					; size = 4
_xmlParseAttValueInternal PROC				; COMDAT

; 8848 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	edi
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 8849 :     xmlChar limit = 0;

	mov	BYTE PTR _limit$[ebp], 0

; 8850 :     const xmlChar *in = NULL, *start, *end, *last;

	mov	DWORD PTR _in$[ebp], 0

; 8851 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 8852 :     int line, col;
; 8853 : 
; 8854 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN12@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN12@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN12@xmlParseAt:

; 8855 :     in = (xmlChar *) CUR_PTR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _in$[ebp], eax

; 8856 :     line = ctxt->input->line;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _line$[ebp], eax

; 8857 :     col = ctxt->input->col;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _col$[ebp], eax

; 8858 :     if (*in != '"' && *in != '\'') {

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	je	SHORT $LN13@xmlParseAt
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	je	SHORT $LN13@xmlParseAt

; 8859 :         xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);

	push	0
	push	39					; 00000027H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 8860 :         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN13@xmlParseAt:

; 8861 :     }
; 8862 :     ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 12			; 0000000cH

; 8863 : 
; 8864 :     /*
; 8865 :      * try to handle in this routine the most common case where no
; 8866 :      * allocation of a new string is required and where content is
; 8867 :      * pure ASCII.
; 8868 :      */
; 8869 :     limit = *in++;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _limit$[ebp], dl
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 8870 :     col++;

	mov	ecx, DWORD PTR _col$[ebp]
	add	ecx, 1
	mov	DWORD PTR _col$[ebp], ecx

; 8871 :     end = ctxt->input->end;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _end$[ebp], ecx

; 8872 :     start = in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _start$[ebp], edx

; 8873 :     if (in >= end) {

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jb	SHORT $LN14@xmlParseAt

; 8874 :         const xmlChar *oldbase = ctxt->input->base;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _oldbase$10[ebp], eax

; 8875 : 	GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN15@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN15@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN15@xmlParseAt:

; 8876 : 	if (oldbase != ctxt->input->base) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _oldbase$10[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	je	SHORT $LN16@xmlParseAt

; 8877 : 	    long delta = ctxt->input->base - oldbase;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _oldbase$10[ebp]
	mov	DWORD PTR _delta$9[ebp], ecx

; 8878 : 	    start = start + delta;

	mov	edx, DWORD PTR _start$[ebp]
	add	edx, DWORD PTR _delta$9[ebp]
	mov	DWORD PTR _start$[ebp], edx

; 8879 : 	    in = in + delta;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _delta$9[ebp]
	mov	DWORD PTR _in$[ebp], eax
$LN16@xmlParseAt:

; 8880 : 	}
; 8881 : 	end = ctxt->input->end;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _end$[ebp], eax
$LN14@xmlParseAt:

; 8882 :     }
; 8883 :     if (normalize) {

	cmp	DWORD PTR _normalize$[ebp], 0
	je	$LN10@xmlParseAt
$LN2@xmlParseAt:

; 8884 :         /*
; 8885 : 	 * Skip any leading spaces
; 8886 : 	 */
; 8887 : 	while ((in < end) && (*in != limit) &&

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jae	$LN4@xmlParseAt
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _limit$[ebp]
	cmp	eax, ecx
	je	$LN4@xmlParseAt
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN19@xmlParseAt
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	je	SHORT $LN19@xmlParseAt
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN19@xmlParseAt
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	$LN4@xmlParseAt
$LN19@xmlParseAt:

; 8888 : 	       ((*in == 0x20) || (*in == 0x9) ||
; 8889 : 	        (*in == 0xA) || (*in == 0xD))) {
; 8890 : 	    if (*in == 0xA) {

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN20@xmlParseAt

; 8891 : 	        line++; col = 1;

	mov	eax, DWORD PTR _line$[ebp]
	add	eax, 1
	mov	DWORD PTR _line$[ebp], eax
	mov	DWORD PTR _col$[ebp], 1

; 8892 : 	    } else {

	jmp	SHORT $LN21@xmlParseAt
$LN20@xmlParseAt:

; 8893 : 	        col++;

	mov	ecx, DWORD PTR _col$[ebp]
	add	ecx, 1
	mov	DWORD PTR _col$[ebp], ecx
$LN21@xmlParseAt:

; 8894 : 	    }
; 8895 : 	    in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx

; 8896 : 	    start = in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 8897 : 	    if (in >= end) {

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jb	$LN22@xmlParseAt

; 8898 : 		const xmlChar *oldbase = ctxt->input->base;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _oldbase$8[ebp], ecx

; 8899 : 		GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN23@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN23@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN23@xmlParseAt:

; 8900 :                 if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN24@xmlParseAt

; 8901 :                     return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN24@xmlParseAt:

; 8902 : 		if (oldbase != ctxt->input->base) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _oldbase$8[ebp]
	cmp	eax, DWORD PTR [edx+12]
	je	SHORT $LN25@xmlParseAt

; 8903 : 		    long delta = ctxt->input->base - oldbase;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR _oldbase$8[ebp]
	mov	DWORD PTR _delta$7[ebp], eax

; 8904 : 		    start = start + delta;

	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, DWORD PTR _delta$7[ebp]
	mov	DWORD PTR _start$[ebp], ecx

; 8905 : 		    in = in + delta;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _delta$7[ebp]
	mov	DWORD PTR _in$[ebp], edx
$LN25@xmlParseAt:

; 8906 : 		}
; 8907 : 		end = ctxt->input->end;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _end$[ebp], edx

; 8908 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	eax, DWORD PTR _in$[ebp]
	sub	eax, DWORD PTR _start$[ebp]
	cmp	eax, 10000000				; 00989680H
	jle	SHORT $LN22@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN22@xmlParseAt

; 8909 :                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 8910 :                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,

	push	OFFSET ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
	push	40					; 00000028H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 8911 :                                    "AttValue length too long\n");
; 8912 :                     return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN22@xmlParseAt:

; 8913 :                 }
; 8914 : 	    }
; 8915 : 	}

	jmp	$LN2@xmlParseAt
$LN4@xmlParseAt:

; 8916 : 	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
; 8917 : 	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jae	$LN5@xmlParseAt
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _limit$[ebp]
	cmp	eax, ecx
	je	$LN5@xmlParseAt
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jl	$LN5@xmlParseAt
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 127				; 0000007fH
	jg	$LN5@xmlParseAt
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 38					; 00000026H
	je	$LN5@xmlParseAt
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	je	$LN5@xmlParseAt

; 8918 : 	    col++;

	mov	ecx, DWORD PTR _col$[ebp]
	add	ecx, 1
	mov	DWORD PTR _col$[ebp], ecx

; 8919 : 	    if ((*in++ == 0x20) && (*in == 0x20)) break;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv211[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	cmp	DWORD PTR tv211[ebp], 32		; 00000020H
	jne	SHORT $LN56@xmlParseAt
	mov	DWORD PTR tv212[ebp], 1
	jmp	SHORT $LN57@xmlParseAt
$LN56@xmlParseAt:
	mov	DWORD PTR tv212[ebp], 0
$LN57@xmlParseAt:
	cmp	DWORD PTR tv212[ebp], 0
	je	SHORT $LN27@xmlParseAt
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN27@xmlParseAt
	jmp	$LN5@xmlParseAt
$LN27@xmlParseAt:

; 8920 : 	    if (in >= end) {

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jb	$LN28@xmlParseAt

; 8921 : 		const xmlChar *oldbase = ctxt->input->base;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _oldbase$6[ebp], ecx

; 8922 : 		GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN29@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN29@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN29@xmlParseAt:

; 8923 :                 if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN30@xmlParseAt

; 8924 :                     return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN30@xmlParseAt:

; 8925 : 		if (oldbase != ctxt->input->base) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _oldbase$6[ebp]
	cmp	eax, DWORD PTR [edx+12]
	je	SHORT $LN31@xmlParseAt

; 8926 : 		    long delta = ctxt->input->base - oldbase;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR _oldbase$6[ebp]
	mov	DWORD PTR _delta$5[ebp], eax

; 8927 : 		    start = start + delta;

	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, DWORD PTR _delta$5[ebp]
	mov	DWORD PTR _start$[ebp], ecx

; 8928 : 		    in = in + delta;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _delta$5[ebp]
	mov	DWORD PTR _in$[ebp], edx
$LN31@xmlParseAt:

; 8929 : 		}
; 8930 : 		end = ctxt->input->end;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _end$[ebp], edx

; 8931 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	eax, DWORD PTR _in$[ebp]
	sub	eax, DWORD PTR _start$[ebp]
	cmp	eax, 10000000				; 00989680H
	jle	SHORT $LN28@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN28@xmlParseAt

; 8932 :                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 8933 :                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,

	push	OFFSET ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
	push	40					; 00000028H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 8934 :                                    "AttValue length too long\n");
; 8935 :                     return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN28@xmlParseAt:

; 8936 :                 }
; 8937 : 	    }
; 8938 : 	}

	jmp	$LN4@xmlParseAt
$LN5@xmlParseAt:

; 8939 : 	last = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _last$[ebp], ecx
$LN6@xmlParseAt:

; 8940 : 	/*
; 8941 : 	 * skip the trailing blanks
; 8942 : 	 */
; 8943 : 	while ((last[-1] == 0x20) && (last > start)) last--;

	mov	edx, 1
	imul	eax, edx, -1
	mov	ecx, DWORD PTR _last$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN8@xmlParseAt
	mov	eax, DWORD PTR _last$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	jbe	SHORT $LN8@xmlParseAt
	mov	ecx, DWORD PTR _last$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _last$[ebp], ecx
	jmp	SHORT $LN6@xmlParseAt
$LN8@xmlParseAt:

; 8944 : 	while ((in < end) && (*in != limit) &&

	mov	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _end$[ebp]
	jae	$LN9@xmlParseAt
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _limit$[ebp]
	cmp	ecx, edx
	je	$LN9@xmlParseAt
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN33@xmlParseAt
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	je	SHORT $LN33@xmlParseAt
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN33@xmlParseAt
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	$LN9@xmlParseAt
$LN33@xmlParseAt:

; 8945 : 	       ((*in == 0x20) || (*in == 0x9) ||
; 8946 : 	        (*in == 0xA) || (*in == 0xD))) {
; 8947 : 	    if (*in == 0xA) {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN34@xmlParseAt

; 8948 : 	        line++, col = 1;

	mov	ecx, DWORD PTR _line$[ebp]
	add	ecx, 1
	mov	DWORD PTR _line$[ebp], ecx
	mov	DWORD PTR _col$[ebp], 1

; 8949 : 	    } else {

	jmp	SHORT $LN35@xmlParseAt
$LN34@xmlParseAt:

; 8950 : 	        col++;

	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 1
	mov	DWORD PTR _col$[ebp], edx
$LN35@xmlParseAt:

; 8951 : 	    }
; 8952 : 	    in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 8953 : 	    if (in >= end) {

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jb	$LN36@xmlParseAt

; 8954 : 		const xmlChar *oldbase = ctxt->input->base;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _oldbase$4[ebp], ecx

; 8955 : 		GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN37@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN37@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN37@xmlParseAt:

; 8956 :                 if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN38@xmlParseAt

; 8957 :                     return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN38@xmlParseAt:

; 8958 : 		if (oldbase != ctxt->input->base) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _oldbase$4[ebp]
	cmp	eax, DWORD PTR [edx+12]
	je	SHORT $LN39@xmlParseAt

; 8959 : 		    long delta = ctxt->input->base - oldbase;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR _oldbase$4[ebp]
	mov	DWORD PTR _delta$3[ebp], eax

; 8960 : 		    start = start + delta;

	mov	ecx, DWORD PTR _start$[ebp]
	add	ecx, DWORD PTR _delta$3[ebp]
	mov	DWORD PTR _start$[ebp], ecx

; 8961 : 		    in = in + delta;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _delta$3[ebp]
	mov	DWORD PTR _in$[ebp], edx

; 8962 : 		    last = last + delta;

	mov	eax, DWORD PTR _last$[ebp]
	add	eax, DWORD PTR _delta$3[ebp]
	mov	DWORD PTR _last$[ebp], eax
$LN39@xmlParseAt:

; 8963 : 		}
; 8964 : 		end = ctxt->input->end;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _end$[ebp], eax

; 8965 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	ecx, DWORD PTR _in$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	cmp	ecx, 10000000				; 00989680H
	jle	SHORT $LN36@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	and	eax, 524288				; 00080000H
	jne	SHORT $LN36@xmlParseAt

; 8966 :                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 8967 :                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,

	push	OFFSET ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
	push	40					; 00000028H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 8968 :                                    "AttValue length too long\n");
; 8969 :                     return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN36@xmlParseAt:

; 8970 :                 }
; 8971 : 	    }
; 8972 : 	}

	jmp	$LN8@xmlParseAt
$LN9@xmlParseAt:

; 8973 :         if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	edx, DWORD PTR _in$[ebp]
	sub	edx, DWORD PTR _start$[ebp]
	cmp	edx, 10000000				; 00989680H
	jle	SHORT $LN41@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	jne	SHORT $LN41@xmlParseAt

; 8974 :             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 8975 :             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,

	push	OFFSET ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
	push	40					; 00000028H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 8976 :                            "AttValue length too long\n");
; 8977 :             return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN41@xmlParseAt:

; 8978 :         }
; 8979 : 	if (*in != limit) goto need_complex;

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _limit$[ebp]
	cmp	ecx, edx
	je	SHORT $LN42@xmlParseAt
	jmp	$need_complex$58
$LN42@xmlParseAt:

; 8980 :     } else {

	jmp	$LN18@xmlParseAt
$LN10@xmlParseAt:

; 8981 : 	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
; 8982 : 	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jae	$LN11@xmlParseAt
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _limit$[ebp]
	cmp	edx, eax
	je	$LN11@xmlParseAt
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jl	$LN11@xmlParseAt
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	jg	$LN11@xmlParseAt
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 38					; 00000026H
	je	$LN11@xmlParseAt
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 60					; 0000003cH
	je	$LN11@xmlParseAt

; 8983 : 	    in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 8984 : 	    col++;

	mov	ecx, DWORD PTR _col$[ebp]
	add	ecx, 1
	mov	DWORD PTR _col$[ebp], ecx

; 8985 : 	    if (in >= end) {

	mov	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _end$[ebp]
	jb	$LN43@xmlParseAt

; 8986 : 		const xmlChar *oldbase = ctxt->input->base;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _oldbase$2[ebp], edx

; 8987 : 		GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN44@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN44@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN44@xmlParseAt:

; 8988 :                 if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN45@xmlParseAt

; 8989 :                     return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN45@xmlParseAt:

; 8990 : 		if (oldbase != ctxt->input->base) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _oldbase$2[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	je	SHORT $LN46@xmlParseAt

; 8991 : 		    long delta = ctxt->input->base - oldbase;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _oldbase$2[ebp]
	mov	DWORD PTR _delta$1[ebp], ecx

; 8992 : 		    start = start + delta;

	mov	edx, DWORD PTR _start$[ebp]
	add	edx, DWORD PTR _delta$1[ebp]
	mov	DWORD PTR _start$[ebp], edx

; 8993 : 		    in = in + delta;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _delta$1[ebp]
	mov	DWORD PTR _in$[ebp], eax
$LN46@xmlParseAt:

; 8994 : 		}
; 8995 : 		end = ctxt->input->end;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _end$[ebp], eax

; 8996 :                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	ecx, DWORD PTR _in$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	cmp	ecx, 10000000				; 00989680H
	jle	SHORT $LN43@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	and	eax, 524288				; 00080000H
	jne	SHORT $LN43@xmlParseAt

; 8997 :                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 8998 :                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,

	push	OFFSET ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
	push	40					; 00000028H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 8999 :                                    "AttValue length too long\n");
; 9000 :                     return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN43@xmlParseAt:

; 9001 :                 }
; 9002 : 	    }
; 9003 : 	}

	jmp	$LN10@xmlParseAt
$LN11@xmlParseAt:

; 9004 : 	last = in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 9005 :         if (((in - start) > XML_MAX_TEXT_LENGTH) &&

	mov	eax, DWORD PTR _in$[ebp]
	sub	eax, DWORD PTR _start$[ebp]
	cmp	eax, 10000000				; 00989680H
	jle	SHORT $LN48@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN48@xmlParseAt

; 9006 :             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 9007 :             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,

	push	OFFSET ??_C@_0BK@JCFIEKOP@AttValue?5length?5too?5long?6@
	push	40					; 00000028H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 9008 :                            "AttValue length too long\n");
; 9009 :             return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN48@xmlParseAt:

; 9010 :         }
; 9011 : 	if (*in != limit) goto need_complex;

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _limit$[ebp]
	cmp	edx, eax
	je	SHORT $LN18@xmlParseAt
	jmp	$need_complex$58
$LN18@xmlParseAt:

; 9012 :     }
; 9013 :     in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 9014 :     col++;

	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 1
	mov	DWORD PTR _col$[ebp], edx

; 9015 :     if (len != NULL) {

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN50@xmlParseAt

; 9016 :         *len = last - start;

	mov	eax, DWORD PTR _last$[ebp]
	sub	eax, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], eax

; 9017 :         ret = (xmlChar *) start;

	mov	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _ret$[ebp], edx

; 9018 :     } else {

	jmp	SHORT $LN51@xmlParseAt
$LN50@xmlParseAt:

; 9019 :         if (alloc) *alloc = 1;

	cmp	DWORD PTR _alloc$[ebp], 0
	je	SHORT $LN52@xmlParseAt
	mov	eax, DWORD PTR _alloc$[ebp]
	mov	DWORD PTR [eax], 1
$LN52@xmlParseAt:

; 9020 :         ret = xmlStrndup(start, last - start);

	mov	ecx, DWORD PTR _last$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN51@xmlParseAt:

; 9021 :     }
; 9022 :     CUR_PTR = in;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 9023 :     ctxt->input->line = line;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 9024 :     ctxt->input->col = col;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 9025 :     if (alloc) *alloc = 0;

	cmp	DWORD PTR _alloc$[ebp], 0
	je	SHORT $LN53@xmlParseAt
	mov	eax, DWORD PTR _alloc$[ebp]
	mov	DWORD PTR [eax], 0
$LN53@xmlParseAt:

; 9026 :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParseAt
$need_complex$58:

; 9027 : need_complex:
; 9028 :     if (alloc) *alloc = 1;

	cmp	DWORD PTR _alloc$[ebp], 0
	je	SHORT $LN54@xmlParseAt
	mov	ecx, DWORD PTR _alloc$[ebp]
	mov	DWORD PTR [ecx], 1
$LN54@xmlParseAt:

; 9029 :     return xmlParseAttValueComplex(ctxt, len, normalize);

	mov	edx, DWORD PTR _normalize$[ebp]
	push	edx
	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseAttValueComplex
	add	esp, 12					; 0000000cH
$LN1@xmlParseAt:

; 9030 : }

	pop	edi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseAttValueInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlIsNameChar
_TEXT	SEGMENT
tv191 = -36						; size = 4
tv190 = -32						; size = 4
tv183 = -28						; size = 4
tv173 = -24						; size = 4
tv172 = -20						; size = 4
tv163 = -16						; size = 4
tv164 = -12						; size = 4
tv155 = -8						; size = 4
tv154 = -4						; size = 4
_ctxt$ = 8						; size = 4
_c$ = 12						; size = 4
_xmlIsNameChar PROC					; COMDAT

; 3104 : xmlIsNameChar(xmlParserCtxtPtr ctxt, int c) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 3105 :     if ((ctxt->options & XML_PARSE_OLD10) == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 131072				; 00020000H
	jne	$LN2@xmlIsNameC

; 3106 :         /*
; 3107 : 	 * Use the new checks of production [4] [4a] amd [5] of the
; 3108 : 	 * Update 5 of XML-1.0
; 3109 : 	 */
; 3110 : 	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	$LN4@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	je	$LN4@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	je	$LN4@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN6@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	$LN5@xmlIsNameC
$LN6@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN7@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	$LN5@xmlIsNameC
$LN7@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN8@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jle	$LN5@xmlIsNameC
$LN8@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	je	$LN5@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	$LN5@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 45			; 0000002dH
	je	$LN5@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 46			; 0000002eH
	je	$LN5@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 183			; 000000b7H
	je	$LN5@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 192			; 000000c0H
	jl	SHORT $LN9@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 214			; 000000d6H
	jle	$LN5@xmlIsNameC
$LN9@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 216			; 000000d8H
	jl	SHORT $LN10@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 246			; 000000f6H
	jle	$LN5@xmlIsNameC
$LN10@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jl	SHORT $LN11@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 767			; 000002ffH
	jle	$LN5@xmlIsNameC
$LN11@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 768			; 00000300H
	jl	SHORT $LN12@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 879			; 0000036fH
	jle	$LN5@xmlIsNameC
$LN12@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 880			; 00000370H
	jl	SHORT $LN13@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 893			; 0000037dH
	jle	$LN5@xmlIsNameC
$LN13@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 895			; 0000037fH
	jl	SHORT $LN14@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 8191		; 00001fffH
	jle	$LN5@xmlIsNameC
$LN14@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 8204		; 0000200cH
	jl	SHORT $LN15@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 8205		; 0000200dH
	jle	SHORT $LN5@xmlIsNameC
$LN15@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 8255		; 0000203fH
	jl	SHORT $LN16@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 8256		; 00002040H
	jle	SHORT $LN5@xmlIsNameC
$LN16@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 8304		; 00002070H
	jl	SHORT $LN17@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 8591		; 0000218fH
	jle	SHORT $LN5@xmlIsNameC
$LN17@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 11264		; 00002c00H
	jl	SHORT $LN18@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 12271		; 00002fefH
	jle	SHORT $LN5@xmlIsNameC
$LN18@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 12289		; 00003001H
	jl	SHORT $LN19@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN5@xmlIsNameC
$LN19@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 63744		; 0000f900H
	jl	SHORT $LN20@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 64975		; 0000fdcfH
	jle	SHORT $LN5@xmlIsNameC
$LN20@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 65008		; 0000fdf0H
	jl	SHORT $LN21@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN5@xmlIsNameC
$LN21@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jl	SHORT $LN4@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 983039		; 000effffH
	jg	SHORT $LN4@xmlIsNameC
$LN5@xmlIsNameC:

; 3111 : 	    (((c >= 'a') && (c <= 'z')) ||
; 3112 : 	     ((c >= 'A') && (c <= 'Z')) ||
; 3113 : 	     ((c >= '0') && (c <= '9')) || /* !start */
; 3114 : 	     (c == '_') || (c == ':') ||
; 3115 : 	     (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
; 3116 : 	     ((c >= 0xC0) && (c <= 0xD6)) ||
; 3117 : 	     ((c >= 0xD8) && (c <= 0xF6)) ||
; 3118 : 	     ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3119 : 	     ((c >= 0x300) && (c <= 0x36F)) || /* !start */
; 3120 : 	     ((c >= 0x370) && (c <= 0x37D)) ||
; 3121 : 	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3122 : 	     ((c >= 0x200C) && (c <= 0x200D)) ||
; 3123 : 	     ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
; 3124 : 	     ((c >= 0x2070) && (c <= 0x218F)) ||
; 3125 : 	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3126 : 	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3127 : 	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3128 : 	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
; 3129 : 	     ((c >= 0x10000) && (c <= 0xEFFFF))))
; 3130 : 	     return(1);

	mov	eax, 1
	jmp	$LN1@xmlIsNameC
$LN4@xmlIsNameC:

; 3131 :     } else {

	jmp	$LN3@xmlIsNameC
$LN2@xmlIsNameC:

; 3132 :         if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
; 3133 :             (c == '.') || (c == '-') ||
; 3134 : 	    (c == '_') || (c == ':') ||
; 3135 : 	    (IS_COMBINING(c)) ||

	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN31@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN25@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	SHORT $LN27@xmlIsNameC
$LN25@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN26@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	SHORT $LN27@xmlIsNameC
$LN26@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 192			; 000000c0H
	jl	SHORT $LN28@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 214			; 000000d6H
	jle	SHORT $LN27@xmlIsNameC
$LN28@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 216			; 000000d8H
	jl	SHORT $LN29@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 246			; 000000f6H
	jle	SHORT $LN27@xmlIsNameC
$LN29@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jge	SHORT $LN27@xmlIsNameC
	mov	DWORD PTR tv154[ebp], 0
	jmp	SHORT $LN30@xmlIsNameC
$LN27@xmlIsNameC:
	mov	DWORD PTR tv154[ebp], 1
$LN30@xmlIsNameC:
	mov	edx, DWORD PTR tv154[ebp]
	mov	DWORD PTR tv155[ebp], edx
	jmp	SHORT $LN32@xmlIsNameC
$LN31@xmlIsNameC:
	push	OFFSET _xmlIsBaseCharGroup
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv155[ebp], eax
$LN32@xmlIsNameC:
	cmp	DWORD PTR tv155[ebp], 0
	jne	$LN23@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN37@xmlIsNameC
	mov	DWORD PTR tv164[ebp], 0
	jmp	SHORT $LN38@xmlIsNameC
$LN37@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 19968		; 00004e00H
	jl	SHORT $LN33@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 40869		; 00009fa5H
	jle	SHORT $LN34@xmlIsNameC
$LN33@xmlIsNameC:
	cmp	DWORD PTR _c$[ebp], 12295		; 00003007H
	je	SHORT $LN34@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 12321		; 00003021H
	jl	SHORT $LN35@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 12329		; 00003029H
	jle	SHORT $LN34@xmlIsNameC
$LN35@xmlIsNameC:
	mov	DWORD PTR tv163[ebp], 0
	jmp	SHORT $LN36@xmlIsNameC
$LN34@xmlIsNameC:
	mov	DWORD PTR tv163[ebp], 1
$LN36@xmlIsNameC:
	mov	ecx, DWORD PTR tv163[ebp]
	mov	DWORD PTR tv164[ebp], ecx
$LN38@xmlIsNameC:
	cmp	DWORD PTR tv164[ebp], 0
	jne	$LN23@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN41@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN39@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jg	SHORT $LN39@xmlIsNameC
	mov	DWORD PTR tv172[ebp], 1
	jmp	SHORT $LN40@xmlIsNameC
$LN39@xmlIsNameC:
	mov	DWORD PTR tv172[ebp], 0
$LN40@xmlIsNameC:
	mov	edx, DWORD PTR tv172[ebp]
	mov	DWORD PTR tv173[ebp], edx
	jmp	SHORT $LN42@xmlIsNameC
$LN41@xmlIsNameC:
	push	OFFSET _xmlIsDigitGroup
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv173[ebp], eax
$LN42@xmlIsNameC:
	cmp	DWORD PTR tv173[ebp], 0
	jne	$LN23@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 46			; 0000002eH
	je	$LN23@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 45			; 0000002dH
	je	SHORT $LN23@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	je	SHORT $LN23@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	SHORT $LN23@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN43@xmlIsNameC
	mov	DWORD PTR tv183[ebp], 0
	jmp	SHORT $LN44@xmlIsNameC
$LN43@xmlIsNameC:
	push	OFFSET _xmlIsCombiningGroup
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv183[ebp], eax
$LN44@xmlIsNameC:
	cmp	DWORD PTR tv183[ebp], 0
	jne	SHORT $LN23@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN47@xmlIsNameC
	cmp	DWORD PTR _c$[ebp], 183			; 000000b7H
	jne	SHORT $LN45@xmlIsNameC
	mov	DWORD PTR tv190[ebp], 1
	jmp	SHORT $LN46@xmlIsNameC
$LN45@xmlIsNameC:
	mov	DWORD PTR tv190[ebp], 0
$LN46@xmlIsNameC:
	mov	edx, DWORD PTR tv190[ebp]
	mov	DWORD PTR tv191[ebp], edx
	jmp	SHORT $LN48@xmlIsNameC
$LN47@xmlIsNameC:
	push	OFFSET _xmlIsExtenderGroup
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv191[ebp], eax
$LN48@xmlIsNameC:
	cmp	DWORD PTR tv191[ebp], 0
	je	SHORT $LN3@xmlIsNameC
$LN23@xmlIsNameC:

; 3136 : 	    (IS_EXTENDER(c)))
; 3137 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlIsNameC
$LN3@xmlIsNameC:

; 3138 :     }
; 3139 :     return(0);

	xor	eax, eax
$LN1@xmlIsNameC:

; 3140 : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlIsNameChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlIsNameStartChar
_TEXT	SEGMENT
tv154 = -16						; size = 4
tv155 = -12						; size = 4
tv146 = -8						; size = 4
tv145 = -4						; size = 4
_ctxt$ = 8						; size = 4
_c$ = 12						; size = 4
_xmlIsNameStartChar PROC				; COMDAT

; 3073 : xmlIsNameStartChar(xmlParserCtxtPtr ctxt, int c) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 3074 :     if ((ctxt->options & XML_PARSE_OLD10) == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 131072				; 00020000H
	jne	$LN2@xmlIsNameS

; 3075 :         /*
; 3076 : 	 * Use the new checks of production [4] [4a] amd [5] of the
; 3077 : 	 * Update 5 of XML-1.0
; 3078 : 	 */
; 3079 : 	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	$LN4@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 62			; 0000003eH
	je	$LN4@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	je	$LN4@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN6@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	$LN5@xmlIsNameS
$LN6@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN7@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	$LN5@xmlIsNameS
$LN7@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	je	$LN5@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	$LN5@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 192			; 000000c0H
	jl	SHORT $LN8@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 214			; 000000d6H
	jle	$LN5@xmlIsNameS
$LN8@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 216			; 000000d8H
	jl	SHORT $LN9@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 246			; 000000f6H
	jle	$LN5@xmlIsNameS
$LN9@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jl	SHORT $LN10@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 767			; 000002ffH
	jle	$LN5@xmlIsNameS
$LN10@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 880			; 00000370H
	jl	SHORT $LN11@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 893			; 0000037dH
	jle	$LN5@xmlIsNameS
$LN11@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 895			; 0000037fH
	jl	SHORT $LN12@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 8191		; 00001fffH
	jle	SHORT $LN5@xmlIsNameS
$LN12@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 8204		; 0000200cH
	jl	SHORT $LN13@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 8205		; 0000200dH
	jle	SHORT $LN5@xmlIsNameS
$LN13@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 8304		; 00002070H
	jl	SHORT $LN14@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 8591		; 0000218fH
	jle	SHORT $LN5@xmlIsNameS
$LN14@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 11264		; 00002c00H
	jl	SHORT $LN15@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 12271		; 00002fefH
	jle	SHORT $LN5@xmlIsNameS
$LN15@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 12289		; 00003001H
	jl	SHORT $LN16@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN5@xmlIsNameS
$LN16@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 63744		; 0000f900H
	jl	SHORT $LN17@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 64975		; 0000fdcfH
	jle	SHORT $LN5@xmlIsNameS
$LN17@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 65008		; 0000fdf0H
	jl	SHORT $LN18@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN5@xmlIsNameS
$LN18@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jl	SHORT $LN4@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 983039		; 000effffH
	jg	SHORT $LN4@xmlIsNameS
$LN5@xmlIsNameS:

; 3080 : 	    (((c >= 'a') && (c <= 'z')) ||
; 3081 : 	     ((c >= 'A') && (c <= 'Z')) ||
; 3082 : 	     (c == '_') || (c == ':') ||
; 3083 : 	     ((c >= 0xC0) && (c <= 0xD6)) ||
; 3084 : 	     ((c >= 0xD8) && (c <= 0xF6)) ||
; 3085 : 	     ((c >= 0xF8) && (c <= 0x2FF)) ||
; 3086 : 	     ((c >= 0x370) && (c <= 0x37D)) ||
; 3087 : 	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
; 3088 : 	     ((c >= 0x200C) && (c <= 0x200D)) ||
; 3089 : 	     ((c >= 0x2070) && (c <= 0x218F)) ||
; 3090 : 	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
; 3091 : 	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
; 3092 : 	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
; 3093 : 	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
; 3094 : 	     ((c >= 0x10000) && (c <= 0xEFFFF))))
; 3095 : 	    return(1);

	mov	eax, 1
	jmp	$LN1@xmlIsNameS
$LN4@xmlIsNameS:

; 3096 :     } else {

	jmp	$LN3@xmlIsNameS
$LN2@xmlIsNameS:

; 3097 :         if (IS_LETTER(c) || (c == '_') || (c == ':'))

	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN28@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN22@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	SHORT $LN24@xmlIsNameS
$LN22@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN23@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	SHORT $LN24@xmlIsNameS
$LN23@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 192			; 000000c0H
	jl	SHORT $LN25@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 214			; 000000d6H
	jle	SHORT $LN24@xmlIsNameS
$LN25@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 216			; 000000d8H
	jl	SHORT $LN26@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 246			; 000000f6H
	jle	SHORT $LN24@xmlIsNameS
$LN26@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 248			; 000000f8H
	jge	SHORT $LN24@xmlIsNameS
	mov	DWORD PTR tv145[ebp], 0
	jmp	SHORT $LN27@xmlIsNameS
$LN24@xmlIsNameS:
	mov	DWORD PTR tv145[ebp], 1
$LN27@xmlIsNameS:
	mov	edx, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv146[ebp], edx
	jmp	SHORT $LN29@xmlIsNameS
$LN28@xmlIsNameS:
	push	OFFSET _xmlIsBaseCharGroup
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv146[ebp], eax
$LN29@xmlIsNameS:
	cmp	DWORD PTR tv146[ebp], 0
	jne	SHORT $LN20@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN34@xmlIsNameS
	mov	DWORD PTR tv155[ebp], 0
	jmp	SHORT $LN35@xmlIsNameS
$LN34@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 19968		; 00004e00H
	jl	SHORT $LN30@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 40869		; 00009fa5H
	jle	SHORT $LN31@xmlIsNameS
$LN30@xmlIsNameS:
	cmp	DWORD PTR _c$[ebp], 12295		; 00003007H
	je	SHORT $LN31@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 12321		; 00003021H
	jl	SHORT $LN32@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 12329		; 00003029H
	jle	SHORT $LN31@xmlIsNameS
$LN32@xmlIsNameS:
	mov	DWORD PTR tv154[ebp], 0
	jmp	SHORT $LN33@xmlIsNameS
$LN31@xmlIsNameS:
	mov	DWORD PTR tv154[ebp], 1
$LN33@xmlIsNameS:
	mov	ecx, DWORD PTR tv154[ebp]
	mov	DWORD PTR tv155[ebp], ecx
$LN35@xmlIsNameS:
	cmp	DWORD PTR tv155[ebp], 0
	jne	SHORT $LN20@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	je	SHORT $LN20@xmlIsNameS
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	jne	SHORT $LN3@xmlIsNameS
$LN20@xmlIsNameS:

; 3098 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlIsNameS
$LN3@xmlIsNameS:

; 3099 :     }
; 3100 :     return(0);

	xor	eax, eax
$LN1@xmlIsNameS:

; 3101 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlIsNameStartChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _areBlanks
_TEXT	SEGMENT
_lastChild$ = -12					; size = 4
_ret$ = -8						; size = 4
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
_blank_chars$ = 20					; size = 4
_areBlanks PROC						; COMDAT

; 2808 :                      int blank_chars) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2809 :     int i, ret;
; 2810 :     xmlNodePtr lastChild;
; 2811 : 
; 2812 :     /*
; 2813 :      * Don't spend time trying to differentiate them, the same callback is
; 2814 :      * used !
; 2815 :      */
; 2816 :     if (ctxt->sax->ignorableWhitespace == ctxt->sax->characters)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+72]
	cmp	ecx, DWORD PTR [eax+68]
	jne	SHORT $LN5@areBlanks

; 2817 : 	return(0);

	xor	eax, eax
	jmp	$LN1@areBlanks
$LN5@areBlanks:

; 2818 : 
; 2819 :     /*
; 2820 :      * Check for xml:space value.
; 2821 :      */
; 2822 :     if ((ctxt->space == NULL) || (*(ctxt->space) == 1) ||

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+232], 0
	je	SHORT $LN7@areBlanks
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	cmp	DWORD PTR [ecx], 1
	je	SHORT $LN7@areBlanks
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+232]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN6@areBlanks
$LN7@areBlanks:

; 2823 :         (*(ctxt->space) == -2))
; 2824 : 	return(0);

	xor	eax, eax
	jmp	$LN1@areBlanks
$LN6@areBlanks:

; 2825 : 
; 2826 :     /*
; 2827 :      * Check that the string is made of blanks
; 2828 :      */
; 2829 :     if (blank_chars == 0) {

	cmp	DWORD PTR _blank_chars$[ebp], 0
	jne	SHORT $LN8@areBlanks

; 2830 : 	for (i = 0;i < len;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@areBlanks
$LN2@areBlanks:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@areBlanks:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jge	SHORT $LN8@areBlanks

; 2831 : 	    if (!(IS_BLANK_CH(str[i]))) return(0);

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN9@areBlanks
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN10@areBlanks
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN9@areBlanks
$LN10@areBlanks:
	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN9@areBlanks
	xor	eax, eax
	jmp	$LN1@areBlanks
$LN9@areBlanks:
	jmp	SHORT $LN2@areBlanks
$LN8@areBlanks:

; 2832 :     }
; 2833 : 
; 2834 :     /*
; 2835 :      * Look if the element is mixed content in the DTD if available
; 2836 :      */
; 2837 :     if (ctxt->node == NULL) return(0);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jne	SHORT $LN11@areBlanks
	xor	eax, eax
	jmp	$LN1@areBlanks
$LN11@areBlanks:

; 2838 :     if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN12@areBlanks

; 2839 : 	ret = xmlIsMixedElement(ctxt->myDoc, ctxt->node->name);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlIsMixedElement
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2840 :         if (ret == 0) return(1);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN13@areBlanks
	mov	eax, 1
	jmp	$LN1@areBlanks
$LN13@areBlanks:

; 2841 :         if (ret == 1) return(0);

	cmp	DWORD PTR _ret$[ebp], 1
	jne	SHORT $LN12@areBlanks
	xor	eax, eax
	jmp	$LN1@areBlanks
$LN12@areBlanks:

; 2842 :     }
; 2843 : 
; 2844 :     /*
; 2845 :      * Otherwise, heuristic :-\
; 2846 :      */
; 2847 :     if ((RAW != '<') && (RAW != 0xD)) return(0);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN15@areBlanks
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN15@areBlanks
	xor	eax, eax
	jmp	$LN1@areBlanks
$LN15@areBlanks:

; 2848 :     if ((ctxt->node->children == NULL) &&
; 2849 : 	(RAW == '<') && (NXT(1) == '/')) return(0);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN16@areBlanks
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN16@areBlanks
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN16@areBlanks
	xor	eax, eax
	jmp	SHORT $LN1@areBlanks
$LN16@areBlanks:

; 2850 : 
; 2851 :     lastChild = xmlGetLastChild(ctxt->node);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_xmlGetLastChild
	add	esp, 4
	mov	DWORD PTR _lastChild$[ebp], eax

; 2852 :     if (lastChild == NULL) {

	cmp	DWORD PTR _lastChild$[ebp], 0
	jne	SHORT $LN17@areBlanks

; 2853 :         if ((ctxt->node->type != XML_ELEMENT_NODE) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	cmp	DWORD PTR [ecx+4], 1
	je	SHORT $LN19@areBlanks
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN19@areBlanks

; 2854 :             (ctxt->node->content != NULL)) return(0);

	xor	eax, eax
	jmp	SHORT $LN1@areBlanks
$LN19@areBlanks:

; 2855 :     } else if (xmlNodeIsText(lastChild))

	jmp	SHORT $LN18@areBlanks
$LN17@areBlanks:
	mov	ecx, DWORD PTR _lastChild$[ebp]
	push	ecx
	call	_xmlNodeIsText
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@areBlanks

; 2856 :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@areBlanks
	jmp	SHORT $LN18@areBlanks
$LN20@areBlanks:

; 2857 :     else if ((ctxt->node->children != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN18@areBlanks
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlNodeIsText
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@areBlanks

; 2858 :              (xmlNodeIsText(ctxt->node->children)))
; 2859 :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@areBlanks
$LN18@areBlanks:

; 2860 :     return(1);

	mov	eax, 1
$LN1@areBlanks:

; 2861 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_areBlanks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStringCharRef
_TEXT	SEGMENT
tv184 = -28						; size = 4
tv186 = -24						; size = 4
tv185 = -20						; size = 4
_outofrange$ = -16					; size = 4
_val$ = -12						; size = 4
_cur$ = -5						; size = 1
_ptr$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParseStringCharRef PROC				; COMDAT

; 2394 : xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2395 :     const xmlChar *ptr;
; 2396 :     xmlChar cur;
; 2397 :     unsigned int val = 0;

	mov	DWORD PTR _val$[ebp], 0

; 2398 :     unsigned int outofrange = 0;

	mov	DWORD PTR _outofrange$[ebp], 0

; 2399 : 
; 2400 :     if ((str == NULL) || (*str == NULL)) return(0);

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN7@xmlParseSt
	mov	eax, DWORD PTR _str$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN6@xmlParseSt
$LN7@xmlParseSt:
	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN6@xmlParseSt:

; 2401 :     ptr = *str;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ptr$[ebp], edx

; 2402 :     cur = *ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cur$[ebp], cl

; 2403 :     if ((cur == '&') && (ptr[1] == '#') && (ptr[2] == 'x')) {

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 38					; 00000026H
	jne	$LN8@xmlParseSt
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 35					; 00000023H
	jne	$LN8@xmlParseSt
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	jne	$LN8@xmlParseSt

; 2404 : 	ptr += 3;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 3
	mov	DWORD PTR _ptr$[ebp], eax

; 2405 : 	cur = *ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _cur$[ebp], dl
$LN2@xmlParseSt:

; 2406 : 	while (cur != ';') { /* Non input consuming loop */

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 59					; 0000003bH
	je	$LN3@xmlParseSt

; 2407 : 	    if ((cur >= '0') && (cur <= '9'))

	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN10@xmlParseSt
	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN10@xmlParseSt

; 2408 : 	        val = val * 16 + (cur - '0');

	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 4
	movzx	ecx, BYTE PTR _cur$[ebp]
	lea	edx, DWORD PTR [eax+ecx-48]
	mov	DWORD PTR _val$[ebp], edx
	jmp	SHORT $LN11@xmlParseSt
$LN10@xmlParseSt:

; 2409 : 	    else if ((cur >= 'a') && (cur <= 'f'))

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN12@xmlParseSt
	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 102				; 00000066H
	jg	SHORT $LN12@xmlParseSt

; 2410 : 	        val = val * 16 + (cur - 'a') + 10;

	mov	edx, DWORD PTR _val$[ebp]
	shl	edx, 4
	movzx	eax, BYTE PTR _cur$[ebp]
	lea	ecx, DWORD PTR [edx+eax-87]
	mov	DWORD PTR _val$[ebp], ecx
	jmp	SHORT $LN11@xmlParseSt
$LN12@xmlParseSt:

; 2411 : 	    else if ((cur >= 'A') && (cur <= 'F'))

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN14@xmlParseSt
	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 70					; 00000046H
	jg	SHORT $LN14@xmlParseSt

; 2412 : 	        val = val * 16 + (cur - 'A') + 10;

	mov	ecx, DWORD PTR _val$[ebp]
	shl	ecx, 4
	movzx	edx, BYTE PTR _cur$[ebp]
	lea	eax, DWORD PTR [ecx+edx-55]
	mov	DWORD PTR _val$[ebp], eax
	jmp	SHORT $LN11@xmlParseSt
$LN14@xmlParseSt:

; 2413 : 	    else {
; 2414 : 		xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);

	push	0
	push	6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2415 : 		val = 0;

	mov	DWORD PTR _val$[ebp], 0

; 2416 : 		break;

	jmp	SHORT $LN3@xmlParseSt
$LN11@xmlParseSt:

; 2417 : 	    }
; 2418 : 	    if (val > 0x10FFFF)

	cmp	DWORD PTR _val$[ebp], 1114111		; 0010ffffH
	jbe	SHORT $LN16@xmlParseSt

; 2419 : 	        outofrange = val;

	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _outofrange$[ebp], edx
$LN16@xmlParseSt:

; 2420 : 
; 2421 : 	    ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 2422 : 	    cur = *ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _cur$[ebp], dl

; 2423 : 	}

	jmp	$LN2@xmlParseSt
$LN3@xmlParseSt:

; 2424 : 	if (cur == ';')

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN17@xmlParseSt

; 2425 : 	    ptr++;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx
$LN17@xmlParseSt:

; 2426 :     } else if  ((cur == '&') && (ptr[1] == '#')){

	jmp	$LN9@xmlParseSt
$LN8@xmlParseSt:
	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 38					; 00000026H
	jne	$LN18@xmlParseSt
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 35					; 00000023H
	jne	$LN18@xmlParseSt

; 2427 : 	ptr += 2;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _ptr$[ebp], eax

; 2428 : 	cur = *ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _cur$[ebp], dl
$LN4@xmlParseSt:

; 2429 : 	while (cur != ';') { /* Non input consuming loops */

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 59					; 0000003bH
	je	SHORT $LN5@xmlParseSt

; 2430 : 	    if ((cur >= '0') && (cur <= '9'))

	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN20@xmlParseSt
	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN20@xmlParseSt

; 2431 : 	        val = val * 10 + (cur - '0');

	imul	eax, DWORD PTR _val$[ebp], 10
	movzx	ecx, BYTE PTR _cur$[ebp]
	lea	edx, DWORD PTR [eax+ecx-48]
	mov	DWORD PTR _val$[ebp], edx
	jmp	SHORT $LN21@xmlParseSt
$LN20@xmlParseSt:

; 2432 : 	    else {
; 2433 : 		xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);

	push	0
	push	7
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2434 : 		val = 0;

	mov	DWORD PTR _val$[ebp], 0

; 2435 : 		break;

	jmp	SHORT $LN5@xmlParseSt
$LN21@xmlParseSt:

; 2436 : 	    }
; 2437 : 	    if (val > 0x10FFFF)

	cmp	DWORD PTR _val$[ebp], 1114111		; 0010ffffH
	jbe	SHORT $LN22@xmlParseSt

; 2438 : 	        outofrange = val;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _outofrange$[ebp], ecx
$LN22@xmlParseSt:

; 2439 : 
; 2440 : 	    ptr++;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx

; 2441 : 	    cur = *ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cur$[ebp], cl

; 2442 : 	}

	jmp	SHORT $LN4@xmlParseSt
$LN5@xmlParseSt:

; 2443 : 	if (cur == ';')

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 59					; 0000003bH
	jne	SHORT $LN23@xmlParseSt

; 2444 : 	    ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax
$LN23@xmlParseSt:

; 2445 :     } else {

	jmp	SHORT $LN9@xmlParseSt
$LN18@xmlParseSt:

; 2446 : 	xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);

	push	0
	push	8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2447 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN9@xmlParseSt:

; 2448 :     }
; 2449 :     *str = ptr;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], eax

; 2450 : 
; 2451 :     /*
; 2452 :      * [ WFC: Legal Character ]
; 2453 :      * Characters referred to using character references must match the
; 2454 :      * production for Char.
; 2455 :      */
; 2456 :     if ((IS_CHAR(val) && (outofrange == 0))) {

	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jae	SHORT $LN35@xmlParseSt
	cmp	DWORD PTR _val$[ebp], 9
	jb	SHORT $LN27@xmlParseSt
	cmp	DWORD PTR _val$[ebp], 10		; 0000000aH
	jbe	SHORT $LN28@xmlParseSt
$LN27@xmlParseSt:
	cmp	DWORD PTR _val$[ebp], 13		; 0000000dH
	je	SHORT $LN28@xmlParseSt
	cmp	DWORD PTR _val$[ebp], 32		; 00000020H
	jae	SHORT $LN28@xmlParseSt
	mov	DWORD PTR tv185[ebp], 0
	jmp	SHORT $LN34@xmlParseSt
$LN28@xmlParseSt:
	mov	DWORD PTR tv185[ebp], 1
$LN34@xmlParseSt:
	mov	ecx, DWORD PTR tv185[ebp]
	mov	DWORD PTR tv186[ebp], ecx
	jmp	SHORT $LN36@xmlParseSt
$LN35@xmlParseSt:
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jb	SHORT $LN29@xmlParseSt
	cmp	DWORD PTR _val$[ebp], 55295		; 0000d7ffH
	jbe	SHORT $LN31@xmlParseSt
$LN29@xmlParseSt:
	cmp	DWORD PTR _val$[ebp], 57344		; 0000e000H
	jb	SHORT $LN30@xmlParseSt
	cmp	DWORD PTR _val$[ebp], 65533		; 0000fffdH
	jbe	SHORT $LN31@xmlParseSt
$LN30@xmlParseSt:
	cmp	DWORD PTR _val$[ebp], 65536		; 00010000H
	jb	SHORT $LN32@xmlParseSt
	cmp	DWORD PTR _val$[ebp], 1114111		; 0010ffffH
	jbe	SHORT $LN31@xmlParseSt
$LN32@xmlParseSt:
	mov	DWORD PTR tv184[ebp], 0
	jmp	SHORT $LN33@xmlParseSt
$LN31@xmlParseSt:
	mov	DWORD PTR tv184[ebp], 1
$LN33@xmlParseSt:
	mov	edx, DWORD PTR tv184[ebp]
	mov	DWORD PTR tv186[ebp], edx
$LN36@xmlParseSt:
	cmp	DWORD PTR tv186[ebp], 0
	je	SHORT $LN24@xmlParseSt
	cmp	DWORD PTR _outofrange$[ebp], 0
	jne	SHORT $LN24@xmlParseSt

; 2457 :         return(val);

	mov	eax, DWORD PTR _val$[ebp]
	jmp	SHORT $LN1@xmlParseSt

; 2458 :     } else {

	jmp	SHORT $LN25@xmlParseSt
$LN24@xmlParseSt:

; 2459 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	OFFSET ??_C@_0DB@EJFBNJEE@xmlParseStringCharRef?3?5invalid?5@
	push	9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H
$LN25@xmlParseSt:

; 2460 : 			  "xmlParseStringCharRef: invalid xmlChar value %d\n",
; 2461 : 			  val);
; 2462 :     }
; 2463 :     return(0);

	xor	eax, eax
$LN1@xmlParseSt:

; 2464 : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseStringCharRef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlGROW
_TEXT	SEGMENT
_curBase$ = -8						; size = 4
_curEnd$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlGROW PROC						; COMDAT

; 2079 : static void xmlGROW (xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2080 :     unsigned long curEnd = ctxt->input->end - ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _curEnd$[ebp], ecx

; 2081 :     unsigned long curBase = ctxt->input->cur - ctxt->input->base;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _curBase$[ebp], eax

; 2082 : 
; 2083 :     if (((curEnd > (unsigned long) XML_MAX_LOOKUP_LIMIT) ||
; 2084 :          (curBase > (unsigned long) XML_MAX_LOOKUP_LIMIT)) &&
; 2085 :          ((ctxt->input->buf) &&
; 2086 :           (ctxt->input->buf->readcallback != xmlInputReadCallbackNop)) &&

	cmp	DWORD PTR _curEnd$[ebp], 10000000	; 00989680H
	ja	SHORT $LN3@xmlGROW
	cmp	DWORD PTR _curBase$[ebp], 10000000	; 00989680H
	jbe	SHORT $LN2@xmlGROW
$LN3@xmlGROW:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN2@xmlGROW
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+4], OFFSET _xmlInputReadCallbackNop
	je	SHORT $LN2@xmlGROW
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	jne	SHORT $LN2@xmlGROW

; 2087 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 2088 :         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Huge input lookup");

	push	OFFSET ??_C@_0BC@BAMNGBKO@Huge?5input?5lookup@
	push	1
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2089 :         xmlHaltParser(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlHaltParser
	add	esp, 4

; 2090 : 	return;

	jmp	$LN1@xmlGROW
$LN2@xmlGROW:

; 2091 :     }
; 2092 :     xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8

; 2093 :     if ((ctxt->input->cur > ctxt->input->end) ||

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	cmp	ecx, DWORD PTR [eax+20]
	ja	SHORT $LN5@xmlGROW
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	cmp	eax, DWORD PTR [edx+12]
	jae	SHORT $LN4@xmlGROW
$LN5@xmlGROW:

; 2094 :         (ctxt->input->cur < ctxt->input->base)) {
; 2095 :         xmlHaltParser(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlHaltParser
	add	esp, 4

; 2096 :         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "cur index out of bound");

	push	OFFSET ??_C@_0BH@JOKBAJC@cur?5index?5out?5of?5bound@
	push	1
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2097 : 	return;

	jmp	SHORT $LN1@xmlGROW
$LN4@xmlGROW:

; 2098 :     }
; 2099 :     if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0))

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN1@xmlGROW
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN1@xmlGROW

; 2100 :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN1@xmlGROW:

; 2101 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGROW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSHRINK
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlSHRINK PROC						; COMDAT

; 2069 : static void xmlSHRINK (xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2070 :     xmlParserInputShrink(ctxt->input);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputShrink
	add	esp, 4

; 2071 :     if (*ctxt->input->cur == 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN1@xmlSHRINK

; 2072 :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN1@xmlSHRINK:

; 2073 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSHRINK ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _spacePop
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_spacePop PROC						; COMDAT

; 1973 : static int spacePop(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1974 :     int ret;
; 1975 :     if (ctxt->spaceNr <= 0) return(0);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+236], 0
	jg	SHORT $LN2@spacePop
	xor	eax, eax
	jmp	$LN1@spacePop
$LN2@spacePop:

; 1976 :     ctxt->spaceNr--;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+236], edx

; 1977 :     if (ctxt->spaceNr > 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+236], 0
	jle	SHORT $LN3@spacePop

; 1978 : 	ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+236]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+244]
	lea	eax, DWORD PTR [edx+eax*4-4]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+232], eax
	jmp	SHORT $LN4@spacePop
$LN3@spacePop:

; 1979 :     else
; 1980 :         ctxt->space = &ctxt->spaceTab[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	eax, DWORD PTR [ecx+244]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+232], eax
$LN4@spacePop:

; 1981 :     ret = ctxt->spaceTab[ctxt->spaceNr];

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+244]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _ret$[ebp], ecx

; 1982 :     ctxt->spaceTab[ctxt->spaceNr] = -1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+236]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+244]
	mov	DWORD PTR [edx+eax*4], -1

; 1983 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@spacePop:

; 1984 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_spacePop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _spacePush
_TEXT	SEGMENT
tv128 = -8						; size = 4
_tmp$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_val$ = 12						; size = 4
_spacePush PROC						; COMDAT

; 1954 : static int spacePush(xmlParserCtxtPtr ctxt, int val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1955 :     if (ctxt->spaceNr >= ctxt->spaceMax) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+236]
	cmp	edx, DWORD PTR [ecx+240]
	jl	SHORT $LN2@spacePush

; 1956 :         int *tmp;
; 1957 : 
; 1958 : 	ctxt->spaceMax *= 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+240], ecx

; 1959 :         tmp = (int *) xmlRealloc(ctxt->spaceTab,

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+244]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 1960 : 	                         ctxt->spaceMax * sizeof(ctxt->spaceTab[0]));
; 1961 :         if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN3@spacePush

; 1962 : 	    xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 1963 : 	    ctxt->spaceMax /=2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+240]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+240], eax

; 1964 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@spacePush
$LN3@spacePush:

; 1965 : 	}
; 1966 : 	ctxt->spaceTab = tmp;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [edx+244], eax
$LN2@spacePush:

; 1967 :     }
; 1968 :     ctxt->spaceTab[ctxt->spaceNr] = val;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1969 :     ctxt->space = &ctxt->spaceTab[ctxt->spaceNr];

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+232], edx

; 1970 :     return(ctxt->spaceNr++);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	mov	DWORD PTR tv128[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+236], ecx
	mov	eax, DWORD PTR tv128[ebp]
$LN1@spacePush:

; 1971 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_spacePush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nameNsPop
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nameNsPop PROC						; COMDAT

; 1881 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1882 :     const xmlChar *ret;
; 1883 : 
; 1884 :     if (ctxt->nameNr <= 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+188], 0
	jg	SHORT $LN2@nameNsPop

; 1885 :         return (NULL);

	xor	eax, eax
	jmp	$LN1@nameNsPop
$LN2@nameNsPop:

; 1886 :     ctxt->nameNr--;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+188], edx

; 1887 :     if (ctxt->nameNr > 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+188], 0
	jle	SHORT $LN3@nameNsPop

; 1888 :         ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+188]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+eax*4-4]
	mov	DWORD PTR [ecx+184], edx
	jmp	SHORT $LN4@nameNsPop
$LN3@nameNsPop:

; 1889 :     else
; 1890 :         ctxt->name = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+184], 0
$LN4@nameNsPop:

; 1891 :     ret = ctxt->nameTab[ctxt->nameNr];

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _ret$[ebp], edx

; 1892 :     ctxt->nameTab[ctxt->nameNr] = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR [eax+ecx*4], 0

; 1893 :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@nameNsPop:

; 1894 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_nameNsPop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nameNsPush
_TEXT	SEGMENT
tv151 = -12						; size = 4
_tmp2$1 = -8						; size = 4
_tmp$2 = -4						; size = 4
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_prefix$ = 16						; size = 4
_URI$ = 20						; size = 4
_nsNr$ = 24						; size = 4
_nameNsPush PROC					; COMDAT

; 1839 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1840 :     if (ctxt->nameNr >= ctxt->nameMax) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+188]
	cmp	edx, DWORD PTR [ecx+192]
	jl	$LN2@nameNsPush

; 1841 :         const xmlChar * *tmp;
; 1842 :         void **tmp2;
; 1843 :         ctxt->nameMax *= 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+192], ecx

; 1844 :         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+196]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$2[ebp], eax

; 1845 :                                     ctxt->nameMax *
; 1846 :                                     sizeof(ctxt->nameTab[0]));
; 1847 :         if (tmp == NULL) {

	cmp	DWORD PTR _tmp$2[ebp], 0
	jne	SHORT $LN3@nameNsPush

; 1848 : 	    ctxt->nameMax /= 2;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+192]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+192], eax

; 1849 : 	    goto mem_error;

	jmp	$mem_error$6
$LN3@nameNsPush:

; 1850 :         }
; 1851 : 	ctxt->nameTab = tmp;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _tmp$2[ebp]
	mov	DWORD PTR [eax+196], ecx

; 1852 :         tmp2 = (void **) xmlRealloc((void * *)ctxt->pushTab,

	mov	edx, DWORD PTR _ctxt$[ebp]
	imul	eax, DWORD PTR [edx+192], 3
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp2$1[ebp], eax

; 1853 :                                     ctxt->nameMax * 3 *
; 1854 :                                     sizeof(ctxt->pushTab[0]));
; 1855 :         if (tmp2 == NULL) {

	cmp	DWORD PTR _tmp2$1[ebp], 0
	jne	SHORT $LN4@nameNsPush

; 1856 : 	    ctxt->nameMax /= 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+192]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+192], eax

; 1857 : 	    goto mem_error;

	jmp	$mem_error$6
$LN4@nameNsPush:

; 1858 :         }
; 1859 : 	ctxt->pushTab = tmp2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _tmp2$1[ebp]
	mov	DWORD PTR [edx+344], eax
$LN2@nameNsPush:

; 1860 :     }
; 1861 :     ctxt->nameTab[ctxt->nameNr] = value;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1862 :     ctxt->name = value;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx+184], edx

; 1863 :     ctxt->pushTab[ctxt->nameNr * 3] = (void *) prefix;

	mov	eax, DWORD PTR _ctxt$[ebp]
	imul	ecx, DWORD PTR [eax+188], 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+344]
	mov	edx, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 1864 :     ctxt->pushTab[ctxt->nameNr * 3 + 1] = (void *) URI;

	mov	eax, DWORD PTR _ctxt$[ebp]
	imul	ecx, DWORD PTR [eax+188], 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+344]
	mov	edx, DWORD PTR _URI$[ebp]
	mov	DWORD PTR [eax+ecx*4+4], edx

; 1865 :     ctxt->pushTab[ctxt->nameNr * 3 + 2] = (void *) (ptrdiff_t) nsNr;

	mov	eax, DWORD PTR _ctxt$[ebp]
	imul	ecx, DWORD PTR [eax+188], 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+344]
	mov	edx, DWORD PTR _nsNr$[ebp]
	mov	DWORD PTR [eax+ecx*4+8], edx

; 1866 :     return (ctxt->nameNr++);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR tv151[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+188]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+188], eax
	mov	eax, DWORD PTR tv151[ebp]
	jmp	SHORT $LN1@nameNsPush
$mem_error$6:

; 1867 : mem_error:
; 1868 :     xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 1869 :     return (-1);

	or	eax, -1
$LN1@nameNsPush:

; 1870 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_nameNsPush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtGrowAttrs
_TEXT	SEGMENT
_maxatts$ = -12						; size = 4
_attallocs$ = -8					; size = 4
_atts$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nr$ = 12						; size = 4
_xmlCtxtGrowAttrs PROC					; COMDAT

; 1668 : xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1669 :     const xmlChar **atts;
; 1670 :     int *attallocs;
; 1671 :     int maxatts;
; 1672 : 
; 1673 :     if (ctxt->atts == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+300], 0
	jne	$LN2@xmlCtxtGro

; 1674 : 	maxatts = 55; /* allow for 10 attrs by default */

	mov	DWORD PTR _maxatts$[ebp], 55		; 00000037H

; 1675 : 	atts = (const xmlChar **)

	mov	ecx, DWORD PTR _maxatts$[ebp]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _atts$[ebp], eax

; 1676 : 	       xmlMalloc(maxatts * sizeof(xmlChar *));
; 1677 : 	if (atts == NULL) goto mem_error;

	cmp	DWORD PTR _atts$[ebp], 0
	jne	SHORT $LN4@xmlCtxtGro
	jmp	$mem_error$10
$LN4@xmlCtxtGro:

; 1678 : 	ctxt->atts = atts;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [edx+300], eax

; 1679 : 	attallocs = (int *) xmlMalloc((maxatts / 5) * sizeof(int));

	mov	eax, DWORD PTR _maxatts$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _attallocs$[ebp], eax

; 1680 : 	if (attallocs == NULL) goto mem_error;

	cmp	DWORD PTR _attallocs$[ebp], 0
	jne	SHORT $LN5@xmlCtxtGro
	jmp	$mem_error$10
$LN5@xmlCtxtGro:

; 1681 : 	ctxt->attallocs = attallocs;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _attallocs$[ebp]
	mov	DWORD PTR [edx+340], eax

; 1682 : 	ctxt->maxatts = maxatts;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _maxatts$[ebp]
	mov	DWORD PTR [ecx+304], edx
	jmp	$LN3@xmlCtxtGro
$LN2@xmlCtxtGro:

; 1683 :     } else if (nr + 5 > ctxt->maxatts) {

	mov	eax, DWORD PTR _nr$[ebp]
	add	eax, 5
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	eax, DWORD PTR [ecx+304]
	jle	$LN3@xmlCtxtGro

; 1684 : 	maxatts = (nr + 5) * 2;

	mov	edx, DWORD PTR _nr$[ebp]
	lea	eax, DWORD PTR [edx+edx+10]
	mov	DWORD PTR _maxatts$[ebp], eax

; 1685 : 	atts = (const xmlChar **) xmlRealloc((void *) ctxt->atts,

	mov	ecx, DWORD PTR _maxatts$[ebp]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+300]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _atts$[ebp], eax

; 1686 : 				     maxatts * sizeof(const xmlChar *));
; 1687 : 	if (atts == NULL) goto mem_error;

	cmp	DWORD PTR _atts$[ebp], 0
	jne	SHORT $LN7@xmlCtxtGro
	jmp	SHORT $mem_error$10
$LN7@xmlCtxtGro:

; 1688 : 	ctxt->atts = atts;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [ecx+300], edx

; 1689 : 	attallocs = (int *) xmlRealloc((void *) ctxt->attallocs,

	mov	eax, DWORD PTR _maxatts$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+340]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _attallocs$[ebp], eax

; 1690 : 	                             (maxatts / 5) * sizeof(int));
; 1691 : 	if (attallocs == NULL) goto mem_error;

	cmp	DWORD PTR _attallocs$[ebp], 0
	jne	SHORT $LN8@xmlCtxtGro
	jmp	SHORT $mem_error$10
$LN8@xmlCtxtGro:

; 1692 : 	ctxt->attallocs = attallocs;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _attallocs$[ebp]
	mov	DWORD PTR [ecx+340], edx

; 1693 : 	ctxt->maxatts = maxatts;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _maxatts$[ebp]
	mov	DWORD PTR [eax+304], ecx
$LN3@xmlCtxtGro:

; 1694 :     }
; 1695 :     return(ctxt->maxatts);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+304]
	jmp	SHORT $LN1@xmlCtxtGro
$mem_error$10:

; 1696 : mem_error:
; 1697 :     xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 1698 :     return(-1);

	or	eax, -1
$LN1@xmlCtxtGro:

; 1699 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtGrowAttrs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nsPop
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nr$ = 12						; size = 4
_nsPop	PROC						; COMDAT

; 1648 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1649 :     int i;
; 1650 : 
; 1651 :     if (ctxt->nsTab == NULL) return(0);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+336], 0
	jne	SHORT $LN5@nsPop
	xor	eax, eax
	jmp	$LN1@nsPop
$LN5@nsPop:

; 1652 :     if (ctxt->nsNr < nr) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	cmp	edx, DWORD PTR _nr$[ebp]
	jge	SHORT $LN6@nsPop

; 1653 :         xmlGenericError(xmlGenericErrorContext, "Pbm popping %d NS\n", nr);

	mov	esi, esp
	mov	eax, DWORD PTR _nr$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@KIFBOAFI@Pbm?5popping?5?$CFd?5NS?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1654 :         nr = ctxt->nsNr;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	mov	DWORD PTR _nr$[ebp], ecx
$LN6@nsPop:

; 1655 :     }
; 1656 :     if (ctxt->nsNr <= 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+328], 0
	jg	SHORT $LN7@nsPop

; 1657 :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@nsPop
$LN7@nsPop:

; 1658 : 
; 1659 :     for (i = 0;i < nr;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@nsPop
$LN2@nsPop:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@nsPop:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _nr$[ebp]
	jge	SHORT $LN3@nsPop

; 1660 :          ctxt->nsNr--;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	sub	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+328], eax

; 1661 : 	 ctxt->nsTab[ctxt->nsNr] = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+336]
	mov	DWORD PTR [edx+eax*4], 0

; 1662 :     }

	jmp	SHORT $LN2@nsPop
$LN3@nsPop:

; 1663 :     return(nr);

	mov	eax, DWORD PTR _nr$[ebp]
$LN1@nsPop:

; 1664 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_nsPop	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nsPush
_TEXT	SEGMENT
_tmp$1 = -8						; size = 4
_i$2 = -4						; size = 4
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_URL$ = 16						; size = 4
_nsPush	PROC						; COMDAT

; 1598 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1599 :     if (ctxt->options & XML_PARSE_NSCLEAN) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN5@nsPush

; 1600 :         int i;
; 1601 : 	for (i = ctxt->nsNr - 2;i >= 0;i -= 2) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	sub	eax, 2
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN4@nsPush
$LN2@nsPush:
	mov	ecx, DWORD PTR _i$2[ebp]
	sub	ecx, 2
	mov	DWORD PTR _i$2[ebp], ecx
$LN4@nsPush:
	cmp	DWORD PTR _i$2[ebp], 0
	jl	SHORT $LN5@nsPush

; 1602 : 	    if (ctxt->nsTab[i] == prefix) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+336]
	mov	ecx, DWORD PTR _i$2[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	edx, DWORD PTR _prefix$[ebp]
	jne	SHORT $LN6@nsPush

; 1603 : 		/* in scope */
; 1604 : 	        if (ctxt->nsTab[i + 1] == URL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+336]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	cmp	eax, DWORD PTR _URL$[ebp]
	jne	SHORT $LN7@nsPush

; 1605 : 		    return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@nsPush
$LN7@nsPush:

; 1606 : 		/* out of scope keep it */
; 1607 : 		break;

	jmp	SHORT $LN5@nsPush
$LN6@nsPush:

; 1608 : 	    }
; 1609 : 	}

	jmp	SHORT $LN2@nsPush
$LN5@nsPush:

; 1610 :     }
; 1611 :     if ((ctxt->nsMax == 0) || (ctxt->nsTab == NULL)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	je	SHORT $LN10@nsPush
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+336], 0
	jne	SHORT $LN8@nsPush
$LN10@nsPush:

; 1612 : 	ctxt->nsMax = 10;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+332], 10			; 0000000aH

; 1613 : 	ctxt->nsNr = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+328], 0

; 1614 : 	ctxt->nsTab = (const xmlChar **)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+332]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+336], eax

; 1615 : 	              xmlMalloc(ctxt->nsMax * sizeof(xmlChar *));
; 1616 : 	if (ctxt->nsTab == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+336], 0
	jne	SHORT $LN11@nsPush

; 1617 : 	    xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 1618 : 	    ctxt->nsMax = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+332], 0

; 1619 :             return (-1);

	or	eax, -1
	jmp	$LN1@nsPush
$LN11@nsPush:

; 1620 : 	}

	jmp	$LN9@nsPush
$LN8@nsPush:

; 1621 :     } else if (ctxt->nsNr >= ctxt->nsMax) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+328]
	cmp	ecx, DWORD PTR [eax+332]
	jl	SHORT $LN9@nsPush

; 1622 :         const xmlChar ** tmp;
; 1623 :         ctxt->nsMax *= 2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+332]
	shl	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+332], eax

; 1624 :         tmp = (const xmlChar **) xmlRealloc((char *) ctxt->nsTab,

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+332]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+336]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 1625 : 				    ctxt->nsMax * sizeof(ctxt->nsTab[0]));
; 1626 :         if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN13@nsPush

; 1627 :             xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 1628 : 	    ctxt->nsMax /= 2;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+332]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+332], eax

; 1629 :             return (-1);

	or	eax, -1
	jmp	SHORT $LN1@nsPush
$LN13@nsPush:

; 1630 :         }
; 1631 : 	ctxt->nsTab = tmp;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [eax+336], ecx
$LN9@nsPush:

; 1632 :     }
; 1633 :     ctxt->nsTab[ctxt->nsNr++] = prefix;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+336]
	mov	ecx, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+328], eax

; 1634 :     ctxt->nsTab[ctxt->nsNr++] = URL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+336]
	mov	ecx, DWORD PTR _URL$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+328], eax

; 1635 :     return (ctxt->nsNr);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
$LN1@nsPush:

; 1636 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_nsPush	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStringEntityRef
_TEXT	SEGMENT
tv202 = -28						; size = 4
_ent$ = -24						; size = 4
_cur$ = -17						; size = 1
_ptr$ = -12						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParseStringEntityRef PROC				; COMDAT

; 7637 : xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar ** str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 7638 :     xmlChar *name;
; 7639 :     const xmlChar *ptr;
; 7640 :     xmlChar cur;
; 7641 :     xmlEntityPtr ent = NULL;

	mov	DWORD PTR _ent$[ebp], 0

; 7642 : 
; 7643 :     if ((str == NULL) || (*str == NULL))

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN5@xmlParseSt
	mov	eax, DWORD PTR _str$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@xmlParseSt
$LN5@xmlParseSt:

; 7644 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN4@xmlParseSt:

; 7645 :     ptr = *str;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ptr$[ebp], edx

; 7646 :     cur = *ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cur$[ebp], cl

; 7647 :     if (cur != '&')

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 38					; 00000026H
	je	SHORT $LN6@xmlParseSt

; 7648 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN6@xmlParseSt:

; 7649 : 
; 7650 :     ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 7651 :     name = xmlParseStringName(ctxt, &ptr);

	lea	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseStringName
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax

; 7652 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN7@xmlParseSt

; 7653 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CC@PKJKLMCM@xmlParseStringEntityRef?3?5no?5nam@
	push	68					; 00000044H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 7654 : 		       "xmlParseStringEntityRef: no name\n");
; 7655 : 	*str = ptr;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], edx

; 7656 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN7@xmlParseSt:

; 7657 :     }
; 7658 :     if (*ptr != ';') {

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	je	SHORT $LN8@xmlParseSt

; 7659 : 	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);

	push	0
	push	23					; 00000017H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 7660 :         xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7661 : 	*str = ptr;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], edx

; 7662 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN8@xmlParseSt:

; 7663 :     }
; 7664 :     ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 7665 : 
; 7666 : 
; 7667 :     /*
; 7668 :      * Predefined entities override any extra definition
; 7669 :      */
; 7670 :     if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 1048576				; 00100000H
	jne	SHORT $LN9@xmlParseSt

; 7671 :         ent = xmlGetPredefinedEntity(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlGetPredefinedEntity
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 7672 :         if (ent != NULL) {

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN9@xmlParseSt

; 7673 :             xmlFree(name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7674 :             *str = ptr;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], eax

; 7675 :             return(ent);

	mov	eax, DWORD PTR _ent$[ebp]
	jmp	$LN1@xmlParseSt
$LN9@xmlParseSt:

; 7676 :         }
; 7677 :     }
; 7678 : 
; 7679 :     /*
; 7680 :      * Increate the number of entity references parsed
; 7681 :      */
; 7682 :     ctxt->nbentities++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+440]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+440], edx

; 7683 : 
; 7684 :     /*
; 7685 :      * Ask first SAX for entity resolution, otherwise try the
; 7686 :      * entities which may have stored in the parser context.
; 7687 :      */
; 7688 :     if (ctxt->sax != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN11@xmlParseSt

; 7689 : 	if (ctxt->sax->getEntity != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN12@xmlParseSt

; 7690 : 	    ent = ctxt->sax->getEntity(ctxt->userData, name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ent$[ebp], eax
$LN12@xmlParseSt:

; 7691 : 	if ((ent == NULL) && (ctxt->options & XML_PARSE_OLDSAX))

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN13@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 1048576				; 00100000H
	je	SHORT $LN13@xmlParseSt

; 7692 : 	    ent = xmlGetPredefinedEntity(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlGetPredefinedEntity
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax
$LN13@xmlParseSt:

; 7693 : 	if ((ent == NULL) && (ctxt->userData==ctxt)) {

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN11@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _ctxt$[ebp]
	jne	SHORT $LN11@xmlParseSt

; 7694 : 	    ent = xmlSAX2GetEntity(ctxt, name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSAX2GetEntity
	add	esp, 8
	mov	DWORD PTR _ent$[ebp], eax
$LN11@xmlParseSt:

; 7695 : 	}
; 7696 :     }
; 7697 :     if (ctxt->instate == XML_PARSER_EOF) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN15@xmlParseSt

; 7698 : 	xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7699 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN15@xmlParseSt:

; 7700 :     }
; 7701 : 
; 7702 :     /*
; 7703 :      * [ WFC: Entity Declared ]
; 7704 :      * In a document without any DTD, a document with only an
; 7705 :      * internal DTD subset which contains no parameter entity
; 7706 :      * references, or a document with "standalone='yes'", the
; 7707 :      * Name given in the entity reference must match that in an
; 7708 :      * entity declaration, except that well-formed documents
; 7709 :      * need not declare any of the following entities: amp, lt,
; 7710 :      * gt, apos, quot.
; 7711 :      * The declaration of a parameter entity must precede any
; 7712 :      * reference to it.
; 7713 :      * Similarly, the declaration of a general entity must
; 7714 :      * precede any reference to it which appears in a default
; 7715 :      * value in an attribute-list declaration. Note that if
; 7716 :      * entities are declared in the external subset or in
; 7717 :      * external parameter entities, a non-validating processor
; 7718 :      * is not obligated to read and process their declarations;
; 7719 :      * for such documents, the rule that an entity must be
; 7720 :      * declared is a well-formedness constraint only if
; 7721 :      * standalone='yes'.
; 7722 :      */
; 7723 :     if (ent == NULL) {

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN16@xmlParseSt

; 7724 : 	if ((ctxt->standalone == 1) ||

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+28], 1
	je	SHORT $LN20@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+88], 0
	jne	SHORT $LN18@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+92], 0
	jne	SHORT $LN18@xmlParseSt
$LN20@xmlParseSt:

; 7725 : 	    ((ctxt->hasExternalSubset == 0) &&
; 7726 : 	     (ctxt->hasPErefs == 0))) {
; 7727 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@
	push	26					; 0000001aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7728 : 		     "Entity '%s' not defined\n", name);
; 7729 : 	} else {

	jmp	SHORT $LN19@xmlParseSt
$LN18@xmlParseSt:

; 7730 : 	    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMsgStr
	add	esp, 16					; 00000010H
$LN19@xmlParseSt:

; 7731 : 			  "Entity '%s' not defined\n",
; 7732 : 			  name);
; 7733 : 	}
; 7734 : 	xmlParserEntityCheck(ctxt, 0, ent, 0);

	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H

; 7735 : 	/* TODO ? check regressions ctxt->valid = 0; */
; 7736 :     }

	jmp	$LN17@xmlParseSt
$LN16@xmlParseSt:

; 7737 : 
; 7738 :     /*
; 7739 :      * [ WFC: Parsed Entity ]
; 7740 :      * An entity reference must not contain the name of an
; 7741 :      * unparsed entity
; 7742 :      */
; 7743 :     else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+48], 3
	jne	SHORT $LN21@xmlParseSt

; 7744 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0CI@ILCMJJAO@Entity?5reference?5to?5unparsed?5en@
	push	28					; 0000001cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7745 : 		 "Entity reference to unparsed entity %s\n", name);
; 7746 :     }

	jmp	$LN17@xmlParseSt
$LN21@xmlParseSt:

; 7747 : 
; 7748 :     /*
; 7749 :      * [ WFC: No External Entity References ]
; 7750 :      * Attribute values cannot contain direct or indirect
; 7751 :      * entity references to external entities.
; 7752 :      */
; 7753 :     else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], 12			; 0000000cH
	jne	SHORT $LN23@xmlParseSt
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+48], 2
	jne	SHORT $LN23@xmlParseSt

; 7754 : 	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
; 7755 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@HLODLGOA@Attribute?5references?5external?5e@
	push	29					; 0000001dH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7756 : 	 "Attribute references external entity '%s'\n", name);
; 7757 :     }

	jmp	$LN17@xmlParseSt
$LN23@xmlParseSt:

; 7758 :     /*
; 7759 :      * [ WFC: No < in Attribute Values ]
; 7760 :      * The replacement text of any entity referred to directly or
; 7761 :      * indirectly in an attribute value (other than "&lt;") must
; 7762 :      * not contain a <.
; 7763 :      */
; 7764 :     else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
; 7765 : 	     (ent != NULL) && (ent->content != NULL) &&
; 7766 : 	     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], 12			; 0000000cH
	jne	SHORT $LN25@xmlParseSt
	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN25@xmlParseSt
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN25@xmlParseSt
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+48], 6
	je	SHORT $LN25@xmlParseSt
	push	60					; 0000003cH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlParseSt

; 7767 : 	     (xmlStrchr(ent->content, '<'))) {
; 7768 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DI@FDECCCAO@?8?$DM?8?5in?5entity?5?8?$CFs?8?5is?5not?5allow@
	push	38					; 00000026H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7769 :      "'<' in entity '%s' is not allowed in attributes values\n",
; 7770 : 			  name);
; 7771 :     }

	jmp	SHORT $LN17@xmlParseSt
$LN25@xmlParseSt:

; 7772 : 
; 7773 :     /*
; 7774 :      * Internal check, no parameter entities here ...
; 7775 :      */
; 7776 :     else {
; 7777 : 	switch (ent->etype) {

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR tv202[ebp], ecx
	cmp	DWORD PTR tv202[ebp], 4
	jl	SHORT $LN17@xmlParseSt
	cmp	DWORD PTR tv202[ebp], 5
	jle	SHORT $LN27@xmlParseSt
	jmp	SHORT $LN17@xmlParseSt
$LN27@xmlParseSt:

; 7778 : 	    case XML_INTERNAL_PARAMETER_ENTITY:
; 7779 : 	    case XML_EXTERNAL_PARAMETER_ENTITY:
; 7780 : 		xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0DA@CCPGIFBP@Attempt?5to?5reference?5the?5parame@
	push	30					; 0000001eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN17@xmlParseSt:

; 7781 : 	     "Attempt to reference the parameter entity '%s'\n",
; 7782 : 				  name);
; 7783 : 	    break;
; 7784 : 	    default:
; 7785 : 	    break;
; 7786 : 	}
; 7787 :     }
; 7788 : 
; 7789 :     /*
; 7790 :      * [ WFC: No Recursion ]
; 7791 :      * A parsed entity must not contain a recursive reference
; 7792 :      * to itself, either directly or indirectly.
; 7793 :      * Done somewhere else
; 7794 :      */
; 7795 : 
; 7796 :     xmlFree(name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7797 :     *str = ptr;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], eax

; 7798 :     return(ent);

	mov	eax, DWORD PTR _ent$[ebp]
$LN1@xmlParseSt:

; 7799 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@xmlParseSt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@xmlParseSt:
	DD	1
	DD	$LN31@xmlParseSt
$LN31@xmlParseSt:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN30@xmlParseSt
$LN30@xmlParseSt:
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_xmlParseStringEntityRef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCleanSpecialAttr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlCleanSpecialAttr PROC				; COMDAT

; 1368 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1369 :     if (ctxt->attsSpecial == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+352], 0
	jne	SHORT $LN2@xmlCleanSp

; 1370 :         return;

	jmp	SHORT $LN1@xmlCleanSp
$LN2@xmlCleanSp:

; 1371 : 
; 1372 :     xmlHashScanFull(ctxt->attsSpecial, xmlCleanSpecialAttrCallback, ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	push	OFFSET _xmlCleanSpecialAttrCallback
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+352]
	push	eax
	call	_xmlHashScanFull
	add	esp, 12					; 0000000cH

; 1373 : 
; 1374 :     if (xmlHashSize(ctxt->attsSpecial) == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+352]
	push	edx
	call	_xmlHashSize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@xmlCleanSp

; 1375 :         xmlHashFree(ctxt->attsSpecial, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+352]
	push	ecx
	call	_xmlHashFree
	add	esp, 8

; 1376 :         ctxt->attsSpecial = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+352], 0
$LN1@xmlCleanSp:

; 1377 :     }
; 1378 :     return;
; 1379 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCleanSpecialAttr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCleanSpecialAttrCallback
_TEXT	SEGMENT
_ctxt$ = -4						; size = 4
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_fullname$ = 16						; size = 4
_fullattr$ = 20						; size = 4
_unused$ = 24						; size = 4
_xmlCleanSpecialAttrCallback PROC			; COMDAT

; 1350 :                             const xmlChar *unused ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1351 :     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _ctxt$[ebp], eax

; 1352 : 
; 1353 :     if (((ptrdiff_t) payload) == XML_ATTRIBUTE_CDATA) {

	cmp	DWORD PTR _payload$[ebp], 1
	jne	SHORT $LN1@xmlCleanSp

; 1354 :         xmlHashRemoveEntry2(ctxt->attsSpecial, fullname, fullattr, NULL);

	push	0
	mov	ecx, DWORD PTR _fullattr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fullname$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+352]
	push	ecx
	call	_xmlHashRemoveEntry2
	add	esp, 16					; 00000010H
$LN1@xmlCleanSp:

; 1355 :     }
; 1356 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCleanSpecialAttrCallback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlAddSpecialAttr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_fullname$ = 12						; size = 4
_fullattr$ = 16						; size = 4
_type$ = 20						; size = 4
_xmlAddSpecialAttr PROC					; COMDAT

; 1323 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1324 :     if (ctxt->attsSpecial == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+352], 0
	jne	SHORT $LN2@xmlAddSpec

; 1325 :         ctxt->attsSpecial = xmlHashCreateDict(10, ctxt->dict);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	push	10					; 0000000aH
	call	_xmlHashCreateDict
	add	esp, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+352], eax

; 1326 : 	if (ctxt->attsSpecial == NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+352], 0
	jne	SHORT $LN2@xmlAddSpec

; 1327 : 	    goto mem_error;

	jmp	SHORT $mem_error$6
$LN2@xmlAddSpec:

; 1328 :     }
; 1329 : 
; 1330 :     if (xmlHashLookup2(ctxt->attsSpecial, fullname, fullattr) != NULL)

	mov	eax, DWORD PTR _fullattr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fullname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+352]
	push	eax
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@xmlAddSpec

; 1331 :         return;

	jmp	SHORT $LN1@xmlAddSpec
$LN4@xmlAddSpec:

; 1332 : 
; 1333 :     xmlHashAddEntry2(ctxt->attsSpecial, fullname, fullattr,

	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fullattr$[ebp]
	push	edx
	mov	eax, DWORD PTR _fullname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+352]
	push	edx
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H

; 1334 :                      (void *) (ptrdiff_t) type);
; 1335 :     return;

	jmp	SHORT $LN1@xmlAddSpec
$mem_error$6:

; 1336 : 
; 1337 : mem_error:
; 1338 :     xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8
$LN1@xmlAddSpec:

; 1339 :     return;
; 1340 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlAddSpecialAttr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlAddDefAttrs
_TEXT	SEGMENT
_temp$1 = -28						; size = 4
_prefix$ = -24						; size = 4
_name$ = -20						; size = 4
_len$ = -12						; size = 4
_defaults$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_fullname$ = 12						; size = 4
_fullattr$ = 16						; size = 4
_value$ = 20						; size = 4
_xmlAddDefAttrs PROC					; COMDAT

; 1211 :                const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1212 :     xmlDefAttrsPtr defaults;
; 1213 :     int len;
; 1214 :     const xmlChar *name;
; 1215 :     const xmlChar *prefix;
; 1216 : 
; 1217 :     /*
; 1218 :      * Allows to detect attribute redefinitions
; 1219 :      */
; 1220 :     if (ctxt->attsSpecial != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+352], 0
	je	SHORT $LN2@xmlAddDefA

; 1221 :         if (xmlHashLookup2(ctxt->attsSpecial, fullname, fullattr) != NULL)

	mov	ecx, DWORD PTR _fullattr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fullname$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+352]
	push	ecx
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@xmlAddDefA

; 1222 : 	    return;

	jmp	$LN1@xmlAddDefA
$LN2@xmlAddDefA:

; 1223 :     }
; 1224 : 
; 1225 :     if (ctxt->attsDefault == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+348], 0
	jne	SHORT $LN4@xmlAddDefA

; 1226 :         ctxt->attsDefault = xmlHashCreateDict(10, ctxt->dict);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	push	10					; 0000000aH
	call	_xmlHashCreateDict
	add	esp, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+348], eax

; 1227 : 	if (ctxt->attsDefault == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+348], 0
	jne	SHORT $LN4@xmlAddDefA

; 1228 : 	    goto mem_error;

	jmp	$mem_error$23
$LN4@xmlAddDefA:

; 1229 :     }
; 1230 : 
; 1231 :     /*
; 1232 :      * split the element name into prefix:localname , the string found
; 1233 :      * are within the DTD and then not associated to namespace names.
; 1234 :      */
; 1235 :     name = xmlSplitQName3(fullname, &len);

	lea	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fullname$[ebp]
	push	edx
	call	_xmlSplitQName3
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax

; 1236 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN6@xmlAddDefA

; 1237 :         name = xmlDictLookup(ctxt->dict, fullname, -1);

	push	-1
	mov	eax, DWORD PTR _fullname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name$[ebp], eax

; 1238 : 	prefix = NULL;

	mov	DWORD PTR _prefix$[ebp], 0

; 1239 :     } else {

	jmp	SHORT $LN7@xmlAddDefA
$LN6@xmlAddDefA:

; 1240 :         name = xmlDictLookup(ctxt->dict, name, -1);

	push	-1
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name$[ebp], eax

; 1241 : 	prefix = xmlDictLookup(ctxt->dict, fullname, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fullname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _prefix$[ebp], eax
$LN7@xmlAddDefA:

; 1242 :     }
; 1243 : 
; 1244 :     /*
; 1245 :      * make sure there is some storage
; 1246 :      */
; 1247 :     defaults = xmlHashLookup2(ctxt->attsDefault, name, prefix);

	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+348]
	push	ecx
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _defaults$[ebp], eax

; 1248 :     if (defaults == NULL) {

	cmp	DWORD PTR _defaults$[ebp], 0
	jne	SHORT $LN8@xmlAddDefA

; 1249 :         defaults = (xmlDefAttrsPtr) xmlMalloc(sizeof(xmlDefAttrs) +

	mov	esi, esp
	push	108					; 0000006cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _defaults$[ebp], eax

; 1250 : 	                   (4 * 5) * sizeof(const xmlChar *));
; 1251 : 	if (defaults == NULL)

	cmp	DWORD PTR _defaults$[ebp], 0
	jne	SHORT $LN10@xmlAddDefA

; 1252 : 	    goto mem_error;

	jmp	$mem_error$23
$LN10@xmlAddDefA:

; 1253 : 	defaults->nbAttrs = 0;

	mov	edx, DWORD PTR _defaults$[ebp]
	mov	DWORD PTR [edx], 0

; 1254 : 	defaults->maxAttrs = 4;

	mov	eax, DWORD PTR _defaults$[ebp]
	mov	DWORD PTR [eax+4], 4

; 1255 : 	if (xmlHashUpdateEntry2(ctxt->attsDefault, name, prefix,
; 1256 : 	                        defaults, NULL) < 0) {

	push	0
	mov	ecx, DWORD PTR _defaults$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+348]
	push	edx
	call	_xmlHashUpdateEntry2
	add	esp, 20					; 00000014H
	test	eax, eax
	jge	SHORT $LN11@xmlAddDefA

; 1257 : 	    xmlFree(defaults);

	mov	esi, esp
	mov	eax, DWORD PTR _defaults$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1258 : 	    goto mem_error;

	jmp	$mem_error$23
$LN11@xmlAddDefA:

; 1259 : 	}

	jmp	$LN9@xmlAddDefA
$LN8@xmlAddDefA:

; 1260 :     } else if (defaults->nbAttrs >= defaults->maxAttrs) {

	mov	ecx, DWORD PTR _defaults$[ebp]
	mov	edx, DWORD PTR _defaults$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+4]
	jl	$LN9@xmlAddDefA

; 1261 :         xmlDefAttrsPtr temp;
; 1262 : 
; 1263 :         temp = (xmlDefAttrsPtr) xmlRealloc(defaults, sizeof(xmlDefAttrs) +

	mov	ecx, DWORD PTR _defaults$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 1
	imul	eax, edx, 5
	lea	ecx, DWORD PTR [eax*4+28]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _defaults$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _temp$1[ebp], eax

; 1264 : 		       (2 * defaults->maxAttrs * 5) * sizeof(const xmlChar *));
; 1265 : 	if (temp == NULL)

	cmp	DWORD PTR _temp$1[ebp], 0
	jne	SHORT $LN13@xmlAddDefA

; 1266 : 	    goto mem_error;

	jmp	$mem_error$23
$LN13@xmlAddDefA:

; 1267 : 	defaults = temp;

	mov	eax, DWORD PTR _temp$1[ebp]
	mov	DWORD PTR _defaults$[ebp], eax

; 1268 : 	defaults->maxAttrs *= 2;

	mov	ecx, DWORD PTR _defaults$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 1
	mov	eax, DWORD PTR _defaults$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1269 : 	if (xmlHashUpdateEntry2(ctxt->attsDefault, name, prefix,
; 1270 : 	                        defaults, NULL) < 0) {

	push	0
	mov	ecx, DWORD PTR _defaults$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+348]
	push	edx
	call	_xmlHashUpdateEntry2
	add	esp, 20					; 00000014H
	test	eax, eax
	jge	SHORT $LN9@xmlAddDefA

; 1271 : 	    xmlFree(defaults);

	mov	esi, esp
	mov	eax, DWORD PTR _defaults$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1272 : 	    goto mem_error;

	jmp	$mem_error$23
$LN9@xmlAddDefA:

; 1273 : 	}
; 1274 :     }
; 1275 : 
; 1276 :     /*
; 1277 :      * Split the element name into prefix:localname , the string found
; 1278 :      * are within the DTD and hen not associated to namespace names.
; 1279 :      */
; 1280 :     name = xmlSplitQName3(fullattr, &len);

	lea	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fullattr$[ebp]
	push	edx
	call	_xmlSplitQName3
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax

; 1281 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN15@xmlAddDefA

; 1282 :         name = xmlDictLookup(ctxt->dict, fullattr, -1);

	push	-1
	mov	eax, DWORD PTR _fullattr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name$[ebp], eax

; 1283 : 	prefix = NULL;

	mov	DWORD PTR _prefix$[ebp], 0

; 1284 :     } else {

	jmp	SHORT $LN16@xmlAddDefA
$LN15@xmlAddDefA:

; 1285 :         name = xmlDictLookup(ctxt->dict, name, -1);

	push	-1
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name$[ebp], eax

; 1286 : 	prefix = xmlDictLookup(ctxt->dict, fullattr, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fullattr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _prefix$[ebp], eax
$LN16@xmlAddDefA:

; 1287 :     }
; 1288 : 
; 1289 :     defaults->values[5 * defaults->nbAttrs] = name;

	mov	ecx, DWORD PTR _defaults$[ebp]
	imul	edx, DWORD PTR [ecx], 5
	mov	eax, DWORD PTR _defaults$[ebp]
	mov	ecx, DWORD PTR _name$[ebp]
	mov	DWORD PTR [eax+edx*4+8], ecx

; 1290 :     defaults->values[5 * defaults->nbAttrs + 1] = prefix;

	mov	edx, DWORD PTR _defaults$[ebp]
	imul	eax, DWORD PTR [edx], 5
	mov	ecx, DWORD PTR _defaults$[ebp]
	mov	edx, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [ecx+eax*4+12], edx

; 1291 :     /* intern the string and precompute the end */
; 1292 :     len = xmlStrlen(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 1293 :     value = xmlDictLookup(ctxt->dict, value, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _value$[ebp], eax

; 1294 :     defaults->values[5 * defaults->nbAttrs + 2] = value;

	mov	edx, DWORD PTR _defaults$[ebp]
	imul	eax, DWORD PTR [edx], 5
	mov	ecx, DWORD PTR _defaults$[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx+eax*4+16], edx

; 1295 :     defaults->values[5 * defaults->nbAttrs + 3] = value + len;

	mov	eax, DWORD PTR _value$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _defaults$[ebp]
	imul	edx, DWORD PTR [ecx], 5
	mov	ecx, DWORD PTR _defaults$[ebp]
	mov	DWORD PTR [ecx+edx*4+20], eax

; 1296 :     if (ctxt->external)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+96], 0
	je	SHORT $LN17@xmlAddDefA

; 1297 :         defaults->values[5 * defaults->nbAttrs + 4] = BAD_CAST "external";

	mov	eax, DWORD PTR _defaults$[ebp]
	imul	ecx, DWORD PTR [eax], 5
	mov	edx, DWORD PTR _defaults$[ebp]
	mov	DWORD PTR [edx+ecx*4+24], OFFSET ??_C@_08OIBPHJGN@external@
	jmp	SHORT $LN18@xmlAddDefA
$LN17@xmlAddDefA:

; 1298 :     else
; 1299 :         defaults->values[5 * defaults->nbAttrs + 4] = NULL;

	mov	eax, DWORD PTR _defaults$[ebp]
	imul	ecx, DWORD PTR [eax], 5
	mov	edx, DWORD PTR _defaults$[ebp]
	mov	DWORD PTR [edx+ecx*4+24], 0
$LN18@xmlAddDefA:

; 1300 :     defaults->nbAttrs++;

	mov	eax, DWORD PTR _defaults$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _defaults$[ebp]
	mov	DWORD PTR [edx], ecx

; 1301 : 
; 1302 :     return;

	jmp	SHORT $LN1@xmlAddDefA
$mem_error$23:

; 1303 : 
; 1304 : mem_error:
; 1305 :     xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8
$LN1@xmlAddDefA:

; 1306 :     return;
; 1307 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@xmlAddDefA
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN22@xmlAddDefA:
	DD	1
	DD	$LN21@xmlAddDefA
$LN21@xmlAddDefA:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN20@xmlAddDefA
$LN20@xmlAddDefA:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_xmlAddDefAttrs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlAttrNormalizeSpace2
_TEXT	SEGMENT
tv128 = -36						; size = 4
tv166 = -29						; size = 1
tv163 = -28						; size = 4
tv160 = -24						; size = 4
_ret$1 = -20						; size = 4
_cur$ = -16						; size = 4
_need_realloc$ = -12					; size = 4
_remove_head$ = -8					; size = 4
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlAttrNormalizeSpace2 PROC				; COMDAT

; 1152 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1153 :     int i;
; 1154 :     int remove_head = 0;

	mov	DWORD PTR _remove_head$[ebp], 0

; 1155 :     int need_realloc = 0;

	mov	DWORD PTR _need_realloc$[ebp], 0

; 1156 :     const xmlChar *cur;
; 1157 : 
; 1158 :     if ((ctxt == NULL) || (src == NULL) || (len == NULL))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN7@xmlAttrNor
	cmp	DWORD PTR _src$[ebp], 0
	je	SHORT $LN7@xmlAttrNor
	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN6@xmlAttrNor
$LN7@xmlAttrNor:

; 1159 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAttrNor
$LN6@xmlAttrNor:

; 1160 :     i = *len;

	mov	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx

; 1161 :     if (i <= 0)

	cmp	DWORD PTR _i$[ebp], 0
	jg	SHORT $LN8@xmlAttrNor

; 1162 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAttrNor
$LN8@xmlAttrNor:

; 1163 : 
; 1164 :     cur = src;

	mov	edx, DWORD PTR _src$[ebp]
	mov	DWORD PTR _cur$[ebp], edx
$LN2@xmlAttrNor:

; 1165 :     while (*cur == 0x20) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN4@xmlAttrNor

; 1166 :         cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 1167 : 	remove_head++;

	mov	eax, DWORD PTR _remove_head$[ebp]
	add	eax, 1
	mov	DWORD PTR _remove_head$[ebp], eax

; 1168 :     }

	jmp	SHORT $LN2@xmlAttrNor
$LN4@xmlAttrNor:

; 1169 :     while (*cur != 0) {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN5@xmlAttrNor

; 1170 : 	if (*cur == 0x20) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN9@xmlAttrNor

; 1171 : 	    cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 1172 : 	    if ((*cur == 0x20) || (*cur == 0)) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN12@xmlAttrNor
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN11@xmlAttrNor
$LN12@xmlAttrNor:

; 1173 : 	        need_realloc = 1;

	mov	DWORD PTR _need_realloc$[ebp], 1

; 1174 : 		break;

	jmp	SHORT $LN5@xmlAttrNor
$LN11@xmlAttrNor:

; 1175 : 	    }
; 1176 : 	} else

	jmp	SHORT $LN10@xmlAttrNor
$LN9@xmlAttrNor:

; 1177 : 	    cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
$LN10@xmlAttrNor:

; 1178 :     }

	jmp	SHORT $LN4@xmlAttrNor
$LN5@xmlAttrNor:

; 1179 :     if (need_realloc) {

	cmp	DWORD PTR _need_realloc$[ebp], 0
	je	SHORT $LN13@xmlAttrNor

; 1180 :         xmlChar *ret;
; 1181 : 
; 1182 : 	ret = xmlStrndup(src + remove_head, i - remove_head + 1);

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, DWORD PTR _remove_head$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	add	eax, DWORD PTR _remove_head$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _ret$1[ebp], eax

; 1183 : 	if (ret == NULL) {

	cmp	DWORD PTR _ret$1[ebp], 0
	jne	SHORT $LN15@xmlAttrNor

; 1184 : 	    xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 1185 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAttrNor
$LN15@xmlAttrNor:

; 1186 : 	}
; 1187 : 	xmlAttrNormalizeSpace(ret, ret);

	mov	edx, DWORD PTR _ret$1[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$1[ebp]
	push	eax
	call	_xmlAttrNormalizeSpace
	add	esp, 8

; 1188 : 	*len = (int) strlen((const char *)ret);

	mov	ecx, DWORD PTR _ret$1[ebp]
	mov	DWORD PTR tv160[ebp], ecx
	mov	edx, DWORD PTR tv160[ebp]
	add	edx, 1
	mov	DWORD PTR tv163[ebp], edx
$LL18@xmlAttrNor:
	mov	eax, DWORD PTR tv160[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv166[ebp], cl
	add	DWORD PTR tv160[ebp], 1
	cmp	BYTE PTR tv166[ebp], 0
	jne	SHORT $LL18@xmlAttrNor
	mov	edx, DWORD PTR tv160[ebp]
	sub	edx, DWORD PTR tv163[ebp]
	mov	DWORD PTR tv128[ebp], edx
	mov	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR tv128[ebp]
	mov	DWORD PTR [eax], ecx

; 1189 :         return(ret);

	mov	eax, DWORD PTR _ret$1[ebp]
	jmp	SHORT $LN1@xmlAttrNor
	jmp	SHORT $LN14@xmlAttrNor
$LN13@xmlAttrNor:

; 1190 :     } else if (remove_head) {

	cmp	DWORD PTR _remove_head$[ebp], 0
	je	SHORT $LN14@xmlAttrNor

; 1191 :         *len -= remove_head;

	mov	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR _remove_head$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], eax

; 1192 :         memmove(src, src + remove_head, 1 + *len);

	mov	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	add	ecx, DWORD PTR _remove_head$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1193 : 	return(src);

	mov	eax, DWORD PTR _src$[ebp]
	jmp	SHORT $LN1@xmlAttrNor
$LN14@xmlAttrNor:

; 1194 :     }
; 1195 :     return(NULL);

	xor	eax, eax
$LN1@xmlAttrNor:

; 1196 : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAttrNormalizeSpace2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlAttrNormalizeSpace
_TEXT	SEGMENT
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_xmlAttrNormalizeSpace PROC				; COMDAT

; 1119 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1120 :     if ((src == NULL) || (dst == NULL))

	cmp	DWORD PTR _src$[ebp], 0
	je	SHORT $LN9@xmlAttrNor
	cmp	DWORD PTR _dst$[ebp], 0
	jne	SHORT $LN2@xmlAttrNor
$LN9@xmlAttrNor:

; 1121 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAttrNor
$LN2@xmlAttrNor:

; 1122 : 
; 1123 :     while (*src == 0x20) src++;

	mov	eax, DWORD PTR _src$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN4@xmlAttrNor
	mov	edx, DWORD PTR _src$[ebp]
	add	edx, 1
	mov	DWORD PTR _src$[ebp], edx
	jmp	SHORT $LN2@xmlAttrNor
$LN4@xmlAttrNor:

; 1124 :     while (*src != 0) {

	mov	eax, DWORD PTR _src$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@xmlAttrNor

; 1125 : 	if (*src == 0x20) {

	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN10@xmlAttrNor
$LN6@xmlAttrNor:

; 1126 : 	    while (*src == 0x20) src++;

	mov	ecx, DWORD PTR _src$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN7@xmlAttrNor
	mov	eax, DWORD PTR _src$[ebp]
	add	eax, 1
	mov	DWORD PTR _src$[ebp], eax
	jmp	SHORT $LN6@xmlAttrNor
$LN7@xmlAttrNor:

; 1127 : 	    if (*src != 0)

	mov	ecx, DWORD PTR _src$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN12@xmlAttrNor

; 1128 : 		*dst++ = 0x20;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
	mov	ecx, DWORD PTR _dst$[ebp]
	add	ecx, 1
	mov	DWORD PTR _dst$[ebp], ecx
$LN12@xmlAttrNor:

; 1129 : 	} else {

	jmp	SHORT $LN11@xmlAttrNor
$LN10@xmlAttrNor:

; 1130 : 	    *dst++ = *src++;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _dst$[ebp]
	add	edx, 1
	mov	DWORD PTR _dst$[ebp], edx
	mov	eax, DWORD PTR _src$[ebp]
	add	eax, 1
	mov	DWORD PTR _src$[ebp], eax
$LN11@xmlAttrNor:

; 1131 : 	}
; 1132 :     }

	jmp	SHORT $LN4@xmlAttrNor
$LN5@xmlAttrNor:

; 1133 :     *dst = 0;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [ecx], 0

; 1134 :     if (dst == src)

	mov	edx, DWORD PTR _dst$[ebp]
	cmp	edx, DWORD PTR _src$[ebp]
	jne	SHORT $LN13@xmlAttrNor

; 1135 :        return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAttrNor
$LN13@xmlAttrNor:

; 1136 :     return(dst);

	mov	eax, DWORD PTR _dst$[ebp]
$LN1@xmlAttrNor:

; 1137 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlAttrNormalizeSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlDetectSAX2
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlDetectSAX2 PROC					; COMDAT

; 1068 : xmlDetectSAX2(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1069 :     if (ctxt == NULL) return;

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlDetectS
	jmp	$LN1@xmlDetectS
$LN2@xmlDetectS:

; 1070 : #ifdef LIBXML_SAX1_ENABLED
; 1071 :     if ((ctxt->sax) &&  (ctxt->sax->initialized == XML_SAX2_MAGIC) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlDetectS
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+108], -554844497		; deedbeafH
	jne	SHORT $LN3@xmlDetectS
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+116], 0
	jne	SHORT $LN4@xmlDetectS
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+120], 0
	je	SHORT $LN3@xmlDetectS
$LN4@xmlDetectS:

; 1072 :         ((ctxt->sax->startElementNs != NULL) ||
; 1073 :          (ctxt->sax->endElementNs != NULL))) ctxt->sax2 = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+324], 1
$LN3@xmlDetectS:

; 1074 : #else
; 1075 :     ctxt->sax2 = 1;
; 1076 : #endif /* LIBXML_SAX1_ENABLED */
; 1077 : 
; 1078 :     ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);

	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+312], eax

; 1079 :     ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);

	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+316], eax

; 1080 :     ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);

	push	36					; 00000024H
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+320], eax

; 1081 :     if ((ctxt->str_xml==NULL) || (ctxt->str_xmlns==NULL) ||

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+312], 0
	je	SHORT $LN6@xmlDetectS
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+316], 0
	je	SHORT $LN6@xmlDetectS
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+320], 0
	jne	SHORT $LN1@xmlDetectS
$LN6@xmlDetectS:

; 1082 : 		(ctxt->str_xml_ns == NULL)) {
; 1083 :         xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8
$LN1@xmlDetectS:

; 1084 :     }
; 1085 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDetectSAX2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlNsWarn
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_info1$ = 20						; size = 4
_info2$ = 24						; size = 4
_info3$ = 28						; size = 4
_xmlNsWarn PROC						; COMDAT

; 821  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 822  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlNsWarn
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlNsWarn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlNsWarn

; 823  :         (ctxt->instate == XML_PARSER_EOF))
; 824  : 	return;

	jmp	SHORT $LN1@xmlNsWarn
$LN2@xmlNsWarn:

; 825  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,

	mov	edx, DWORD PTR _info3$[ebp]
	push	edx
	mov	eax, DWORD PTR _info2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _info1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _info3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _info2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info1$[ebp]
	push	edx
	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _error$[ebp]
	push	eax
	push	3
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH
$LN1@xmlNsWarn:

; 826  :                     XML_ERR_WARNING, NULL, 0, (const char *) info1,
; 827  :                     (const char *) info2, (const char *) info3, 0, 0, msg,
; 828  :                     info1, info2, info3);
; 829  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlNsWarn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlNsErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_info1$ = 20						; size = 4
_info2$ = 24						; size = 4
_info3$ = 28						; size = 4
_xmlNsErr PROC						; COMDAT

; 792  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 793  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlNsErr
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlNsErr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlNsErr

; 794  :         (ctxt->instate == XML_PARSER_EOF))
; 795  : 	return;

	jmp	SHORT $LN1@xmlNsErr
$LN2@xmlNsErr:

; 796  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlNsErr

; 797  : 	ctxt->errNo = error;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [edx+84], eax
$LN3@xmlNsErr:

; 798  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,

	mov	ecx, DWORD PTR _info3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info2$[ebp]
	push	edx
	mov	eax, DWORD PTR _info1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _info3$[ebp]
	push	edx
	mov	eax, DWORD PTR _info2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _info1$[ebp]
	push	ecx
	push	0
	push	0
	push	2
	mov	edx, DWORD PTR _error$[ebp]
	push	edx
	push	3
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 799  :                     XML_ERR_ERROR, NULL, 0, (const char *) info1,
; 800  :                     (const char *) info2, (const char *) info3, 0, 0, msg,
; 801  :                     info1, info2, info3);
; 802  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN1@xmlNsErr

; 803  : 	ctxt->nsWellFormed = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+356], 0
$LN1@xmlNsErr:

; 804  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlNsErr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlErrMsgStr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_val$ = 20						; size = 4
_xmlErrMsgStr PROC					; COMDAT

; 765  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 766  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlErrMsgS
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlErrMsgS
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlErrMsgS

; 767  :         (ctxt->instate == XML_PARSER_EOF))
; 768  : 	return;

	jmp	SHORT $LN1@xmlErrMsgS
$LN2@xmlErrMsgS:

; 769  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlErrMsgS

; 770  : 	ctxt->errNo = error;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [edx+84], eax
$LN3@xmlErrMsgS:

; 771  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,

	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	0
	push	0
	push	2
	mov	ecx, DWORD PTR _error$[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN1@xmlErrMsgS:

; 772  :                     XML_FROM_PARSER, error, XML_ERR_ERROR,
; 773  :                     NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
; 774  :                     val);
; 775  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlErrMsgStr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlFatalErrMsgStr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_val$ = 20						; size = 4
_xmlFatalErrMsgStr PROC					; COMDAT

; 736  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 737  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlFatalEr
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlFatalEr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlFatalEr

; 738  :         (ctxt->instate == XML_PARSER_EOF))
; 739  : 	return;

	jmp	SHORT $LN1@xmlFatalEr
$LN2@xmlFatalEr:

; 740  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlFatalEr

; 741  : 	ctxt->errNo = error;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [edx+84], eax
$LN3@xmlFatalEr:

; 742  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,

	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _error$[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 743  :                     XML_FROM_PARSER, error, XML_ERR_FATAL,
; 744  :                     NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
; 745  :                     val);
; 746  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN1@xmlFatalEr

; 747  : 	ctxt->wellFormed = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+12], 0

; 748  : 	if (ctxt->recovery == 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+288], 0
	jne	SHORT $LN1@xmlFatalEr

; 749  : 	    ctxt->disableSAX = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+212], 1
$LN1@xmlFatalEr:

; 750  :     }
; 751  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFatalErrMsgStr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlFatalErrMsgStrIntStr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_val$ = 24						; size = 4
_str2$ = 28						; size = 4
_xmlFatalErrMsgStrIntStr PROC				; COMDAT

; 707  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 708  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlFatalEr
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlFatalEr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlFatalEr

; 709  :         (ctxt->instate == XML_PARSER_EOF))
; 710  : 	return;

	jmp	SHORT $LN1@xmlFatalEr
$LN2@xmlFatalEr:

; 711  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlFatalEr

; 712  : 	ctxt->errNo = error;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [edx+84], eax
$LN3@xmlFatalEr:

; 713  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	ecx, DWORD PTR _str2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	eax, DWORD PTR _str1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _str2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str1$[ebp]
	push	ecx
	push	0
	push	0
	push	3
	mov	edx, DWORD PTR _error$[ebp]
	push	edx
	push	1
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 76					; 0000004cH

; 714  :                     ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
; 715  :                     NULL, 0, (const char *) str1, (const char *) str2,
; 716  : 		    NULL, val, 0, msg, str1, val, str2);
; 717  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN1@xmlFatalEr

; 718  : 	ctxt->wellFormed = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 719  : 	if (ctxt->recovery == 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+288], 0
	jne	SHORT $LN1@xmlFatalEr

; 720  : 	    ctxt->disableSAX = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+212], 1
$LN1@xmlFatalEr:

; 721  :     }
; 722  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFatalErrMsgStrIntStr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlFatalErrMsgInt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_val$ = 20						; size = 4
_xmlFatalErrMsgInt PROC					; COMDAT

; 676  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 677  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlFatalEr
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlFatalEr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlFatalEr

; 678  :         (ctxt->instate == XML_PARSER_EOF))
; 679  : 	return;

	jmp	SHORT $LN1@xmlFatalEr
$LN2@xmlFatalEr:

; 680  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlFatalEr

; 681  : 	ctxt->errNo = error;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [edx+84], eax
$LN3@xmlFatalEr:

; 682  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _error$[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 683  :                     ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
; 684  :                     NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
; 685  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN1@xmlFatalEr

; 686  : 	ctxt->wellFormed = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+12], 0

; 687  : 	if (ctxt->recovery == 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+288], 0
	jne	SHORT $LN1@xmlFatalEr

; 688  : 	    ctxt->disableSAX = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+212], 1
$LN1@xmlFatalEr:

; 689  :     }
; 690  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFatalErrMsgInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlValidityError
_TEXT	SEGMENT
_schannel$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_str2$ = 24						; size = 4
_xmlValidityError PROC					; COMDAT

; 636  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 637  :     xmlStructuredErrorFunc schannel = NULL;

	mov	DWORD PTR _schannel$[ebp], 0

; 638  : 
; 639  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlValidit
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlValidit
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlValidit

; 640  :         (ctxt->instate == XML_PARSER_EOF))
; 641  : 	return;

	jmp	$LN1@xmlValidit
$LN2@xmlValidit:

; 642  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlValidit

; 643  : 	ctxt->errNo = error;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [edx+84], eax

; 644  : 	if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@xmlValidit
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+108], -554844497		; deedbeafH
	jne	SHORT $LN3@xmlValidit

; 645  : 	    schannel = ctxt->sax->serror;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+124]
	mov	DWORD PTR _schannel$[ebp], eax
$LN3@xmlValidit:

; 646  :     }
; 647  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN5@xmlValidit

; 648  :         __xmlRaiseError(schannel,

	mov	ecx, DWORD PTR _str2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str1$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _str2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str1$[ebp]
	push	edx
	push	0
	push	0
	push	2
	mov	eax, DWORD PTR _error$[ebp]
	push	eax
	push	4
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	push	edx
	mov	eax, DWORD PTR _schannel$[ebp]
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 649  :                     ctxt->vctxt.error, ctxt->vctxt.userData,
; 650  :                     ctxt, NULL, XML_FROM_DTD, error,
; 651  :                     XML_ERR_ERROR, NULL, 0, (const char *) str1,
; 652  : 		    (const char *) str2, NULL, 0, 0,
; 653  : 		    msg, (const char *) str1, (const char *) str2);
; 654  : 	ctxt->valid = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 655  :     } else {

	jmp	SHORT $LN1@xmlValidit
$LN5@xmlValidit:

; 656  :         __xmlRaiseError(schannel, NULL, NULL,

	mov	edx, DWORD PTR _str2$[ebp]
	push	edx
	mov	eax, DWORD PTR _str1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _str2$[ebp]
	push	edx
	mov	eax, DWORD PTR _str1$[ebp]
	push	eax
	push	0
	push	0
	push	2
	mov	ecx, DWORD PTR _error$[ebp]
	push	ecx
	push	4
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _schannel$[ebp]
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN1@xmlValidit:

; 657  :                     ctxt, NULL, XML_FROM_DTD, error,
; 658  :                     XML_ERR_ERROR, NULL, 0, (const char *) str1,
; 659  : 		    (const char *) str2, NULL, 0, 0,
; 660  : 		    msg, (const char *) str1, (const char *) str2);
; 661  :     }
; 662  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlValidityError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlWarningMsg
_TEXT	SEGMENT
tv131 = -8						; size = 4
_schannel$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_str1$ = 20						; size = 4
_str2$ = 24						; size = 4
_xmlWarningMsg PROC					; COMDAT

; 598  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 599  :     xmlStructuredErrorFunc schannel = NULL;

	mov	DWORD PTR _schannel$[ebp], 0

; 600  : 
; 601  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlWarning
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlWarning
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlWarning

; 602  :         (ctxt->instate == XML_PARSER_EOF))
; 603  : 	return;

	jmp	$LN1@xmlWarning
$LN2@xmlWarning:

; 604  :     if ((ctxt != NULL) && (ctxt->sax != NULL) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlWarning
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN3@xmlWarning
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+108], -554844497		; deedbeafH
	jne	SHORT $LN3@xmlWarning

; 605  :         (ctxt->sax->initialized == XML_SAX2_MAGIC))
; 606  :         schannel = ctxt->sax->serror;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR _schannel$[ebp], ecx
$LN3@xmlWarning:

; 607  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN4@xmlWarning

; 608  :         __xmlRaiseError(schannel,

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN7@xmlWarning
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN8@xmlWarning
$LN7@xmlWarning:
	mov	DWORD PTR tv131[ebp], 0
$LN8@xmlWarning:
	mov	eax, DWORD PTR _str2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _str2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str1$[ebp]
	push	ecx
	push	0
	push	0
	push	1
	mov	edx, DWORD PTR _error$[ebp]
	push	edx
	push	1
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR tv131[ebp]
	push	eax
	mov	ecx, DWORD PTR _schannel$[ebp]
	push	ecx
	call	___xmlRaiseError
	add	esp, 72					; 00000048H

; 609  :                     (ctxt->sax) ? ctxt->sax->warning : NULL,
; 610  :                     ctxt->userData,
; 611  :                     ctxt, NULL, XML_FROM_PARSER, error,
; 612  :                     XML_ERR_WARNING, NULL, 0,
; 613  : 		    (const char *) str1, (const char *) str2, NULL, 0, 0,
; 614  : 		    msg, (const char *) str1, (const char *) str2);
; 615  :     } else {

	jmp	SHORT $LN1@xmlWarning
$LN4@xmlWarning:

; 616  :         __xmlRaiseError(schannel, NULL, NULL,

	mov	edx, DWORD PTR _str2$[ebp]
	push	edx
	mov	eax, DWORD PTR _str1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _str2$[ebp]
	push	edx
	mov	eax, DWORD PTR _str1$[ebp]
	push	eax
	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _error$[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _schannel$[ebp]
	push	eax
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN1@xmlWarning:

; 617  :                     ctxt, NULL, XML_FROM_PARSER, error,
; 618  :                     XML_ERR_WARNING, NULL, 0,
; 619  : 		    (const char *) str1, (const char *) str2, NULL, 0, 0,
; 620  : 		    msg, (const char *) str1, (const char *) str2);
; 621  :     }
; 622  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlWarningMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlFatalErrMsg
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_xmlFatalErrMsg PROC					; COMDAT

; 570  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 571  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlFatalEr
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlFatalEr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlFatalEr

; 572  :         (ctxt->instate == XML_PARSER_EOF))
; 573  : 	return;

	jmp	SHORT $LN1@xmlFatalEr
$LN2@xmlFatalEr:

; 574  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlFatalEr

; 575  : 	ctxt->errNo = error;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [edx+84], eax
$LN3@xmlFatalEr:

; 576  :     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	mov	edx, DWORD PTR _error$[ebp]
	push	edx
	push	1
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 577  :                     XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, "%s", msg);
; 578  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN1@xmlFatalEr

; 579  : 	ctxt->wellFormed = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 580  : 	if (ctxt->recovery == 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+288], 0
	jne	SHORT $LN1@xmlFatalEr

; 581  : 	    ctxt->disableSAX = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+212], 1
$LN1@xmlFatalEr:

; 582  :     }
; 583  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFatalErrMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlErrAttributeDup
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_prefix$ = 12						; size = 4
_localname$ = 16					; size = 4
_xmlErrAttributeDup PROC				; COMDAT

; 318  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 319  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlErrAttr
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN2@xmlErrAttr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN2@xmlErrAttr

; 320  :         (ctxt->instate == XML_PARSER_EOF))
; 321  : 	return;

	jmp	$LN1@xmlErrAttr
$LN2@xmlErrAttr:

; 322  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlErrAttr

; 323  : 	ctxt->errNo = XML_ERR_ATTRIBUTE_REDEFINED;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+84], 42			; 0000002aH
$LN3@xmlErrAttr:

; 324  : 
; 325  :     if (prefix == NULL)

	cmp	DWORD PTR _prefix$[ebp], 0
	jne	SHORT $LN4@xmlErrAttr

; 326  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	mov	eax, DWORD PTR _localname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BI@LJKBJNKP@Attribute?5?$CFs?5redefined?6@
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _localname$[ebp]
	push	ecx
	push	0
	push	0
	push	3
	push	42					; 0000002aH
	push	1
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	jmp	SHORT $LN5@xmlErrAttr
$LN4@xmlErrAttr:

; 327  :                         XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
; 328  :                         (const char *) localname, NULL, NULL, 0, 0,
; 329  :                         "Attribute %s redefined\n", localname);
; 330  :     else
; 331  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,

	mov	eax, DWORD PTR _localname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BL@GJOEMOIC@Attribute?5?$CFs?3?$CFs?5redefined?6@
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _localname$[ebp]
	push	edx
	mov	eax, DWORD PTR _prefix$[ebp]
	push	eax
	push	0
	push	0
	push	3
	push	42					; 0000002aH
	push	1
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN5@xmlErrAttr:

; 332  :                         XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
; 333  :                         (const char *) prefix, (const char *) localname,
; 334  :                         NULL, 0, 0, "Attribute %s:%s redefined\n", prefix,
; 335  :                         localname);
; 336  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN1@xmlErrAttr

; 337  : 	ctxt->wellFormed = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+12], 0

; 338  : 	if (ctxt->recovery == 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+288], 0
	jne	SHORT $LN1@xmlErrAttr

; 339  : 	    ctxt->disableSAX = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+212], 1
$LN1@xmlErrAttr:

; 340  :     }
; 341  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlErrAttributeDup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlLoadEntityContent
_TEXT	SEGMENT
tv254 = -60						; size = 4
tv256 = -56						; size = 4
tv255 = -52						; size = 4
tv175 = -48						; size = 4
tv174 = -44						; size = 4
tv163 = -40						; size = 4
tv165 = -36						; size = 4
tv164 = -32						; size = 4
_count$ = -28						; size = 4
_c$ = -24						; size = 4
_l$ = -16						; size = 4
_buf$ = -8						; size = 4
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_entity$ = 12						; size = 4
_xmlLoadEntityContent PROC				; COMDAT

; 7976 : xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 7977 :     xmlParserInputPtr input;
; 7978 :     xmlBufferPtr buf;
; 7979 :     int l, c;
; 7980 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 7981 : 
; 7982 :     if ((ctxt == NULL) || (entity == NULL) ||
; 7983 :         ((entity->etype != XML_EXTERNAL_PARAMETER_ENTITY) &&
; 7984 : 	 (entity->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN8@xmlLoadEnt
	cmp	DWORD PTR _entity$[ebp], 0
	je	SHORT $LN8@xmlLoadEnt
	mov	eax, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [eax+48], 5
	je	SHORT $LN9@xmlLoadEnt
	mov	ecx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [ecx+48], 2
	jne	SHORT $LN8@xmlLoadEnt
$LN9@xmlLoadEnt:
	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN7@xmlLoadEnt
$LN8@xmlLoadEnt:

; 7985 : 	(entity->content != NULL)) {
; 7986 : 	xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CF@PMEPEHIL@xmlLoadEntityContent?5parameter?5@
	push	1
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 7987 : 	            "xmlLoadEntityContent parameter error");
; 7988 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlLoadEnt
$LN7@xmlLoadEnt:

; 7989 :     }
; 7990 : 
; 7991 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN10@xmlLoadEnt

; 7992 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _entity$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_0CB@NCAMLBBH@Reading?5?$CFs?5entity?5content?5input@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlLoadEnt:

; 7993 : 		"Reading %s entity content input\n", entity->name);
; 7994 : 
; 7995 :     buf = xmlBufferCreate();

	call	_xmlBufferCreate
	mov	DWORD PTR _buf$[ebp], eax

; 7996 :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN11@xmlLoadEnt

; 7997 : 	xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CF@PMEPEHIL@xmlLoadEntityContent?5parameter?5@
	push	1
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 7998 : 	            "xmlLoadEntityContent parameter error");
; 7999 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlLoadEnt
$LN11@xmlLoadEnt:

; 8000 :     }
; 8001 : 
; 8002 :     input = xmlNewEntityInputStream(ctxt, entity);

	mov	eax, DWORD PTR _entity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNewEntityInputStream
	add	esp, 8
	mov	DWORD PTR _input$[ebp], eax

; 8003 :     if (input == NULL) {

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN12@xmlLoadEnt

; 8004 : 	xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CB@HEAOEFBK@xmlLoadEntityContent?5input?5erro@
	push	1
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 8005 : 	            "xmlLoadEntityContent input error");
; 8006 : 	xmlBufferFree(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferFree
	add	esp, 4

; 8007 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlLoadEnt
$LN12@xmlLoadEnt:

; 8008 :     }
; 8009 : 
; 8010 :     /*
; 8011 :      * Push the entity as the current input, read char by char
; 8012 :      * saving to the buffer until the end of the entity or an error
; 8013 :      */
; 8014 :     if (xmlPushInput(ctxt, input) < 0) {

	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlPushInput
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN13@xmlLoadEnt

; 8015 :         xmlBufferFree(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferFree
	add	esp, 4

; 8016 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlLoadEnt
$LN13@xmlLoadEnt:

; 8017 :     }
; 8018 : 
; 8019 :     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN14@xmlLoadEnt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN14@xmlLoadEnt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN14@xmlLoadEnt:

; 8020 :     c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
$LN2@xmlLoadEnt:

; 8021 :     while ((ctxt->input == input) && (ctxt->input->cur < ctxt->input->end) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR _input$[ebp]
	jne	$LN3@xmlLoadEnt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	cmp	ecx, DWORD PTR [eax+20]
	jae	$LN3@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN35@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 9
	jl	SHORT $LN27@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	jle	SHORT $LN28@xmlLoadEnt
$LN27@xmlLoadEnt:
	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $LN28@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jge	SHORT $LN28@xmlLoadEnt
	mov	DWORD PTR tv164[ebp], 0
	jmp	SHORT $LN34@xmlLoadEnt
$LN28@xmlLoadEnt:
	mov	DWORD PTR tv164[ebp], 1
$LN34@xmlLoadEnt:
	mov	edx, DWORD PTR tv164[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN36@xmlLoadEnt
$LN35@xmlLoadEnt:
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jl	SHORT $LN29@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN31@xmlLoadEnt
$LN29@xmlLoadEnt:
	cmp	DWORD PTR _c$[ebp], 57344		; 0000e000H
	jl	SHORT $LN30@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN31@xmlLoadEnt
$LN30@xmlLoadEnt:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jl	SHORT $LN32@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN31@xmlLoadEnt
$LN32@xmlLoadEnt:
	mov	DWORD PTR tv163[ebp], 0
	jmp	SHORT $LN33@xmlLoadEnt
$LN31@xmlLoadEnt:
	mov	DWORD PTR tv163[ebp], 1
$LN33@xmlLoadEnt:
	mov	eax, DWORD PTR tv163[ebp]
	mov	DWORD PTR tv165[ebp], eax
$LN36@xmlLoadEnt:
	cmp	DWORD PTR tv165[ebp], 0
	je	$LN3@xmlLoadEnt

; 8022 :            (IS_CHAR(c))) {
; 8023 :         xmlBufferAdd(buf, ctxt->input->cur, l);

	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferAdd
	add	esp, 12					; 0000000cH

; 8024 : 	if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv174[ebp], eax
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	cmp	DWORD PTR tv174[ebp], 100		; 00000064H
	jle	SHORT $LN37@xmlLoadEnt
	mov	DWORD PTR tv175[ebp], 1
	jmp	SHORT $LN38@xmlLoadEnt
$LN37@xmlLoadEnt:
	mov	DWORD PTR tv175[ebp], 0
$LN38@xmlLoadEnt:
	cmp	DWORD PTR tv175[ebp], 0
	je	SHORT $LN6@xmlLoadEnt

; 8025 : 	    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 8026 : 	    GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN16@xmlLoadEnt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN16@xmlLoadEnt
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN16@xmlLoadEnt:

; 8027 :             if (ctxt->instate == XML_PARSER_EOF) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN6@xmlLoadEnt

; 8028 :                 xmlBufferFree(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferFree
	add	esp, 4

; 8029 :                 return(-1);

	or	eax, -1
	jmp	$LN1@xmlLoadEnt
$LN6@xmlLoadEnt:

; 8030 :             }
; 8031 : 	}
; 8032 : 	NEXTL(l);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN18@xmlLoadEnt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+28], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN19@xmlLoadEnt
$LN18@xmlLoadEnt:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
$LN19@xmlLoadEnt:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	xor	edx, edx
	jne	SHORT $LN6@xmlLoadEnt

; 8033 : 	c = CUR_CHAR(l);

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 8034 : 	if (c == 0) {

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN20@xmlLoadEnt

; 8035 : 	    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 8036 : 	    GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN21@xmlLoadEnt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN21@xmlLoadEnt
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN21@xmlLoadEnt:

; 8037 :             if (ctxt->instate == XML_PARSER_EOF) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN22@xmlLoadEnt

; 8038 :                 xmlBufferFree(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferFree
	add	esp, 4

; 8039 :                 return(-1);

	or	eax, -1
	jmp	$LN1@xmlLoadEnt
$LN22@xmlLoadEnt:

; 8040 :             }
; 8041 : 	    c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
$LN20@xmlLoadEnt:

; 8042 : 	}
; 8043 :     }

	jmp	$LN2@xmlLoadEnt
$LN3@xmlLoadEnt:

; 8044 : 
; 8045 :     if ((ctxt->input == input) && (ctxt->input->cur >= ctxt->input->end)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR _input$[ebp]
	jne	SHORT $LN23@xmlLoadEnt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	cmp	ecx, DWORD PTR [eax+20]
	jb	SHORT $LN23@xmlLoadEnt

; 8046 :         xmlPopInput(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlPopInput
	add	esp, 4
	jmp	$LN24@xmlLoadEnt
$LN23@xmlLoadEnt:

; 8047 :     } else if (!IS_CHAR(c)) {

	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN47@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 9
	jl	SHORT $LN39@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	jle	SHORT $LN40@xmlLoadEnt
$LN39@xmlLoadEnt:
	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $LN40@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jge	SHORT $LN40@xmlLoadEnt
	mov	DWORD PTR tv255[ebp], 0
	jmp	SHORT $LN46@xmlLoadEnt
$LN40@xmlLoadEnt:
	mov	DWORD PTR tv255[ebp], 1
$LN46@xmlLoadEnt:
	mov	eax, DWORD PTR tv255[ebp]
	mov	DWORD PTR tv256[ebp], eax
	jmp	SHORT $LN48@xmlLoadEnt
$LN47@xmlLoadEnt:
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jl	SHORT $LN41@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN43@xmlLoadEnt
$LN41@xmlLoadEnt:
	cmp	DWORD PTR _c$[ebp], 57344		; 0000e000H
	jl	SHORT $LN42@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN43@xmlLoadEnt
$LN42@xmlLoadEnt:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jl	SHORT $LN44@xmlLoadEnt
	cmp	DWORD PTR _c$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN43@xmlLoadEnt
$LN44@xmlLoadEnt:
	mov	DWORD PTR tv254[ebp], 0
	jmp	SHORT $LN45@xmlLoadEnt
$LN43@xmlLoadEnt:
	mov	DWORD PTR tv254[ebp], 1
$LN45@xmlLoadEnt:
	mov	ecx, DWORD PTR tv254[ebp]
	mov	DWORD PTR tv256[ebp], ecx
$LN48@xmlLoadEnt:
	cmp	DWORD PTR tv256[ebp], 0
	jne	SHORT $LN24@xmlLoadEnt

; 8048 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	push	OFFSET ??_C@_0CN@NHLEKBNA@xmlLoadEntityContent?3?5invalid?5c@
	push	9
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 8049 :                           "xmlLoadEntityContent: invalid char value %d\n",
; 8050 : 	                  c);
; 8051 : 	xmlBufferFree(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferFree
	add	esp, 4

; 8052 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlLoadEnt
$LN24@xmlLoadEnt:

; 8053 :     }
; 8054 :     entity->content = buf->content;

	mov	edx, DWORD PTR _entity$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+40], ecx

; 8055 :     buf->content = NULL;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx], 0

; 8056 :     xmlBufferFree(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferFree
	add	esp, 4

; 8057 : 
; 8058 :     return(0);

	xor	eax, eax
$LN1@xmlLoadEnt:

; 8059 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN51@xmlLoadEnt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN51@xmlLoadEnt:
	DD	1
	DD	$LN50@xmlLoadEnt
$LN50@xmlLoadEnt:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN49@xmlLoadEnt
$LN49@xmlLoadEnt:
	DB	108					; 0000006cH
	DB	0
_xmlLoadEntityContent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseBalancedChunkMemoryInternal
_TEXT	SEGMENT
_cur$1 = -40						; size = 4
_i$ = -36						; size = 4
_ret$ = -32						; size = 4
_size$ = -28						; size = 4
_last$ = -24						; size = 4
_content$ = -20						; size = 4
_oldsax$ = -16						; size = 4
_newRoot$ = -12						; size = 4
_newDoc$ = -8						; size = 4
_ctxt$ = -4						; size = 4
_oldctxt$ = 8						; size = 4
_string$ = 12						; size = 4
_user_data$ = 16					; size = 4
_lst$ = 20						; size = 4
_xmlParseBalancedChunkMemoryInternal PROC		; COMDAT

; 13343: 	const xmlChar *string, void *user_data, xmlNodePtr *lst) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 13344:     xmlParserCtxtPtr ctxt;
; 13345:     xmlDocPtr newDoc = NULL;

	mov	DWORD PTR _newDoc$[ebp], 0

; 13346:     xmlNodePtr newRoot;
; 13347:     xmlSAXHandlerPtr oldsax = NULL;

	mov	DWORD PTR _oldsax$[ebp], 0

; 13348:     xmlNodePtr content = NULL;

	mov	DWORD PTR _content$[ebp], 0

; 13349:     xmlNodePtr last = NULL;

	mov	DWORD PTR _last$[ebp], 0

; 13350:     int size;
; 13351:     xmlParserErrors ret = XML_ERR_OK;

	mov	DWORD PTR _ret$[ebp], 0

; 13352: #ifdef SAX2
; 13353:     int i;
; 13354: #endif
; 13355: 
; 13356:     if (((oldctxt->depth > 40) && ((oldctxt->options & XML_PARSE_HUGE) == 0)) ||

	mov	eax, DWORD PTR _oldctxt$[ebp]
	cmp	DWORD PTR [eax+248], 40			; 00000028H
	jle	SHORT $LN9@xmlParseBa
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	je	SHORT $LN8@xmlParseBa
$LN9@xmlParseBa:
	mov	eax, DWORD PTR _oldctxt$[ebp]
	cmp	DWORD PTR [eax+248], 1024		; 00000400H
	jle	SHORT $LN7@xmlParseBa
$LN8@xmlParseBa:

; 13357:         (oldctxt->depth >  1024)) {
; 13358: 	return(XML_ERR_ENTITY_LOOP);

	mov	eax, 89					; 00000059H
	jmp	$LN1@xmlParseBa
$LN7@xmlParseBa:

; 13359:     }
; 13360: 
; 13361: 
; 13362:     if (lst != NULL)

	cmp	DWORD PTR _lst$[ebp], 0
	je	SHORT $LN10@xmlParseBa

; 13363:         *lst = NULL;

	mov	ecx, DWORD PTR _lst$[ebp]
	mov	DWORD PTR [ecx], 0
$LN10@xmlParseBa:

; 13364:     if (string == NULL)

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN11@xmlParseBa

; 13365:         return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseBa
$LN11@xmlParseBa:

; 13366: 
; 13367:     size = xmlStrlen(string);

	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 13368: 
; 13369:     ctxt = xmlCreateMemoryParserCtxt((char *) string, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_xmlCreateMemoryParserCtxt
	add	esp, 8
	mov	DWORD PTR _ctxt$[ebp], eax

; 13370:     if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN12@xmlParseBa
	mov	eax, 27					; 0000001bH
	jmp	$LN1@xmlParseBa
$LN12@xmlParseBa:

; 13371:     if (user_data != NULL)

	cmp	DWORD PTR _user_data$[ebp], 0
	je	SHORT $LN13@xmlParseBa

; 13372: 	ctxt->userData = user_data;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	SHORT $LN14@xmlParseBa
$LN13@xmlParseBa:

; 13373:     else
; 13374: 	ctxt->userData = ctxt;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN14@xmlParseBa:

; 13375:     if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+296], 0
	je	SHORT $LN15@xmlParseBa
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	_xmlDictFree
	add	esp, 4
$LN15@xmlParseBa:

; 13376:     ctxt->dict = oldctxt->dict;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	DWORD PTR [eax+296], edx

; 13377:     ctxt->input_id = oldctxt->input_id + 1;

	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+464], ecx

; 13378:     ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);

	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+312], eax

; 13379:     ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);

	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+316], eax

; 13380:     ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);

	push	36					; 00000024H
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+320], eax

; 13381: 
; 13382: #ifdef SAX2
; 13383:     /* propagate namespaces down the entity */
; 13384:     for (i = 0;i < oldctxt->nsNr;i += 2) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlParseBa
$LN2@xmlParseBa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlParseBa:
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+328]
	jge	SHORT $LN3@xmlParseBa

; 13385:         nsPush(ctxt, oldctxt->nsTab[i], oldctxt->nsTab[i+1]);

	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+336]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	push	eax
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	edx, DWORD PTR [ecx+336]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_nsPush
	add	esp, 12					; 0000000cH

; 13386:     }

	jmp	SHORT $LN2@xmlParseBa
$LN3@xmlParseBa:

; 13387: #endif
; 13388: 
; 13389:     oldsax = ctxt->sax;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _oldsax$[ebp], ecx

; 13390:     ctxt->sax = oldctxt->sax;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 13391:     xmlDetectSAX2(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDetectSAX2
	add	esp, 4

; 13392:     ctxt->replaceEntities = oldctxt->replaceEntities;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 13393:     ctxt->options = oldctxt->options;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	mov	DWORD PTR [eax+360], edx

; 13394: 
; 13395:     ctxt->_private = oldctxt->_private;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	mov	DWORD PTR [eax+272], edx

; 13396:     if (oldctxt->myDoc == NULL) {

	mov	eax, DWORD PTR _oldctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN16@xmlParseBa

; 13397: 	newDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _newDoc$[ebp], eax

; 13398: 	if (newDoc == NULL) {

	cmp	DWORD PTR _newDoc$[ebp], 0
	jne	SHORT $LN18@xmlParseBa

; 13399: 	    ctxt->sax = oldsax;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _oldsax$[ebp]
	mov	DWORD PTR [ecx], edx

; 13400: 	    ctxt->dict = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+296], 0

; 13401: 	    xmlFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13402: 	    return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseBa
$LN18@xmlParseBa:

; 13403: 	}
; 13404: 	newDoc->properties = XML_DOC_INTERNAL;

	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [edx+92], 64			; 00000040H

; 13405: 	newDoc->dict = ctxt->dict;

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	DWORD PTR [eax+80], edx

; 13406: 	xmlDictReference(newDoc->dict);

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	call	_xmlDictReference
	add	esp, 4

; 13407: 	ctxt->myDoc = newDoc;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [edx+8], eax

; 13408:     } else {

	jmp	SHORT $LN17@xmlParseBa
$LN16@xmlParseBa:

; 13409: 	ctxt->myDoc = oldctxt->myDoc;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _oldctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 13410:         content = ctxt->myDoc->children;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _content$[ebp], eax

; 13411: 	last = ctxt->myDoc->last;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _last$[ebp], eax
$LN17@xmlParseBa:

; 13412:     }
; 13413:     newRoot = xmlNewDocNode(ctxt->myDoc, NULL, BAD_CAST "pseudoroot", NULL);

	push	0
	push	OFFSET ??_C@_0L@OLLEMIAI@pseudoroot@
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newRoot$[ebp], eax

; 13414:     if (newRoot == NULL) {

	cmp	DWORD PTR _newRoot$[ebp], 0
	jne	SHORT $LN19@xmlParseBa

; 13415: 	ctxt->sax = oldsax;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _oldsax$[ebp]
	mov	DWORD PTR [eax], ecx

; 13416: 	ctxt->dict = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+296], 0

; 13417: 	xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13418: 	if (newDoc != NULL) {

	cmp	DWORD PTR _newDoc$[ebp], 0
	je	SHORT $LN20@xmlParseBa

; 13419: 	    xmlFreeDoc(newDoc);

	mov	ecx, DWORD PTR _newDoc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4
$LN20@xmlParseBa:

; 13420: 	}
; 13421: 	return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseBa
$LN19@xmlParseBa:

; 13422:     }
; 13423:     ctxt->myDoc->children = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+12], 0

; 13424:     ctxt->myDoc->last = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+16], 0

; 13425:     xmlAddChild((xmlNodePtr) ctxt->myDoc, newRoot);

	mov	eax, DWORD PTR _newRoot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlAddChild
	add	esp, 8

; 13426:     nodePush(ctxt, ctxt->myDoc->children);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_nodePush
	add	esp, 8

; 13427:     ctxt->instate = XML_PARSER_CONTENT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 7

; 13428:     ctxt->depth = oldctxt->depth + 1;

	mov	edx, DWORD PTR _oldctxt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+248], eax

; 13429: 
; 13430:     ctxt->validate = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+104], 0

; 13431:     ctxt->loadsubset = oldctxt->loadsubset;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	edx, DWORD PTR [ecx+276]
	mov	DWORD PTR [eax+276], edx

; 13432:     if ((oldctxt->validate) || (oldctxt->replaceEntities != 0)) {

	mov	eax, DWORD PTR _oldctxt$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jne	SHORT $LN22@xmlParseBa
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN21@xmlParseBa
$LN22@xmlParseBa:

; 13433: 	/*
; 13434: 	 * ID/IDREF registration will be done in xmlValidateElement below
; 13435: 	 */
; 13436: 	ctxt->loadsubset |= XML_SKIP_IDS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+276]
	or	eax, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+276], eax
$LN21@xmlParseBa:

; 13437:     }
; 13438:     ctxt->dictNames = oldctxt->dictNames;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+364]
	mov	DWORD PTR [edx+364], ecx

; 13439:     ctxt->attsDefault = oldctxt->attsDefault;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+348]
	mov	DWORD PTR [edx+348], ecx

; 13440:     ctxt->attsSpecial = oldctxt->attsSpecial;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+352]
	mov	DWORD PTR [edx+352], ecx

; 13441: 
; 13442:     xmlParseContent(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseContent
	add	esp, 4

; 13443:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN23@xmlParseBa
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN23@xmlParseBa

; 13444: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);

	push	0
	push	85					; 00000055H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN24@xmlParseBa
$LN23@xmlParseBa:

; 13445:     } else if (RAW != 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN24@xmlParseBa

; 13446: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);

	push	0
	push	86					; 00000056H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN24@xmlParseBa:

; 13447:     }
; 13448:     if (ctxt->node != ctxt->myDoc->children) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	cmp	eax, DWORD PTR [ecx+12]
	je	SHORT $LN26@xmlParseBa

; 13449: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);

	push	0
	push	85					; 00000055H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN26@xmlParseBa:

; 13450:     }
; 13451: 
; 13452:     if (!ctxt->wellFormed) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN27@xmlParseBa

; 13453:         if (ctxt->errNo == 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 0
	jne	SHORT $LN29@xmlParseBa

; 13454: 	    ret = XML_ERR_INTERNAL_ERROR;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN30@xmlParseBa
$LN29@xmlParseBa:

; 13455: 	else
; 13456: 	    ret = (xmlParserErrors)ctxt->errNo;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _ret$[ebp], edx
$LN30@xmlParseBa:

; 13457:     } else {

	jmp	SHORT $LN28@xmlParseBa
$LN27@xmlParseBa:

; 13458:       ret = XML_ERR_OK;

	mov	DWORD PTR _ret$[ebp], 0
$LN28@xmlParseBa:

; 13459:     }
; 13460: 
; 13461:     if ((lst != NULL) && (ret == XML_ERR_OK)) {

	cmp	DWORD PTR _lst$[ebp], 0
	je	$LN31@xmlParseBa
	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN31@xmlParseBa

; 13462: 	xmlNodePtr cur;
; 13463: 
; 13464: 	/*
; 13465: 	 * Return the newly created nodeset after unlinking it from
; 13466: 	 * they pseudo parent.
; 13467: 	 */
; 13468: 	cur = ctxt->myDoc->children->children;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$1[ebp], eax

; 13469: 	*lst = cur;

	mov	ecx, DWORD PTR _lst$[ebp]
	mov	edx, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR [ecx], edx
$LN5@xmlParseBa:

; 13470: 	while (cur != NULL) {

	cmp	DWORD PTR _cur$1[ebp], 0
	je	SHORT $LN6@xmlParseBa

; 13471: #ifdef LIBXML_VALID_ENABLED
; 13472: 	    if ((oldctxt->validate) && (oldctxt->wellFormed) &&
; 13473: 		(oldctxt->myDoc) && (oldctxt->myDoc->intSubset) &&

	mov	eax, DWORD PTR _oldctxt$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN32@xmlParseBa
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN32@xmlParseBa
	mov	edx, DWORD PTR _oldctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN32@xmlParseBa
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN32@xmlParseBa
	mov	edx, DWORD PTR _cur$1[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN32@xmlParseBa

; 13474: 		(cur->type == XML_ELEMENT_NODE)) {
; 13475: 		oldctxt->valid &= xmlValidateElement(&oldctxt->vctxt,

	mov	eax, DWORD PTR _cur$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _oldctxt$[ebp]
	add	eax, 108				; 0000006cH
	push	eax
	call	_xmlValidateElement
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	and	eax, DWORD PTR [ecx+100]
	mov	edx, DWORD PTR _oldctxt$[ebp]
	mov	DWORD PTR [edx+100], eax
$LN32@xmlParseBa:

; 13476: 			oldctxt->myDoc, cur);
; 13477: 	    }
; 13478: #endif /* LIBXML_VALID_ENABLED */
; 13479: 	    cur->parent = NULL;

	mov	eax, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR [eax+20], 0

; 13480: 	    cur = cur->next;

	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$1[ebp], edx

; 13481: 	}

	jmp	SHORT $LN5@xmlParseBa
$LN6@xmlParseBa:

; 13482: 	ctxt->myDoc->children->children = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], 0
$LN31@xmlParseBa:

; 13483:     }
; 13484:     if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN33@xmlParseBa

; 13485: 	xmlFreeNode(ctxt->myDoc->children);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlFreeNode
	add	esp, 4

; 13486:         ctxt->myDoc->children = content;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+12], eax

; 13487:         ctxt->myDoc->last = last;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _last$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN33@xmlParseBa:

; 13488:     }
; 13489: 
; 13490:     /*
; 13491:      * Record in the parent context the number of entities replacement
; 13492:      * done when parsing that reference.
; 13493:      */
; 13494:     if (oldctxt != NULL)

	cmp	DWORD PTR _oldctxt$[ebp], 0
	je	SHORT $LN34@xmlParseBa

; 13495:         oldctxt->nbentities += ctxt->nbentities;

	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	edx, DWORD PTR [ecx+440]
	mov	eax, DWORD PTR _ctxt$[ebp]
	add	edx, DWORD PTR [eax+440]
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	DWORD PTR [ecx+440], edx
$LN34@xmlParseBa:

; 13496: 
; 13497:     /*
; 13498:      * Also record the last error if any
; 13499:      */
; 13500:     if (ctxt->lastError.code != XML_ERR_OK)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+388], 0
	je	SHORT $LN35@xmlParseBa

; 13501:         xmlCopyError(&ctxt->lastError, &oldctxt->lastError);

	mov	eax, DWORD PTR _oldctxt$[ebp]
	add	eax, 384				; 00000180H
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	ecx, 384				; 00000180H
	push	ecx
	call	_xmlCopyError
	add	esp, 8
$LN35@xmlParseBa:

; 13502: 
; 13503:     ctxt->sax = oldsax;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldsax$[ebp]
	mov	DWORD PTR [edx], eax

; 13504:     ctxt->dict = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+296], 0

; 13505:     ctxt->attsDefault = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+348], 0

; 13506:     ctxt->attsSpecial = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+352], 0

; 13507:     xmlFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13508:     if (newDoc != NULL) {

	cmp	DWORD PTR _newDoc$[ebp], 0
	je	SHORT $LN36@xmlParseBa

; 13509: 	xmlFreeDoc(newDoc);

	mov	edx, DWORD PTR _newDoc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4
$LN36@xmlParseBa:

; 13510:     }
; 13511: 
; 13512:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseBa:

; 13513: }

	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseBalancedChunkMemoryInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlAddEntityReference
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_firstNode$ = 12					; size = 4
_lastNode$ = 16						; size = 4
_xmlAddEntityReference PROC				; COMDAT

; 14666: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14667:     if (xmlEntityRefFunc != NULL) {

	cmp	DWORD PTR _xmlEntityRefFunc, 0
	je	SHORT $LN1@xmlAddEnti

; 14668:         (*xmlEntityRefFunc) (ent, firstNode, lastNode);

	mov	esi, esp
	mov	eax, DWORD PTR _lastNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _firstNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	DWORD PTR _xmlEntityRefFunc
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlAddEnti:

; 14669:     }
; 14670: }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlAddEntityReference ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtUseOptionsInternal
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_options$ = 12						; size = 4
_encoding$ = 16						; size = 4
_xmlCtxtUseOptionsInternal PROC				; COMDAT

; 15024: {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15025:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlCtxtUse

; 15026:         return(-1);

	or	eax, -1
	jmp	$LN1@xmlCtxtUse
$LN2@xmlCtxtUse:

; 15027:     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN3@xmlCtxtUse

; 15028:         if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN4@xmlCtxtUse

; 15029: 	    xmlFree((xmlChar *) ctxt->encoding);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlCtxtUse:

; 15030:         ctxt->encoding = xmlStrdup((const xmlChar *) encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN3@xmlCtxtUse:

; 15031:     }
; 15032:     if (options & XML_PARSE_RECOVER) {

	mov	edx, DWORD PTR _options$[ebp]
	and	edx, 1
	je	SHORT $LN5@xmlCtxtUse

; 15033:         ctxt->recovery = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+288], 1

; 15034:         options -= XML_PARSE_RECOVER;

	mov	ecx, DWORD PTR _options$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _options$[ebp], ecx

; 15035: 	ctxt->options |= XML_PARSE_RECOVER;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	or	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+360], eax

; 15036:     } else

	jmp	SHORT $LN6@xmlCtxtUse
$LN5@xmlCtxtUse:

; 15037:         ctxt->recovery = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+288], 0
$LN6@xmlCtxtUse:

; 15038:     if (options & XML_PARSE_DTDLOAD) {

	mov	eax, DWORD PTR _options$[ebp]
	and	eax, 4
	je	SHORT $LN7@xmlCtxtUse

; 15039:         ctxt->loadsubset = XML_DETECT_IDS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+276], 2

; 15040:         options -= XML_PARSE_DTDLOAD;

	mov	edx, DWORD PTR _options$[ebp]
	sub	edx, 4
	mov	DWORD PTR _options$[ebp], edx

; 15041: 	ctxt->options |= XML_PARSE_DTDLOAD;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	or	ecx, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+360], ecx

; 15042:     } else

	jmp	SHORT $LN8@xmlCtxtUse
$LN7@xmlCtxtUse:

; 15043:         ctxt->loadsubset = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+276], 0
$LN8@xmlCtxtUse:

; 15044:     if (options & XML_PARSE_DTDATTR) {

	mov	ecx, DWORD PTR _options$[ebp]
	and	ecx, 8
	je	SHORT $LN9@xmlCtxtUse

; 15045:         ctxt->loadsubset |= XML_COMPLETE_ATTRS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+276]
	or	eax, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+276], eax

; 15046:         options -= XML_PARSE_DTDATTR;

	mov	edx, DWORD PTR _options$[ebp]
	sub	edx, 8
	mov	DWORD PTR _options$[ebp], edx

; 15047: 	ctxt->options |= XML_PARSE_DTDATTR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	or	ecx, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+360], ecx
$LN9@xmlCtxtUse:

; 15048:     }
; 15049:     if (options & XML_PARSE_NOENT) {

	mov	eax, DWORD PTR _options$[ebp]
	and	eax, 2
	je	SHORT $LN10@xmlCtxtUse

; 15050:         ctxt->replaceEntities = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+16], 1

; 15051:         /* ctxt->loadsubset |= XML_DETECT_IDS; */
; 15052:         options -= XML_PARSE_NOENT;

	mov	edx, DWORD PTR _options$[ebp]
	sub	edx, 2
	mov	DWORD PTR _options$[ebp], edx

; 15053: 	ctxt->options |= XML_PARSE_NOENT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	or	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+360], ecx

; 15054:     } else

	jmp	SHORT $LN11@xmlCtxtUse
$LN10@xmlCtxtUse:

; 15055:         ctxt->replaceEntities = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+16], 0
$LN11@xmlCtxtUse:

; 15056:     if (options & XML_PARSE_PEDANTIC) {

	mov	ecx, DWORD PTR _options$[ebp]
	and	ecx, 128				; 00000080H
	je	SHORT $LN12@xmlCtxtUse

; 15057:         ctxt->pedantic = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+268], 1

; 15058:         options -= XML_PARSE_PEDANTIC;

	mov	eax, DWORD PTR _options$[ebp]
	sub	eax, 128				; 00000080H
	mov	DWORD PTR _options$[ebp], eax

; 15059: 	ctxt->options |= XML_PARSE_PEDANTIC;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+360], edx

; 15060:     } else

	jmp	SHORT $LN13@xmlCtxtUse
$LN12@xmlCtxtUse:

; 15061:         ctxt->pedantic = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+268], 0
$LN13@xmlCtxtUse:

; 15062:     if (options & XML_PARSE_NOBLANKS) {

	mov	edx, DWORD PTR _options$[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN14@xmlCtxtUse

; 15063:         ctxt->keepBlanks = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+208], 0

; 15064:         ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+72], OFFSET _xmlSAX2IgnorableWhitespace

; 15065:         options -= XML_PARSE_NOBLANKS;

	mov	eax, DWORD PTR _options$[ebp]
	sub	eax, 256				; 00000100H
	mov	DWORD PTR _options$[ebp], eax

; 15066: 	ctxt->options |= XML_PARSE_NOBLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	or	edx, 256				; 00000100H
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+360], edx

; 15067:     } else

	jmp	SHORT $LN15@xmlCtxtUse
$LN14@xmlCtxtUse:

; 15068:         ctxt->keepBlanks = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+208], 1
$LN15@xmlCtxtUse:

; 15069:     if (options & XML_PARSE_DTDVALID) {

	mov	edx, DWORD PTR _options$[ebp]
	and	edx, 16					; 00000010H
	je	SHORT $LN16@xmlCtxtUse

; 15070:         ctxt->validate = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+104], 1

; 15071:         if (options & XML_PARSE_NOWARNING)

	mov	ecx, DWORD PTR _options$[ebp]
	and	ecx, 64					; 00000040H
	je	SHORT $LN18@xmlCtxtUse

; 15072:             ctxt->vctxt.warning = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+116], 0
$LN18@xmlCtxtUse:

; 15073:         if (options & XML_PARSE_NOERROR)

	mov	eax, DWORD PTR _options$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN19@xmlCtxtUse

; 15074:             ctxt->vctxt.error = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+112], 0
$LN19@xmlCtxtUse:

; 15075:         options -= XML_PARSE_DTDVALID;

	mov	edx, DWORD PTR _options$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR _options$[ebp], edx

; 15076: 	ctxt->options |= XML_PARSE_DTDVALID;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+360], ecx

; 15077:     } else

	jmp	SHORT $LN17@xmlCtxtUse
$LN16@xmlCtxtUse:

; 15078:         ctxt->validate = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+104], 0
$LN17@xmlCtxtUse:

; 15079:     if (options & XML_PARSE_NOWARNING) {

	mov	ecx, DWORD PTR _options$[ebp]
	and	ecx, 64					; 00000040H
	je	SHORT $LN20@xmlCtxtUse

; 15080:         ctxt->sax->warning = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax+84], 0

; 15081:         options -= XML_PARSE_NOWARNING;

	mov	ecx, DWORD PTR _options$[ebp]
	sub	ecx, 64					; 00000040H
	mov	DWORD PTR _options$[ebp], ecx
$LN20@xmlCtxtUse:

; 15082:     }
; 15083:     if (options & XML_PARSE_NOERROR) {

	mov	edx, DWORD PTR _options$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN21@xmlCtxtUse

; 15084:         ctxt->sax->error = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+88], 0

; 15085:         ctxt->sax->fatalError = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax+92], 0

; 15086:         options -= XML_PARSE_NOERROR;

	mov	ecx, DWORD PTR _options$[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR _options$[ebp], ecx
$LN21@xmlCtxtUse:

; 15087:     }
; 15088: #ifdef LIBXML_SAX1_ENABLED
; 15089:     if (options & XML_PARSE_SAX1) {

	mov	edx, DWORD PTR _options$[ebp]
	and	edx, 512				; 00000200H
	je	SHORT $LN22@xmlCtxtUse

; 15090:         ctxt->sax->startElement = xmlSAX2StartElement;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+56], OFFSET _xmlSAX2StartElement

; 15091:         ctxt->sax->endElement = xmlSAX2EndElement;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax+60], OFFSET _xmlSAX2EndElement

; 15092:         ctxt->sax->startElementNs = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+116], 0

; 15093:         ctxt->sax->endElementNs = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+120], 0

; 15094:         ctxt->sax->initialized = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax+108], 1

; 15095:         options -= XML_PARSE_SAX1;

	mov	ecx, DWORD PTR _options$[ebp]
	sub	ecx, 512				; 00000200H
	mov	DWORD PTR _options$[ebp], ecx

; 15096: 	ctxt->options |= XML_PARSE_SAX1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	or	eax, 512				; 00000200H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+360], eax
$LN22@xmlCtxtUse:

; 15097:     }
; 15098: #endif /* LIBXML_SAX1_ENABLED */
; 15099:     if (options & XML_PARSE_NODICT) {

	mov	edx, DWORD PTR _options$[ebp]
	and	edx, 4096				; 00001000H
	je	SHORT $LN23@xmlCtxtUse

; 15100:         ctxt->dictNames = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+364], 0

; 15101:         options -= XML_PARSE_NODICT;

	mov	ecx, DWORD PTR _options$[ebp]
	sub	ecx, 4096				; 00001000H
	mov	DWORD PTR _options$[ebp], ecx

; 15102: 	ctxt->options |= XML_PARSE_NODICT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	or	eax, 4096				; 00001000H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+360], eax

; 15103:     } else {

	jmp	SHORT $LN24@xmlCtxtUse
$LN23@xmlCtxtUse:

; 15104:         ctxt->dictNames = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+364], 1
$LN24@xmlCtxtUse:

; 15105:     }
; 15106:     if (options & XML_PARSE_NOCDATA) {

	mov	eax, DWORD PTR _options$[ebp]
	and	eax, 16384				; 00004000H
	je	SHORT $LN25@xmlCtxtUse

; 15107:         ctxt->sax->cdataBlock = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+100], 0

; 15108:         options -= XML_PARSE_NOCDATA;

	mov	eax, DWORD PTR _options$[ebp]
	sub	eax, 16384				; 00004000H
	mov	DWORD PTR _options$[ebp], eax

; 15109: 	ctxt->options |= XML_PARSE_NOCDATA;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	or	edx, 16384				; 00004000H
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+360], edx
$LN25@xmlCtxtUse:

; 15110:     }
; 15111:     if (options & XML_PARSE_NSCLEAN) {

	mov	ecx, DWORD PTR _options$[ebp]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN26@xmlCtxtUse

; 15112: 	ctxt->options |= XML_PARSE_NSCLEAN;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	or	eax, 8192				; 00002000H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+360], eax

; 15113:         options -= XML_PARSE_NSCLEAN;

	mov	edx, DWORD PTR _options$[ebp]
	sub	edx, 8192				; 00002000H
	mov	DWORD PTR _options$[ebp], edx
$LN26@xmlCtxtUse:

; 15114:     }
; 15115:     if (options & XML_PARSE_NONET) {

	mov	eax, DWORD PTR _options$[ebp]
	and	eax, 2048				; 00000800H
	je	SHORT $LN27@xmlCtxtUse

; 15116: 	ctxt->options |= XML_PARSE_NONET;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	or	edx, 2048				; 00000800H
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+360], edx

; 15117:         options -= XML_PARSE_NONET;

	mov	ecx, DWORD PTR _options$[ebp]
	sub	ecx, 2048				; 00000800H
	mov	DWORD PTR _options$[ebp], ecx
$LN27@xmlCtxtUse:

; 15118:     }
; 15119:     if (options & XML_PARSE_COMPACT) {

	mov	edx, DWORD PTR _options$[ebp]
	and	edx, 65536				; 00010000H
	je	SHORT $LN28@xmlCtxtUse

; 15120: 	ctxt->options |= XML_PARSE_COMPACT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	or	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+360], ecx

; 15121:         options -= XML_PARSE_COMPACT;

	mov	eax, DWORD PTR _options$[ebp]
	sub	eax, 65536				; 00010000H
	mov	DWORD PTR _options$[ebp], eax
$LN28@xmlCtxtUse:

; 15122:     }
; 15123:     if (options & XML_PARSE_OLD10) {

	mov	ecx, DWORD PTR _options$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN29@xmlCtxtUse

; 15124: 	ctxt->options |= XML_PARSE_OLD10;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	or	eax, 131072				; 00020000H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+360], eax

; 15125:         options -= XML_PARSE_OLD10;

	mov	edx, DWORD PTR _options$[ebp]
	sub	edx, 131072				; 00020000H
	mov	DWORD PTR _options$[ebp], edx
$LN29@xmlCtxtUse:

; 15126:     }
; 15127:     if (options & XML_PARSE_NOBASEFIX) {

	mov	eax, DWORD PTR _options$[ebp]
	and	eax, 262144				; 00040000H
	je	SHORT $LN30@xmlCtxtUse

; 15128: 	ctxt->options |= XML_PARSE_NOBASEFIX;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	or	edx, 262144				; 00040000H
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+360], edx

; 15129:         options -= XML_PARSE_NOBASEFIX;

	mov	ecx, DWORD PTR _options$[ebp]
	sub	ecx, 262144				; 00040000H
	mov	DWORD PTR _options$[ebp], ecx
$LN30@xmlCtxtUse:

; 15130:     }
; 15131:     if (options & XML_PARSE_HUGE) {

	mov	edx, DWORD PTR _options$[ebp]
	and	edx, 524288				; 00080000H
	je	SHORT $LN31@xmlCtxtUse

; 15132: 	ctxt->options |= XML_PARSE_HUGE;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	or	ecx, 524288				; 00080000H
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+360], ecx

; 15133:         options -= XML_PARSE_HUGE;

	mov	eax, DWORD PTR _options$[ebp]
	sub	eax, 524288				; 00080000H
	mov	DWORD PTR _options$[ebp], eax

; 15134:         if (ctxt->dict != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+296], 0
	je	SHORT $LN31@xmlCtxtUse

; 15135:             xmlDictSetLimit(ctxt->dict, 0);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictSetLimit
	add	esp, 8
$LN31@xmlCtxtUse:

; 15136:     }
; 15137:     if (options & XML_PARSE_OLDSAX) {

	mov	ecx, DWORD PTR _options$[ebp]
	and	ecx, 1048576				; 00100000H
	je	SHORT $LN33@xmlCtxtUse

; 15138: 	ctxt->options |= XML_PARSE_OLDSAX;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	or	eax, 1048576				; 00100000H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+360], eax

; 15139:         options -= XML_PARSE_OLDSAX;

	mov	edx, DWORD PTR _options$[ebp]
	sub	edx, 1048576				; 00100000H
	mov	DWORD PTR _options$[ebp], edx
$LN33@xmlCtxtUse:

; 15140:     }
; 15141:     if (options & XML_PARSE_IGNORE_ENC) {

	mov	eax, DWORD PTR _options$[ebp]
	and	eax, 2097152				; 00200000H
	je	SHORT $LN34@xmlCtxtUse

; 15142: 	ctxt->options |= XML_PARSE_IGNORE_ENC;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	or	edx, 2097152				; 00200000H
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+360], edx

; 15143:         options -= XML_PARSE_IGNORE_ENC;

	mov	ecx, DWORD PTR _options$[ebp]
	sub	ecx, 2097152				; 00200000H
	mov	DWORD PTR _options$[ebp], ecx
$LN34@xmlCtxtUse:

; 15144:     }
; 15145:     if (options & XML_PARSE_BIG_LINES) {

	mov	edx, DWORD PTR _options$[ebp]
	and	edx, 4194304				; 00400000H
	je	SHORT $LN35@xmlCtxtUse

; 15146: 	ctxt->options |= XML_PARSE_BIG_LINES;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	or	ecx, 4194304				; 00400000H
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+360], ecx

; 15147:         options -= XML_PARSE_BIG_LINES;

	mov	eax, DWORD PTR _options$[ebp]
	sub	eax, 4194304				; 00400000H
	mov	DWORD PTR _options$[ebp], eax
$LN35@xmlCtxtUse:

; 15148:     }
; 15149:     ctxt->linenumbers = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+280], 1

; 15150:     return (options);

	mov	eax, DWORD PTR _options$[ebp]
$LN1@xmlCtxtUse:

; 15151: }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtUseOptionsInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseExternalEntityPrivate
_TEXT	SEGMENT
_cur$1 = -40						; size = 4
_enc$ = -36						; size = 4
_start$ = -28						; size = 4
_ret$ = -20						; size = 4
_oldsax$ = -16						; size = 4
_newRoot$ = -12						; size = 4
_newDoc$ = -8						; size = 4
_ctxt$ = -4						; size = 4
_doc$ = 8						; size = 4
_oldctxt$ = 12						; size = 4
_sax$ = 16						; size = 4
_user_data$ = 20					; size = 4
_depth$ = 24						; size = 4
_URL$ = 28						; size = 4
_ID$ = 32						; size = 4
_list$ = 36						; size = 4
_xmlParseExternalEntityPrivate PROC			; COMDAT

; 13077: 		      const xmlChar *ID, xmlNodePtr *list) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 13078:     xmlParserCtxtPtr ctxt;
; 13079:     xmlDocPtr newDoc;
; 13080:     xmlNodePtr newRoot;
; 13081:     xmlSAXHandlerPtr oldsax = NULL;

	mov	DWORD PTR _oldsax$[ebp], 0

; 13082:     xmlParserErrors ret = XML_ERR_OK;

	mov	DWORD PTR _ret$[ebp], 0

; 13083:     xmlChar start[4];
; 13084:     xmlCharEncoding enc;
; 13085: 
; 13086:     if (((depth > 40) &&
; 13087: 	((oldctxt == NULL) || (oldctxt->options & XML_PARSE_HUGE) == 0)) ||

	cmp	DWORD PTR _depth$[ebp], 40		; 00000028H
	jle	SHORT $LN6@xmlParseEx
	cmp	DWORD PTR _oldctxt$[ebp], 0
	je	SHORT $LN5@xmlParseEx
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	je	SHORT $LN5@xmlParseEx
$LN6@xmlParseEx:
	cmp	DWORD PTR _depth$[ebp], 1024		; 00000400H
	jle	SHORT $LN4@xmlParseEx
$LN5@xmlParseEx:

; 13088: 	(depth > 1024)) {
; 13089: 	return(XML_ERR_ENTITY_LOOP);

	mov	eax, 89					; 00000059H
	jmp	$LN1@xmlParseEx
$LN4@xmlParseEx:

; 13090:     }
; 13091: 
; 13092:     if (list != NULL)

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN7@xmlParseEx

; 13093:         *list = NULL;

	mov	edx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx], 0
$LN7@xmlParseEx:

; 13094:     if ((URL == NULL) && (ID == NULL))

	cmp	DWORD PTR _URL$[ebp], 0
	jne	SHORT $LN8@xmlParseEx
	cmp	DWORD PTR _ID$[ebp], 0
	jne	SHORT $LN8@xmlParseEx

; 13095: 	return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseEx
$LN8@xmlParseEx:

; 13096:     if (doc == NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN9@xmlParseEx

; 13097: 	return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseEx
$LN9@xmlParseEx:

; 13098: 
; 13099: 
; 13100:     ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, oldctxt);

	mov	eax, DWORD PTR _oldctxt$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	_xmlCreateEntityParserCtxtInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ctxt$[ebp], eax

; 13101:     if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN10@xmlParseEx
	mov	eax, 27					; 0000001bH
	jmp	$LN1@xmlParseEx
$LN10@xmlParseEx:

; 13102:     ctxt->userData = ctxt;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 13103:     if (oldctxt != NULL) {

	cmp	DWORD PTR _oldctxt$[ebp], 0
	je	SHORT $LN11@xmlParseEx

; 13104: 	ctxt->_private = oldctxt->_private;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	mov	DWORD PTR [edx+272], ecx

; 13105: 	ctxt->loadsubset = oldctxt->loadsubset;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	mov	DWORD PTR [edx+276], ecx

; 13106: 	ctxt->validate = oldctxt->validate;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR [edx+104], ecx

; 13107: 	ctxt->external = oldctxt->external;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR [edx+96], ecx

; 13108: 	ctxt->record_info = oldctxt->record_info;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+68], ecx

; 13109: 	ctxt->node_seq.maximum = oldctxt->node_seq.maximum;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR [edx+72], ecx

; 13110: 	ctxt->node_seq.length = oldctxt->node_seq.length;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [edx+76], ecx

; 13111: 	ctxt->node_seq.buffer = oldctxt->node_seq.buffer;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldctxt$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [edx+80], ecx

; 13112:     } else {

	jmp	SHORT $LN12@xmlParseEx
$LN11@xmlParseEx:

; 13113: 	/*
; 13114: 	 * Doing validity checking on chunk without context
; 13115: 	 * doesn't make sense
; 13116: 	 */
; 13117: 	ctxt->_private = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+272], 0

; 13118: 	ctxt->validate = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+104], 0

; 13119: 	ctxt->external = 2;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+96], 2

; 13120: 	ctxt->loadsubset = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+276], 0
$LN12@xmlParseEx:

; 13121:     }
; 13122:     if (sax != NULL) {

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN13@xmlParseEx

; 13123: 	oldsax = ctxt->sax;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _oldsax$[ebp], ecx

; 13124:         ctxt->sax = sax;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [edx], eax

; 13125: 	if (user_data != NULL)

	cmp	DWORD PTR _user_data$[ebp], 0
	je	SHORT $LN13@xmlParseEx

; 13126: 	    ctxt->userData = user_data;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN13@xmlParseEx:

; 13127:     }
; 13128:     xmlDetectSAX2(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDetectSAX2
	add	esp, 4

; 13129:     newDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _newDoc$[ebp], eax

; 13130:     if (newDoc == NULL) {

	cmp	DWORD PTR _newDoc$[ebp], 0
	jne	SHORT $LN15@xmlParseEx

; 13131: 	ctxt->node_seq.maximum = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 13132: 	ctxt->node_seq.length = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+76], 0

; 13133: 	ctxt->node_seq.buffer = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+80], 0

; 13134: 	xmlFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13135: 	return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseEx
$LN15@xmlParseEx:

; 13136:     }
; 13137:     newDoc->properties = XML_DOC_INTERNAL;

	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [edx+92], 64			; 00000040H

; 13138:     newDoc->intSubset = doc->intSubset;

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx

; 13139:     newDoc->extSubset = doc->extSubset;

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx

; 13140:     newDoc->dict = doc->dict;

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx

; 13141:     xmlDictReference(newDoc->dict);

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	call	_xmlDictReference
	add	esp, 4

; 13142: 
; 13143:     if (doc->URL != NULL) {

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+72], 0
	je	SHORT $LN16@xmlParseEx

; 13144: 	newDoc->URL = xmlStrdup(doc->URL);

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [edx+72], eax
$LN16@xmlParseEx:

; 13145:     }
; 13146:     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST "pseudoroot", NULL);

	push	0
	push	OFFSET ??_C@_0L@OLLEMIAI@pseudoroot@
	push	0
	mov	eax, DWORD PTR _newDoc$[ebp]
	push	eax
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newRoot$[ebp], eax

; 13147:     if (newRoot == NULL) {

	cmp	DWORD PTR _newRoot$[ebp], 0
	jne	SHORT $LN17@xmlParseEx

; 13148: 	if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN18@xmlParseEx

; 13149: 	    ctxt->sax = oldsax;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _oldsax$[ebp]
	mov	DWORD PTR [ecx], edx
$LN18@xmlParseEx:

; 13150: 	ctxt->node_seq.maximum = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+72], 0

; 13151: 	ctxt->node_seq.length = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+76], 0

; 13152: 	ctxt->node_seq.buffer = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+80], 0

; 13153: 	xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13154: 	newDoc->intSubset = NULL;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 13155: 	newDoc->extSubset = NULL;

	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [edx+48], 0

; 13156:         xmlFreeDoc(newDoc);

	mov	eax, DWORD PTR _newDoc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 13157: 	return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseEx
$LN17@xmlParseEx:

; 13158:     }
; 13159:     xmlAddChild((xmlNodePtr) newDoc, newRoot);

	mov	ecx, DWORD PTR _newRoot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newDoc$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8

; 13160:     nodePush(ctxt, newDoc->children);

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_nodePush
	add	esp, 8

; 13161:     ctxt->myDoc = doc;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 13162:     newRoot->doc = doc;

	mov	edx, DWORD PTR _newRoot$[ebp]
	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [edx+32], eax

; 13163: 
; 13164:     /*
; 13165:      * Get the 4 first bytes and decode the charset
; 13166:      * if enc != XML_CHAR_ENCODING_NONE
; 13167:      * plug some encoding conversion routines.
; 13168:      */
; 13169:     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN19@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN19@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN19@xmlParseEx:

; 13170:     if ((ctxt->input->end - ctxt->input->cur) >= 4) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 4
	jl	$LN20@xmlParseEx

; 13171: 	start[0] = RAW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR _start$[ebp+edx], al

; 13172: 	start[1] = NXT(1);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR [eax+ecx]
	mov	BYTE PTR _start$[ebp+edx], al

; 13173: 	start[2] = NXT(2);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, 1
	shl	edx, 1
	mov	al, BYTE PTR [eax+ecx]
	mov	BYTE PTR _start$[ebp+edx], al

; 13174: 	start[3] = NXT(3);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	mov	eax, 1
	imul	eax, eax, 3
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR _start$[ebp+eax], cl

; 13175: 	enc = xmlDetectCharEncoding(start, 4);

	push	4
	lea	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$[ebp], eax

; 13176: 	if (enc != XML_CHAR_ENCODING_NONE) {

	cmp	DWORD PTR _enc$[ebp], 0
	je	SHORT $LN20@xmlParseEx

; 13177: 	    xmlSwitchEncoding(ctxt, enc);

	mov	eax, DWORD PTR _enc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSwitchEncoding
	add	esp, 8
$LN20@xmlParseEx:

; 13178: 	}
; 13179:     }
; 13180: 
; 13181:     /*
; 13182:      * Parse a possible text declaration first
; 13183:      */
; 13184:     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 60					; 0000003cH
	jne	$LN22@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 63					; 0000003fH
	jne	$LN22@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	jne	$LN22@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 109				; 0000006dH
	jne	$LN22@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 108				; 0000006cH
	jne	SHORT $LN22@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN23@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 9
	jl	SHORT $LN24@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN23@xmlParseEx
$LN24@xmlParseEx:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN22@xmlParseEx
$LN23@xmlParseEx:

; 13185: 	xmlParseTextDecl(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseTextDecl
	add	esp, 4
$LN22@xmlParseEx:

; 13186:     }
; 13187: 
; 13188:     ctxt->instate = XML_PARSER_CONTENT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 7

; 13189:     ctxt->depth = depth;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _depth$[ebp]
	mov	DWORD PTR [ecx+248], edx

; 13190: 
; 13191:     xmlParseContent(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseContent
	add	esp, 4

; 13192: 
; 13193:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN25@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN25@xmlParseEx

; 13194: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);

	push	0
	push	85					; 00000055H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN26@xmlParseEx
$LN25@xmlParseEx:

; 13195:     } else if (RAW != 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN26@xmlParseEx

; 13196: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);

	push	0
	push	86					; 00000056H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN26@xmlParseEx:

; 13197:     }
; 13198:     if (ctxt->node != newDoc->children) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	eax, DWORD PTR [ecx+52]
	cmp	eax, DWORD PTR [edx+12]
	je	SHORT $LN28@xmlParseEx

; 13199: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);

	push	0
	push	85					; 00000055H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN28@xmlParseEx:

; 13200:     }
; 13201: 
; 13202:     if (!ctxt->wellFormed) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN29@xmlParseEx

; 13203:         if (ctxt->errNo == 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 0
	jne	SHORT $LN31@xmlParseEx

; 13204: 	    ret = XML_ERR_INTERNAL_ERROR;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN32@xmlParseEx
$LN31@xmlParseEx:

; 13205: 	else
; 13206: 	    ret = (xmlParserErrors)ctxt->errNo;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _ret$[ebp], edx
$LN32@xmlParseEx:

; 13207:     } else {

	jmp	SHORT $LN30@xmlParseEx
$LN29@xmlParseEx:

; 13208: 	if (list != NULL) {

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN33@xmlParseEx

; 13209: 	    xmlNodePtr cur;
; 13210: 
; 13211: 	    /*
; 13212: 	     * Return the newly created nodeset after unlinking it from
; 13213: 	     * they pseudo parent.
; 13214: 	     */
; 13215: 	    cur = newDoc->children->children;

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$1[ebp], edx

; 13216: 	    *list = cur;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@xmlParseEx:

; 13217: 	    while (cur != NULL) {

	cmp	DWORD PTR _cur$1[ebp], 0
	je	SHORT $LN3@xmlParseEx

; 13218: 		cur->parent = NULL;

	mov	edx, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR [edx+20], 0

; 13219: 		cur = cur->next;

	mov	eax, DWORD PTR _cur$1[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$1[ebp], ecx

; 13220: 	    }

	jmp	SHORT $LN2@xmlParseEx
$LN3@xmlParseEx:

; 13221:             newDoc->children->children = NULL;

	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], 0
$LN33@xmlParseEx:

; 13222: 	}
; 13223: 	ret = XML_ERR_OK;

	mov	DWORD PTR _ret$[ebp], 0
$LN30@xmlParseEx:

; 13224:     }
; 13225: 
; 13226:     /*
; 13227:      * Record in the parent context the number of entities replacement
; 13228:      * done when parsing that reference.
; 13229:      */
; 13230:     if (oldctxt != NULL)

	cmp	DWORD PTR _oldctxt$[ebp], 0
	je	SHORT $LN34@xmlParseEx

; 13231:         oldctxt->nbentities += ctxt->nbentities;

	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	edx, DWORD PTR [ecx+440]
	mov	eax, DWORD PTR _ctxt$[ebp]
	add	edx, DWORD PTR [eax+440]
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	DWORD PTR [ecx+440], edx
$LN34@xmlParseEx:

; 13232: 
; 13233:     /*
; 13234:      * Also record the size of the entity parsed
; 13235:      */
; 13236:     if (ctxt->input != NULL && oldctxt != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN35@xmlParseEx
	cmp	DWORD PTR _oldctxt$[ebp], 0
	je	SHORT $LN35@xmlParseEx

; 13237: 	oldctxt->sizeentities += ctxt->input->consumed;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _oldctxt$[ebp]
	mov	eax, DWORD PTR [edx+444]
	add	eax, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	mov	DWORD PTR [ecx+444], eax

; 13238: 	oldctxt->sizeentities += (ctxt->input->cur - ctxt->input->base);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _oldctxt$[ebp]
	add	eax, DWORD PTR [ecx+444]
	mov	edx, DWORD PTR _oldctxt$[ebp]
	mov	DWORD PTR [edx+444], eax
$LN35@xmlParseEx:

; 13239:     }
; 13240:     /*
; 13241:      * And record the last error if any
; 13242:      */
; 13243:     if ((oldctxt != NULL) && (ctxt->lastError.code != XML_ERR_OK))

	cmp	DWORD PTR _oldctxt$[ebp], 0
	je	SHORT $LN36@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+388], 0
	je	SHORT $LN36@xmlParseEx

; 13244:         xmlCopyError(&ctxt->lastError, &oldctxt->lastError);

	mov	ecx, DWORD PTR _oldctxt$[ebp]
	add	ecx, 384				; 00000180H
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	edx, 384				; 00000180H
	push	edx
	call	_xmlCopyError
	add	esp, 8
$LN36@xmlParseEx:

; 13245: 
; 13246:     if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN37@xmlParseEx

; 13247: 	ctxt->sax = oldsax;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _oldsax$[ebp]
	mov	DWORD PTR [eax], ecx
$LN37@xmlParseEx:

; 13248:     if (oldctxt != NULL) {

	cmp	DWORD PTR _oldctxt$[ebp], 0
	je	SHORT $LN38@xmlParseEx

; 13249:         oldctxt->node_seq.maximum = ctxt->node_seq.maximum;

	mov	edx, DWORD PTR _oldctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR [edx+72], ecx

; 13250:         oldctxt->node_seq.length = ctxt->node_seq.length;

	mov	edx, DWORD PTR _oldctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR [edx+76], ecx

; 13251:         oldctxt->node_seq.buffer = ctxt->node_seq.buffer;

	mov	edx, DWORD PTR _oldctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [edx+80], ecx
$LN38@xmlParseEx:

; 13252:     }
; 13253:     ctxt->node_seq.maximum = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+72], 0

; 13254:     ctxt->node_seq.length = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+76], 0

; 13255:     ctxt->node_seq.buffer = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+80], 0

; 13256:     xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13257:     newDoc->intSubset = NULL;

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [eax+44], 0

; 13258:     newDoc->extSubset = NULL;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 13259:     xmlFreeDoc(newDoc);

	mov	edx, DWORD PTR _newDoc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 13260: 
; 13261:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseEx:

; 13262: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN42@xmlParseEx
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlParseEx:
	DD	1
	DD	$LN41@xmlParseEx
$LN41@xmlParseEx:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN40@xmlParseEx
$LN40@xmlParseEx:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
_xmlParseExternalEntityPrivate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStringPEReference
_TEXT	SEGMENT
_entity$ = -24						; size = 4
_name$ = -20						; size = 4
_cur$ = -13						; size = 1
_ptr$ = -8						; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParseStringPEReference PROC				; COMDAT

; 8093 : xmlParseStringPEReference(xmlParserCtxtPtr ctxt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 8094 :     const xmlChar *ptr;
; 8095 :     xmlChar cur;
; 8096 :     xmlChar *name;
; 8097 :     xmlEntityPtr entity = NULL;

	mov	DWORD PTR _entity$[ebp], 0

; 8098 : 
; 8099 :     if ((str == NULL) || (*str == NULL)) return(NULL);

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN3@xmlParseSt
	mov	eax, DWORD PTR _str$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@xmlParseSt
$LN3@xmlParseSt:
	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN2@xmlParseSt:

; 8100 :     ptr = *str;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ptr$[ebp], edx

; 8101 :     cur = *ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cur$[ebp], cl

; 8102 :     if (cur != '%')

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 37					; 00000025H
	je	SHORT $LN4@xmlParseSt

; 8103 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN4@xmlParseSt:

; 8104 :     ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 8105 :     name = xmlParseStringName(ctxt, &ptr);

	lea	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseStringName
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax

; 8106 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN5@xmlParseSt

; 8107 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CE@PLGLFALL@xmlParseStringPEReference?3?5no?5n@
	push	68					; 00000044H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 8108 : 		       "xmlParseStringPEReference: no name\n");
; 8109 : 	*str = ptr;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], edx

; 8110 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN5@xmlParseSt:

; 8111 :     }
; 8112 :     cur = *ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cur$[ebp], cl

; 8113 :     if (cur != ';') {

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN6@xmlParseSt

; 8114 : 	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);

	push	0
	push	23					; 00000017H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 8115 : 	xmlFree(name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8116 : 	*str = ptr;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [edx], eax

; 8117 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN6@xmlParseSt:

; 8118 :     }
; 8119 :     ptr++;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx

; 8120 : 
; 8121 :     /*
; 8122 :      * Increate the number of entity references parsed
; 8123 :      */
; 8124 :     ctxt->nbentities++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+440]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+440], eax

; 8125 : 
; 8126 :     /*
; 8127 :      * Request the entity from SAX
; 8128 :      */
; 8129 :     if ((ctxt->sax != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN7@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+96], 0
	je	SHORT $LN7@xmlParseSt

; 8130 : 	(ctxt->sax->getParameterEntity != NULL))
; 8131 : 	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);

	mov	esi, esp
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+96]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _entity$[ebp], eax
$LN7@xmlParseSt:

; 8132 :     if (ctxt->instate == XML_PARSER_EOF) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN8@xmlParseSt

; 8133 : 	xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8134 : 	*str = ptr;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], edx

; 8135 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN8@xmlParseSt:

; 8136 :     }
; 8137 :     if (entity == NULL) {

	cmp	DWORD PTR _entity$[ebp], 0
	jne	SHORT $LN9@xmlParseSt

; 8138 : 	/*
; 8139 : 	 * [ WFC: Entity Declared ]
; 8140 : 	 * In a document without any DTD, a document with only an
; 8141 : 	 * internal DTD subset which contains no parameter entity
; 8142 : 	 * references, or a document with "standalone='yes'", ...
; 8143 : 	 * ... The declaration of a parameter entity must precede
; 8144 : 	 * any reference to it...
; 8145 : 	 */
; 8146 : 	if ((ctxt->standalone == 1) ||

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+28], 1
	je	SHORT $LN13@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+88], 0
	jne	SHORT $LN11@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+92], 0
	jne	SHORT $LN11@xmlParseSt
$LN13@xmlParseSt:

; 8147 : 	    ((ctxt->hasExternalSubset == 0) && (ctxt->hasPErefs == 0))) {
; 8148 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 8149 : 		 "PEReference: %%%s; not found\n", name);
; 8150 : 	} else {

	jmp	SHORT $LN12@xmlParseSt
$LN11@xmlParseSt:

; 8151 : 	    /*
; 8152 : 	     * [ VC: Entity Declared ]
; 8153 : 	     * In a document with an external subset or external
; 8154 : 	     * parameter entities with "standalone='no'", ...
; 8155 : 	     * ... The declaration of a parameter entity must
; 8156 : 	     * precede any reference to it...
; 8157 : 	     */
; 8158 : 	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
	push	27					; 0000001bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H

; 8159 : 			  "PEReference: %%%s; not found\n",
; 8160 : 			  name, NULL);
; 8161 : 	    ctxt->valid = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+100], 0
$LN12@xmlParseSt:

; 8162 : 	}
; 8163 : 	xmlParserEntityCheck(ctxt, 0, NULL, 0);

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H

; 8164 :     } else {

	jmp	SHORT $LN10@xmlParseSt
$LN9@xmlParseSt:

; 8165 : 	/*
; 8166 : 	 * Internal checking in case the entity quest barfed
; 8167 : 	 */
; 8168 : 	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&

	mov	eax, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [eax+48], 4
	je	SHORT $LN10@xmlParseSt
	mov	ecx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [ecx+48], 5
	je	SHORT $LN10@xmlParseSt

; 8169 : 	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
; 8170 : 	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0CB@HMFAEMHO@?$CF?$CF?$CFs?$DL?5is?5not?5a?5parameter?5entity@
	push	27					; 0000001bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN10@xmlParseSt:

; 8171 : 			  "%%%s; is not a parameter entity\n",
; 8172 : 			  name, NULL);
; 8173 : 	}
; 8174 :     }
; 8175 :     ctxt->hasPErefs = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+92], 1

; 8176 :     xmlFree(name);

	mov	esi, esp
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8177 :     *str = ptr;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 8178 :     return(entity);

	mov	eax, DWORD PTR _entity$[ebp]
$LN1@xmlParseSt:

; 8179 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@xmlParseSt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN18@xmlParseSt:
	DD	1
	DD	$LN17@xmlParseSt
$LN17@xmlParseSt:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN16@xmlParseSt
$LN16@xmlParseSt:
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_xmlParseStringPEReference ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParserEntityCheck
_TEXT	SEGMENT
_rep$1 = -12						; size = 4
_oldnbent$2 = -8					; size = 4
_consumed$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_size$ = 12						; size = 4
_ent$ = 16						; size = 4
_replacement$ = 20					; size = 4
_xmlParserEntityCheck PROC				; COMDAT

; 130  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 131  :     size_t consumed = 0;

	mov	DWORD PTR _consumed$[ebp], 0

; 132  : 
; 133  :     if ((ctxt == NULL) || (ctxt->options & XML_PARSE_HUGE))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlParserE
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	je	SHORT $LN2@xmlParserE
$LN3@xmlParserE:

; 134  :         return (0);

	xor	eax, eax
	jmp	$LN1@xmlParserE
$LN2@xmlParserE:

; 135  :     if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+388], 89			; 00000059H
	jne	SHORT $LN4@xmlParserE

; 136  :         return (1);

	mov	eax, 1
	jmp	$LN1@xmlParserE
$LN4@xmlParserE:

; 137  : 
; 138  :     /*
; 139  :      * This may look absurd but is needed to detect
; 140  :      * entities problems
; 141  :      */
; 142  :     if ((ent != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
; 143  : 	(ent->content != NULL) && (ent->checked == 0) &&

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN5@xmlParserE
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+48], 6
	je	$LN5@xmlParserE
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	$LN5@xmlParserE
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+72], 0
	jne	$LN5@xmlParserE
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 89			; 00000059H
	je	$LN5@xmlParserE

; 144  : 	(ctxt->errNo != XML_ERR_ENTITY_LOOP)) {
; 145  : 	unsigned long oldnbent = ctxt->nbentities;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+440]
	mov	DWORD PTR _oldnbent$2[ebp], edx

; 146  : 	xmlChar *rep;
; 147  : 
; 148  : 	ent->checked = 1;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+72], 1

; 149  : 
; 150  :         ++ctxt->depth;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+248]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+248], edx

; 151  : 	rep = xmlStringDecodeEntities(ctxt, ent->content,

	push	0
	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlStringDecodeEntities
	add	esp, 24					; 00000018H
	mov	DWORD PTR _rep$1[ebp], eax

; 152  : 				  XML_SUBSTITUTE_REF, 0, 0, 0);
; 153  :         --ctxt->depth;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+248]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+248], edx

; 154  : 	if ((rep == NULL) || (ctxt->errNo == XML_ERR_ENTITY_LOOP)) {

	cmp	DWORD PTR _rep$1[ebp], 0
	je	SHORT $LN7@xmlParserE
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+84], 89			; 00000059H
	jne	SHORT $LN6@xmlParserE
$LN7@xmlParserE:

; 155  : 	    ent->content[0] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	BYTE PTR [eax+edx], 0
$LN6@xmlParserE:

; 156  : 	}
; 157  : 
; 158  : 	ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+440]
	sub	ecx, DWORD PTR _oldnbent$2[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+72], edx

; 159  : 	if (rep != NULL) {

	cmp	DWORD PTR _rep$1[ebp], 0
	je	SHORT $LN5@xmlParserE

; 160  : 	    if (xmlStrchr(rep, '<'))

	push	60					; 0000003cH
	mov	ecx, DWORD PTR _rep$1[ebp]
	push	ecx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlParserE

; 161  : 		ent->checked |= 1;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+72]
	or	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+72], eax
$LN9@xmlParserE:

; 162  : 	    xmlFree(rep);

	mov	esi, esp
	mov	edx, DWORD PTR _rep$1[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 163  : 	    rep = NULL;

	mov	DWORD PTR _rep$1[ebp], 0
$LN5@xmlParserE:

; 164  : 	}
; 165  :     }
; 166  :     if (replacement != 0) {

	cmp	DWORD PTR _replacement$[ebp], 0
	je	SHORT $LN10@xmlParserE

; 167  : 	if (replacement < XML_MAX_TEXT_LENGTH)

	cmp	DWORD PTR _replacement$[ebp], 10000000	; 00989680H
	jae	SHORT $LN12@xmlParserE

; 168  : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlParserE
$LN12@xmlParserE:

; 169  : 
; 170  :         /*
; 171  : 	 * If the volume of entity copy reaches 10 times the
; 172  : 	 * amount of parsed data and over the large text threshold
; 173  : 	 * then that's very likely to be an abuse.
; 174  : 	 */
; 175  :         if (ctxt->input != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN13@xmlParserE

; 176  : 	    consumed = ctxt->input->consumed +

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _consumed$[ebp], ecx
$LN13@xmlParserE:

; 177  : 	               (ctxt->input->cur - ctxt->input->base);
; 178  : 	}
; 179  :         consumed += ctxt->sizeentities;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _consumed$[ebp]
	add	eax, DWORD PTR [edx+444]
	mov	DWORD PTR _consumed$[ebp], eax

; 180  : 
; 181  :         if (replacement < XML_PARSER_NON_LINEAR * consumed)

	imul	ecx, DWORD PTR _consumed$[ebp], 10
	cmp	DWORD PTR _replacement$[ebp], ecx
	jae	SHORT $LN14@xmlParserE

; 182  : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlParserE
$LN14@xmlParserE:

; 183  :     } else if (size != 0) {

	jmp	$LN11@xmlParserE
$LN10@xmlParserE:
	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN15@xmlParserE

; 184  :         /*
; 185  :          * Do the check based on the replacement size of the entity
; 186  :          */
; 187  :         if (size < XML_PARSER_BIG_ENTITY)

	cmp	DWORD PTR _size$[ebp], 1000		; 000003e8H
	jae	SHORT $LN17@xmlParserE

; 188  : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlParserE
$LN17@xmlParserE:

; 189  : 
; 190  :         /*
; 191  :          * A limit on the amount of text data reasonably used
; 192  :          */
; 193  :         if (ctxt->input != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN18@xmlParserE

; 194  :             consumed = ctxt->input->consumed +

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _consumed$[ebp], eax
$LN18@xmlParserE:

; 195  :                 (ctxt->input->cur - ctxt->input->base);
; 196  :         }
; 197  :         consumed += ctxt->sizeentities;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _consumed$[ebp]
	add	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR _consumed$[ebp], edx

; 198  : 
; 199  :         if ((size < XML_PARSER_NON_LINEAR * consumed) &&

	imul	eax, DWORD PTR _consumed$[ebp], 10
	cmp	DWORD PTR _size$[ebp], eax
	jae	SHORT $LN19@xmlParserE
	mov	ecx, DWORD PTR _ctxt$[ebp]
	imul	edx, DWORD PTR [ecx+440], 3
	imul	eax, DWORD PTR _consumed$[ebp], 10
	cmp	edx, eax
	jae	SHORT $LN19@xmlParserE

; 200  : 	    (ctxt->nbentities * 3 < XML_PARSER_NON_LINEAR * consumed))
; 201  :             return (0);

	xor	eax, eax
	jmp	$LN1@xmlParserE
$LN19@xmlParserE:

; 202  :     } else if (ent != NULL) {

	jmp	$LN11@xmlParserE
$LN15@xmlParserE:
	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN20@xmlParserE

; 203  :         /*
; 204  :          * use the number of parsed entities in the replacement
; 205  :          */
; 206  :         size = ent->checked / 2;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [ecx+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 207  : 
; 208  :         /*
; 209  :          * The amount of data parsed counting entities size only once
; 210  :          */
; 211  :         if (ctxt->input != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN22@xmlParserE

; 212  :             consumed = ctxt->input->consumed +

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _consumed$[ebp], eax
$LN22@xmlParserE:

; 213  :                 (ctxt->input->cur - ctxt->input->base);
; 214  :         }
; 215  :         consumed += ctxt->sizeentities;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _consumed$[ebp]
	add	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR _consumed$[ebp], edx

; 216  : 
; 217  :         /*
; 218  :          * Check the density of entities for the amount of data
; 219  : 	 * knowing an entity reference will take at least 3 bytes
; 220  :          */
; 221  :         if (size * 3 < consumed * XML_PARSER_NON_LINEAR)

	imul	eax, DWORD PTR _size$[ebp], 3
	imul	ecx, DWORD PTR _consumed$[ebp], 10
	cmp	eax, ecx
	jae	SHORT $LN23@xmlParserE

; 222  :             return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParserE
$LN23@xmlParserE:

; 223  :     } else {

	jmp	SHORT $LN11@xmlParserE
$LN20@xmlParserE:

; 224  :         /*
; 225  :          * strange we got no data for checking
; 226  :          */
; 227  : 	if (((ctxt->lastError.code != XML_ERR_UNDECLARED_ENTITY) &&
; 228  : 	     (ctxt->lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+388], 26			; 0000001aH
	je	SHORT $LN26@xmlParserE
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+388], 27			; 0000001bH
	jne	SHORT $LN25@xmlParserE
$LN26@xmlParserE:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+440], 10000		; 00002710H
	ja	SHORT $LN11@xmlParserE
$LN25@xmlParserE:

; 229  : 	    (ctxt->nbentities <= 10000))
; 230  : 	    return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParserE
$LN11@xmlParserE:

; 231  :     }
; 232  :     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);

	push	0
	push	89					; 00000059H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 233  :     return (1);

	mov	eax, 1
$LN1@xmlParserE:

; 234  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParserEntityCheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlHaltParser
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlHaltParser PROC					; COMDAT

; 12451: xmlHaltParser(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 12452:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN4@xmlHaltPar

; 12453:         return;

	jmp	$LN1@xmlHaltPar
$LN4@xmlHaltPar:

; 12454:     ctxt->instate = XML_PARSER_EOF;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], -1

; 12455:     ctxt->disableSAX = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+212], 1
$LN2@xmlHaltPar:

; 12456:     while (ctxt->inputNr > 1)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1
	jle	SHORT $LN3@xmlHaltPar

; 12457:         xmlFreeInputStream(inputPop(ctxt));

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_inputPop
	add	esp, 4
	push	eax
	call	_xmlFreeInputStream
	add	esp, 4
	jmp	SHORT $LN2@xmlHaltPar
$LN3@xmlHaltPar:

; 12458:     if (ctxt->input != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	$LN1@xmlHaltPar

; 12459:         /*
; 12460: 	 * in case there was a specific allocation deallocate before
; 12461: 	 * overriding base
; 12462: 	 */
; 12463:         if (ctxt->input->free != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN6@xmlHaltPar

; 12464: 	    ctxt->input->free((xmlChar *) ctxt->input->base);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12465: 	    ctxt->input->free = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+40], 0
$LN6@xmlHaltPar:

; 12466: 	}
; 12467:         if (ctxt->input->buf != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN7@xmlHaltPar

; 12468:             xmlFreeParserInputBuffer(ctxt->input->buf);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 12469:             ctxt->input->buf = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax], 0
$LN7@xmlHaltPar:

; 12470:         }
; 12471: 	ctxt->input->cur = BAD_CAST"";

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], OFFSET ??_C@_00CNPNBAHC@@

; 12472:         ctxt->input->length = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+24], 0

; 12473: 	ctxt->input->base = ctxt->input->cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+12], eax

; 12474:         ctxt->input->end = ctxt->input->cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+20], edx
$LN1@xmlHaltPar:

; 12475:     }
; 12476: }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHaltParser ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateEntityParserCtxtInternal
_TEXT	SEGMENT
_uri$ = -16						; size = 4
_directory$ = -12					; size = 4
_inputStream$ = -8					; size = 4
_ctxt$ = -4						; size = 4
_URL$ = 8						; size = 4
_ID$ = 12						; size = 4
_base$ = 16						; size = 4
_pctx$ = 20						; size = 4
_xmlCreateEntityParserCtxtInternal PROC			; COMDAT

; 13991: 	                  const xmlChar *base, xmlParserCtxtPtr pctx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 13992:     xmlParserCtxtPtr ctxt;
; 13993:     xmlParserInputPtr inputStream;
; 13994:     char *directory = NULL;

	mov	DWORD PTR _directory$[ebp], 0

; 13995:     xmlChar *uri;
; 13996: 
; 13997:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 13998:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlCreateE

; 13999: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateE
$LN2@xmlCreateE:

; 14000:     }
; 14001: 
; 14002:     if (pctx != NULL) {

	cmp	DWORD PTR _pctx$[ebp], 0
	je	SHORT $LN3@xmlCreateE

; 14003:         ctxt->options = pctx->options;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _pctx$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	mov	DWORD PTR [eax+360], edx

; 14004:         ctxt->_private = pctx->_private;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _pctx$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	mov	DWORD PTR [eax+272], edx

; 14005: 	/*
; 14006: 	 * this is a subparser of pctx, so the input_id should be
; 14007: 	 * incremented to distinguish from main entity
; 14008: 	 */
; 14009: 	ctxt->input_id = pctx->input_id + 1;

	mov	eax, DWORD PTR _pctx$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+464], ecx
$LN3@xmlCreateE:

; 14010:     }
; 14011: 
; 14012:     uri = xmlBuildURI(URL, base);

	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	call	_xmlBuildURI
	add	esp, 8
	mov	DWORD PTR _uri$[ebp], eax

; 14013: 
; 14014:     if (uri == NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	jne	$LN4@xmlCreateE

; 14015: 	inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	call	_xmlLoadExternalEntity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _inputStream$[ebp], eax

; 14016: 	if (inputStream == NULL) {

	cmp	DWORD PTR _inputStream$[ebp], 0
	jne	SHORT $LN6@xmlCreateE

; 14017: 	    xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14018: 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateE
$LN6@xmlCreateE:

; 14019: 	}
; 14020: 
; 14021: 	inputPush(ctxt, inputStream);

	mov	eax, DWORD PTR _inputStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_inputPush
	add	esp, 8

; 14022: 
; 14023: 	if ((ctxt->directory == NULL) && (directory == NULL))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+180], 0
	jne	SHORT $LN7@xmlCreateE
	cmp	DWORD PTR _directory$[ebp], 0
	jne	SHORT $LN7@xmlCreateE

; 14024: 	    directory = xmlParserGetDirectory((char *)URL);

	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	DWORD PTR _directory$[ebp], eax
$LN7@xmlCreateE:

; 14025: 	if ((ctxt->directory == NULL) && (directory != NULL))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+180], 0
	jne	SHORT $LN8@xmlCreateE
	cmp	DWORD PTR _directory$[ebp], 0
	je	SHORT $LN8@xmlCreateE

; 14026: 	    ctxt->directory = directory;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _directory$[ebp]
	mov	DWORD PTR [edx+180], eax
$LN8@xmlCreateE:

; 14027:     } else {

	jmp	$LN5@xmlCreateE
$LN4@xmlCreateE:

; 14028: 	inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ID$[ebp]
	push	edx
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlLoadExternalEntity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _inputStream$[ebp], eax

; 14029: 	if (inputStream == NULL) {

	cmp	DWORD PTR _inputStream$[ebp], 0
	jne	SHORT $LN9@xmlCreateE

; 14030: 	    xmlFree(uri);

	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14031: 	    xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14032: 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCreateE
$LN9@xmlCreateE:

; 14033: 	}
; 14034: 
; 14035: 	inputPush(ctxt, inputStream);

	mov	eax, DWORD PTR _inputStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_inputPush
	add	esp, 8

; 14036: 
; 14037: 	if ((ctxt->directory == NULL) && (directory == NULL))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+180], 0
	jne	SHORT $LN10@xmlCreateE
	cmp	DWORD PTR _directory$[ebp], 0
	jne	SHORT $LN10@xmlCreateE

; 14038: 	    directory = xmlParserGetDirectory((char *)uri);

	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	DWORD PTR _directory$[ebp], eax
$LN10@xmlCreateE:

; 14039: 	if ((ctxt->directory == NULL) && (directory != NULL))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+180], 0
	jne	SHORT $LN11@xmlCreateE
	cmp	DWORD PTR _directory$[ebp], 0
	je	SHORT $LN11@xmlCreateE

; 14040: 	    ctxt->directory = directory;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _directory$[ebp]
	mov	DWORD PTR [edx+180], eax
$LN11@xmlCreateE:

; 14041: 	xmlFree(uri);

	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlCreateE:

; 14042:     }
; 14043:     return(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
$LN1@xmlCreateE:

; 14044: }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCreateEntityParserCtxtInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlFatalErr
_TEXT	SEGMENT
tv69 = -8						; size = 4
_errmsg$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_info$ = 16						; size = 4
_xmlFatalErr PROC					; COMDAT

; 353  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 354  :     const char *errmsg;
; 355  : 
; 356  :     if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN4@xmlFatalEr
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN4@xmlFatalEr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN4@xmlFatalEr

; 357  :         (ctxt->instate == XML_PARSER_EOF))
; 358  : 	return;

	jmp	$LN1@xmlFatalEr
$LN4@xmlFatalEr:

; 359  :     switch (error) {

	mov	edx, DWORD PTR _error$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR tv69[ebp]
	sub	eax, 1
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 109		; 0000006dH
	ja	$LN62@xmlFatalEr
	mov	ecx, DWORD PTR tv69[ebp]
	movzx	edx, BYTE PTR $LN69@xmlFatalEr[ecx]
	jmp	DWORD PTR $LN70@xmlFatalEr[edx*4]
$LN5@xmlFatalEr:

; 360  :         case XML_ERR_INVALID_HEX_CHARREF:
; 361  :             errmsg = "CharRef: invalid hexadecimal value";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CD@IIBKOMHK@CharRef?3?5invalid?5hexadecimal?5va@

; 362  :             break;

	jmp	$LN2@xmlFatalEr
$LN6@xmlFatalEr:

; 363  :         case XML_ERR_INVALID_DEC_CHARREF:
; 364  :             errmsg = "CharRef: invalid decimal value";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BP@DEJKBBIB@CharRef?3?5invalid?5decimal?5value@

; 365  :             break;

	jmp	$LN2@xmlFatalEr
$LN7@xmlFatalEr:

; 366  :         case XML_ERR_INVALID_CHARREF:
; 367  :             errmsg = "CharRef: invalid value";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BH@OCLALBPG@CharRef?3?5invalid?5value@

; 368  :             break;

	jmp	$LN2@xmlFatalEr
$LN8@xmlFatalEr:

; 369  :         case XML_ERR_INTERNAL_ERROR:
; 370  :             errmsg = "internal error";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0P@LPIEGNHB@internal?5error@

; 371  :             break;

	jmp	$LN2@xmlFatalEr
$LN9@xmlFatalEr:

; 372  :         case XML_ERR_PEREF_AT_EOF:
; 373  :             errmsg = "PEReference at end of document";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BP@MALDLPDI@PEReference?5at?5end?5of?5document@

; 374  :             break;

	jmp	$LN2@xmlFatalEr
$LN10@xmlFatalEr:

; 375  :         case XML_ERR_PEREF_IN_PROLOG:
; 376  :             errmsg = "PEReference in prolog";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BG@GLMIGPKG@PEReference?5in?5prolog@

; 377  :             break;

	jmp	$LN2@xmlFatalEr
$LN11@xmlFatalEr:

; 378  :         case XML_ERR_PEREF_IN_EPILOG:
; 379  :             errmsg = "PEReference in epilog";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BG@JMKGIIGE@PEReference?5in?5epilog@

; 380  :             break;

	jmp	$LN2@xmlFatalEr
$LN12@xmlFatalEr:

; 381  :         case XML_ERR_PEREF_NO_NAME:
; 382  :             errmsg = "PEReference: no name";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BF@DCHKIALM@PEReference?3?5no?5name@

; 383  :             break;

	jmp	$LN2@xmlFatalEr
$LN13@xmlFatalEr:

; 384  :         case XML_ERR_PEREF_SEMICOL_MISSING:
; 385  :             errmsg = "PEReference: expecting ';'";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BL@PFALGNCI@PEReference?3?5expecting?5?8?$DL?8@

; 386  :             break;

	jmp	$LN2@xmlFatalEr
$LN14@xmlFatalEr:

; 387  :         case XML_ERR_ENTITY_LOOP:
; 388  :             errmsg = "Detected an entity reference loop";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CC@LFHGNGFD@Detected?5an?5entity?5reference?5lo@

; 389  :             break;

	jmp	$LN2@xmlFatalEr
$LN15@xmlFatalEr:

; 390  :         case XML_ERR_ENTITY_NOT_STARTED:
; 391  :             errmsg = "EntityValue: \" or ' expected";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BN@DPACNJHE@EntityValue?3?5?$CC?5or?5?8?5expected@

; 392  :             break;

	jmp	$LN2@xmlFatalEr
$LN16@xmlFatalEr:

; 393  :         case XML_ERR_ENTITY_PE_INTERNAL:
; 394  :             errmsg = "PEReferences forbidden in internal subset";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CK@GAJOCPOL@PEReferences?5forbidden?5in?5inter@

; 395  :             break;

	jmp	$LN2@xmlFatalEr
$LN17@xmlFatalEr:

; 396  :         case XML_ERR_ENTITY_NOT_FINISHED:
; 397  :             errmsg = "EntityValue: \" or ' expected";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BN@DPACNJHE@EntityValue?3?5?$CC?5or?5?8?5expected@

; 398  :             break;

	jmp	$LN2@xmlFatalEr
$LN18@xmlFatalEr:

; 399  :         case XML_ERR_ATTRIBUTE_NOT_STARTED:
; 400  :             errmsg = "AttValue: \" or ' expected";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BK@ELBMECGA@AttValue?3?5?$CC?5or?5?8?5expected@

; 401  :             break;

	jmp	$LN2@xmlFatalEr
$LN19@xmlFatalEr:

; 402  :         case XML_ERR_LT_IN_ATTRIBUTE:
; 403  :             errmsg = "Unescaped '<' not allowed in attributes values";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CP@FNIFNHDI@Unescaped?5?8?$DM?8?5not?5allowed?5in?5at@

; 404  :             break;

	jmp	$LN2@xmlFatalEr
$LN20@xmlFatalEr:

; 405  :         case XML_ERR_LITERAL_NOT_STARTED:
; 406  :             errmsg = "SystemLiteral \" or ' expected";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BO@NINNHDOL@SystemLiteral?5?$CC?5or?5?8?5expected@

; 407  :             break;

	jmp	$LN2@xmlFatalEr
$LN21@xmlFatalEr:

; 408  :         case XML_ERR_LITERAL_NOT_FINISHED:
; 409  :             errmsg = "Unfinished System or Public ID \" or ' expected";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CP@PIPOCKJD@Unfinished?5System?5or?5Public?5ID?5@

; 410  :             break;

	jmp	$LN2@xmlFatalEr
$LN22@xmlFatalEr:

; 411  :         case XML_ERR_MISPLACED_CDATA_END:
; 412  :             errmsg = "Sequence ']]>' not allowed in content";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CG@PLPMIKHI@Sequence?5?8?$FN?$FN?$DO?8?5not?5allowed?5in?5c@

; 413  :             break;

	jmp	$LN2@xmlFatalEr
$LN23@xmlFatalEr:

; 414  :         case XML_ERR_URI_REQUIRED:
; 415  :             errmsg = "SYSTEM or PUBLIC, the URI is missing";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CF@GDPMMHJJ@SYSTEM?5or?5PUBLIC?0?5the?5URI?5is?5mi@

; 416  :             break;

	jmp	$LN2@xmlFatalEr
$LN24@xmlFatalEr:

; 417  :         case XML_ERR_PUBID_REQUIRED:
; 418  :             errmsg = "PUBLIC, the Public Identifier is missing";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CJ@ICNPKBIN@PUBLIC?0?5the?5Public?5Identifier?5i@

; 419  :             break;

	jmp	$LN2@xmlFatalEr
$LN25@xmlFatalEr:

; 420  :         case XML_ERR_HYPHEN_IN_COMMENT:
; 421  :             errmsg = "Comment must not contain '--' (double-hyphen)";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CO@IKEFGBAE@Comment?5must?5not?5contain?5?8?9?9?8?5?$CI@

; 422  :             break;

	jmp	$LN2@xmlFatalEr
$LN26@xmlFatalEr:

; 423  :         case XML_ERR_PI_NOT_STARTED:
; 424  :             errmsg = "xmlParsePI : no target name";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BM@HPBPCNCM@xmlParsePI?5?3?5no?5target?5name@

; 425  :             break;

	jmp	$LN2@xmlFatalEr
$LN27@xmlFatalEr:

; 426  :         case XML_ERR_RESERVED_XML_NAME:
; 427  :             errmsg = "Invalid PI name";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BA@KMPMBNCM@Invalid?5PI?5name@

; 428  :             break;

	jmp	$LN2@xmlFatalEr
$LN28@xmlFatalEr:

; 429  :         case XML_ERR_NOTATION_NOT_STARTED:
; 430  :             errmsg = "NOTATION: Name expected here";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BN@HECCFNBP@NOTATION?3?5Name?5expected?5here@

; 431  :             break;

	jmp	$LN2@xmlFatalEr
$LN29@xmlFatalEr:

; 432  :         case XML_ERR_NOTATION_NOT_FINISHED:
; 433  :             errmsg = "'>' required to close NOTATION declaration";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CL@MHMGOJAD@?8?$DO?8?5required?5to?5close?5NOTATION?5@

; 434  :             break;

	jmp	$LN2@xmlFatalEr
$LN30@xmlFatalEr:

; 435  :         case XML_ERR_VALUE_REQUIRED:
; 436  :             errmsg = "Entity value required";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BG@LMNHCPFE@Entity?5value?5required@

; 437  :             break;

	jmp	$LN2@xmlFatalEr
$LN31@xmlFatalEr:

; 438  :         case XML_ERR_URI_FRAGMENT:
; 439  :             errmsg = "Fragment not allowed";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BF@DMGJOFPK@Fragment?5not?5allowed@

; 440  :             break;

	jmp	$LN2@xmlFatalEr
$LN32@xmlFatalEr:

; 441  :         case XML_ERR_ATTLIST_NOT_STARTED:
; 442  :             errmsg = "'(' required to start ATTLIST enumeration";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CK@NNFMCGNH@?8?$CI?8?5required?5to?5start?5ATTLIST?5e@

; 443  :             break;

	jmp	$LN2@xmlFatalEr
$LN33@xmlFatalEr:

; 444  :         case XML_ERR_NMTOKEN_REQUIRED:
; 445  :             errmsg = "NmToken expected in ATTLIST enumeration";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CI@EHCBGKID@NmToken?5expected?5in?5ATTLIST?5enu@

; 446  :             break;

	jmp	$LN2@xmlFatalEr
$LN34@xmlFatalEr:

; 447  :         case XML_ERR_ATTLIST_NOT_FINISHED:
; 448  :             errmsg = "')' required to finish ATTLIST enumeration";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CL@KPIIIINI@?8?$CJ?8?5required?5to?5finish?5ATTLIST?5@

; 449  :             break;

	jmp	$LN2@xmlFatalEr
$LN35@xmlFatalEr:

; 450  :         case XML_ERR_MIXED_NOT_STARTED:
; 451  :             errmsg = "MixedContentDecl : '|' or ')*' expected";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CI@LOAMKAA@MixedContentDecl?5?3?5?8?$HM?8?5or?5?8?$CJ?$CK?8?5@

; 452  :             break;

	jmp	$LN2@xmlFatalEr
$LN36@xmlFatalEr:

; 453  :         case XML_ERR_PCDATA_REQUIRED:
; 454  :             errmsg = "MixedContentDecl : '#PCDATA' expected";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CG@HEHENOGB@MixedContentDecl?5?3?5?8?$CDPCDATA?8?5ex@

; 455  :             break;

	jmp	$LN2@xmlFatalEr
$LN37@xmlFatalEr:

; 456  :         case XML_ERR_ELEMCONTENT_NOT_STARTED:
; 457  :             errmsg = "ContentDecl : Name or '(' expected";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CD@NHADBOBB@ContentDecl?5?3?5Name?5or?5?8?$CI?8?5expec@

; 458  :             break;

	jmp	$LN2@xmlFatalEr
$LN38@xmlFatalEr:

; 459  :         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
; 460  :             errmsg = "ContentDecl : ',' '|' or ')' expected";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CG@EHNJPHMB@ContentDecl?5?3?5?8?0?8?5?8?$HM?8?5or?5?8?$CJ?8?5ex@

; 461  :             break;

	jmp	$LN2@xmlFatalEr
$LN39@xmlFatalEr:

; 462  :         case XML_ERR_PEREF_IN_INT_SUBSET:
; 463  :             errmsg =

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0DN@CEDHFOGD@PEReference?3?5forbidden?5within?5m@

; 464  :                 "PEReference: forbidden within markup decl in internal subset";
; 465  :             break;

	jmp	$LN2@xmlFatalEr
$LN40@xmlFatalEr:

; 466  :         case XML_ERR_GT_REQUIRED:
; 467  :             errmsg = "expected '>'";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0N@HPGHEIE@expected?5?8?$DO?8@

; 468  :             break;

	jmp	$LN2@xmlFatalEr
$LN41@xmlFatalEr:

; 469  :         case XML_ERR_CONDSEC_INVALID:
; 470  :             errmsg = "XML conditional section '[' expected";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CF@GGBMHDE@XML?5conditional?5section?5?8?$FL?8?5exp@

; 471  :             break;

	jmp	$LN2@xmlFatalEr
$LN42@xmlFatalEr:

; 472  :         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
; 473  :             errmsg = "Content error in the external subset";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CF@HHCGNGIK@Content?5error?5in?5the?5external?5s@

; 474  :             break;

	jmp	$LN2@xmlFatalEr
$LN43@xmlFatalEr:

; 475  :         case XML_ERR_CONDSEC_INVALID_KEYWORD:
; 476  :             errmsg =

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0DH@JDEKAAA@conditional?5section?5INCLUDE?5or?5@

; 477  :                 "conditional section INCLUDE or IGNORE keyword expected";
; 478  :             break;

	jmp	$LN2@xmlFatalEr
$LN44@xmlFatalEr:

; 479  :         case XML_ERR_CONDSEC_NOT_FINISHED:
; 480  :             errmsg = "XML conditional section not closed";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CD@OHPJFFIN@XML?5conditional?5section?5not?5clo@

; 481  :             break;

	jmp	$LN2@xmlFatalEr
$LN45@xmlFatalEr:

; 482  :         case XML_ERR_XMLDECL_NOT_STARTED:
; 483  :             errmsg = "Text declaration '<?xml' required";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CC@HHECNJCA@Text?5declaration?5?8?$DM?$DPxml?8?5requir@

; 484  :             break;

	jmp	$LN2@xmlFatalEr
$LN46@xmlFatalEr:

; 485  :         case XML_ERR_XMLDECL_NOT_FINISHED:
; 486  :             errmsg = "parsing XML declaration: '?>' expected";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CH@DOCCAFM@parsing?5XML?5declaration?3?5?8?$DP?$DO?8?5e@

; 487  :             break;

	jmp	$LN2@xmlFatalEr
$LN47@xmlFatalEr:

; 488  :         case XML_ERR_EXT_ENTITY_STANDALONE:
; 489  :             errmsg = "external parsed entities cannot be standalone";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CO@LJALGGHL@external?5parsed?5entities?5cannot@

; 490  :             break;

	jmp	$LN2@xmlFatalEr
$LN48@xmlFatalEr:

; 491  :         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
; 492  :             errmsg = "EntityRef: expecting ';'";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BJ@KLEMOBLL@EntityRef?3?5expecting?5?8?$DL?8@

; 493  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN49@xmlFatalEr:

; 494  :         case XML_ERR_DOCTYPE_NOT_FINISHED:
; 495  :             errmsg = "DOCTYPE improperly terminated";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BO@NIFLODD@DOCTYPE?5improperly?5terminated@

; 496  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN50@xmlFatalEr:

; 497  :         case XML_ERR_LTSLASH_REQUIRED:
; 498  :             errmsg = "EndTag: '</' not found";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BH@ELMJBAIC@EndTag?3?5?8?$DM?1?8?5not?5found@

; 499  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN51@xmlFatalEr:

; 500  :         case XML_ERR_EQUAL_REQUIRED:
; 501  :             errmsg = "expected '='";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0N@FLAMKNN@expected?5?8?$DN?8@

; 502  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN52@xmlFatalEr:

; 503  :         case XML_ERR_STRING_NOT_CLOSED:
; 504  :             errmsg = "String not closed expecting \" or '";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CD@GLDIEMIA@String?5not?5closed?5expecting?5?$CC?5o@

; 505  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN53@xmlFatalEr:

; 506  :         case XML_ERR_STRING_NOT_STARTED:
; 507  :             errmsg = "String not started expecting ' or \"";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CE@EGHHEGNE@String?5not?5started?5expecting?5?8?5@

; 508  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN54@xmlFatalEr:

; 509  :         case XML_ERR_ENCODING_NAME:
; 510  :             errmsg = "Invalid XML encoding name";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BK@CMOJKGNC@Invalid?5XML?5encoding?5name@

; 511  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN55@xmlFatalEr:

; 512  :         case XML_ERR_STANDALONE_VALUE:
; 513  :             errmsg = "standalone accepts only 'yes' or 'no'";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CG@MBLHCBEE@standalone?5accepts?5only?5?8yes?8?5o@

; 514  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN56@xmlFatalEr:

; 515  :         case XML_ERR_DOCUMENT_EMPTY:
; 516  :             errmsg = "Document is empty";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BC@LDMJLCHP@Document?5is?5empty@

; 517  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN57@xmlFatalEr:

; 518  :         case XML_ERR_DOCUMENT_END:
; 519  :             errmsg = "Extra content at the end of the document";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CJ@JKANOFNI@Extra?5content?5at?5the?5end?5of?5the@

; 520  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN58@xmlFatalEr:

; 521  :         case XML_ERR_NOT_WELL_BALANCED:
; 522  :             errmsg = "chunk is not well balanced";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BL@EKLHFGHK@chunk?5is?5not?5well?5balanced@

; 523  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN59@xmlFatalEr:

; 524  :         case XML_ERR_EXTRA_CONTENT:
; 525  :             errmsg = "extra content at the end of well balanced chunk";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0DA@BPKCCNLP@extra?5content?5at?5the?5end?5of?5wel@

; 526  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN60@xmlFatalEr:

; 527  :         case XML_ERR_VERSION_MISSING:
; 528  :             errmsg = "Malformed declaration expecting version";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CI@FHFOLBEM@Malformed?5declaration?5expecting@

; 529  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN61@xmlFatalEr:

; 530  :         case XML_ERR_NAME_TOO_LONG:
; 531  :             errmsg = "Name too long use XML_PARSE_HUGE option";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0CI@CJGDNBNK@Name?5too?5long?5use?5XML_PARSE_HUG@

; 532  :             break;

	jmp	SHORT $LN2@xmlFatalEr
$LN62@xmlFatalEr:

; 533  : #if 0
; 534  :         case:
; 535  :             errmsg = "";
; 536  :             break;
; 537  : #endif
; 538  :         default:
; 539  :             errmsg = "Unregistered error message";

	mov	DWORD PTR _errmsg$[ebp], OFFSET ??_C@_0BL@COECCIID@Unregistered?5error?5message@
$LN2@xmlFatalEr:

; 540  :     }
; 541  :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN63@xmlFatalEr

; 542  : 	ctxt->errNo = error;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax+84], ecx
$LN63@xmlFatalEr:

; 543  :     if (info == NULL) {

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN64@xmlFatalEr

; 544  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	mov	edx, DWORD PTR _errmsg$[ebp]
	push	edx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _error$[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 545  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
; 546  :                         errmsg);
; 547  :     } else {

	jmp	SHORT $LN65@xmlFatalEr
$LN64@xmlFatalEr:

; 548  :         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _errmsg$[ebp]
	push	ecx
	push	OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	push	0
	push	0
	push	3
	mov	eax, DWORD PTR _error$[ebp]
	push	eax
	push	1
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 72					; 00000048H
$LN65@xmlFatalEr:

; 549  :                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
; 550  :                         errmsg, info);
; 551  :     }
; 552  :     if (ctxt != NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN1@xmlFatalEr

; 553  : 	ctxt->wellFormed = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+12], 0

; 554  : 	if (ctxt->recovery == 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+288], 0
	jne	SHORT $LN1@xmlFatalEr

; 555  : 	    ctxt->disableSAX = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+212], 1
$LN1@xmlFatalEr:

; 556  :     }
; 557  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@xmlFatalEr:
	DD	$LN8@xmlFatalEr
	DD	$LN56@xmlFatalEr
	DD	$LN57@xmlFatalEr
	DD	$LN5@xmlFatalEr
	DD	$LN6@xmlFatalEr
	DD	$LN7@xmlFatalEr
	DD	$LN9@xmlFatalEr
	DD	$LN10@xmlFatalEr
	DD	$LN11@xmlFatalEr
	DD	$LN39@xmlFatalEr
	DD	$LN48@xmlFatalEr
	DD	$LN12@xmlFatalEr
	DD	$LN13@xmlFatalEr
	DD	$LN53@xmlFatalEr
	DD	$LN52@xmlFatalEr
	DD	$LN15@xmlFatalEr
	DD	$LN17@xmlFatalEr
	DD	$LN19@xmlFatalEr
	DD	$LN18@xmlFatalEr
	DD	$LN20@xmlFatalEr
	DD	$LN21@xmlFatalEr
	DD	$LN26@xmlFatalEr
	DD	$LN28@xmlFatalEr
	DD	$LN29@xmlFatalEr
	DD	$LN32@xmlFatalEr
	DD	$LN34@xmlFatalEr
	DD	$LN35@xmlFatalEr
	DD	$LN37@xmlFatalEr
	DD	$LN38@xmlFatalEr
	DD	$LN45@xmlFatalEr
	DD	$LN46@xmlFatalEr
	DD	$LN44@xmlFatalEr
	DD	$LN42@xmlFatalEr
	DD	$LN49@xmlFatalEr
	DD	$LN22@xmlFatalEr
	DD	$LN27@xmlFatalEr
	DD	$LN33@xmlFatalEr
	DD	$LN36@xmlFatalEr
	DD	$LN23@xmlFatalEr
	DD	$LN24@xmlFatalEr
	DD	$LN40@xmlFatalEr
	DD	$LN50@xmlFatalEr
	DD	$LN51@xmlFatalEr
	DD	$LN55@xmlFatalEr
	DD	$LN54@xmlFatalEr
	DD	$LN25@xmlFatalEr
	DD	$LN47@xmlFatalEr
	DD	$LN41@xmlFatalEr
	DD	$LN30@xmlFatalEr
	DD	$LN58@xmlFatalEr
	DD	$LN59@xmlFatalEr
	DD	$LN16@xmlFatalEr
	DD	$LN14@xmlFatalEr
	DD	$LN31@xmlFatalEr
	DD	$LN43@xmlFatalEr
	DD	$LN60@xmlFatalEr
	DD	$LN61@xmlFatalEr
	DD	$LN62@xmlFatalEr
$LN69@xmlFatalEr:
	DB	0
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	6
	DB	7
	DB	8
	DB	9
	DB	57					; 00000039H
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	57					; 00000039H
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	57					; 00000039H
	DB	21					; 00000015H
	DB	57					; 00000039H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	57					; 00000039H
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	57					; 00000039H
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	57					; 00000039H
	DB	35					; 00000023H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	36					; 00000024H
	DB	57					; 00000039H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	57					; 00000039H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	57					; 00000039H
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	48					; 00000030H
	DB	49					; 00000031H
	DB	50					; 00000032H
	DB	57					; 00000039H
	DB	51					; 00000033H
	DB	52					; 00000034H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	53					; 00000035H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	54					; 00000036H
	DB	55					; 00000037H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	57					; 00000039H
	DB	56					; 00000038H
_xmlFatalErr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSetEntityReferenceFunc
_TEXT	SEGMENT
_func$ = 8						; size = 4
_xmlSetEntityReferenceFunc PROC				; COMDAT

; 14681: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14682:     xmlEntityRefFunc = func;

	mov	eax, DWORD PTR _func$[ebp]
	mov	DWORD PTR _xmlEntityRefFunc, eax

; 14683: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSetEntityReferenceFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCheckLanguageID
_TEXT	SEGMENT
tv151 = -12						; size = 4
_nxt$ = -8						; size = 4
_cur$ = -4						; size = 4
_lang$ = 8						; size = 4
_xmlCheckLanguageID PROC				; COMDAT

; 1441 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1442 :     const xmlChar *cur = lang, *nxt;

	mov	eax, DWORD PTR _lang$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 1443 : 
; 1444 :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN14@xmlCheckLa

; 1445 :         return (0);

	xor	eax, eax
	jmp	$LN1@xmlCheckLa
$LN14@xmlCheckLa:

; 1446 :     if (((cur[0] == 'i') && (cur[1] == '-')) ||
; 1447 :         ((cur[0] == 'I') && (cur[1] == '-')) ||
; 1448 :         ((cur[0] == 'x') && (cur[1] == '-')) ||

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 105				; 00000069H
	jne	SHORT $LN17@xmlCheckLa
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	je	$LN16@xmlCheckLa
$LN17@xmlCheckLa:
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	SHORT $LN18@xmlCheckLa
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN16@xmlCheckLa
$LN18@xmlCheckLa:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 120				; 00000078H
	jne	SHORT $LN19@xmlCheckLa
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN16@xmlCheckLa
$LN19@xmlCheckLa:
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 88					; 00000058H
	jne	$LN15@xmlCheckLa
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	jne	$LN15@xmlCheckLa
$LN16@xmlCheckLa:

; 1449 :         ((cur[0] == 'X') && (cur[1] == '-'))) {
; 1450 :         /*
; 1451 :          * Still allow IANA code and user code which were coming
; 1452 :          * from the previous version of the XML-1.0 specification
; 1453 :          * it's deprecated but we should not fail
; 1454 :          */
; 1455 :         cur += 2;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 2
	mov	DWORD PTR _cur$[ebp], edx
$LN2@xmlCheckLa:

; 1456 :         while (((cur[0] >= 'A') && (cur[0] <= 'Z')) ||

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN21@xmlCheckLa
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 90					; 0000005aH
	jle	SHORT $LN20@xmlCheckLa
$LN21@xmlCheckLa:
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN3@xmlCheckLa
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN3@xmlCheckLa
$LN20@xmlCheckLa:

; 1457 :                ((cur[0] >= 'a') && (cur[0] <= 'z')))
; 1458 :             cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN2@xmlCheckLa
$LN3@xmlCheckLa:

; 1459 :         return(cur[0] == 0);

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN62@xmlCheckLa
	mov	DWORD PTR tv151[ebp], 1
	jmp	SHORT $LN63@xmlCheckLa
$LN62@xmlCheckLa:
	mov	DWORD PTR tv151[ebp], 0
$LN63@xmlCheckLa:
	mov	eax, DWORD PTR tv151[ebp]
	jmp	$LN1@xmlCheckLa
$LN15@xmlCheckLa:

; 1460 :     }
; 1461 :     nxt = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _nxt$[ebp], eax
$LN4@xmlCheckLa:

; 1462 :     while (((nxt[0] >= 'A') && (nxt[0] <= 'Z')) ||

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN23@xmlCheckLa
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 90					; 0000005aH
	jle	SHORT $LN22@xmlCheckLa
$LN23@xmlCheckLa:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN5@xmlCheckLa
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 122				; 0000007aH
	jg	SHORT $LN5@xmlCheckLa
$LN22@xmlCheckLa:

; 1463 :            ((nxt[0] >= 'a') && (nxt[0] <= 'z')))
; 1464 :            nxt++;

	mov	edx, DWORD PTR _nxt$[ebp]
	add	edx, 1
	mov	DWORD PTR _nxt$[ebp], edx
	jmp	SHORT $LN4@xmlCheckLa
$LN5@xmlCheckLa:

; 1465 :     if (nxt - cur >= 4) {

	mov	eax, DWORD PTR _nxt$[ebp]
	sub	eax, DWORD PTR _cur$[ebp]
	cmp	eax, 4
	jl	SHORT $LN24@xmlCheckLa

; 1466 :         /*
; 1467 :          * Reserved
; 1468 :          */
; 1469 :         if ((nxt - cur > 8) || (nxt[0] != 0))

	mov	ecx, DWORD PTR _nxt$[ebp]
	sub	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, 8
	jg	SHORT $LN26@xmlCheckLa
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN25@xmlCheckLa
$LN26@xmlCheckLa:

; 1470 :             return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckLa
$LN25@xmlCheckLa:

; 1471 :         return(1);

	mov	eax, 1
	jmp	$LN1@xmlCheckLa
$LN24@xmlCheckLa:

; 1472 :     }
; 1473 :     if (nxt - cur < 2)

	mov	eax, DWORD PTR _nxt$[ebp]
	sub	eax, DWORD PTR _cur$[ebp]
	cmp	eax, 2
	jge	SHORT $LN27@xmlCheckLa

; 1474 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckLa
$LN27@xmlCheckLa:

; 1475 :     /* we got an ISO 639 code */
; 1476 :     if (nxt[0] == 0)

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN28@xmlCheckLa

; 1477 :         return(1);

	mov	eax, 1
	jmp	$LN1@xmlCheckLa
$LN28@xmlCheckLa:

; 1478 :     if (nxt[0] != '-')

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN29@xmlCheckLa

; 1479 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckLa
$LN29@xmlCheckLa:

; 1480 : 
; 1481 :     nxt++;

	mov	eax, DWORD PTR _nxt$[ebp]
	add	eax, 1
	mov	DWORD PTR _nxt$[ebp], eax

; 1482 :     cur = nxt;

	mov	ecx, DWORD PTR _nxt$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 1483 :     /* now we can have extlang or script or region or variant */
; 1484 :     if ((nxt[0] >= '0') && (nxt[0] <= '9'))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN6@xmlCheckLa
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN6@xmlCheckLa

; 1485 :         goto region_m49;

	jmp	$region_m49$64
$LN6@xmlCheckLa:

; 1486 : 
; 1487 :     while (((nxt[0] >= 'A') && (nxt[0] <= 'Z')) ||

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN32@xmlCheckLa
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 90					; 0000005aH
	jle	SHORT $LN31@xmlCheckLa
$LN32@xmlCheckLa:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN7@xmlCheckLa
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 122				; 0000007aH
	jg	SHORT $LN7@xmlCheckLa
$LN31@xmlCheckLa:

; 1488 :            ((nxt[0] >= 'a') && (nxt[0] <= 'z')))
; 1489 :            nxt++;

	mov	edx, DWORD PTR _nxt$[ebp]
	add	edx, 1
	mov	DWORD PTR _nxt$[ebp], edx
	jmp	SHORT $LN6@xmlCheckLa
$LN7@xmlCheckLa:

; 1490 :     if (nxt - cur == 4)

	mov	eax, DWORD PTR _nxt$[ebp]
	sub	eax, DWORD PTR _cur$[ebp]
	cmp	eax, 4
	jne	SHORT $LN33@xmlCheckLa

; 1491 :         goto script;

	jmp	$script$65
$LN33@xmlCheckLa:

; 1492 :     if (nxt - cur == 2)

	mov	ecx, DWORD PTR _nxt$[ebp]
	sub	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, 2
	jne	SHORT $LN34@xmlCheckLa

; 1493 :         goto region;

	jmp	$region$66
$LN34@xmlCheckLa:

; 1494 :     if ((nxt - cur >= 5) && (nxt - cur <= 8))

	mov	edx, DWORD PTR _nxt$[ebp]
	sub	edx, DWORD PTR _cur$[ebp]
	cmp	edx, 5
	jl	SHORT $LN35@xmlCheckLa
	mov	eax, DWORD PTR _nxt$[ebp]
	sub	eax, DWORD PTR _cur$[ebp]
	cmp	eax, 8
	jg	SHORT $LN35@xmlCheckLa

; 1495 :         goto variant;

	jmp	$variant$67
$LN35@xmlCheckLa:

; 1496 :     if (nxt - cur != 3)

	mov	ecx, DWORD PTR _nxt$[ebp]
	sub	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, 3
	je	SHORT $LN36@xmlCheckLa

; 1497 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckLa
$LN36@xmlCheckLa:

; 1498 :     /* we parsed an extlang */
; 1499 :     if (nxt[0] == 0)

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN37@xmlCheckLa

; 1500 :         return(1);

	mov	eax, 1
	jmp	$LN1@xmlCheckLa
$LN37@xmlCheckLa:

; 1501 :     if (nxt[0] != '-')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN38@xmlCheckLa

; 1502 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckLa
$LN38@xmlCheckLa:

; 1503 : 
; 1504 :     nxt++;

	mov	ecx, DWORD PTR _nxt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nxt$[ebp], ecx

; 1505 :     cur = nxt;

	mov	edx, DWORD PTR _nxt$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 1506 :     /* now we can have script or region or variant */
; 1507 :     if ((nxt[0] >= '0') && (nxt[0] <= '9'))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN8@xmlCheckLa
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN8@xmlCheckLa

; 1508 :         goto region_m49;

	jmp	$region_m49$64
$LN8@xmlCheckLa:

; 1509 : 
; 1510 :     while (((nxt[0] >= 'A') && (nxt[0] <= 'Z')) ||

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN41@xmlCheckLa
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 90					; 0000005aH
	jle	SHORT $LN40@xmlCheckLa
$LN41@xmlCheckLa:
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN9@xmlCheckLa
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 122				; 0000007aH
	jg	SHORT $LN9@xmlCheckLa
$LN40@xmlCheckLa:

; 1511 :            ((nxt[0] >= 'a') && (nxt[0] <= 'z')))
; 1512 :            nxt++;

	mov	eax, DWORD PTR _nxt$[ebp]
	add	eax, 1
	mov	DWORD PTR _nxt$[ebp], eax
	jmp	SHORT $LN8@xmlCheckLa
$LN9@xmlCheckLa:

; 1513 :     if (nxt - cur == 2)

	mov	ecx, DWORD PTR _nxt$[ebp]
	sub	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, 2
	jne	SHORT $LN42@xmlCheckLa

; 1514 :         goto region;

	jmp	$region$66
$LN42@xmlCheckLa:

; 1515 :     if ((nxt - cur >= 5) && (nxt - cur <= 8))

	mov	edx, DWORD PTR _nxt$[ebp]
	sub	edx, DWORD PTR _cur$[ebp]
	cmp	edx, 5
	jl	SHORT $LN43@xmlCheckLa
	mov	eax, DWORD PTR _nxt$[ebp]
	sub	eax, DWORD PTR _cur$[ebp]
	cmp	eax, 8
	jg	SHORT $LN43@xmlCheckLa

; 1516 :         goto variant;

	jmp	$variant$67
$LN43@xmlCheckLa:

; 1517 :     if (nxt - cur != 4)

	mov	ecx, DWORD PTR _nxt$[ebp]
	sub	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, 4
	je	SHORT $script$65

; 1518 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckLa
$script$65:

; 1519 :     /* we parsed a script */
; 1520 : script:
; 1521 :     if (nxt[0] == 0)

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN45@xmlCheckLa

; 1522 :         return(1);

	mov	eax, 1
	jmp	$LN1@xmlCheckLa
$LN45@xmlCheckLa:

; 1523 :     if (nxt[0] != '-')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN46@xmlCheckLa

; 1524 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckLa
$LN46@xmlCheckLa:

; 1525 : 
; 1526 :     nxt++;

	mov	ecx, DWORD PTR _nxt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nxt$[ebp], ecx

; 1527 :     cur = nxt;

	mov	edx, DWORD PTR _nxt$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 1528 :     /* now we can have region or variant */
; 1529 :     if ((nxt[0] >= '0') && (nxt[0] <= '9'))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN10@xmlCheckLa
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN10@xmlCheckLa

; 1530 :         goto region_m49;

	jmp	$region_m49$64
$LN10@xmlCheckLa:

; 1531 : 
; 1532 :     while (((nxt[0] >= 'A') && (nxt[0] <= 'Z')) ||

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN49@xmlCheckLa
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 90					; 0000005aH
	jle	SHORT $LN48@xmlCheckLa
$LN49@xmlCheckLa:
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN11@xmlCheckLa
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 122				; 0000007aH
	jg	SHORT $LN11@xmlCheckLa
$LN48@xmlCheckLa:

; 1533 :            ((nxt[0] >= 'a') && (nxt[0] <= 'z')))
; 1534 :            nxt++;

	mov	eax, DWORD PTR _nxt$[ebp]
	add	eax, 1
	mov	DWORD PTR _nxt$[ebp], eax
	jmp	SHORT $LN10@xmlCheckLa
$LN11@xmlCheckLa:

; 1535 : 
; 1536 :     if ((nxt - cur >= 5) && (nxt - cur <= 8))

	mov	ecx, DWORD PTR _nxt$[ebp]
	sub	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, 5
	jl	SHORT $LN50@xmlCheckLa
	mov	edx, DWORD PTR _nxt$[ebp]
	sub	edx, DWORD PTR _cur$[ebp]
	cmp	edx, 8
	jg	SHORT $LN50@xmlCheckLa

; 1537 :         goto variant;

	jmp	$variant$67
$LN50@xmlCheckLa:

; 1538 :     if (nxt - cur != 2)

	mov	eax, DWORD PTR _nxt$[ebp]
	sub	eax, DWORD PTR _cur$[ebp]
	cmp	eax, 2
	je	SHORT $region$66

; 1539 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckLa
$region$66:

; 1540 :     /* we parsed a region */
; 1541 : region:
; 1542 :     if (nxt[0] == 0)

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN52@xmlCheckLa

; 1543 :         return(1);

	mov	eax, 1
	jmp	$LN1@xmlCheckLa
$LN52@xmlCheckLa:

; 1544 :     if (nxt[0] != '-')

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN53@xmlCheckLa

; 1545 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckLa
$LN53@xmlCheckLa:

; 1546 : 
; 1547 :     nxt++;

	mov	eax, DWORD PTR _nxt$[ebp]
	add	eax, 1
	mov	DWORD PTR _nxt$[ebp], eax

; 1548 :     cur = nxt;

	mov	ecx, DWORD PTR _nxt$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
$LN12@xmlCheckLa:

; 1549 :     /* now we can just have a variant */
; 1550 :     while (((nxt[0] >= 'A') && (nxt[0] <= 'Z')) ||

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN55@xmlCheckLa
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 90					; 0000005aH
	jle	SHORT $LN54@xmlCheckLa
$LN55@xmlCheckLa:
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN13@xmlCheckLa
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _nxt$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 122				; 0000007aH
	jg	SHORT $LN13@xmlCheckLa
$LN54@xmlCheckLa:

; 1551 :            ((nxt[0] >= 'a') && (nxt[0] <= 'z')))
; 1552 :            nxt++;

	mov	eax, DWORD PTR _nxt$[ebp]
	add	eax, 1
	mov	DWORD PTR _nxt$[ebp], eax
	jmp	SHORT $LN12@xmlCheckLa
$LN13@xmlCheckLa:

; 1553 : 
; 1554 :     if ((nxt - cur < 5) || (nxt - cur > 8))

	mov	ecx, DWORD PTR _nxt$[ebp]
	sub	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, 5
	jl	SHORT $LN57@xmlCheckLa
	mov	edx, DWORD PTR _nxt$[ebp]
	sub	edx, DWORD PTR _cur$[ebp]
	cmp	edx, 8
	jle	SHORT $variant$67
$LN57@xmlCheckLa:

; 1555 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckLa
$variant$67:

; 1556 : 
; 1557 :     /* we parsed a variant */
; 1558 : variant:
; 1559 :     if (nxt[0] == 0)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nxt$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN58@xmlCheckLa

; 1560 :         return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlCheckLa
$LN58@xmlCheckLa:

; 1561 :     if (nxt[0] != '-')

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN59@xmlCheckLa

; 1562 :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCheckLa
$LN59@xmlCheckLa:

; 1563 :     /* extensions and private use subtags not checked */
; 1564 :     return (1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlCheckLa
$region_m49$64:

; 1565 : 
; 1566 : region_m49:
; 1567 :     if (((nxt[1] >= '0') && (nxt[1] <= '9')) &&

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN60@xmlCheckLa
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN60@xmlCheckLa
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN60@xmlCheckLa
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _nxt$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN60@xmlCheckLa

; 1568 :         ((nxt[2] >= '0') && (nxt[2] <= '9'))) {
; 1569 :         nxt += 3;

	mov	edx, DWORD PTR _nxt$[ebp]
	add	edx, 3
	mov	DWORD PTR _nxt$[ebp], edx

; 1570 :         goto region;

	jmp	$region$66
$LN60@xmlCheckLa:

; 1571 :     }
; 1572 :     return(0);

	xor	eax, eax
$LN1@xmlCheckLa:

; 1573 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCheckLanguageID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParserHandlePEReference
_TEXT	SEGMENT
tv65 = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParserHandlePEReference PROC			; COMDAT

; 2499 : xmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2500 :     switch(ctxt->instate) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	mov	DWORD PTR tv65[ebp], ecx
	mov	edx, DWORD PTR tv65[ebp]
	add	edx, 1
	mov	DWORD PTR tv65[ebp], edx
	cmp	DWORD PTR tv65[ebp], 17			; 00000011H
	ja	$LN2@xmlParserH
	mov	eax, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN20@xmlParserH[eax*4]
$LN4@xmlParserH:

; 2501 : 	case XML_PARSER_CDATA_SECTION:
; 2502 : 	    return;

	jmp	$LN1@xmlParserH
$LN5@xmlParserH:

; 2503 :         case XML_PARSER_COMMENT:
; 2504 : 	    return;

	jmp	$LN1@xmlParserH
$LN6@xmlParserH:

; 2505 : 	case XML_PARSER_START_TAG:
; 2506 : 	    return;

	jmp	$LN1@xmlParserH
$LN7@xmlParserH:

; 2507 : 	case XML_PARSER_END_TAG:
; 2508 : 	    return;

	jmp	$LN1@xmlParserH
$LN8@xmlParserH:

; 2509 :         case XML_PARSER_EOF:
; 2510 : 	    xmlFatalErr(ctxt, XML_ERR_PEREF_AT_EOF, NULL);

	push	0
	push	18					; 00000012H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2511 : 	    return;

	jmp	$LN1@xmlParserH
$LN9@xmlParserH:

; 2512 :         case XML_PARSER_PROLOG:
; 2513 : 	case XML_PARSER_START:
; 2514 : 	case XML_PARSER_MISC:
; 2515 : 	    xmlFatalErr(ctxt, XML_ERR_PEREF_IN_PROLOG, NULL);

	push	0
	push	19					; 00000013H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2516 : 	    return;

	jmp	$LN1@xmlParserH
$LN10@xmlParserH:

; 2517 : 	case XML_PARSER_ENTITY_DECL:
; 2518 :         case XML_PARSER_CONTENT:
; 2519 :         case XML_PARSER_ATTRIBUTE_VALUE:
; 2520 :         case XML_PARSER_PI:
; 2521 : 	case XML_PARSER_SYSTEM_LITERAL:
; 2522 : 	case XML_PARSER_PUBLIC_LITERAL:
; 2523 : 	    /* we just ignore it there */
; 2524 : 	    return;

	jmp	$LN1@xmlParserH
$LN11@xmlParserH:

; 2525 :         case XML_PARSER_EPILOG:
; 2526 : 	    xmlFatalErr(ctxt, XML_ERR_PEREF_IN_EPILOG, NULL);

	push	0
	push	20					; 00000014H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2527 : 	    return;

	jmp	$LN1@xmlParserH
$LN12@xmlParserH:

; 2528 : 	case XML_PARSER_ENTITY_VALUE:
; 2529 : 	    /*
; 2530 : 	     * NOTE: in the case of entity values, we don't do the
; 2531 : 	     *       substitution here since we need the literal
; 2532 : 	     *       entity value to be able to save the internal
; 2533 : 	     *       subset of the document.
; 2534 : 	     *       This will be handled by xmlStringDecodeEntities
; 2535 : 	     */
; 2536 : 	    return;

	jmp	$LN1@xmlParserH
$LN13@xmlParserH:

; 2537 :         case XML_PARSER_DTD:
; 2538 : 	    /*
; 2539 : 	     * [WFC: Well-Formedness Constraint: PEs in Internal Subset]
; 2540 : 	     * In the internal DTD subset, parameter-entity references
; 2541 : 	     * can occur only where markup declarations can occur, not
; 2542 : 	     * within markup declarations.
; 2543 : 	     * In that case this is handled in xmlParseMarkupDecl
; 2544 : 	     */
; 2545 : 	    if ((ctxt->external == 0) && (ctxt->inputNr == 1))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+96], 0
	jne	SHORT $LN14@xmlParserH
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1
	jne	SHORT $LN14@xmlParserH

; 2546 : 		return;

	jmp	$LN1@xmlParserH
$LN14@xmlParserH:

; 2547 : 	    if (IS_BLANK_CH(NXT(1)) || NXT(1) == 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN16@xmlParserH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 9
	jl	SHORT $LN17@xmlParserH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN16@xmlParserH
$LN17@xmlParserH:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN16@xmlParserH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN15@xmlParserH
$LN16@xmlParserH:

; 2548 : 		return;

	jmp	SHORT $LN1@xmlParserH
$LN15@xmlParserH:

; 2549 :             break;

	jmp	SHORT $LN2@xmlParserH
$LN18@xmlParserH:

; 2550 :         case XML_PARSER_IGNORE:
; 2551 :             return;

	jmp	SHORT $LN1@xmlParserH
$LN2@xmlParserH:

; 2552 :     }
; 2553 : 
; 2554 :     xmlParsePEReference(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParsePEReference
	add	esp, 4
$LN1@xmlParserH:

; 2555 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN20@xmlParserH:
	DD	$LN8@xmlParserH
	DD	$LN9@xmlParserH
	DD	$LN9@xmlParserH
	DD	$LN10@xmlParserH
	DD	$LN13@xmlParserH
	DD	$LN9@xmlParserH
	DD	$LN5@xmlParserH
	DD	$LN6@xmlParserH
	DD	$LN10@xmlParserH
	DD	$LN4@xmlParserH
	DD	$LN7@xmlParserH
	DD	$LN10@xmlParserH
	DD	$LN12@xmlParserH
	DD	$LN10@xmlParserH
	DD	$LN10@xmlParserH
	DD	$LN11@xmlParserH
	DD	$LN18@xmlParserH
	DD	$LN10@xmlParserH
_xmlParserHandlePEReference ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSkipBlankChars
_TEXT	SEGMENT
tv145 = -16						; size = 4
_expandPE$1 = -12					; size = 4
_cur$2 = -8						; size = 4
_res$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlSkipBlankChars PROC					; COMDAT

; 2140 : xmlSkipBlankChars(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2141 :     int res = 0;

	mov	DWORD PTR _res$[ebp], 0

; 2142 : 
; 2143 :     /*
; 2144 :      * It's Okay to use CUR/NEXT here since all the blanks are on
; 2145 :      * the ASCII range.
; 2146 :      */
; 2147 :     if ((ctxt->inputNr == 1) && (ctxt->instate != XML_PARSER_DTD)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+40], 1
	jne	$LN6@xmlSkipBla
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], 3
	je	$LN6@xmlSkipBla

; 2148 : 	const xmlChar *cur;
; 2149 : 	/*
; 2150 : 	 * if we are in the document content, go really fast
; 2151 : 	 */
; 2152 : 	cur = ctxt->input->cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _cur$2[ebp], ecx
$LN2@xmlSkipBla:

; 2153 : 	while (IS_BLANK_CH(*cur)) {

	mov	edx, DWORD PTR _cur$2[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN8@xmlSkipBla
	mov	ecx, DWORD PTR _cur$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN9@xmlSkipBla
	mov	eax, DWORD PTR _cur$2[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN8@xmlSkipBla
$LN9@xmlSkipBla:
	mov	edx, DWORD PTR _cur$2[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	$LN3@xmlSkipBla
$LN8@xmlSkipBla:

; 2154 : 	    if (*cur == '\n') {

	mov	ecx, DWORD PTR _cur$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN10@xmlSkipBla

; 2155 : 		ctxt->input->line++; ctxt->input->col = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+28], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], 1

; 2156 : 	    } else {

	jmp	SHORT $LN11@xmlSkipBla
$LN10@xmlSkipBla:

; 2157 : 		ctxt->input->col++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
$LN11@xmlSkipBla:

; 2158 : 	    }
; 2159 : 	    cur++;

	mov	eax, DWORD PTR _cur$2[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$2[ebp], eax

; 2160 : 	    res++;

	mov	ecx, DWORD PTR _res$[ebp]
	add	ecx, 1
	mov	DWORD PTR _res$[ebp], ecx

; 2161 : 	    if (*cur == 0) {

	mov	edx, DWORD PTR _cur$2[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN12@xmlSkipBla

; 2162 : 		ctxt->input->cur = cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _cur$2[ebp]
	mov	DWORD PTR [edx+16], eax

; 2163 : 		xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8

; 2164 : 		cur = ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _cur$2[ebp], edx
$LN12@xmlSkipBla:

; 2165 : 	    }
; 2166 : 	}

	jmp	$LN2@xmlSkipBla
$LN3@xmlSkipBla:

; 2167 : 	ctxt->input->cur = cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _cur$2[ebp]
	mov	DWORD PTR [ecx+16], edx

; 2168 :     } else {

	jmp	$LN7@xmlSkipBla
$LN6@xmlSkipBla:

; 2169 :         int expandPE = ((ctxt->external != 0) || (ctxt->inputNr != 1));

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+96], 0
	jne	SHORT $LN26@xmlSkipBla
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 1
	jne	SHORT $LN26@xmlSkipBla
	mov	DWORD PTR tv145[ebp], 0
	jmp	SHORT $LN27@xmlSkipBla
$LN26@xmlSkipBla:
	mov	DWORD PTR tv145[ebp], 1
$LN27@xmlSkipBla:
	mov	edx, DWORD PTR tv145[ebp]
	mov	DWORD PTR _expandPE$1[ebp], edx
$LN4@xmlSkipBla:

; 2170 : 
; 2171 : 	while (1) {

	mov	eax, 1
	test	eax, eax
	je	$LN7@xmlSkipBla

; 2172 :             if (IS_BLANK_CH(CUR)) { /* CHECKED tstblanks.xml */

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN15@xmlSkipBla
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN16@xmlSkipBla
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN15@xmlSkipBla
$LN16@xmlSkipBla:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN13@xmlSkipBla
$LN15@xmlSkipBla:

; 2173 : 		NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4
	jmp	$LN14@xmlSkipBla
$LN13@xmlSkipBla:

; 2174 : 	    } else if (CUR == '%') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 37					; 00000025H
	jne	$LN17@xmlSkipBla

; 2175 :                 /*
; 2176 :                  * Need to handle support of entities branching here
; 2177 :                  */
; 2178 : 	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))

	cmp	DWORD PTR _expandPE$1[ebp], 0
	je	$LN20@xmlSkipBla
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN20@xmlSkipBla
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 9
	jl	SHORT $LN21@xmlSkipBla
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN20@xmlSkipBla
$LN21@xmlSkipBla:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN20@xmlSkipBla
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN19@xmlSkipBla
$LN20@xmlSkipBla:

; 2179 :                     break;

	jmp	SHORT $LN7@xmlSkipBla
$LN19@xmlSkipBla:

; 2180 : 	        xmlParsePEReference(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParsePEReference
	add	esp, 4
	jmp	SHORT $LN14@xmlSkipBla
$LN17@xmlSkipBla:

; 2181 :             } else if (CUR == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN22@xmlSkipBla

; 2182 :                 if (ctxt->inputNr <= 1)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 1
	jg	SHORT $LN24@xmlSkipBla

; 2183 :                     break;

	jmp	SHORT $LN7@xmlSkipBla
$LN24@xmlSkipBla:

; 2184 :                 xmlPopInput(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlPopInput
	add	esp, 4

; 2185 :             } else {

	jmp	SHORT $LN14@xmlSkipBla
$LN22@xmlSkipBla:

; 2186 :                 break;

	jmp	SHORT $LN7@xmlSkipBla
$LN14@xmlSkipBla:

; 2187 :             }
; 2188 : 
; 2189 :             /*
; 2190 :              * Also increase the counter when entering or exiting a PERef.
; 2191 :              * The spec says: "When a parameter-entity reference is recognized
; 2192 :              * in the DTD and included, its replacement text MUST be enlarged
; 2193 :              * by the attachment of one leading and one following space (#x20)
; 2194 :              * character."
; 2195 :              */
; 2196 : 	    res++;

	mov	eax, DWORD PTR _res$[ebp]
	add	eax, 1
	mov	DWORD PTR _res$[ebp], eax

; 2197 :         }

	jmp	$LN4@xmlSkipBla
$LN7@xmlSkipBla:

; 2198 :     }
; 2199 :     return(res);

	mov	eax, DWORD PTR _res$[ebp]

; 2200 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSkipBlankChars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _namePush
_TEXT	SEGMENT
tv89 = -8						; size = 4
_tmp$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_namePush PROC						; COMDAT

; 1908 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1909 :     if (ctxt == NULL) return (-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@namePush
	or	eax, -1
	jmp	$LN1@namePush
$LN2@namePush:

; 1910 : 
; 1911 :     if (ctxt->nameNr >= ctxt->nameMax) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+188]
	cmp	edx, DWORD PTR [ecx+192]
	jl	SHORT $LN3@namePush

; 1912 :         const xmlChar * *tmp;
; 1913 :         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	shl	ecx, 1
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+196]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 1914 :                                     ctxt->nameMax * 2 *
; 1915 :                                     sizeof(ctxt->nameTab[0]));
; 1916 :         if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN4@namePush

; 1917 : 	    goto mem_error;

	jmp	SHORT $mem_error$6
$LN4@namePush:

; 1918 :         }
; 1919 : 	ctxt->nameTab = tmp;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [ecx+196], edx

; 1920 :         ctxt->nameMax *= 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+192], ecx
$LN3@namePush:

; 1921 :     }
; 1922 :     ctxt->nameTab[ctxt->nameNr] = value;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 1923 :     ctxt->name = value;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+184], ecx

; 1924 :     return (ctxt->nameNr++);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+188]
	mov	DWORD PTR tv89[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+188], edx
	mov	eax, DWORD PTR tv89[ebp]
	jmp	SHORT $LN1@namePush
$mem_error$6:

; 1925 : mem_error:
; 1926 :     xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 1927 :     return (-1);

	or	eax, -1
$LN1@namePush:

; 1928 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_namePush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _namePop
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_namePop PROC						; COMDAT

; 1939 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1940 :     const xmlChar *ret;
; 1941 : 
; 1942 :     if ((ctxt == NULL) || (ctxt->nameNr <= 0))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@namePop
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+188], 0
	jg	SHORT $LN2@namePop
$LN3@namePop:

; 1943 :         return (NULL);

	xor	eax, eax
	jmp	$LN1@namePop
$LN2@namePop:

; 1944 :     ctxt->nameNr--;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+188], edx

; 1945 :     if (ctxt->nameNr > 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+188], 0
	jle	SHORT $LN4@namePop

; 1946 :         ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+188]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+eax*4-4]
	mov	DWORD PTR [ecx+184], edx
	jmp	SHORT $LN5@namePop
$LN4@namePop:

; 1947 :     else
; 1948 :         ctxt->name = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+184], 0
$LN5@namePop:

; 1949 :     ret = ctxt->nameTab[ctxt->nameNr];

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+188]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+196]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _ret$[ebp], edx

; 1950 :     ctxt->nameTab[ctxt->nameNr] = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR [eax+ecx*4], 0

; 1951 :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@namePop:

; 1952 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_namePop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _inputPop
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_inputPop PROC						; COMDAT

; 1743 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1744 :     xmlParserInputPtr ret;
; 1745 : 
; 1746 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@inputPop

; 1747 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@inputPop
$LN2@inputPop:

; 1748 :     if (ctxt->inputNr <= 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jg	SHORT $LN3@inputPop

; 1749 :         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@inputPop
$LN3@inputPop:

; 1750 :     ctxt->inputNr--;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+40], edx

; 1751 :     if (ctxt->inputNr > 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	jle	SHORT $LN4@inputPop

; 1752 :         ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+eax*4-4]
	mov	DWORD PTR [ecx+36], edx
	jmp	SHORT $LN5@inputPop
$LN4@inputPop:

; 1753 :     else
; 1754 :         ctxt->input = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+36], 0
$LN5@inputPop:

; 1755 :     ret = ctxt->inputTab[ctxt->inputNr];

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _ret$[ebp], edx

; 1756 :     ctxt->inputTab[ctxt->inputNr] = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [eax+ecx*4], 0

; 1757 :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@inputPop:

; 1758 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_inputPop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _inputPush
_TEXT	SEGMENT
tv128 = -4						; size = 4
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_inputPush PROC						; COMDAT

; 1712 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1713 :     if ((ctxt == NULL) || (value == NULL))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@inputPush
	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@inputPush
$LN3@inputPush:

; 1714 :         return(-1);

	or	eax, -1
	jmp	$LN1@inputPush
$LN2@inputPush:

; 1715 :     if (ctxt->inputNr >= ctxt->inputMax) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+40]
	cmp	edx, DWORD PTR [ecx+44]
	jl	SHORT $LN4@inputPush

; 1716 :         ctxt->inputMax *= 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	shl	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+44], ecx

; 1717 :         ctxt->inputTab =

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 1718 :             (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,
; 1719 :                                              ctxt->inputMax *
; 1720 :                                              sizeof(ctxt->inputTab[0]));
; 1721 :         if (ctxt->inputTab == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN4@inputPush

; 1722 :             xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 1723 : 	    xmlFreeInputStream(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlFreeInputStream
	add	esp, 4

; 1724 : 	    ctxt->inputMax /= 2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+44]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 1725 : 	    value = NULL;

	mov	DWORD PTR _value$[ebp], 0

; 1726 :             return (-1);

	or	eax, -1
	jmp	SHORT $LN1@inputPush
$LN4@inputPush:

; 1727 :         }
; 1728 :     }
; 1729 :     ctxt->inputTab[ctxt->inputNr] = value;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1730 :     ctxt->input = value;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [edx+36], eax

; 1731 :     return (ctxt->inputNr++);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR tv128[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+40], ecx
	mov	eax, DWORD PTR tv128[ebp]
$LN1@inputPush:

; 1732 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_inputPush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nodePop
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nodePop PROC						; COMDAT

; 1808 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1809 :     xmlNodePtr ret;
; 1810 : 
; 1811 :     if (ctxt == NULL) return(NULL);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@nodePop
	xor	eax, eax
	jmp	SHORT $LN1@nodePop
$LN2@nodePop:

; 1812 :     if (ctxt->nodeNr <= 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jg	SHORT $LN3@nodePop

; 1813 :         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@nodePop
$LN3@nodePop:

; 1814 :     ctxt->nodeNr--;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+56], edx

; 1815 :     if (ctxt->nodeNr > 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	jle	SHORT $LN4@nodePop

; 1816 :         ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+eax*4-4]
	mov	DWORD PTR [ecx+52], edx
	jmp	SHORT $LN5@nodePop
$LN4@nodePop:

; 1817 :     else
; 1818 :         ctxt->node = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+52], 0
$LN5@nodePop:

; 1819 :     ret = ctxt->nodeTab[ctxt->nodeNr];

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _ret$[ebp], edx

; 1820 :     ctxt->nodeTab[ctxt->nodeNr] = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR [eax+ecx*4], 0

; 1821 :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@nodePop:

; 1822 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_nodePop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _nodePush
_TEXT	SEGMENT
tv133 = -8						; size = 4
_tmp$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_nodePush PROC						; COMDAT

; 1770 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 1771 :     if (ctxt == NULL) return(0);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@nodePush
	xor	eax, eax
	jmp	$LN1@nodePush
$LN2@nodePush:

; 1772 :     if (ctxt->nodeNr >= ctxt->nodeMax) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+56]
	cmp	edx, DWORD PTR [ecx+60]
	jl	SHORT $LN3@nodePush

; 1773 :         xmlNodePtr *tmp;
; 1774 : 
; 1775 : 	tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	shl	ecx, 1
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 1776 :                                       ctxt->nodeMax * 2 *
; 1777 :                                       sizeof(ctxt->nodeTab[0]));
; 1778 :         if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN4@nodePush

; 1779 :             xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 1780 :             return (-1);

	or	eax, -1
	jmp	$LN1@nodePush
$LN4@nodePush:

; 1781 :         }
; 1782 :         ctxt->nodeTab = tmp;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [edx+64], eax

; 1783 : 	ctxt->nodeMax *= 2;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	shl	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+60], edx
$LN3@nodePush:

; 1784 :     }
; 1785 :     if ((((unsigned int) ctxt->nodeNr) > xmlParserMaxDepth) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	cmp	edx, DWORD PTR _xmlParserMaxDepth
	jbe	SHORT $LN5@nodePush
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	jne	SHORT $LN5@nodePush

; 1786 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 1787 : 	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,

	mov	edx, DWORD PTR _xmlParserMaxDepth
	push	edx
	push	OFFSET ??_C@_0DL@HADOBDDE@Excessive?5depth?5in?5document?3?5?$CFd@
	push	1
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 1788 : 		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
; 1789 : 			  xmlParserMaxDepth);
; 1790 : 	xmlHaltParser(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlHaltParser
	add	esp, 4

; 1791 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@nodePush
$LN5@nodePush:

; 1792 :     }
; 1793 :     ctxt->nodeTab[ctxt->nodeNr] = value;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1794 :     ctxt->node = value;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [edx+52], eax

; 1795 :     return (ctxt->nodeNr++);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR tv133[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+56], ecx
	mov	eax, DWORD PTR tv133[ebp]
$LN1@nodePush:

; 1796 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_nodePush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlStringLenDecodeEntities
_TEXT	SEGMENT
$T1 = -105						; size = 1
_new_size$2 = -104					; size = 4
_tmp$3 = -100						; size = 4
_new_size$4 = -96					; size = 4
_tmp$5 = -92						; size = 4
_new_size$6 = -88					; size = 4
_tmp$7 = -84						; size = 4
_cur$8 = -80						; size = 4
_i$9 = -76						; size = 4
_new_size$10 = -72					; size = 4
_tmp$11 = -68						; size = 4
_new_size$12 = -64					; size = 4
_tmp$13 = -60						; size = 4
_new_size$14 = -56					; size = 4
_tmp$15 = -52						; size = 4
_val$16 = -48						; size = 4
_l$ = -40						; size = 4
_c$ = -32						; size = 4
_ent$ = -28						; size = 4
_last$ = -24						; size = 4
_rep$ = -20						; size = 4
_current$ = -16						; size = 4
_nbchars$ = -12						; size = 4
_buffer_size$ = -8					; size = 4
_buffer$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_len$ = 16						; size = 4
_what$ = 20						; size = 4
_end$ = 24						; size = 1
_end2$ = 28						; size = 1
_end3$ = 32						; size = 1
_xmlStringLenDecodeEntities PROC			; COMDAT

; 2593 : 		      int what, xmlChar end, xmlChar  end2, xmlChar end3) {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-108]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T1[ebp], 0
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2594 :     xmlChar *buffer = NULL;

	mov	DWORD PTR _buffer$[ebp], 0

; 2595 :     size_t buffer_size = 0;

	mov	DWORD PTR _buffer_size$[ebp], 0

; 2596 :     size_t nbchars = 0;

	mov	DWORD PTR _nbchars$[ebp], 0

; 2597 : 
; 2598 :     xmlChar *current = NULL;

	mov	DWORD PTR _current$[ebp], 0

; 2599 :     xmlChar *rep = NULL;

	mov	DWORD PTR _rep$[ebp], 0

; 2600 :     const xmlChar *last;
; 2601 :     xmlEntityPtr ent;
; 2602 :     int c,l;
; 2603 : 
; 2604 :     if ((ctxt == NULL) || (str == NULL) || (len < 0))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN12@xmlStringL
	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN12@xmlStringL
	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN11@xmlStringL
$LN12@xmlStringL:

; 2605 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlStringL
$LN11@xmlStringL:

; 2606 :     last = str + len;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _last$[ebp], eax

; 2607 : 
; 2608 :     if (((ctxt->depth > 40) &&
; 2609 :          ((ctxt->options & XML_PARSE_HUGE) == 0)) ||

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+248], 40			; 00000028H
	jle	SHORT $LN15@xmlStringL
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	and	eax, 524288				; 00080000H
	je	SHORT $LN14@xmlStringL
$LN15@xmlStringL:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+248], 1024		; 00000400H
	jle	SHORT $LN13@xmlStringL
$LN14@xmlStringL:

; 2610 : 	(ctxt->depth > 1024)) {
; 2611 : 	xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);

	push	0
	push	89					; 00000059H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2612 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlStringL
$LN13@xmlStringL:

; 2613 :     }
; 2614 : 
; 2615 :     /*
; 2616 :      * allocate a translation buffer.
; 2617 :      */
; 2618 :     buffer_size = XML_PARSER_BIG_BUFFER_SIZE;

	mov	DWORD PTR _buffer_size$[ebp], 300	; 0000012cH

; 2619 :     buffer = (xmlChar *) xmlMallocAtomic(buffer_size);

	mov	esi, esp
	mov	eax, DWORD PTR _buffer_size$[ebp]
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buffer$[ebp], eax

; 2620 :     if (buffer == NULL) goto mem_error;

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN16@xmlStringL
	jmp	$mem_error$81
$LN16@xmlStringL:

; 2621 : 
; 2622 :     /*
; 2623 :      * OK loop until we reach one of the ending char or a size limit.
; 2624 :      * we are operating on already parsed values.
; 2625 :      */
; 2626 :     if (str < last)

	mov	ecx, DWORD PTR _str$[ebp]
	cmp	ecx, DWORD PTR _last$[ebp]
	jae	SHORT $LN17@xmlStringL

; 2627 : 	c = CUR_SCHAR(str, l);

	mov	BYTE PTR $T1[ebp], 1
	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN2@xmlStringL
$LN17@xmlStringL:

; 2628 :     else
; 2629 :         c = 0;

	mov	DWORD PTR _c$[ebp], 0
$LN2@xmlStringL:

; 2630 :     while ((c != 0) && (c != end) && /* non input consuming loop */
; 2631 : 	   (c != end2) && (c != end3)) {

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN3@xmlStringL
	movzx	edx, BYTE PTR _end$[ebp]
	cmp	DWORD PTR _c$[ebp], edx
	je	$LN3@xmlStringL
	movzx	eax, BYTE PTR _end2$[ebp]
	cmp	DWORD PTR _c$[ebp], eax
	je	$LN3@xmlStringL
	movzx	ecx, BYTE PTR _end3$[ebp]
	cmp	DWORD PTR _c$[ebp], ecx
	je	$LN3@xmlStringL

; 2632 : 
; 2633 : 	if (c == 0) break;

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN19@xmlStringL
	jmp	$LN3@xmlStringL
$LN19@xmlStringL:

; 2634 :         if ((c == '&') && (str[1] == '#')) {

	cmp	DWORD PTR _c$[ebp], 38			; 00000026H
	jne	$LN20@xmlStringL
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _str$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 35					; 00000023H
	jne	$LN20@xmlStringL

; 2635 : 	    int val = xmlParseStringCharRef(ctxt, &str);

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseStringCharRef
	add	esp, 8
	mov	DWORD PTR _val$16[ebp], eax

; 2636 : 	    if (val == 0)

	cmp	DWORD PTR _val$16[ebp], 0
	jne	SHORT $LN22@xmlStringL

; 2637 :                 goto int_error;

	jmp	$int_error$82
$LN22@xmlStringL:

; 2638 : 	    COPY_BUF(0,buffer,nbchars,val);

	xor	ecx, ecx
	je	SHORT $LN23@xmlStringL
	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _nbchars$[ebp]
	mov	al, BYTE PTR _val$16[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _nbchars$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbchars$[ebp], ecx
	jmp	SHORT $LN24@xmlStringL
$LN23@xmlStringL:
	mov	edx, DWORD PTR _val$16[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _nbchars$[ebp]
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _nbchars$[ebp]
	mov	DWORD PTR _nbchars$[ebp], eax
$LN24@xmlStringL:

; 2639 : 	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {

	mov	ecx, DWORD PTR _nbchars$[ebp]
	add	ecx, 100				; 00000064H
	cmp	ecx, DWORD PTR _buffer_size$[ebp]
	jbe	SHORT $LN25@xmlStringL

; 2640 : 	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);

	mov	edx, DWORD PTR _buffer_size$[ebp]
	lea	eax, DWORD PTR [edx+edx+100]
	mov	DWORD PTR _new_size$14[ebp], eax
	mov	ecx, DWORD PTR _new_size$14[ebp]
	cmp	ecx, DWORD PTR _buffer_size$[ebp]
	jae	SHORT $LN26@xmlStringL
	jmp	$mem_error$81
$LN26@xmlStringL:
	mov	esi, esp
	mov	edx, DWORD PTR _new_size$14[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$15[ebp], eax
	cmp	DWORD PTR _tmp$15[ebp], 0
	jne	SHORT $LN27@xmlStringL
	jmp	$mem_error$81
$LN27@xmlStringL:
	mov	ecx, DWORD PTR _tmp$15[ebp]
	mov	DWORD PTR _buffer$[ebp], ecx
	mov	edx, DWORD PTR _new_size$14[ebp]
	mov	DWORD PTR _buffer_size$[ebp], edx
$LN25@xmlStringL:

; 2641 : 	    }

	jmp	$LN21@xmlStringL
$LN20@xmlStringL:

; 2642 : 	} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {

	cmp	DWORD PTR _c$[ebp], 38			; 00000026H
	jne	$LN28@xmlStringL
	mov	eax, DWORD PTR _what$[ebp]
	and	eax, 1
	je	$LN28@xmlStringL

; 2643 : 	    if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN30@xmlStringL

; 2644 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CJ@JICBMJMM@String?5decoding?5Entity?5Referenc@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN30@xmlStringL:

; 2645 : 			"String decoding Entity Reference: %.30s\n",
; 2646 : 			str);
; 2647 : 	    ent = xmlParseStringEntityRef(ctxt, &str);

	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseStringEntityRef
	add	esp, 8
	mov	DWORD PTR _ent$[ebp], eax

; 2648 : 	    xmlParserEntityCheck(ctxt, 0, ent, 0);

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H

; 2649 : 	    if (ent != NULL)

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN31@xmlStringL

; 2650 : 	        ctxt->nbentities += ent->checked / 2;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	eax, DWORD PTR [ecx+440]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+440], eax
$LN31@xmlStringL:

; 2651 : 	    if ((ent != NULL) &&

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN32@xmlStringL
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+48], 6
	jne	$LN32@xmlStringL

; 2652 : 		(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
; 2653 : 		if (ent->content != NULL) {

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	$LN34@xmlStringL

; 2654 : 		    COPY_BUF(0,buffer,nbchars,ent->content[0]);

	xor	edx, edx
	je	SHORT $LN36@xmlStringL
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _nbchars$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _nbchars$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbchars$[ebp], ecx
	jmp	SHORT $LN37@xmlStringL
$LN36@xmlStringL:
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movzx	eax, BYTE PTR [edx+eax]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _nbchars$[ebp]
	push	ecx
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _nbchars$[ebp]
	mov	DWORD PTR _nbchars$[ebp], eax
$LN37@xmlStringL:

; 2655 : 		    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {

	mov	edx, DWORD PTR _nbchars$[ebp]
	add	edx, 100				; 00000064H
	cmp	edx, DWORD PTR _buffer_size$[ebp]
	jbe	SHORT $LN38@xmlStringL

; 2656 : 			growBuffer(buffer, XML_PARSER_BUFFER_SIZE);

	mov	eax, DWORD PTR _buffer_size$[ebp]
	lea	ecx, DWORD PTR [eax+eax+100]
	mov	DWORD PTR _new_size$12[ebp], ecx
	mov	edx, DWORD PTR _new_size$12[ebp]
	cmp	edx, DWORD PTR _buffer_size$[ebp]
	jae	SHORT $LN39@xmlStringL
	jmp	$mem_error$81
$LN39@xmlStringL:
	mov	esi, esp
	mov	eax, DWORD PTR _new_size$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$13[ebp], eax
	cmp	DWORD PTR _tmp$13[ebp], 0
	jne	SHORT $LN40@xmlStringL
	jmp	$mem_error$81
$LN40@xmlStringL:
	mov	edx, DWORD PTR _tmp$13[ebp]
	mov	DWORD PTR _buffer$[ebp], edx
	mov	eax, DWORD PTR _new_size$12[ebp]
	mov	DWORD PTR _buffer_size$[ebp], eax
$LN38@xmlStringL:

; 2657 : 		    }
; 2658 : 		} else {

	jmp	SHORT $LN35@xmlStringL
$LN34@xmlStringL:

; 2659 : 		    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CC@KGDPFIJL@predefined?5entity?5has?5no?5conten@
	push	1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 2660 : 			    "predefined entity has no content\n");
; 2661 :                     goto int_error;

	jmp	$int_error$82
$LN35@xmlStringL:

; 2662 : 		}

	jmp	$LN33@xmlStringL
$LN32@xmlStringL:

; 2663 : 	    } else if ((ent != NULL) && (ent->content != NULL)) {

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN41@xmlStringL
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	$LN41@xmlStringL

; 2664 : 		ctxt->depth++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+248]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+248], ecx

; 2665 : 		rep = xmlStringDecodeEntities(ctxt, ent->content, what,

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _what$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlStringDecodeEntities
	add	esp, 24					; 00000018H
	mov	DWORD PTR _rep$[ebp], eax

; 2666 : 			                      0, 0, 0);
; 2667 : 		ctxt->depth--;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+248]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+248], edx

; 2668 : 		if (rep == NULL)

	cmp	DWORD PTR _rep$[ebp], 0
	jne	SHORT $LN43@xmlStringL

; 2669 :                     goto int_error;

	jmp	$int_error$82
$LN43@xmlStringL:

; 2670 : 
; 2671 :                 current = rep;

	mov	ecx, DWORD PTR _rep$[ebp]
	mov	DWORD PTR _current$[ebp], ecx
$LN4@xmlStringL:

; 2672 :                 while (*current != 0) { /* non input consuming loop */

	mov	edx, DWORD PTR _current$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN5@xmlStringL

; 2673 :                     buffer[nbchars++] = *current++;

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _nbchars$[ebp]
	mov	edx, DWORD PTR _current$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _nbchars$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbchars$[ebp], ecx
	mov	edx, DWORD PTR _current$[ebp]
	add	edx, 1
	mov	DWORD PTR _current$[ebp], edx

; 2674 :                     if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {

	mov	eax, DWORD PTR _nbchars$[ebp]
	add	eax, 100				; 00000064H
	cmp	eax, DWORD PTR _buffer_size$[ebp]
	jbe	SHORT $LN44@xmlStringL

; 2675 :                         if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))

	push	0
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nbchars$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN45@xmlStringL

; 2676 :                             goto int_error;

	jmp	$int_error$82
$LN45@xmlStringL:

; 2677 :                         growBuffer(buffer, XML_PARSER_BUFFER_SIZE);

	mov	ecx, DWORD PTR _buffer_size$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+100]
	mov	DWORD PTR _new_size$10[ebp], edx
	mov	eax, DWORD PTR _new_size$10[ebp]
	cmp	eax, DWORD PTR _buffer_size$[ebp]
	jae	SHORT $LN46@xmlStringL
	jmp	$mem_error$81
$LN46@xmlStringL:
	mov	esi, esp
	mov	ecx, DWORD PTR _new_size$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$11[ebp], eax
	cmp	DWORD PTR _tmp$11[ebp], 0
	jne	SHORT $LN47@xmlStringL
	jmp	$mem_error$81
$LN47@xmlStringL:
	mov	eax, DWORD PTR _tmp$11[ebp]
	mov	DWORD PTR _buffer$[ebp], eax
	mov	ecx, DWORD PTR _new_size$10[ebp]
	mov	DWORD PTR _buffer_size$[ebp], ecx
$LN44@xmlStringL:

; 2678 :                     }
; 2679 :                 }

	jmp	$LN4@xmlStringL
$LN5@xmlStringL:

; 2680 :                 xmlFree(rep);

	mov	esi, esp
	mov	edx, DWORD PTR _rep$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2681 :                 rep = NULL;

	mov	DWORD PTR _rep$[ebp], 0
	jmp	$LN33@xmlStringL
$LN41@xmlStringL:

; 2682 : 	    } else if (ent != NULL) {

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN33@xmlStringL

; 2683 : 		int i = xmlStrlen(ent->name);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _i$9[ebp], eax

; 2684 : 		const xmlChar *cur = ent->name;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$8[ebp], eax

; 2685 : 
; 2686 : 		buffer[nbchars++] = '&';

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _nbchars$[ebp]
	mov	BYTE PTR [ecx], 38			; 00000026H
	mov	edx, DWORD PTR _nbchars$[ebp]
	add	edx, 1
	mov	DWORD PTR _nbchars$[ebp], edx

; 2687 : 		if (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) {

	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR _nbchars$[ebp]
	lea	edx, DWORD PTR [ecx+eax+100]
	cmp	edx, DWORD PTR _buffer_size$[ebp]
	jbe	SHORT $LN49@xmlStringL

; 2688 : 		    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);

	mov	eax, DWORD PTR _buffer_size$[ebp]
	mov	ecx, DWORD PTR _i$9[ebp]
	lea	edx, DWORD PTR [ecx+eax*2+100]
	mov	DWORD PTR _new_size$6[ebp], edx
	mov	eax, DWORD PTR _new_size$6[ebp]
	cmp	eax, DWORD PTR _buffer_size$[ebp]
	jae	SHORT $LN50@xmlStringL
	jmp	$mem_error$81
$LN50@xmlStringL:
	mov	esi, esp
	mov	ecx, DWORD PTR _new_size$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$7[ebp], eax
	cmp	DWORD PTR _tmp$7[ebp], 0
	jne	SHORT $LN51@xmlStringL
	jmp	$mem_error$81
$LN51@xmlStringL:
	mov	eax, DWORD PTR _tmp$7[ebp]
	mov	DWORD PTR _buffer$[ebp], eax
	mov	ecx, DWORD PTR _new_size$6[ebp]
	mov	DWORD PTR _buffer_size$[ebp], ecx
$LN49@xmlStringL:

; 2689 : 		}
; 2690 : 		for (;i > 0;i--)

	jmp	SHORT $LN8@xmlStringL
$LN6@xmlStringL:
	mov	edx, DWORD PTR _i$9[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$9[ebp], edx
$LN8@xmlStringL:
	cmp	DWORD PTR _i$9[ebp], 0
	jle	SHORT $LN7@xmlStringL

; 2691 : 		    buffer[nbchars++] = *cur++;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _nbchars$[ebp]
	mov	ecx, DWORD PTR _cur$8[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _nbchars$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbchars$[ebp], eax
	mov	ecx, DWORD PTR _cur$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$8[ebp], ecx
	jmp	SHORT $LN6@xmlStringL
$LN7@xmlStringL:

; 2692 : 		buffer[nbchars++] = ';';

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _nbchars$[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _nbchars$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbchars$[ebp], eax
$LN33@xmlStringL:

; 2693 : 	    }

	jmp	$LN21@xmlStringL
$LN28@xmlStringL:

; 2694 : 	} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {

	cmp	DWORD PTR _c$[ebp], 37			; 00000025H
	jne	$LN52@xmlStringL
	mov	ecx, DWORD PTR _what$[ebp]
	and	ecx, 2
	je	$LN52@xmlStringL

; 2695 : 	    if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN54@xmlStringL

; 2696 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	push	OFFSET ??_C@_0CF@DIAKJGNK@String?5decoding?5PE?5Reference?3?5?$CF@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN54@xmlStringL:

; 2697 : 			"String decoding PE Reference: %.30s\n", str);
; 2698 : 	    ent = xmlParseStringPEReference(ctxt, &str);

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseStringPEReference
	add	esp, 8
	mov	DWORD PTR _ent$[ebp], eax

; 2699 : 	    xmlParserEntityCheck(ctxt, 0, ent, 0);

	push	0
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H

; 2700 : 	    if (ent != NULL)

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN55@xmlStringL

; 2701 : 	        ctxt->nbentities += ent->checked / 2;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [eax+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	eax, DWORD PTR [ecx+440]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+440], eax
$LN55@xmlStringL:

; 2702 : 	    if (ent != NULL) {

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN56@xmlStringL

; 2703 :                 if (ent->content == NULL) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN57@xmlStringL

; 2704 : 		    /*
; 2705 : 		     * Note: external parsed entities will not be loaded,
; 2706 : 		     * it is not required for a non-validating parser to
; 2707 : 		     * complete external PEreferences coming from the
; 2708 : 		     * internal subset
; 2709 : 		     */
; 2710 : 		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
; 2711 : 			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 2
	jne	SHORT $LN60@xmlStringL
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 16					; 00000010H
	jne	SHORT $LN60@xmlStringL
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+104], 0
	je	SHORT $LN58@xmlStringL
$LN60@xmlStringL:

; 2712 : 			(ctxt->validate != 0)) {
; 2713 : 			xmlLoadEntityContent(ctxt, ent);

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlLoadEntityContent
	add	esp, 8

; 2714 : 		    } else {

	jmp	SHORT $LN57@xmlStringL
$LN58@xmlStringL:

; 2715 : 			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,

	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_0DH@IENLJLFO@not?5validating?5will?5not?5read?5co@
	push	104					; 00000068H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN57@xmlStringL:

; 2716 : 		  "not validating will not read content for PE entity %s\n",
; 2717 : 		                      ent->name, NULL);
; 2718 : 		    }
; 2719 : 		}
; 2720 : 		ctxt->depth++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+248], eax

; 2721 : 		rep = xmlStringDecodeEntities(ctxt, ent->content, what,

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _what$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlStringDecodeEntities
	add	esp, 24					; 00000018H
	mov	DWORD PTR _rep$[ebp], eax

; 2722 : 			                      0, 0, 0);
; 2723 : 		ctxt->depth--;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+248]
	sub	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+248], ecx

; 2724 : 		if (rep == NULL)

	cmp	DWORD PTR _rep$[ebp], 0
	jne	SHORT $LN61@xmlStringL

; 2725 :                     goto int_error;

	jmp	$int_error$82
$LN61@xmlStringL:

; 2726 :                 current = rep;

	mov	eax, DWORD PTR _rep$[ebp]
	mov	DWORD PTR _current$[ebp], eax
$LN9@xmlStringL:

; 2727 :                 while (*current != 0) { /* non input consuming loop */

	mov	ecx, DWORD PTR _current$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN10@xmlStringL

; 2728 :                     buffer[nbchars++] = *current++;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _nbchars$[ebp]
	mov	ecx, DWORD PTR _current$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _nbchars$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbchars$[ebp], eax
	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx

; 2729 :                     if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {

	mov	edx, DWORD PTR _nbchars$[ebp]
	add	edx, 100				; 00000064H
	cmp	edx, DWORD PTR _buffer_size$[ebp]
	jbe	SHORT $LN62@xmlStringL

; 2730 :                         if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nbchars$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN63@xmlStringL

; 2731 :                             goto int_error;

	jmp	$int_error$82
$LN63@xmlStringL:

; 2732 :                         growBuffer(buffer, XML_PARSER_BUFFER_SIZE);

	mov	eax, DWORD PTR _buffer_size$[ebp]
	lea	ecx, DWORD PTR [eax+eax+100]
	mov	DWORD PTR _new_size$4[ebp], ecx
	mov	edx, DWORD PTR _new_size$4[ebp]
	cmp	edx, DWORD PTR _buffer_size$[ebp]
	jae	SHORT $LN64@xmlStringL
	jmp	$mem_error$81
$LN64@xmlStringL:
	mov	esi, esp
	mov	eax, DWORD PTR _new_size$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$5[ebp], eax
	cmp	DWORD PTR _tmp$5[ebp], 0
	jne	SHORT $LN65@xmlStringL
	jmp	$mem_error$81
$LN65@xmlStringL:
	mov	edx, DWORD PTR _tmp$5[ebp]
	mov	DWORD PTR _buffer$[ebp], edx
	mov	eax, DWORD PTR _new_size$4[ebp]
	mov	DWORD PTR _buffer_size$[ebp], eax
$LN62@xmlStringL:

; 2733 :                     }
; 2734 :                 }

	jmp	$LN9@xmlStringL
$LN10@xmlStringL:

; 2735 :                 xmlFree(rep);

	mov	esi, esp
	mov	ecx, DWORD PTR _rep$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2736 :                 rep = NULL;

	mov	DWORD PTR _rep$[ebp], 0
$LN56@xmlStringL:

; 2737 : 	    }
; 2738 : 	} else {

	jmp	$LN21@xmlStringL
$LN52@xmlStringL:

; 2739 : 	    COPY_BUF(l,buffer,nbchars,c);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN76@xmlStringL
	push	OFFSET $LN77@xmlStringL
	call	__RTC_UninitUse
	add	esp, 4
$LN76@xmlStringL:
	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN66@xmlStringL
	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _nbchars$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _nbchars$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbchars$[ebp], ecx
	jmp	SHORT $LN67@xmlStringL
$LN66@xmlStringL:
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _nbchars$[ebp]
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _nbchars$[ebp]
	mov	DWORD PTR _nbchars$[ebp], eax
$LN67@xmlStringL:

; 2740 : 	    str += l;

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN78@xmlStringL
	push	OFFSET $LN77@xmlStringL
	call	__RTC_UninitUse
	add	esp, 4
$LN78@xmlStringL:
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _str$[ebp], ecx

; 2741 : 	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {

	mov	edx, DWORD PTR _nbchars$[ebp]
	add	edx, 100				; 00000064H
	cmp	edx, DWORD PTR _buffer_size$[ebp]
	jbe	SHORT $LN21@xmlStringL

; 2742 : 	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);

	mov	eax, DWORD PTR _buffer_size$[ebp]
	lea	ecx, DWORD PTR [eax+eax+100]
	mov	DWORD PTR _new_size$2[ebp], ecx
	mov	edx, DWORD PTR _new_size$2[ebp]
	cmp	edx, DWORD PTR _buffer_size$[ebp]
	jae	SHORT $LN69@xmlStringL
	jmp	SHORT $mem_error$81
$LN69@xmlStringL:
	mov	esi, esp
	mov	eax, DWORD PTR _new_size$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$3[ebp], eax
	cmp	DWORD PTR _tmp$3[ebp], 0
	jne	SHORT $LN70@xmlStringL
	jmp	SHORT $mem_error$81
$LN70@xmlStringL:
	mov	edx, DWORD PTR _tmp$3[ebp]
	mov	DWORD PTR _buffer$[ebp], edx
	mov	eax, DWORD PTR _new_size$2[ebp]
	mov	DWORD PTR _buffer_size$[ebp], eax
$LN21@xmlStringL:

; 2743 : 	    }
; 2744 : 	}
; 2745 : 	if (str < last)

	mov	ecx, DWORD PTR _str$[ebp]
	cmp	ecx, DWORD PTR _last$[ebp]
	jae	SHORT $LN71@xmlStringL

; 2746 : 	    c = CUR_SCHAR(str, l);

	mov	BYTE PTR $T1[ebp], 1
	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN72@xmlStringL
$LN71@xmlStringL:

; 2747 : 	else
; 2748 : 	    c = 0;

	mov	DWORD PTR _c$[ebp], 0
$LN72@xmlStringL:

; 2749 :     }

	jmp	$LN2@xmlStringL
$LN3@xmlStringL:

; 2750 :     buffer[nbchars] = 0;

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _nbchars$[ebp]
	mov	BYTE PTR [edx], 0

; 2751 :     return(buffer);

	mov	eax, DWORD PTR _buffer$[ebp]
	jmp	SHORT $LN1@xmlStringL
$mem_error$81:

; 2752 : 
; 2753 : mem_error:
; 2754 :     xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8
$int_error$82:

; 2755 : int_error:
; 2756 :     if (rep != NULL)

	cmp	DWORD PTR _rep$[ebp], 0
	je	SHORT $LN73@xmlStringL

; 2757 :         xmlFree(rep);

	mov	esi, esp
	mov	ecx, DWORD PTR _rep$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN73@xmlStringL:

; 2758 :     if (buffer != NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN74@xmlStringL

; 2759 :         xmlFree(buffer);

	mov	esi, esp
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN74@xmlStringL:

; 2760 :     return(NULL);

	xor	eax, eax
$LN1@xmlStringL:

; 2761 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN80@xmlStringL
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 108				; 0000006cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN80@xmlStringL:
	DD	1
	DD	$LN79@xmlStringL
$LN79@xmlStringL:
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN77@xmlStringL
$LN77@xmlStringL:
	DB	108					; 0000006cH
	DB	0
_xmlStringLenDecodeEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlStringDecodeEntities
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_what$ = 16						; size = 4
_end$ = 20						; size = 1
_end2$ = 24						; size = 1
_end3$ = 28						; size = 1
_xmlStringDecodeEntities PROC				; COMDAT

; 2783 : 		        xmlChar end, xmlChar  end2, xmlChar end3) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2784 :     if ((ctxt == NULL) || (str == NULL)) return(NULL);

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlStringD
	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@xmlStringD
$LN3@xmlStringD:
	xor	eax, eax
	jmp	SHORT $LN1@xmlStringD
$LN2@xmlStringD:

; 2785 :     return(xmlStringLenDecodeEntities(ctxt, str, xmlStrlen(str), what,

	movzx	eax, BYTE PTR _end3$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _end2$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _what$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlStringLenDecodeEntities
	add	esp, 28					; 0000001cH
$LN1@xmlStringD:

; 2786 :            end, end2, end3));
; 2787 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlStringDecodeEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseExternalSubset
_TEXT	SEGMENT
_cons$1 = -24						; size = 4
_check$2 = -20						; size = 4
_enc$3 = -16						; size = 4
_start$4 = -8						; size = 4
_ctxt$ = 8						; size = 4
_ExternalID$ = 12					; size = 4
_SystemID$ = 16						; size = 4
_xmlParseExternalSubset PROC				; COMDAT

; 6919 :                        const xmlChar *SystemID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 6920 :     xmlDetectSAX2(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDetectSAX2
	add	esp, 4

; 6921 :     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN4@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN4@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseEx:

; 6922 : 
; 6923 :     if ((ctxt->encoding == NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	$LN5@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 4
	jl	$LN5@xmlParseEx

; 6924 :         (ctxt->input->end - ctxt->input->cur >= 4)) {
; 6925 :         xmlChar start[4];
; 6926 : 	xmlCharEncoding enc;
; 6927 : 
; 6928 : 	start[0] = RAW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR _start$4[ebp+eax], cl

; 6929 : 	start[1] = NXT(1);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	mov	eax, 1
	shl	eax, 0
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR _start$4[ebp+eax], cl

; 6930 : 	start[2] = NXT(2);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	mov	eax, 1
	shl	eax, 1
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR _start$4[ebp+eax], cl

; 6931 : 	start[3] = NXT(3);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, 1
	imul	ecx, ecx, 3
	mov	dl, BYTE PTR [edx+eax]
	mov	BYTE PTR _start$4[ebp+ecx], dl

; 6932 : 	enc = xmlDetectCharEncoding(start, 4);

	push	4
	lea	eax, DWORD PTR _start$4[ebp]
	push	eax
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$3[ebp], eax

; 6933 : 	if (enc != XML_CHAR_ENCODING_NONE)

	cmp	DWORD PTR _enc$3[ebp], 0
	je	SHORT $LN5@xmlParseEx

; 6934 : 	    xmlSwitchEncoding(ctxt, enc);

	mov	ecx, DWORD PTR _enc$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSwitchEncoding
	add	esp, 8
$LN5@xmlParseEx:

; 6935 :     }
; 6936 : 
; 6937 :     if (CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 60					; 0000003cH
	jne	$LN7@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 63					; 0000003fH
	jne	SHORT $LN7@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 120				; 00000078H
	jne	SHORT $LN7@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 109				; 0000006dH
	jne	SHORT $LN7@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 108				; 0000006cH
	jne	SHORT $LN7@xmlParseEx

; 6938 : 	xmlParseTextDecl(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseTextDecl
	add	esp, 4

; 6939 : 	if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+84], 32			; 00000020H
	jne	SHORT $LN7@xmlParseEx

; 6940 : 	    /*
; 6941 : 	     * The XML REC instructs us to stop parsing right here
; 6942 : 	     */
; 6943 : 	    xmlHaltParser(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlHaltParser
	add	esp, 4

; 6944 : 	    return;

	jmp	$LN1@xmlParseEx
$LN7@xmlParseEx:

; 6945 : 	}
; 6946 :     }
; 6947 :     if (ctxt->myDoc == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN9@xmlParseEx

; 6948 :         ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 6949 : 	if (ctxt->myDoc == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@xmlParseEx

; 6950 : 	    xmlErrMemory(ctxt, "New Doc failed");

	push	OFFSET ??_C@_0P@IDBIGKBI@New?5Doc?5failed@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 6951 : 	    return;

	jmp	$LN1@xmlParseEx
$LN10@xmlParseEx:

; 6952 : 	}
; 6953 : 	ctxt->myDoc->properties = XML_DOC_INTERNAL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+92], 64			; 00000040H
$LN9@xmlParseEx:

; 6954 :     }
; 6955 :     if ((ctxt->myDoc != NULL) && (ctxt->myDoc->intSubset == NULL))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN11@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+44], 0
	jne	SHORT $LN11@xmlParseEx

; 6956 :         xmlCreateIntSubset(ctxt->myDoc, NULL, ExternalID, SystemID);

	mov	eax, DWORD PTR _SystemID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ExternalID$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlCreateIntSubset
	add	esp, 16					; 00000010H
$LN11@xmlParseEx:

; 6957 : 
; 6958 :     ctxt->instate = XML_PARSER_DTD;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 3

; 6959 :     ctxt->external = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+96], 1

; 6960 :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4
$LN2@xmlParseEx:

; 6961 :     while (((RAW == '<') && (NXT(1) == '?')) ||
; 6962 :            ((RAW == '<') && (NXT(1) == '!')) ||

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN13@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN12@xmlParseEx
$LN13@xmlParseEx:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN14@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	je	SHORT $LN12@xmlParseEx
$LN14@xmlParseEx:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	jne	$LN3@xmlParseEx
$LN12@xmlParseEx:

; 6963 : 	   (RAW == '%')) {
; 6964 : 	const xmlChar *check = CUR_PTR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _check$2[ebp], ecx

; 6965 : 	unsigned int cons = ctxt->input->consumed;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _cons$1[ebp], ecx

; 6966 : 
; 6967 : 	GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN15@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN15@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN15@xmlParseEx:

; 6968 :         if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN16@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 33					; 00000021H
	jne	SHORT $LN16@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 91					; 0000005bH
	jne	SHORT $LN16@xmlParseEx

; 6969 : 	    xmlParseConditionalSections(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseConditionalSections
	add	esp, 4

; 6970 : 	} else

	jmp	SHORT $LN17@xmlParseEx
$LN16@xmlParseEx:

; 6971 : 	    xmlParseMarkupDecl(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseMarkupDecl
	add	esp, 4
$LN17@xmlParseEx:

; 6972 :         SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6973 : 
; 6974 : 	if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _check$2[ebp]
	jne	SHORT $LN18@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _cons$1[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jne	SHORT $LN18@xmlParseEx

; 6975 : 	    xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);

	push	0
	push	60					; 0000003cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6976 : 	    break;

	jmp	SHORT $LN3@xmlParseEx
$LN18@xmlParseEx:

; 6977 : 	}
; 6978 :     }

	jmp	$LN2@xmlParseEx
$LN3@xmlParseEx:

; 6979 : 
; 6980 :     if (RAW != 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN1@xmlParseEx

; 6981 : 	xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);

	push	0
	push	60					; 0000003cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN1@xmlParseEx:

; 6982 :     }
; 6983 : 
; 6984 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@xmlParseEx
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN23@xmlParseEx:
	DD	1
	DD	$LN22@xmlParseEx
$LN22@xmlParseEx:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN21@xmlParseEx
$LN21@xmlParseEx:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
_xmlParseExternalSubset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseMisc
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseMisc PROC					; COMDAT

; 10551: xmlParseMisc(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlParseMi:

; 10552:     while ((ctxt->instate != XML_PARSER_EOF) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	je	$LN1@xmlParseMi
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN5@xmlParseMi
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 63					; 0000003fH
	je	$LN4@xmlParseMi
$LN5@xmlParseMi:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN6@xmlParseMi
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 33					; 00000021H
	jne	SHORT $LN6@xmlParseMi
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN6@xmlParseMi
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN4@xmlParseMi
$LN6@xmlParseMi:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN4@xmlParseMi
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN8@xmlParseMi
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN4@xmlParseMi
$LN8@xmlParseMi:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	$LN1@xmlParseMi
$LN4@xmlParseMi:

; 10553:            (((RAW == '<') && (NXT(1) == '?')) ||
; 10554:             (CMP4(CUR_PTR, '<', '!', '-', '-')) ||
; 10555:             IS_BLANK_CH(CUR))) {
; 10556:         if ((RAW == '<') && (NXT(1) == '?')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN9@xmlParseMi
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN9@xmlParseMi

; 10557: 	    xmlParsePI(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParsePI
	add	esp, 4
	jmp	SHORT $LN10@xmlParseMi
$LN9@xmlParseMi:

; 10558: 	} else if (IS_BLANK_CH(CUR)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN13@xmlParseMi
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN14@xmlParseMi
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN13@xmlParseMi
$LN14@xmlParseMi:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN11@xmlParseMi
$LN13@xmlParseMi:

; 10559: 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 10560: 	} else

	jmp	SHORT $LN10@xmlParseMi
$LN11@xmlParseMi:

; 10561: 	    xmlParseComment(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseComment
	add	esp, 4
$LN10@xmlParseMi:

; 10562:     }

	jmp	$LN2@xmlParseMi
$LN1@xmlParseMi:

; 10563: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseMisc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseTextDecl
_TEXT	SEGMENT
_encoding$ = -8						; size = 4
_version$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseTextDecl PROC					; COMDAT

; 6843 : xmlParseTextDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 6844 :     xmlChar *version;
; 6845 :     const xmlChar *encoding;
; 6846 : 
; 6847 :     /*
; 6848 :      * We know that '<?xml' is here.
; 6849 :      */
; 6850 :     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 60					; 0000003cH
	jne	$LN10@xmlParseTe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 63					; 0000003fH
	jne	$LN10@xmlParseTe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 120				; 00000078H
	jne	$LN10@xmlParseTe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 109				; 0000006dH
	jne	$LN10@xmlParseTe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 108				; 0000006cH
	jne	$LN10@xmlParseTe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN4@xmlParseTe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 9
	jl	SHORT $LN13@xmlParseTe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN4@xmlParseTe
$LN13@xmlParseTe:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN10@xmlParseTe
$LN4@xmlParseTe:

; 6851 : 	SKIP(5);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 5
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 5
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 5
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@xmlParseTe
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseTe:
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseTe

; 6852 :     } else {

	jmp	SHORT $LN11@xmlParseTe
$LN10@xmlParseTe:

; 6853 : 	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_STARTED, NULL);

	push	0
	push	56					; 00000038H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6854 : 	return;

	jmp	$LN1@xmlParseTe
$LN11@xmlParseTe:

; 6855 :     }
; 6856 : 
; 6857 :     if (SKIP_BLANKS == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@xmlParseTe

; 6858 : 	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BM@OIPNJGND@Space?5needed?5after?5?8?$DM?$DPxml?8?6@
	push	65					; 00000041H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN15@xmlParseTe:

; 6859 : 		       "Space needed after '<?xml'\n");
; 6860 :     }
; 6861 : 
; 6862 :     /*
; 6863 :      * We may have the VersionInfo here.
; 6864 :      */
; 6865 :     version = xmlParseVersionInfo(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseVersionInfo
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 6866 :     if (version == NULL)

	cmp	DWORD PTR _version$[ebp], 0
	jne	SHORT $LN16@xmlParseTe

; 6867 : 	version = xmlCharStrdup(XML_DEFAULT_VERSION);

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlCharStrdup
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax
	jmp	SHORT $LN17@xmlParseTe
$LN16@xmlParseTe:

; 6868 :     else {
; 6869 : 	if (SKIP_BLANKS == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN17@xmlParseTe

; 6870 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BD@LJKHCJDH@Space?5needed?5here?6@
	push	65					; 00000041H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN17@xmlParseTe:

; 6871 : 		           "Space needed here\n");
; 6872 : 	}
; 6873 :     }
; 6874 :     ctxt->input->version = version;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _version$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 6875 : 
; 6876 :     /*
; 6877 :      * We must have the encoding declaration
; 6878 :      */
; 6879 :     encoding = xmlParseEncodingDecl(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseEncodingDecl
	add	esp, 4
	mov	DWORD PTR _encoding$[ebp], eax

; 6880 :     if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 32			; 00000020H
	jne	SHORT $LN19@xmlParseTe

; 6881 : 	/*
; 6882 : 	 * The XML REC instructs us to stop parsing right here
; 6883 : 	 */
; 6884 :         return;

	jmp	$LN1@xmlParseTe
$LN19@xmlParseTe:

; 6885 :     }
; 6886 :     if ((encoding == NULL) && (ctxt->errNo == XML_ERR_OK)) {

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN20@xmlParseTe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+84], 0
	jne	SHORT $LN20@xmlParseTe

; 6887 : 	xmlFatalErrMsg(ctxt, XML_ERR_MISSING_ENCODING,

	push	OFFSET ??_C@_0CG@OFFEFIEL@Missing?5encoding?5in?5text?5declar@
	push	101					; 00000065H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN20@xmlParseTe:

; 6888 : 		       "Missing encoding in text declaration\n");
; 6889 :     }
; 6890 : 
; 6891 :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 6892 :     if ((RAW == '?') && (NXT(1) == '>')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 63					; 0000003fH
	jne	$LN21@xmlParseTe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN21@xmlParseTe
$LN7@xmlParseTe:

; 6893 :         SKIP(2);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN5@xmlParseTe
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseTe:
	xor	edx, edx
	jne	SHORT $LN7@xmlParseTe

; 6894 :     } else if (RAW == '>') {

	jmp	$LN1@xmlParseTe
$LN21@xmlParseTe:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN24@xmlParseTe

; 6895 :         /* Deprecated old WD ... */
; 6896 : 	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);

	push	0
	push	57					; 00000039H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6897 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 6898 :     } else {

	jmp	SHORT $LN1@xmlParseTe
$LN24@xmlParseTe:

; 6899 : 	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);

	push	0
	push	57					; 00000039H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN8@xmlParseTe:

; 6900 : 	MOVETO_ENDTAG(CUR_PTR);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN9@xmlParseTe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	je	SHORT $LN9@xmlParseTe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	jmp	SHORT $LN8@xmlParseTe
$LN9@xmlParseTe:

; 6901 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4
$LN1@xmlParseTe:

; 6902 :     }
; 6903 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseTextDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseXMLDecl
_TEXT	SEGMENT
_version$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseXMLDecl PROC					; COMDAT

; 10436: xmlParseXMLDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 10437:     xmlChar *version;
; 10438: 
; 10439:     /*
; 10440:      * This value for standalone indicates that the document has an
; 10441:      * XML declaration but it does not have a standalone attribute.
; 10442:      * It will be overwritten later if a standalone attribute is found.
; 10443:      */
; 10444:     ctxt->input->standalone = -2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+52], -2			; fffffffeH
$LN4@xmlParseXM:

; 10445: 
; 10446:     /*
; 10447:      * We know that '<?xml' is here.
; 10448:      */
; 10449:     SKIP(5);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 5
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 5
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 5
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN2@xmlParseXM
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseXM:
	xor	eax, eax
	jne	SHORT $LN4@xmlParseXM

; 10450: 
; 10451:     if (!IS_BLANK_CH(RAW)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN17@xmlParseXM
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN18@xmlParseXM
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN17@xmlParseXM
$LN18@xmlParseXM:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN17@xmlParseXM

; 10452: 	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BM@BPKNILCI@Blank?5needed?5after?5?8?$DM?$DPxml?8?6@
	push	65					; 00000041H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN17@xmlParseXM:

; 10453: 	               "Blank needed after '<?xml'\n");
; 10454:     }
; 10455:     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 10456: 
; 10457:     /*
; 10458:      * We must have the VersionInfo here.
; 10459:      */
; 10460:     version = xmlParseVersionInfo(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseVersionInfo
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 10461:     if (version == NULL) {

	cmp	DWORD PTR _version$[ebp], 0
	jne	SHORT $LN19@xmlParseXM

; 10462: 	xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);

	push	0
	push	96					; 00000060H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10463:     } else {

	jmp	$LN20@xmlParseXM
$LN19@xmlParseXM:

; 10464: 	if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	$LN21@xmlParseXM

; 10465: 	    /*
; 10466: 	     * Changed here for XML-1.0 5th edition
; 10467: 	     */
; 10468: 	    if (ctxt->options & XML_PARSE_OLD10) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 131072				; 00020000H
	je	SHORT $LN22@xmlParseXM

; 10469: 		xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,

	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@MGCDLOCB@Unsupported?5version?5?8?$CFs?8?6@
	push	108					; 0000006cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 10470: 			          "Unsupported version '%s'\n",
; 10471: 			          version);
; 10472: 	    } else {

	jmp	SHORT $LN21@xmlParseXM
$LN22@xmlParseXM:

; 10473: 	        if ((version[0] == '1') && ((version[1] == '.'))) {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _version$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 49					; 00000031H
	jne	SHORT $LN24@xmlParseXM
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _version$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN24@xmlParseXM

; 10474: 		    xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,

	push	0
	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@MGCDLOCB@Unsupported?5version?5?8?$CFs?8?6@
	push	97					; 00000061H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H

; 10475: 		                  "Unsupported version '%s'\n",
; 10476: 				  version, NULL);
; 10477: 		} else {

	jmp	SHORT $LN21@xmlParseXM
$LN24@xmlParseXM:

; 10478: 		    xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,

	mov	edx, DWORD PTR _version$[ebp]
	push	edx
	push	OFFSET ??_C@_0BK@MGCDLOCB@Unsupported?5version?5?8?$CFs?8?6@
	push	108					; 0000006cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN21@xmlParseXM:

; 10479: 				      "Unsupported version '%s'\n",
; 10480: 				      version);
; 10481: 		}
; 10482: 	    }
; 10483: 	}
; 10484: 	if (ctxt->version != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN26@xmlParseXM

; 10485: 	    xmlFree((void *) ctxt->version);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@xmlParseXM:

; 10486: 	ctxt->version = version;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _version$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN20@xmlParseXM:

; 10487:     }
; 10488: 
; 10489:     /*
; 10490:      * We may have the encoding declaration
; 10491:      */
; 10492:     if (!IS_BLANK_CH(RAW)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	$LN27@xmlParseXM
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN28@xmlParseXM
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	$LN27@xmlParseXM
$LN28@xmlParseXM:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	$LN27@xmlParseXM

; 10493:         if ((RAW == '?') && (NXT(1) == '>')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 63					; 0000003fH
	jne	$LN29@xmlParseXM
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN29@xmlParseXM
$LN7@xmlParseXM:

; 10494: 	    SKIP(2);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN5@xmlParseXM
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseXM:
	xor	edx, edx
	jne	SHORT $LN7@xmlParseXM

; 10495: 	    return;

	jmp	$LN1@xmlParseXM
$LN29@xmlParseXM:

; 10496: 	}
; 10497: 	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");

	push	OFFSET ??_C@_0BD@KLGEONFL@Blank?5needed?5here?6@
	push	65					; 00000041H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN27@xmlParseXM:

; 10498:     }
; 10499:     xmlParseEncodingDecl(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseEncodingDecl
	add	esp, 4

; 10500:     if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+84], 32			; 00000020H
	je	SHORT $LN32@xmlParseXM
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN31@xmlParseXM
$LN32@xmlParseXM:

; 10501:          (ctxt->instate == XML_PARSER_EOF)) {
; 10502: 	/*
; 10503: 	 * The XML REC instructs us to stop parsing right here
; 10504: 	 */
; 10505:         return;

	jmp	$LN1@xmlParseXM
$LN31@xmlParseXM:

; 10506:     }
; 10507: 
; 10508:     /*
; 10509:      * We may have the standalone status.
; 10510:      */
; 10511:     if ((ctxt->input->encoding != NULL) && (!IS_BLANK_CH(RAW))) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx+44], 0
	je	$LN33@xmlParseXM
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	$LN33@xmlParseXM
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN34@xmlParseXM
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	$LN33@xmlParseXM
$LN34@xmlParseXM:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	$LN33@xmlParseXM

; 10512:         if ((RAW == '?') && (NXT(1) == '>')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 63					; 0000003fH
	jne	$LN35@xmlParseXM
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN35@xmlParseXM
$LN10@xmlParseXM:

; 10513: 	    SKIP(2);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN8@xmlParseXM
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN8@xmlParseXM:
	xor	edx, edx
	jne	SHORT $LN10@xmlParseXM

; 10514: 	    return;

	jmp	$LN1@xmlParseXM
$LN35@xmlParseXM:

; 10515: 	}
; 10516: 	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");

	push	OFFSET ??_C@_0BD@KLGEONFL@Blank?5needed?5here?6@
	push	65					; 00000041H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN33@xmlParseXM:

; 10517:     }
; 10518: 
; 10519:     /*
; 10520:      * We can grow the input buffer freely at that point
; 10521:      */
; 10522:     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN37@xmlParseXM
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN37@xmlParseXM
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN37@xmlParseXM:

; 10523: 
; 10524:     SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 10525:     ctxt->input->standalone = xmlParseSDDecl(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseSDDecl
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+52], eax

; 10526: 
; 10527:     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 10528:     if ((RAW == '?') && (NXT(1) == '>')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 63					; 0000003fH
	jne	$LN38@xmlParseXM
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN38@xmlParseXM
$LN13@xmlParseXM:

; 10529:         SKIP(2);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN11@xmlParseXM
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN11@xmlParseXM:
	xor	edx, edx
	jne	SHORT $LN13@xmlParseXM

; 10530:     } else if (RAW == '>') {

	jmp	$LN1@xmlParseXM
$LN38@xmlParseXM:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN41@xmlParseXM

; 10531:         /* Deprecated old WD ... */
; 10532: 	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);

	push	0
	push	57					; 00000039H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10533: 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 10534:     } else {

	jmp	SHORT $LN1@xmlParseXM
$LN41@xmlParseXM:

; 10535: 	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);

	push	0
	push	57					; 00000039H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN14@xmlParseXM:

; 10536: 	MOVETO_ENDTAG(CUR_PTR);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN15@xmlParseXM
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	je	SHORT $LN15@xmlParseXM
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	jmp	SHORT $LN14@xmlParseXM
$LN15@xmlParseXM:

; 10537: 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4
$LN1@xmlParseXM:

; 10538:     }
; 10539: }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseXMLDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseSDDecl
_TEXT	SEGMENT
_standalone$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_xmlParseSDDecl PROC					; COMDAT

; 10374: xmlParseSDDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 10375:     int standalone = -2;

	mov	DWORD PTR _standalone$[ebp], -2		; fffffffeH

; 10376: 
; 10377:     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 10378:     if (CMP10(CUR_PTR, 's', 't', 'a', 'n', 'd', 'a', 'l', 'o', 'n', 'e')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 115				; 00000073H
	jne	$LN17@xmlParseSD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 116				; 00000074H
	jne	$LN17@xmlParseSD
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 97					; 00000061H
	jne	$LN17@xmlParseSD
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 110				; 0000006eH
	jne	$LN17@xmlParseSD
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 100				; 00000064H
	jne	$LN17@xmlParseSD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 97					; 00000061H
	jne	$LN17@xmlParseSD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 108				; 0000006cH
	jne	$LN17@xmlParseSD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 111				; 0000006fH
	jne	$LN17@xmlParseSD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 110				; 0000006eH
	jne	$LN17@xmlParseSD
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 9
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 101				; 00000065H
	jne	$LN17@xmlParseSD
$LN4@xmlParseSD:

; 10379: 	SKIP(10);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@xmlParseSD
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseSD:
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseSD

; 10380:         SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 10381: 	if (RAW != '=') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN19@xmlParseSD

; 10382: 	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);

	push	0
	push	75					; 0000004bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10383: 	    return(standalone);

	mov	eax, DWORD PTR _standalone$[ebp]
	jmp	$LN1@xmlParseSD
$LN19@xmlParseSD:

; 10384:         }
; 10385: 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 10386: 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 10387:         if (RAW == '\''){

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	$LN20@xmlParseSD

; 10388: 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 10389: 	    if ((RAW == 'n') && (NXT(1) == 'o')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 110				; 0000006eH
	jne	$LN22@xmlParseSD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 111				; 0000006fH
	jne	SHORT $LN22@xmlParseSD

; 10390: 	        standalone = 0;

	mov	DWORD PTR _standalone$[ebp], 0
$LN7@xmlParseSD:

; 10391:                 SKIP(2);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@xmlParseSD
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseSD:
	xor	ecx, ecx
	jne	SHORT $LN7@xmlParseSD

; 10392: 	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&

	jmp	$LN23@xmlParseSD
$LN22@xmlParseSD:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 121				; 00000079H
	jne	$LN25@xmlParseSD
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 101				; 00000065H
	jne	$LN25@xmlParseSD
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 115				; 00000073H
	jne	SHORT $LN25@xmlParseSD

; 10393: 	               (NXT(2) == 's')) {
; 10394: 	        standalone = 1;

	mov	DWORD PTR _standalone$[ebp], 1
$LN10@xmlParseSD:

; 10395: 		SKIP(3);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN8@xmlParseSD
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN8@xmlParseSD:
	xor	edx, edx
	jne	SHORT $LN10@xmlParseSD

; 10396:             } else {

	jmp	SHORT $LN23@xmlParseSD
$LN25@xmlParseSD:

; 10397: 		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);

	push	0
	push	78					; 0000004eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN23@xmlParseSD:

; 10398: 	    }
; 10399: 	    if (RAW != '\'') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	je	SHORT $LN28@xmlParseSD

; 10400: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);

	push	0
	push	34					; 00000022H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10401: 	    } else

	jmp	SHORT $LN29@xmlParseSD
$LN28@xmlParseSD:

; 10402: 	        NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4
$LN29@xmlParseSD:

; 10403: 	} else if (RAW == '"'){

	jmp	$LN17@xmlParseSD
$LN20@xmlParseSD:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	$LN30@xmlParseSD

; 10404: 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 10405: 	    if ((RAW == 'n') && (NXT(1) == 'o')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 110				; 0000006eH
	jne	$LN32@xmlParseSD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 111				; 0000006fH
	jne	SHORT $LN32@xmlParseSD

; 10406: 	        standalone = 0;

	mov	DWORD PTR _standalone$[ebp], 0
$LN13@xmlParseSD:

; 10407: 		SKIP(2);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN11@xmlParseSD
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN11@xmlParseSD:
	xor	ecx, ecx
	jne	SHORT $LN13@xmlParseSD

; 10408: 	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&

	jmp	$LN33@xmlParseSD
$LN32@xmlParseSD:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 121				; 00000079H
	jne	$LN35@xmlParseSD
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 101				; 00000065H
	jne	$LN35@xmlParseSD
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 115				; 00000073H
	jne	SHORT $LN35@xmlParseSD

; 10409: 	               (NXT(2) == 's')) {
; 10410: 	        standalone = 1;

	mov	DWORD PTR _standalone$[ebp], 1
$LN16@xmlParseSD:

; 10411:                 SKIP(3);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN14@xmlParseSD
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN14@xmlParseSD:
	xor	edx, edx
	jne	SHORT $LN16@xmlParseSD

; 10412:             } else {

	jmp	SHORT $LN33@xmlParseSD
$LN35@xmlParseSD:

; 10413: 		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);

	push	0
	push	78					; 0000004eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN33@xmlParseSD:

; 10414: 	    }
; 10415: 	    if (RAW != '"') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN38@xmlParseSD

; 10416: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);

	push	0
	push	34					; 00000022H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10417: 	    } else

	jmp	SHORT $LN39@xmlParseSD
$LN38@xmlParseSD:

; 10418: 	        NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4
$LN39@xmlParseSD:

; 10419: 	} else {

	jmp	SHORT $LN17@xmlParseSD
$LN30@xmlParseSD:

; 10420: 	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);

	push	0
	push	33					; 00000021H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN17@xmlParseSD:

; 10421:         }
; 10422:     }
; 10423:     return(standalone);

	mov	eax, DWORD PTR _standalone$[ebp]
$LN1@xmlParseSD:

; 10424: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseSDDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEncodingDecl
_TEXT	SEGMENT
_handler$1 = -8						; size = 4
_encoding$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseEncodingDecl PROC				; COMDAT

; 10242: xmlParseEncodingDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 10243:     xmlChar *encoding = NULL;

	mov	DWORD PTR _encoding$[ebp], 0

; 10244: 
; 10245:     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 10246:     if (CMP8(CUR_PTR, 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 101				; 00000065H
	jne	$LN5@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 110				; 0000006eH
	jne	$LN5@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 99					; 00000063H
	jne	$LN5@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 111				; 0000006fH
	jne	$LN5@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 100				; 00000064H
	jne	$LN5@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 105				; 00000069H
	jne	$LN5@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 110				; 0000006eH
	jne	$LN5@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 103				; 00000067H
	jne	$LN5@xmlParseEn
$LN4@xmlParseEn:

; 10247: 	SKIP(8);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 8
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 8
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN2@xmlParseEn
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEn:
	xor	edx, edx
	jne	SHORT $LN4@xmlParseEn

; 10248: 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 10249: 	if (RAW != '=') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $LN7@xmlParseEn

; 10250: 	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);

	push	0
	push	75					; 0000004bH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10251: 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN7@xmlParseEn:

; 10252:         }
; 10253: 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 10254: 	SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 10255: 	if (RAW == '"') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN8@xmlParseEn

; 10256: 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 10257: 	    encoding = xmlParseEncName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseEncName
	add	esp, 4
	mov	DWORD PTR _encoding$[ebp], eax

; 10258: 	    if (RAW != '"') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	je	SHORT $LN10@xmlParseEn

; 10259: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);

	push	0
	push	34					; 00000022H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10260: 		xmlFree((xmlChar *) encoding);

	mov	esi, esp
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10261: 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn

; 10262: 	    } else

	jmp	SHORT $LN11@xmlParseEn
$LN10@xmlParseEn:

; 10263: 	        NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4
$LN11@xmlParseEn:

; 10264: 	} else if (RAW == '\''){

	jmp	$LN9@xmlParseEn
$LN8@xmlParseEn:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN12@xmlParseEn

; 10265: 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 10266: 	    encoding = xmlParseEncName(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseEncName
	add	esp, 4
	mov	DWORD PTR _encoding$[ebp], eax

; 10267: 	    if (RAW != '\'') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN14@xmlParseEn

; 10268: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);

	push	0
	push	34					; 00000022H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10269: 		xmlFree((xmlChar *) encoding);

	mov	esi, esp
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10270: 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn

; 10271: 	    } else

	jmp	SHORT $LN15@xmlParseEn
$LN14@xmlParseEn:

; 10272: 	        NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4
$LN15@xmlParseEn:

; 10273: 	} else {

	jmp	SHORT $LN9@xmlParseEn
$LN12@xmlParseEn:

; 10274: 	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);

	push	0
	push	33					; 00000021H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN9@xmlParseEn:

; 10275: 	}
; 10276: 
; 10277:         /*
; 10278:          * Non standard parsing, allowing the user to ignore encoding
; 10279:          */
; 10280:         if (ctxt->options & XML_PARSE_IGNORE_ENC) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	and	eax, 2097152				; 00200000H
	je	SHORT $LN16@xmlParseEn

; 10281: 	    xmlFree((xmlChar *) encoding);

	mov	esi, esp
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10282:             return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN16@xmlParseEn:

; 10283: 	}
; 10284: 
; 10285: 	/*
; 10286: 	 * UTF-16 encoding stwich has already taken place at this stage,
; 10287: 	 * more over the little-endian/big-endian selection is already done
; 10288: 	 */
; 10289:         if ((encoding != NULL) &&

	cmp	DWORD PTR _encoding$[ebp], 0
	je	$LN17@xmlParseEn
	push	OFFSET ??_C@_06KNDPGIKI@UTF?916@
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlParseEn
	push	OFFSET ??_C@_05MNCHLHCA@UTF16@
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@xmlParseEn
$LN19@xmlParseEn:

; 10290: 	    ((!xmlStrcasecmp(encoding, BAD_CAST "UTF-16")) ||
; 10291: 	     (!xmlStrcasecmp(encoding, BAD_CAST "UTF16")))) {
; 10292: 	    /*
; 10293: 	     * If no encoding was passed to the parser, that we are
; 10294: 	     * using UTF-16 and no decoder is present i.e. the
; 10295: 	     * document is apparently UTF-8 compatible, then raise an
; 10296: 	     * encoding mismatch fatal error
; 10297: 	     */
; 10298: 	    if ((ctxt->encoding == NULL) &&
; 10299: 	        (ctxt->input->buf != NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN20@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN20@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN20@xmlParseEn

; 10300: 	        (ctxt->input->buf->encoder == NULL)) {
; 10301: 		xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,

	push	OFFSET ??_C@_0DA@MEEPFAA@Document?5labelled?5UTF?916?5but?5ha@
	push	81					; 00000051H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN20@xmlParseEn:

; 10302: 		  "Document labelled UTF-16 but has UTF-8 content\n");
; 10303: 	    }
; 10304: 	    if (ctxt->encoding != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN21@xmlParseEn

; 10305: 		xmlFree((xmlChar *) ctxt->encoding);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@xmlParseEn:

; 10306: 	    ctxt->encoding = encoding;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _encoding$[ebp]
	mov	DWORD PTR [edx+24], eax

; 10307: 	}

	jmp	$LN5@xmlParseEn
$LN17@xmlParseEn:

; 10308: 	/*
; 10309: 	 * UTF-8 encoding is handled natively
; 10310: 	 */
; 10311:         else if ((encoding != NULL) &&

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN22@xmlParseEn
	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@xmlParseEn
	push	OFFSET ??_C@_04OOMJJNCF@UTF8@
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	call	_xmlStrcasecmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@xmlParseEn
$LN24@xmlParseEn:

; 10312: 	    ((!xmlStrcasecmp(encoding, BAD_CAST "UTF-8")) ||
; 10313: 	     (!xmlStrcasecmp(encoding, BAD_CAST "UTF8")))) {
; 10314: 	    if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN25@xmlParseEn

; 10315: 		xmlFree((xmlChar *) ctxt->encoding);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN25@xmlParseEn:

; 10316: 	    ctxt->encoding = encoding;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _encoding$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 10317: 	}

	jmp	$LN5@xmlParseEn
$LN22@xmlParseEn:

; 10318: 	else if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	$LN5@xmlParseEn

; 10319: 	    xmlCharEncodingHandlerPtr handler;
; 10320: 
; 10321: 	    if (ctxt->input->encoding != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN27@xmlParseEn

; 10322: 		xmlFree((xmlChar *) ctxt->input->encoding);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN27@xmlParseEn:

; 10323: 	    ctxt->input->encoding = encoding;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _encoding$[ebp]
	mov	DWORD PTR [edx+44], eax

; 10324: 
; 10325:             handler = xmlFindCharEncodingHandler((const char *) encoding);

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$1[ebp], eax

; 10326: 	    if (handler != NULL) {

	cmp	DWORD PTR _handler$1[ebp], 0
	je	SHORT $LN28@xmlParseEn

; 10327: 		if (xmlSwitchToEncoding(ctxt, handler) < 0) {

	mov	edx, DWORD PTR _handler$1[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSwitchToEncoding
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN30@xmlParseEn

; 10328: 		    /* failed to convert */
; 10329: 		    ctxt->errNo = XML_ERR_UNSUPPORTED_ENCODING;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+84], 32			; 00000020H

; 10330: 		    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseEn
$LN30@xmlParseEn:

; 10331: 		}
; 10332: 	    } else {

	jmp	SHORT $LN5@xmlParseEn
$LN28@xmlParseEn:

; 10333: 		xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	push	OFFSET ??_C@_0BJ@FCHADMKI@Unsupported?5encoding?5?$CFs?6@
	push	32					; 00000020H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 10334: 			"Unsupported encoding %s\n", encoding);
; 10335: 		return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseEn
$LN5@xmlParseEn:

; 10336: 	    }
; 10337: 	}
; 10338:     }
; 10339:     return(encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
$LN1@xmlParseEn:

; 10340: }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseEncodingDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEncName
_TEXT	SEGMENT
_tmp$1 = -20						; size = 4
_cur$ = -13						; size = 1
_size$ = -12						; size = 4
_len$ = -8						; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseEncName PROC					; COMDAT

; 10177: xmlParseEncName(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 10178:     xmlChar *buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 10179:     int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 10180:     int size = 10;

	mov	DWORD PTR _size$[ebp], 10		; 0000000aH

; 10181:     xmlChar cur;
; 10182: 
; 10183:     cur = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _cur$[ebp], al

; 10184:     if (((cur >= 'a') && (cur <= 'z')) ||

	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN7@xmlParseEn
	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 122				; 0000007aH
	jle	SHORT $LN6@xmlParseEn
$LN7@xmlParseEn:
	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 65					; 00000041H
	jl	$LN4@xmlParseEn
	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 90					; 0000005aH
	jg	$LN4@xmlParseEn
$LN6@xmlParseEn:

; 10185:         ((cur >= 'A') && (cur <= 'Z'))) {
; 10186: 	buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	mov	esi, esp
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$[ebp], eax

; 10187: 	if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN8@xmlParseEn

; 10188: 	    xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 10189: 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN8@xmlParseEn:

; 10190: 	}
; 10191: 
; 10192: 	buf[len++] = cur;

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	dl, BYTE PTR _cur$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 10193: 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 10194: 	cur = CUR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _cur$[ebp], dl
$LN2@xmlParseEn:

; 10195: 	while (((cur >= 'a') && (cur <= 'z')) ||
; 10196: 	       ((cur >= 'A') && (cur <= 'Z')) ||
; 10197: 	       ((cur >= '0') && (cur <= '9')) ||
; 10198: 	       (cur == '.') || (cur == '_') ||

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN10@xmlParseEn
	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 122				; 0000007aH
	jle	SHORT $LN9@xmlParseEn
$LN10@xmlParseEn:
	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN11@xmlParseEn
	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 90					; 0000005aH
	jle	SHORT $LN9@xmlParseEn
$LN11@xmlParseEn:
	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN12@xmlParseEn
	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN9@xmlParseEn
$LN12@xmlParseEn:
	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN9@xmlParseEn
	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 95					; 0000005fH
	je	SHORT $LN9@xmlParseEn
	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 45					; 0000002dH
	jne	$LN3@xmlParseEn
$LN9@xmlParseEn:

; 10199: 	       (cur == '-')) {
; 10200: 	    if (len + 1 >= size) {

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _size$[ebp]
	jl	SHORT $LN13@xmlParseEn

; 10201: 	        xmlChar *tmp;
; 10202: 
; 10203: 		size *= 2;

	mov	ecx, DWORD PTR _size$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _size$[ebp], ecx

; 10204: 		tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	mov	esi, esp
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 10205: 		if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN14@xmlParseEn

; 10206: 		    xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 10207: 		    xmlFree(buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10208: 		    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN14@xmlParseEn:

; 10209: 		}
; 10210: 		buf = tmp;

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _buf$[ebp], eax
$LN13@xmlParseEn:

; 10211: 	    }
; 10212: 	    buf[len++] = cur;

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	dl, BYTE PTR _cur$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 10213: 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 10214: 	    cur = CUR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _cur$[ebp], dl

; 10215: 	    if (cur == 0) {

	movzx	eax, BYTE PTR _cur$[ebp]
	test	eax, eax
	jne	$LN15@xmlParseEn

; 10216: 	        SHRINK;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN16@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN16@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 500				; 000001f4H
	jge	SHORT $LN16@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSHRINK
	add	esp, 4
$LN16@xmlParseEn:

; 10217: 		GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN17@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN17@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN17@xmlParseEn:

; 10218: 		cur = CUR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _cur$[ebp], dl
$LN15@xmlParseEn:

; 10219: 	    }
; 10220:         }

	jmp	$LN2@xmlParseEn
$LN3@xmlParseEn:

; 10221: 	buf[len] = 0;

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0

; 10222:     } else {

	jmp	SHORT $LN5@xmlParseEn
$LN4@xmlParseEn:

; 10223: 	xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);

	push	0
	push	79					; 0000004fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN5@xmlParseEn:

; 10224:     }
; 10225:     return(buf);

	mov	eax, DWORD PTR _buf$[ebp]
$LN1@xmlParseEn:

; 10226: }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseEncName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseVersionInfo
_TEXT	SEGMENT
_version$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseVersionInfo PROC				; COMDAT

; 10133: xmlParseVersionInfo(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 10134:     xmlChar *version = NULL;

	mov	DWORD PTR _version$[ebp], 0

; 10135: 
; 10136:     if (CMP7(CUR_PTR, 'v', 'e', 'r', 's', 'i', 'o', 'n')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 118				; 00000076H
	jne	$LN5@xmlParseVe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 101				; 00000065H
	jne	$LN5@xmlParseVe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 114				; 00000072H
	jne	$LN5@xmlParseVe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 115				; 00000073H
	jne	$LN5@xmlParseVe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 105				; 00000069H
	jne	$LN5@xmlParseVe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 111				; 0000006fH
	jne	$LN5@xmlParseVe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 110				; 0000006eH
	jne	$LN5@xmlParseVe
$LN4@xmlParseVe:

; 10137: 	SKIP(7);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 7
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 7
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 7
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@xmlParseVe
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseVe:
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseVe

; 10138: 	SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 10139: 	if (RAW != '=') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN7@xmlParseVe

; 10140: 	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);

	push	0
	push	75					; 0000004bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10141: 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseVe
$LN7@xmlParseVe:

; 10142:         }
; 10143: 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 10144: 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 10145: 	if (RAW == '"') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN8@xmlParseVe

; 10146: 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 10147: 	    version = xmlParseVersionNum(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseVersionNum
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 10148: 	    if (RAW != '"') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN10@xmlParseVe

; 10149: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);

	push	0
	push	34					; 00000022H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10150: 	    } else

	jmp	SHORT $LN11@xmlParseVe
$LN10@xmlParseVe:

; 10151: 	        NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4
$LN11@xmlParseVe:

; 10152: 	} else if (RAW == '\''){

	jmp	SHORT $LN5@xmlParseVe
$LN8@xmlParseVe:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $LN12@xmlParseVe

; 10153: 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 10154: 	    version = xmlParseVersionNum(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseVersionNum
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 10155: 	    if (RAW != '\'') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	je	SHORT $LN14@xmlParseVe

; 10156: 		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);

	push	0
	push	34					; 00000022H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10157: 	    } else

	jmp	SHORT $LN15@xmlParseVe
$LN14@xmlParseVe:

; 10158: 	        NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4
$LN15@xmlParseVe:

; 10159: 	} else {

	jmp	SHORT $LN5@xmlParseVe
$LN12@xmlParseVe:

; 10160: 	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);

	push	0
	push	33					; 00000021H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN5@xmlParseVe:

; 10161: 	}
; 10162:     }
; 10163:     return(version);

	mov	eax, DWORD PTR _version$[ebp]
$LN1@xmlParseVe:

; 10164: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseVersionInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseVersionNum
_TEXT	SEGMENT
_tmp$1 = -20						; size = 4
_cur$ = -13						; size = 1
_size$ = -12						; size = 4
_len$ = -8						; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseVersionNum PROC				; COMDAT

; 10072: xmlParseVersionNum(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 10073:     xmlChar *buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 10074:     int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 10075:     int size = 10;

	mov	DWORD PTR _size$[ebp], 10		; 0000000aH

; 10076:     xmlChar cur;
; 10077: 
; 10078:     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$[ebp], eax

; 10079:     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN4@xmlParseVe

; 10080: 	xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 10081: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseVe
$LN4@xmlParseVe:

; 10082:     }
; 10083:     cur = CUR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _cur$[ebp], dl

; 10084:     if (!((cur >= '0') && (cur <= '9'))) {

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN6@xmlParseVe
	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 57					; 00000039H
	jle	SHORT $LN5@xmlParseVe
$LN6@xmlParseVe:

; 10085: 	xmlFree(buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10086: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseVe
$LN5@xmlParseVe:

; 10087:     }
; 10088:     buf[len++] = cur;

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _cur$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 10089:     NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 10090:     cur=CUR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cur$[ebp], cl

; 10091:     if (cur != '.') {

	movzx	edx, BYTE PTR _cur$[ebp]
	cmp	edx, 46					; 0000002eH
	je	SHORT $LN7@xmlParseVe

; 10092: 	xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10093: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseVe
$LN7@xmlParseVe:

; 10094:     }
; 10095:     buf[len++] = cur;

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	dl, BYTE PTR _cur$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 10096:     NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 10097:     cur=CUR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _cur$[ebp], dl
$LN2@xmlParseVe:

; 10098:     while ((cur >= '0') && (cur <= '9')) {

	movzx	eax, BYTE PTR _cur$[ebp]
	cmp	eax, 48					; 00000030H
	jl	$LN3@xmlParseVe
	movzx	ecx, BYTE PTR _cur$[ebp]
	cmp	ecx, 57					; 00000039H
	jg	$LN3@xmlParseVe

; 10099: 	if (len + 1 >= size) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	cmp	edx, DWORD PTR _size$[ebp]
	jl	SHORT $LN8@xmlParseVe

; 10100: 	    xmlChar *tmp;
; 10101: 
; 10102: 	    size *= 2;

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 10103: 	    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	mov	esi, esp
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 10104: 	    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN9@xmlParseVe

; 10105: 	        xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10106: 		xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 10107: 		return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseVe
$LN9@xmlParseVe:

; 10108: 	    }
; 10109: 	    buf = tmp;

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _buf$[ebp], edx
$LN8@xmlParseVe:

; 10110: 	}
; 10111: 	buf[len++] = cur;

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _cur$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 10112: 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 10113: 	cur=CUR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cur$[ebp], cl

; 10114:     }

	jmp	$LN2@xmlParseVe
$LN3@xmlParseVe:

; 10115:     buf[len] = 0;

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 0

; 10116:     return(buf);

	mov	eax, DWORD PTR _buf$[ebp]
$LN1@xmlParseVe:

; 10117: }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseVersionNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElement
_TEXT	SEGMENT
_nsNr$ = -80						; size = 4
_ret$ = -76						; size = 4
_tlen$ = -68						; size = 4
_line$ = -60						; size = 4
_node_info$ = -52					; size = 20
_URI$ = -24						; size = 4
_prefix$ = -12						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseElement PROC					; COMDAT

; 9894 : xmlParseElement(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 9895 :     const xmlChar *name;
; 9896 :     const xmlChar *prefix = NULL;

	mov	DWORD PTR _prefix$[ebp], 0

; 9897 :     const xmlChar *URI = NULL;

	mov	DWORD PTR _URI$[ebp], 0

; 9898 :     xmlParserNodeInfo node_info;
; 9899 :     int line, tlen = 0;

	mov	DWORD PTR _tlen$[ebp], 0

; 9900 :     xmlNodePtr ret;
; 9901 :     int nsNr = ctxt->nsNr;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	mov	DWORD PTR _nsNr$[ebp], ecx

; 9902 : 
; 9903 :     if (((unsigned int) ctxt->nameNr > xmlParserMaxDepth) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+188]
	cmp	eax, DWORD PTR _xmlParserMaxDepth
	jbe	SHORT $LN5@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN5@xmlParseEl

; 9904 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 9905 : 	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,

	mov	eax, DWORD PTR _xmlParserMaxDepth
	push	eax
	push	OFFSET ??_C@_0DL@HADOBDDE@Excessive?5depth?5in?5document?3?5?$CFd@
	push	1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 9906 : 		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
; 9907 : 			  xmlParserMaxDepth);
; 9908 : 	xmlHaltParser(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlHaltParser
	add	esp, 4

; 9909 : 	return;

	jmp	$LN1@xmlParseEl
$LN5@xmlParseEl:

; 9910 :     }
; 9911 : 
; 9912 :     /* Capture start position */
; 9913 :     if (ctxt->record_info) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN6@xmlParseEl

; 9914 :         node_info.begin_pos = ctxt->input->consumed +

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _node_info$[ebp+4], ecx

; 9915 :                           (CUR_PTR - ctxt->input->base);
; 9916 : 	node_info.begin_line = ctxt->input->line;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _node_info$[ebp+8], ecx
$LN6@xmlParseEl:

; 9917 :     }
; 9918 : 
; 9919 :     if (ctxt->spaceNr == 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+236], 0
	jne	SHORT $LN7@xmlParseEl

; 9920 : 	spacePush(ctxt, -1);

	push	-1
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_spacePush
	add	esp, 8
	jmp	SHORT $LN8@xmlParseEl
$LN7@xmlParseEl:

; 9921 :     else if (*ctxt->space == -2)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	cmp	DWORD PTR [edx], -2			; fffffffeH
	jne	SHORT $LN9@xmlParseEl

; 9922 : 	spacePush(ctxt, -1);

	push	-1
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_spacePush
	add	esp, 8
	jmp	SHORT $LN8@xmlParseEl
$LN9@xmlParseEl:

; 9923 :     else
; 9924 : 	spacePush(ctxt, *ctxt->space);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_spacePush
	add	esp, 8
$LN8@xmlParseEl:

; 9925 : 
; 9926 :     line = ctxt->input->line;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _line$[ebp], ecx

; 9927 : #ifdef LIBXML_SAX1_ENABLED
; 9928 :     if (ctxt->sax2)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+324], 0
	je	SHORT $LN11@xmlParseEl

; 9929 : #endif /* LIBXML_SAX1_ENABLED */
; 9930 :         name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);

	lea	eax, DWORD PTR _tlen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	lea	edx, DWORD PTR _prefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseStartTag2
	add	esp, 16					; 00000010H
	mov	DWORD PTR _name$[ebp], eax
	jmp	SHORT $LN12@xmlParseEl
$LN11@xmlParseEl:

; 9931 : #ifdef LIBXML_SAX1_ENABLED
; 9932 :     else
; 9933 : 	name = xmlParseStartTag(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseStartTag
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax
$LN12@xmlParseEl:

; 9934 : #endif /* LIBXML_SAX1_ENABLED */
; 9935 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN13@xmlParseEl

; 9936 : 	return;

	jmp	$LN1@xmlParseEl
$LN13@xmlParseEl:

; 9937 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN14@xmlParseEl

; 9938 : 	spacePop(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_spacePop
	add	esp, 4

; 9939 :         return;

	jmp	$LN1@xmlParseEl
$LN14@xmlParseEl:

; 9940 :     }
; 9941 :     namePush(ctxt, name);

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_namePush
	add	esp, 8

; 9942 :     ret = ctxt->node;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _ret$[ebp], ecx

; 9943 : 
; 9944 : #ifdef LIBXML_VALID_ENABLED
; 9945 :     /*
; 9946 :      * [ VC: Root Element Type ]
; 9947 :      * The Name in the document type declaration must match the element
; 9948 :      * type of the root element.
; 9949 :      */
; 9950 :     if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
; 9951 :         ctxt->node && (ctxt->node == ctxt->myDoc->children))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+104], 0
	je	SHORT $LN15@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN15@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN15@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN15@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+52]
	cmp	eax, DWORD PTR [ecx+12]
	jne	SHORT $LN15@xmlParseEl

; 9952 :         ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	add	eax, 108				; 0000006cH
	push	eax
	call	_xmlValidateRoot
	add	esp, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	and	eax, DWORD PTR [ecx+100]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+100], eax
$LN15@xmlParseEl:

; 9953 : #endif /* LIBXML_VALID_ENABLED */
; 9954 : 
; 9955 :     /*
; 9956 :      * Check for an Empty Element.
; 9957 :      */
; 9958 :     if ((RAW == '/') && (NXT(1) == '>')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	$LN16@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 62					; 0000003eH
	jne	$LN16@xmlParseEl
$LN4@xmlParseEl:

; 9959 :         SKIP(2);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@xmlParseEl
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEl:
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseEl

; 9960 : 	if (ctxt->sax2) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+324], 0
	je	SHORT $LN18@xmlParseEl

; 9961 : 	    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN20@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+120], 0
	je	SHORT $LN20@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN20@xmlParseEl

; 9962 : 		(!ctxt->disableSAX))
; 9963 : 		ctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);

	mov	esi, esp
	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+120]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@xmlParseEl:

; 9964 : #ifdef LIBXML_SAX1_ENABLED
; 9965 : 	} else {

	jmp	SHORT $LN19@xmlParseEl
$LN18@xmlParseEl:

; 9966 : 	    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN19@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+60], 0
	je	SHORT $LN19@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN19@xmlParseEl

; 9967 : 		(!ctxt->disableSAX))
; 9968 : 		ctxt->sax->endElement(ctxt->userData, name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+60]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@xmlParseEl:

; 9969 : #endif /* LIBXML_SAX1_ENABLED */
; 9970 : 	}
; 9971 : 	namePop(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_namePop
	add	esp, 4

; 9972 : 	spacePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_spacePop
	add	esp, 4

; 9973 : 	if (nsNr != ctxt->nsNr)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _nsNr$[ebp]
	cmp	ecx, DWORD PTR [eax+328]
	je	SHORT $LN22@xmlParseEl

; 9974 : 	    nsPop(ctxt, ctxt->nsNr - nsNr);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	sub	eax, DWORD PTR _nsNr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_nsPop
	add	esp, 8
$LN22@xmlParseEl:

; 9975 : 	if ( ret != NULL && ctxt->record_info ) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN23@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN23@xmlParseEl

; 9976 : 	   node_info.end_pos = ctxt->input->consumed +

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _node_info$[ebp+12], eax

; 9977 : 			      (CUR_PTR - ctxt->input->base);
; 9978 : 	   node_info.end_line = ctxt->input->line;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _node_info$[ebp+16], eax

; 9979 : 	   node_info.node = ret;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _node_info$[ebp], ecx

; 9980 : 	   xmlParserAddNodeInfo(ctxt, &node_info);

	lea	edx, DWORD PTR _node_info$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParserAddNodeInfo
	add	esp, 8
$LN23@xmlParseEl:

; 9981 : 	}
; 9982 : 	return;

	jmp	$LN1@xmlParseEl
$LN16@xmlParseEl:

; 9983 :     }
; 9984 :     if (RAW == '>') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 62					; 0000003eH
	jne	SHORT $LN24@xmlParseEl

; 9985 :         NEXT1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN26@xmlParseEl
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN26@xmlParseEl:

; 9986 :     } else {

	jmp	$LN25@xmlParseEl
$LN24@xmlParseEl:

; 9987 :         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,

	push	0
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CL@LKDFGLKB@Couldn?8t?5find?5end?5of?5Start?5Tag?5@
	push	73					; 00000049H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStrIntStr
	add	esp, 24					; 00000018H

; 9988 : 		     "Couldn't find end of Start Tag %s line %d\n",
; 9989 : 		                name, line, NULL);
; 9990 : 
; 9991 : 	/*
; 9992 : 	 * end of parsing of this node.
; 9993 : 	 */
; 9994 : 	nodePop(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_nodePop
	add	esp, 4

; 9995 : 	namePop(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_namePop
	add	esp, 4

; 9996 : 	spacePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_spacePop
	add	esp, 4

; 9997 : 	if (nsNr != ctxt->nsNr)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _nsNr$[ebp]
	cmp	ecx, DWORD PTR [eax+328]
	je	SHORT $LN27@xmlParseEl

; 9998 : 	    nsPop(ctxt, ctxt->nsNr - nsNr);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	sub	eax, DWORD PTR _nsNr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_nsPop
	add	esp, 8
$LN27@xmlParseEl:

; 9999 : 
; 10000: 	/*
; 10001: 	 * Capture end position and add node
; 10002: 	 */
; 10003: 	if ( ret != NULL && ctxt->record_info ) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN28@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN28@xmlParseEl

; 10004: 	   node_info.end_pos = ctxt->input->consumed +

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _node_info$[ebp+12], eax

; 10005: 			      (CUR_PTR - ctxt->input->base);
; 10006: 	   node_info.end_line = ctxt->input->line;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _node_info$[ebp+16], eax

; 10007: 	   node_info.node = ret;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _node_info$[ebp], ecx

; 10008: 	   xmlParserAddNodeInfo(ctxt, &node_info);

	lea	edx, DWORD PTR _node_info$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParserAddNodeInfo
	add	esp, 8
$LN28@xmlParseEl:

; 10009: 	}
; 10010: 	return;

	jmp	$LN1@xmlParseEl
$LN25@xmlParseEl:

; 10011:     }
; 10012: 
; 10013:     /*
; 10014:      * Parse the content of the element:
; 10015:      */
; 10016:     xmlParseContent(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseContent
	add	esp, 4

; 10017:     if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN29@xmlParseEl

; 10018: 	return;

	jmp	$LN1@xmlParseEl
$LN29@xmlParseEl:

; 10019:     if (!IS_BYTE_CHAR(RAW)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN31@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	$LN30@xmlParseEl
$LN31@xmlParseEl:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN30@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN30@xmlParseEl

; 10020:         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,

	push	0
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0CJ@JPBGMEM@Premature?5end?5of?5data?5in?5tag?5?$CFs@
	push	77					; 0000004dH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStrIntStr
	add	esp, 24					; 00000018H

; 10021: 	 "Premature end of data in tag %s line %d\n",
; 10022: 		                name, line, NULL);
; 10023: 
; 10024: 	/*
; 10025: 	 * end of parsing of this node.
; 10026: 	 */
; 10027: 	nodePop(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_nodePop
	add	esp, 4

; 10028: 	namePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_namePop
	add	esp, 4

; 10029: 	spacePop(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_spacePop
	add	esp, 4

; 10030: 	if (nsNr != ctxt->nsNr)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _nsNr$[ebp]
	cmp	edx, DWORD PTR [ecx+328]
	je	SHORT $LN32@xmlParseEl

; 10031: 	    nsPop(ctxt, ctxt->nsNr - nsNr);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	sub	ecx, DWORD PTR _nsNr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_nsPop
	add	esp, 8
$LN32@xmlParseEl:

; 10032: 	return;

	jmp	$LN1@xmlParseEl
$LN30@xmlParseEl:

; 10033:     }
; 10034: 
; 10035:     /*
; 10036:      * parse the end of tag: '</' should be here.
; 10037:      */
; 10038:     if (ctxt->sax2) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+324], 0
	je	SHORT $LN33@xmlParseEl

; 10039: 	xmlParseEndTag2(ctxt, prefix, URI, line, ctxt->nsNr - nsNr, tlen);

	mov	ecx, DWORD PTR _tlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+328]
	sub	eax, DWORD PTR _nsNr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	mov	eax, DWORD PTR _prefix$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseEndTag2
	add	esp, 24					; 00000018H

; 10040: 	namePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_namePop
	add	esp, 4

; 10041:     }

	jmp	SHORT $LN34@xmlParseEl
$LN33@xmlParseEl:

; 10042: #ifdef LIBXML_SAX1_ENABLED
; 10043:       else
; 10044: 	xmlParseEndTag1(ctxt, line);

	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseEndTag1
	add	esp, 8
$LN34@xmlParseEl:

; 10045: #endif /* LIBXML_SAX1_ENABLED */
; 10046: 
; 10047:     /*
; 10048:      * Capture end position and add node
; 10049:      */
; 10050:     if ( ret != NULL && ctxt->record_info ) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN1@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN1@xmlParseEl

; 10051:        node_info.end_pos = ctxt->input->consumed +

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _node_info$[ebp+12], eax

; 10052:                           (CUR_PTR - ctxt->input->base);
; 10053:        node_info.end_line = ctxt->input->line;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _node_info$[ebp+16], eax

; 10054:        node_info.node = ret;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _node_info$[ebp], ecx

; 10055:        xmlParserAddNodeInfo(ctxt, &node_info);

	lea	edx, DWORD PTR _node_info$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParserAddNodeInfo
	add	esp, 8
$LN1@xmlParseEl:

; 10056:     }
; 10057: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN42@xmlParseEl
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlParseEl:
	DD	4
	DD	$LN41@xmlParseEl
$LN41@xmlParseEl:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN37@xmlParseEl
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN38@xmlParseEl
	DD	-52					; ffffffccH
	DD	20					; 00000014H
	DD	$LN39@xmlParseEl
	DD	-68					; ffffffbcH
	DD	4
	DD	$LN40@xmlParseEl
$LN40@xmlParseEl:
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN39@xmlParseEl:
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
$LN38@xmlParseEl:
	DB	85					; 00000055H
	DB	82					; 00000052H
	DB	73					; 00000049H
	DB	0
$LN37@xmlParseEl:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	0
_xmlParseElement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseContent
_TEXT	SEGMENT
_cur$1 = -12						; size = 4
_cons$2 = -8						; size = 4
_test$3 = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseContent PROC					; COMDAT

; 9811 : xmlParseContent(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 9812 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN2@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN2@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN2@xmlParseCo:

; 9813 :     while ((RAW != 0) &&
; 9814 : 	   ((RAW != '<') || (NXT(1) != '/')) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN1@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 60					; 0000003cH
	jne	SHORT $LN5@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 47					; 0000002fH
	je	$LN1@xmlParseCo
$LN5@xmlParseCo:
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	je	$LN1@xmlParseCo

; 9815 : 	   (ctxt->instate != XML_PARSER_EOF)) {
; 9816 : 	const xmlChar *test = CUR_PTR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _test$3[ebp], edx

; 9817 : 	unsigned int cons = ctxt->input->consumed;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _cons$2[ebp], edx

; 9818 : 	const xmlChar *cur = ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _cur$1[ebp], edx

; 9819 : 
; 9820 : 	/*
; 9821 : 	 * First case : a Processing Instruction.
; 9822 : 	 */
; 9823 : 	if ((*cur == '<') && (cur[1] == '?')) {

	mov	eax, DWORD PTR _cur$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN6@xmlParseCo
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 63					; 0000003fH
	jne	SHORT $LN6@xmlParseCo

; 9824 : 	    xmlParsePI(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParsePI
	add	esp, 4

; 9825 : 	}

	jmp	$LN7@xmlParseCo
$LN6@xmlParseCo:

; 9826 : 
; 9827 : 	/*
; 9828 : 	 * Second case : a CDSection
; 9829 : 	 */
; 9830 : 	/* 2.6.0 test was *cur not RAW */
; 9831 : 	else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 60					; 0000003cH
	jne	$LN8@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	$LN8@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 91					; 0000005bH
	jne	$LN8@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 67					; 00000043H
	jne	$LN8@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 68					; 00000044H
	jne	SHORT $LN8@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jne	SHORT $LN8@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 84					; 00000054H
	jne	SHORT $LN8@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 7
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jne	SHORT $LN8@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 91					; 0000005bH
	jne	SHORT $LN8@xmlParseCo

; 9832 : 	    xmlParseCDSect(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseCDSect
	add	esp, 4

; 9833 : 	}

	jmp	$LN7@xmlParseCo
$LN8@xmlParseCo:

; 9834 : 
; 9835 : 	/*
; 9836 : 	 * Third case :  a comment
; 9837 : 	 */
; 9838 : 	else if ((*cur == '<') && (NXT(1) == '!') &&
; 9839 : 		 (NXT(2) == '-') && (NXT(3) == '-')) {

	mov	eax, DWORD PTR _cur$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN10@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN10@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN10@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN10@xmlParseCo

; 9840 : 	    xmlParseComment(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseComment
	add	esp, 4

; 9841 : 	    ctxt->instate = XML_PARSER_CONTENT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 7

; 9842 : 	}

	jmp	SHORT $LN7@xmlParseCo
$LN10@xmlParseCo:

; 9843 : 
; 9844 : 	/*
; 9845 : 	 * Fourth case :  a sub-element.
; 9846 : 	 */
; 9847 : 	else if (*cur == '<') {

	mov	edx, DWORD PTR _cur$1[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN12@xmlParseCo

; 9848 : 	    xmlParseElement(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseElement
	add	esp, 4

; 9849 : 	}

	jmp	SHORT $LN7@xmlParseCo
$LN12@xmlParseCo:

; 9850 : 
; 9851 : 	/*
; 9852 : 	 * Fifth case : a reference. If if has not been resolved,
; 9853 : 	 *    parsing returns it's Name, create the node
; 9854 : 	 */
; 9855 : 
; 9856 : 	else if (*cur == '&') {

	mov	edx, DWORD PTR _cur$1[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN14@xmlParseCo

; 9857 : 	    xmlParseReference(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseReference
	add	esp, 4

; 9858 : 	}

	jmp	SHORT $LN7@xmlParseCo
$LN14@xmlParseCo:

; 9859 : 
; 9860 : 	/*
; 9861 : 	 * Last case, text. Note that References are handled directly.
; 9862 : 	 */
; 9863 : 	else {
; 9864 : 	    xmlParseCharData(ctxt, 0);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseCharData
	add	esp, 8
$LN7@xmlParseCo:

; 9865 : 	}
; 9866 : 
; 9867 : 	GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN16@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN16@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN16@xmlParseCo:

; 9868 : 	SHRINK;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN17@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN17@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 500				; 000001f4H
	jge	SHORT $LN17@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSHRINK
	add	esp, 4
$LN17@xmlParseCo:

; 9869 : 
; 9870 : 	if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _cons$2[ebp]
	cmp	eax, DWORD PTR [edx+36]
	jne	SHORT $LN18@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _test$3[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jne	SHORT $LN18@xmlParseCo

; 9871 : 	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CG@FCFCBOFE@detected?5an?5error?5in?5element?5co@
	push	1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 9872 : 	                "detected an error in element content\n");
; 9873 : 	    xmlHaltParser(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlHaltParser
	add	esp, 4

; 9874 :             break;

	jmp	SHORT $LN1@xmlParseCo
$LN18@xmlParseCo:

; 9875 : 	}
; 9876 :     }

	jmp	$LN2@xmlParseCo
$LN1@xmlParseCo:

; 9877 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseContent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCDSect
_TEXT	SEGMENT
tv290 = -104						; size = 4
tv292 = -100						; size = 4
tv291 = -96						; size = 4
tv236 = -92						; size = 4
tv238 = -88						; size = 4
tv237 = -84						; size = 4
tv187 = -80						; size = 4
tv189 = -76						; size = 4
tv188 = -72						; size = 4
_tmp$1 = -68						; size = 4
_count$ = -64						; size = 4
_l$ = -56						; size = 4
_cur$ = -48						; size = 4
_sl$ = -40						; size = 4
_s$ = -32						; size = 4
_rl$ = -24						; size = 4
_r$ = -16						; size = 4
_size$ = -12						; size = 4
_len$ = -8						; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseCDSect PROC					; COMDAT

; 9705 : xmlParseCDSect(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-104]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 9706 :     xmlChar *buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 9707 :     int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 9708 :     int size = XML_PARSER_BUFFER_SIZE;

	mov	DWORD PTR _size$[ebp], 100		; 00000064H

; 9709 :     int r, rl;
; 9710 :     int	s, sl;
; 9711 :     int cur, l;
; 9712 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 9713 : 
; 9714 :     /* Check 2.6.0 was NXT(0) not RAW */
; 9715 :     if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 60					; 0000003cH
	jne	$LN19@xmlParseCD
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	$LN19@xmlParseCD
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 91					; 0000005bH
	jne	$LN19@xmlParseCD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 67					; 00000043H
	jne	$LN19@xmlParseCD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 68					; 00000044H
	jne	$LN19@xmlParseCD
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jne	$LN19@xmlParseCD
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 84					; 00000054H
	jne	$LN19@xmlParseCD
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 7
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jne	$LN19@xmlParseCD
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 91					; 0000005bH
	jne	SHORT $LN19@xmlParseCD
$LN4@xmlParseCD:

; 9716 : 	SKIP(9);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 9
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN2@xmlParseCD
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseCD:
	xor	eax, eax
	jne	SHORT $LN4@xmlParseCD

; 9717 :     } else

	jmp	SHORT $LN20@xmlParseCD
$LN19@xmlParseCD:

; 9718 :         return;

	jmp	$LN1@xmlParseCD
$LN20@xmlParseCD:

; 9719 : 
; 9720 :     ctxt->instate = XML_PARSER_CDATA_SECTION;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 8

; 9721 :     r = CUR_CHAR(rl);

	lea	edx, DWORD PTR _rl$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _r$[ebp], eax

; 9722 :     if (!IS_CHAR(r)) {

	cmp	DWORD PTR _r$[ebp], 256			; 00000100H
	jge	SHORT $LN56@xmlParseCD
	cmp	DWORD PTR _r$[ebp], 9
	jl	SHORT $LN48@xmlParseCD
	cmp	DWORD PTR _r$[ebp], 10			; 0000000aH
	jle	SHORT $LN49@xmlParseCD
$LN48@xmlParseCD:
	cmp	DWORD PTR _r$[ebp], 13			; 0000000dH
	je	SHORT $LN49@xmlParseCD
	cmp	DWORD PTR _r$[ebp], 32			; 00000020H
	jge	SHORT $LN49@xmlParseCD
	mov	DWORD PTR tv188[ebp], 0
	jmp	SHORT $LN55@xmlParseCD
$LN49@xmlParseCD:
	mov	DWORD PTR tv188[ebp], 1
$LN55@xmlParseCD:
	mov	ecx, DWORD PTR tv188[ebp]
	mov	DWORD PTR tv189[ebp], ecx
	jmp	SHORT $LN57@xmlParseCD
$LN56@xmlParseCD:
	cmp	DWORD PTR _r$[ebp], 256			; 00000100H
	jl	SHORT $LN50@xmlParseCD
	cmp	DWORD PTR _r$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN52@xmlParseCD
$LN50@xmlParseCD:
	cmp	DWORD PTR _r$[ebp], 57344		; 0000e000H
	jl	SHORT $LN51@xmlParseCD
	cmp	DWORD PTR _r$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN52@xmlParseCD
$LN51@xmlParseCD:
	cmp	DWORD PTR _r$[ebp], 65536		; 00010000H
	jl	SHORT $LN53@xmlParseCD
	cmp	DWORD PTR _r$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN52@xmlParseCD
$LN53@xmlParseCD:
	mov	DWORD PTR tv187[ebp], 0
	jmp	SHORT $LN54@xmlParseCD
$LN52@xmlParseCD:
	mov	DWORD PTR tv187[ebp], 1
$LN54@xmlParseCD:
	mov	edx, DWORD PTR tv187[ebp]
	mov	DWORD PTR tv189[ebp], edx
$LN57@xmlParseCD:
	cmp	DWORD PTR tv189[ebp], 0
	jne	SHORT $LN7@xmlParseCD

; 9723 : 	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);

	push	0
	push	63					; 0000003fH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 9724 : 	ctxt->instate = XML_PARSER_CONTENT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 7

; 9725 :         return;

	jmp	$LN1@xmlParseCD
$LN7@xmlParseCD:

; 9726 :     }
; 9727 :     NEXTL(rl);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN23@xmlParseCD
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+28], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], 1
	jmp	SHORT $LN24@xmlParseCD
$LN23@xmlParseCD:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
$LN24@xmlParseCD:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _rl$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	xor	edx, edx
	jne	SHORT $LN7@xmlParseCD

; 9728 :     s = CUR_CHAR(sl);

	lea	eax, DWORD PTR _sl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 9729 :     if (!IS_CHAR(s)) {

	cmp	DWORD PTR _s$[ebp], 256			; 00000100H
	jge	SHORT $LN66@xmlParseCD
	cmp	DWORD PTR _s$[ebp], 9
	jl	SHORT $LN58@xmlParseCD
	cmp	DWORD PTR _s$[ebp], 10			; 0000000aH
	jle	SHORT $LN59@xmlParseCD
$LN58@xmlParseCD:
	cmp	DWORD PTR _s$[ebp], 13			; 0000000dH
	je	SHORT $LN59@xmlParseCD
	cmp	DWORD PTR _s$[ebp], 32			; 00000020H
	jge	SHORT $LN59@xmlParseCD
	mov	DWORD PTR tv237[ebp], 0
	jmp	SHORT $LN65@xmlParseCD
$LN59@xmlParseCD:
	mov	DWORD PTR tv237[ebp], 1
$LN65@xmlParseCD:
	mov	edx, DWORD PTR tv237[ebp]
	mov	DWORD PTR tv238[ebp], edx
	jmp	SHORT $LN67@xmlParseCD
$LN66@xmlParseCD:
	cmp	DWORD PTR _s$[ebp], 256			; 00000100H
	jl	SHORT $LN60@xmlParseCD
	cmp	DWORD PTR _s$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN62@xmlParseCD
$LN60@xmlParseCD:
	cmp	DWORD PTR _s$[ebp], 57344		; 0000e000H
	jl	SHORT $LN61@xmlParseCD
	cmp	DWORD PTR _s$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN62@xmlParseCD
$LN61@xmlParseCD:
	cmp	DWORD PTR _s$[ebp], 65536		; 00010000H
	jl	SHORT $LN63@xmlParseCD
	cmp	DWORD PTR _s$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN62@xmlParseCD
$LN63@xmlParseCD:
	mov	DWORD PTR tv236[ebp], 0
	jmp	SHORT $LN64@xmlParseCD
$LN62@xmlParseCD:
	mov	DWORD PTR tv236[ebp], 1
$LN64@xmlParseCD:
	mov	eax, DWORD PTR tv236[ebp]
	mov	DWORD PTR tv238[ebp], eax
$LN67@xmlParseCD:
	cmp	DWORD PTR tv238[ebp], 0
	jne	SHORT $LN10@xmlParseCD

; 9730 : 	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);

	push	0
	push	63					; 0000003fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 9731 : 	ctxt->instate = XML_PARSER_CONTENT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 7

; 9732 :         return;

	jmp	$LN1@xmlParseCD
$LN10@xmlParseCD:

; 9733 :     }
; 9734 :     NEXTL(sl);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN26@xmlParseCD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
	jmp	SHORT $LN27@xmlParseCD
$LN26@xmlParseCD:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN27@xmlParseCD:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _sl$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	xor	eax, eax
	jne	SHORT $LN10@xmlParseCD

; 9735 :     cur = CUR_CHAR(l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9736 :     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$[ebp], eax

; 9737 :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN11@xmlParseCD

; 9738 : 	xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 9739 : 	return;

	jmp	$LN1@xmlParseCD
$LN11@xmlParseCD:

; 9740 :     }
; 9741 :     while (IS_CHAR(cur) &&

	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jge	SHORT $LN76@xmlParseCD
	cmp	DWORD PTR _cur$[ebp], 9
	jl	SHORT $LN68@xmlParseCD
	cmp	DWORD PTR _cur$[ebp], 10		; 0000000aH
	jle	SHORT $LN69@xmlParseCD
$LN68@xmlParseCD:
	cmp	DWORD PTR _cur$[ebp], 13		; 0000000dH
	je	SHORT $LN69@xmlParseCD
	cmp	DWORD PTR _cur$[ebp], 32		; 00000020H
	jge	SHORT $LN69@xmlParseCD
	mov	DWORD PTR tv291[ebp], 0
	jmp	SHORT $LN75@xmlParseCD
$LN69@xmlParseCD:
	mov	DWORD PTR tv291[ebp], 1
$LN75@xmlParseCD:
	mov	edx, DWORD PTR tv291[ebp]
	mov	DWORD PTR tv292[ebp], edx
	jmp	SHORT $LN77@xmlParseCD
$LN76@xmlParseCD:
	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jl	SHORT $LN70@xmlParseCD
	cmp	DWORD PTR _cur$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN72@xmlParseCD
$LN70@xmlParseCD:
	cmp	DWORD PTR _cur$[ebp], 57344		; 0000e000H
	jl	SHORT $LN71@xmlParseCD
	cmp	DWORD PTR _cur$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN72@xmlParseCD
$LN71@xmlParseCD:
	cmp	DWORD PTR _cur$[ebp], 65536		; 00010000H
	jl	SHORT $LN73@xmlParseCD
	cmp	DWORD PTR _cur$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN72@xmlParseCD
$LN73@xmlParseCD:
	mov	DWORD PTR tv290[ebp], 0
	jmp	SHORT $LN74@xmlParseCD
$LN72@xmlParseCD:
	mov	DWORD PTR tv290[ebp], 1
$LN74@xmlParseCD:
	mov	eax, DWORD PTR tv290[ebp]
	mov	DWORD PTR tv292[ebp], eax
$LN77@xmlParseCD:
	cmp	DWORD PTR tv292[ebp], 0
	je	$LN12@xmlParseCD
	cmp	DWORD PTR _r$[ebp], 93			; 0000005dH
	jne	SHORT $LN29@xmlParseCD
	cmp	DWORD PTR _s$[ebp], 93			; 0000005dH
	jne	SHORT $LN29@xmlParseCD
	cmp	DWORD PTR _cur$[ebp], 62		; 0000003eH
	je	$LN12@xmlParseCD
$LN29@xmlParseCD:

; 9742 :            ((r != ']') || (s != ']') || (cur != '>'))) {
; 9743 : 	if (len + 5 >= size) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 5
	cmp	ecx, DWORD PTR _size$[ebp]
	jl	$LN30@xmlParseCD

; 9744 : 	    xmlChar *tmp;
; 9745 : 
; 9746 :             if ((size > XML_MAX_TEXT_LENGTH) &&

	cmp	DWORD PTR _size$[ebp], 10000000		; 00989680H
	jle	SHORT $LN31@xmlParseCD
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	and	eax, 524288				; 00080000H
	jne	SHORT $LN31@xmlParseCD

; 9747 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 9748 :                 xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,

	push	0
	push	OFFSET ??_C@_0BM@HGOGNNNB@CData?5section?5too?5big?5found@
	push	63					; 0000003fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 9749 :                              "CData section too big found", NULL);
; 9750 :                 xmlFree (buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9751 :                 return;

	jmp	$LN1@xmlParseCD
$LN31@xmlParseCD:

; 9752 :             }
; 9753 : 	    tmp = (xmlChar *) xmlRealloc(buf, size * 2 * sizeof(xmlChar));

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 1
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 9754 : 	    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN32@xmlParseCD

; 9755 : 	        xmlFree(buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9756 : 		xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 9757 : 		return;

	jmp	$LN1@xmlParseCD
$LN32@xmlParseCD:

; 9758 : 	    }
; 9759 : 	    buf = tmp;

	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _buf$[ebp], ecx

; 9760 : 	    size *= 2;

	mov	edx, DWORD PTR _size$[ebp]
	shl	edx, 1
	mov	DWORD PTR _size$[ebp], edx
$LN30@xmlParseCD:

; 9761 : 	}
; 9762 : 	COPY_BUF(rl,buf,len,r);

	cmp	DWORD PTR _rl$[ebp], 1
	jne	SHORT $LN33@xmlParseCD
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _r$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
	jmp	SHORT $LN34@xmlParseCD
$LN33@xmlParseCD:
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	push	ecx
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN34@xmlParseCD:

; 9763 : 	r = s;

	mov	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 9764 : 	rl = sl;

	mov	eax, DWORD PTR _sl$[ebp]
	mov	DWORD PTR _rl$[ebp], eax

; 9765 : 	s = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _s$[ebp], ecx

; 9766 : 	sl = l;

	mov	edx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _sl$[ebp], edx

; 9767 : 	count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 9768 : 	if (count > 50) {

	cmp	DWORD PTR _count$[ebp], 50		; 00000032H
	jle	SHORT $LN15@xmlParseCD

; 9769 : 	    GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN36@xmlParseCD
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN36@xmlParseCD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN36@xmlParseCD:

; 9770 :             if (ctxt->instate == XML_PARSER_EOF) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN37@xmlParseCD

; 9771 : 		xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9772 : 		return;

	jmp	$LN1@xmlParseCD
$LN37@xmlParseCD:

; 9773 :             }
; 9774 : 	    count = 0;

	mov	DWORD PTR _count$[ebp], 0
$LN15@xmlParseCD:

; 9775 : 	}
; 9776 : 	NEXTL(l);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN38@xmlParseCD
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], 1
	jmp	SHORT $LN39@xmlParseCD
$LN38@xmlParseCD:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
$LN39@xmlParseCD:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	xor	ecx, ecx
	jne	SHORT $LN15@xmlParseCD

; 9777 : 	cur = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9778 :     }

	jmp	$LN11@xmlParseCD
$LN12@xmlParseCD:

; 9779 :     buf[len] = 0;

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 0

; 9780 :     ctxt->instate = XML_PARSER_CONTENT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 7

; 9781 :     if (cur != '>') {

	cmp	DWORD PTR _cur$[ebp], 62		; 0000003eH
	je	SHORT $LN18@xmlParseCD

; 9782 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@HAEHMHLE@CData?5section?5not?5finished?6?$CF?450@
	push	63					; 0000003fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 9783 : 	                     "CData section not finished\n%.50s\n", buf);
; 9784 : 	xmlFree(buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9785 :         return;

	jmp	$LN1@xmlParseCD
$LN18@xmlParseCD:

; 9786 :     }
; 9787 :     NEXTL(l);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN41@xmlParseCD
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
	jmp	SHORT $LN42@xmlParseCD
$LN41@xmlParseCD:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN42@xmlParseCD:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	xor	eax, eax
	jne	SHORT $LN18@xmlParseCD

; 9788 : 
; 9789 :     /*
; 9790 :      * OK the buffer is to be consumed as cdata.
; 9791 :      */
; 9792 :     if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN43@xmlParseCD
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN43@xmlParseCD

; 9793 : 	if (ctxt->sax->cdataBlock != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+100], 0
	je	SHORT $LN44@xmlParseCD

; 9794 : 	    ctxt->sax->cdataBlock(ctxt->userData, buf, len);

	mov	esi, esp
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+100]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN43@xmlParseCD
$LN44@xmlParseCD:

; 9795 : 	else if (ctxt->sax->characters != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN43@xmlParseCD

; 9796 : 	    ctxt->sax->characters(ctxt->userData, buf, len);

	mov	esi, esp
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+68]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN43@xmlParseCD:

; 9797 :     }
; 9798 :     xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlParseCD:

; 9799 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN82@xmlParseCD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 104				; 00000068H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN82@xmlParseCD:
	DD	3
	DD	$LN81@xmlParseCD
$LN81@xmlParseCD:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN78@xmlParseCD
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN79@xmlParseCD
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN80@xmlParseCD
$LN80@xmlParseCD:
	DB	108					; 0000006cH
	DB	0
$LN79@xmlParseCD:
	DB	115					; 00000073H
	DB	108					; 0000006cH
	DB	0
$LN78@xmlParseCD:
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	0
_xmlParseCDSect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEndTag
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseEndTag PROC					; COMDAT

; 8643 : xmlParseEndTag(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 8644 :     xmlParseEndTag1(ctxt, 0);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseEndTag1
	add	esp, 8

; 8645 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseEndTag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseStartTag
_TEXT	SEGMENT
_n$1 = -48						; size = 4
_cons$2 = -44						; size = 4
_q$3 = -40						; size = 4
_i$ = -36						; size = 4
_maxatts$ = -32						; size = 4
_nbatts$ = -28						; size = 4
_atts$ = -24						; size = 4
_attvalue$ = -16					; size = 4
_attname$ = -8						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseStartTag PROC					; COMDAT

; 8439 : xmlParseStartTag(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 8440 :     const xmlChar *name;
; 8441 :     const xmlChar *attname;
; 8442 :     xmlChar *attvalue;
; 8443 :     const xmlChar **atts = ctxt->atts;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	mov	DWORD PTR _atts$[ebp], ecx

; 8444 :     int nbatts = 0;

	mov	DWORD PTR _nbatts$[ebp], 0

; 8445 :     int maxatts = ctxt->maxatts;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+304]
	mov	DWORD PTR _maxatts$[ebp], eax

; 8446 :     int i;
; 8447 : 
; 8448 :     if (RAW != '<') return(NULL);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	je	SHORT $LN10@xmlParseSt
	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN10@xmlParseSt:

; 8449 :     NEXT1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN11@xmlParseSt
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN11@xmlParseSt:

; 8450 : 
; 8451 :     name = xmlParseName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 8452 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN12@xmlParseSt

; 8453 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CI@FEOPKDBB@xmlParseStartTag?3?5invalid?5eleme@
	push	68					; 00000044H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 8454 : 	     "xmlParseStartTag: invalid element name\n");
; 8455 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSt
$LN12@xmlParseSt:

; 8456 :     }
; 8457 : 
; 8458 :     /*
; 8459 :      * Now parse the attributes, it ends up with the ending
; 8460 :      *
; 8461 :      * (S Attribute)* S?
; 8462 :      */
; 8463 :     SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 8464 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN2@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN2@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN2@xmlParseSt:

; 8465 : 
; 8466 :     while (((RAW != '>') &&
; 8467 : 	   ((RAW != '/') || (NXT(1) != '>')) &&
; 8468 : 	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 62					; 0000003eH
	je	$LN3@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN14@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 62					; 0000003eH
	je	$LN3@xmlParseSt
$LN14@xmlParseSt:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN16@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN15@xmlParseSt
$LN16@xmlParseSt:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN15@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jl	$LN3@xmlParseSt
$LN15@xmlParseSt:
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	je	$LN3@xmlParseSt

; 8469 : 	const xmlChar *q = CUR_PTR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _q$3[ebp], eax

; 8470 : 	unsigned int cons = ctxt->input->consumed;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _cons$2[ebp], eax

; 8471 : 
; 8472 : 	attname = xmlParseAttribute(ctxt, &attvalue);

	lea	ecx, DWORD PTR _attvalue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseAttribute
	add	esp, 8
	mov	DWORD PTR _attname$[ebp], eax

; 8473 :         if ((attname != NULL) && (attvalue != NULL)) {

	cmp	DWORD PTR _attname$[ebp], 0
	je	$LN17@xmlParseSt
	cmp	DWORD PTR _attvalue$[ebp], 0
	je	$LN17@xmlParseSt

; 8474 : 	    /*
; 8475 : 	     * [ WFC: Unique Att Spec ]
; 8476 : 	     * No attribute name may appear more than once in the same
; 8477 : 	     * start-tag or empty-element tag.
; 8478 : 	     */
; 8479 : 	    for (i = 0; i < nbatts;i += 2) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@xmlParseSt
$LN4@xmlParseSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax
$LN6@xmlParseSt:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _nbatts$[ebp]
	jge	SHORT $LN5@xmlParseSt

; 8480 : 	        if (xmlStrEqual(atts[i], attname)) {

	mov	edx, DWORD PTR _attname$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@xmlParseSt

; 8481 : 		    xmlErrAttributeDup(ctxt, NULL, attname);

	mov	eax, DWORD PTR _attname$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrAttributeDup
	add	esp, 12					; 0000000cH

; 8482 : 		    xmlFree(attvalue);

	mov	esi, esp
	mov	edx, DWORD PTR _attvalue$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8483 : 		    goto failed;

	jmp	$failed$44
$LN19@xmlParseSt:

; 8484 : 		}
; 8485 : 	    }

	jmp	SHORT $LN4@xmlParseSt
$LN5@xmlParseSt:

; 8486 : 	    /*
; 8487 : 	     * Add the pair to atts
; 8488 : 	     */
; 8489 : 	    if (atts == NULL) {

	cmp	DWORD PTR _atts$[ebp], 0
	jne	SHORT $LN20@xmlParseSt

; 8490 : 	        maxatts = 22; /* allow for 10 attrs by default */

	mov	DWORD PTR _maxatts$[ebp], 22		; 00000016H

; 8491 : 	        atts = (const xmlChar **)

	mov	eax, DWORD PTR _maxatts$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _atts$[ebp], eax

; 8492 : 		       xmlMalloc(maxatts * sizeof(xmlChar *));
; 8493 : 		if (atts == NULL) {

	cmp	DWORD PTR _atts$[ebp], 0
	jne	SHORT $LN22@xmlParseSt

; 8494 : 		    xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 8495 : 		    if (attvalue != NULL)

	cmp	DWORD PTR _attvalue$[ebp], 0
	je	SHORT $LN23@xmlParseSt

; 8496 : 			xmlFree(attvalue);

	mov	esi, esp
	mov	edx, DWORD PTR _attvalue$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN23@xmlParseSt:

; 8497 : 		    goto failed;

	jmp	$failed$44
$LN22@xmlParseSt:

; 8498 : 		}
; 8499 : 		ctxt->atts = atts;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [eax+300], ecx

; 8500 : 		ctxt->maxatts = maxatts;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _maxatts$[ebp]
	mov	DWORD PTR [edx+304], eax
	jmp	$LN21@xmlParseSt
$LN20@xmlParseSt:

; 8501 : 	    } else if (nbatts + 4 > maxatts) {

	mov	ecx, DWORD PTR _nbatts$[ebp]
	add	ecx, 4
	cmp	ecx, DWORD PTR _maxatts$[ebp]
	jle	SHORT $LN21@xmlParseSt

; 8502 : 	        const xmlChar **n;
; 8503 : 
; 8504 : 	        maxatts *= 2;

	mov	edx, DWORD PTR _maxatts$[ebp]
	shl	edx, 1
	mov	DWORD PTR _maxatts$[ebp], edx

; 8505 : 	        n = (const xmlChar **) xmlRealloc((void *) atts,

	mov	eax, DWORD PTR _maxatts$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _atts$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _n$1[ebp], eax

; 8506 : 					     maxatts * sizeof(const xmlChar *));
; 8507 : 		if (n == NULL) {

	cmp	DWORD PTR _n$1[ebp], 0
	jne	SHORT $LN25@xmlParseSt

; 8508 : 		    xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 8509 : 		    if (attvalue != NULL)

	cmp	DWORD PTR _attvalue$[ebp], 0
	je	SHORT $LN26@xmlParseSt

; 8510 : 			xmlFree(attvalue);

	mov	esi, esp
	mov	eax, DWORD PTR _attvalue$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@xmlParseSt:

; 8511 : 		    goto failed;

	jmp	$failed$44
$LN25@xmlParseSt:

; 8512 : 		}
; 8513 : 		atts = n;

	mov	ecx, DWORD PTR _n$1[ebp]
	mov	DWORD PTR _atts$[ebp], ecx

; 8514 : 		ctxt->atts = atts;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [edx+300], eax

; 8515 : 		ctxt->maxatts = maxatts;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _maxatts$[ebp]
	mov	DWORD PTR [ecx+304], edx
$LN21@xmlParseSt:

; 8516 : 	    }
; 8517 : 	    atts[nbatts++] = attname;

	mov	eax, DWORD PTR _nbatts$[ebp]
	mov	ecx, DWORD PTR _atts$[ebp]
	mov	edx, DWORD PTR _attname$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _nbatts$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbatts$[ebp], eax

; 8518 : 	    atts[nbatts++] = attvalue;

	mov	ecx, DWORD PTR _nbatts$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR _attvalue$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _nbatts$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbatts$[ebp], ecx

; 8519 : 	    atts[nbatts] = NULL;

	mov	edx, DWORD PTR _nbatts$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [eax+edx*4], 0

; 8520 : 	    atts[nbatts + 1] = NULL;

	mov	ecx, DWORD PTR _nbatts$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], 0

; 8521 : 	} else {

	jmp	SHORT $failed$44
$LN17@xmlParseSt:

; 8522 : 	    if (attvalue != NULL)

	cmp	DWORD PTR _attvalue$[ebp], 0
	je	SHORT $failed$44

; 8523 : 		xmlFree(attvalue);

	mov	esi, esp
	mov	eax, DWORD PTR _attvalue$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$failed$44:

; 8524 : 	}
; 8525 : 
; 8526 : failed:
; 8527 : 
; 8528 : 	GROW

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN28@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN28@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN28@xmlParseSt:

; 8529 : 	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	je	SHORT $LN30@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN29@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 62					; 0000003eH
	jne	SHORT $LN29@xmlParseSt
$LN30@xmlParseSt:

; 8530 : 	    break;

	jmp	$LN3@xmlParseSt
$LN29@xmlParseSt:

; 8531 : 	if (SKIP_BLANKS == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN31@xmlParseSt

; 8532 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BM@FKPAGOOK@attributes?5construct?5error?6@
	push	65					; 00000041H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN31@xmlParseSt:

; 8533 : 			   "attributes construct error\n");
; 8534 : 	}
; 8535 :         if ((cons == ctxt->input->consumed) && (q == CUR_PTR) &&
; 8536 :             (attname == NULL) && (attvalue == NULL)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _cons$2[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jne	SHORT $LN32@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _q$3[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN32@xmlParseSt
	cmp	DWORD PTR _attname$[ebp], 0
	jne	SHORT $LN32@xmlParseSt
	cmp	DWORD PTR _attvalue$[ebp], 0
	jne	SHORT $LN32@xmlParseSt

; 8537 : 	    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CO@KAECIKGE@xmlParseStartTag?3?5problem?5parsi@
	push	1
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 8538 : 			   "xmlParseStartTag: problem parsing attributes\n");
; 8539 : 	    break;

	jmp	$LN3@xmlParseSt
$LN32@xmlParseSt:

; 8540 : 	}
; 8541 : 	SHRINK;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN33@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	cmp	edx, 500				; 000001f4H
	jle	SHORT $LN33@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 500				; 000001f4H
	jge	SHORT $LN33@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSHRINK
	add	esp, 4
$LN33@xmlParseSt:

; 8542 :         GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN34@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN34@xmlParseSt
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN34@xmlParseSt:

; 8543 :     }

	jmp	$LN2@xmlParseSt
$LN3@xmlParseSt:

; 8544 : 
; 8545 :     /*
; 8546 :      * SAX: Start of Element !
; 8547 :      */
; 8548 :     if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN35@xmlParseSt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN35@xmlParseSt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN35@xmlParseSt

; 8549 : 	(!ctxt->disableSAX)) {
; 8550 : 	if (nbatts > 0)

	cmp	DWORD PTR _nbatts$[ebp], 0
	jle	SHORT $LN36@xmlParseSt

; 8551 : 	    ctxt->sax->startElement(ctxt->userData, name, atts);

	mov	esi, esp
	mov	edx, DWORD PTR _atts$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+56]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN35@xmlParseSt
$LN36@xmlParseSt:

; 8552 : 	else
; 8553 : 	    ctxt->sax->startElement(ctxt->userData, name, NULL);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+56]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN35@xmlParseSt:

; 8554 :     }
; 8555 : 
; 8556 :     if (atts != NULL) {

	cmp	DWORD PTR _atts$[ebp], 0
	je	SHORT $LN38@xmlParseSt

; 8557 :         /* Free only the content strings */
; 8558 :         for (i = 1;i < nbatts;i+=2)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN9@xmlParseSt
$LN7@xmlParseSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax
$LN9@xmlParseSt:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _nbatts$[ebp]
	jge	SHORT $LN38@xmlParseSt

; 8559 : 	    if (atts[i] != NULL)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _atts$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $LN39@xmlParseSt

; 8560 : 	       xmlFree((xmlChar *) atts[i]);

	mov	esi, esp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _atts$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN39@xmlParseSt:
	jmp	SHORT $LN7@xmlParseSt
$LN38@xmlParseSt:

; 8561 :     }
; 8562 :     return(name);

	mov	eax, DWORD PTR _name$[ebp]
$LN1@xmlParseSt:

; 8563 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN43@xmlParseSt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN43@xmlParseSt:
	DD	1
	DD	$LN42@xmlParseSt
$LN42@xmlParseSt:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN41@xmlParseSt
$LN41@xmlParseSt:
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_xmlParseStartTag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttribute
_TEXT	SEGMENT
_val$ = -8						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlParseAttribute PROC					; COMDAT

; 8350 : xmlParseAttribute(xmlParserCtxtPtr ctxt, xmlChar **value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 8351 :     const xmlChar *name;
; 8352 :     xmlChar *val;
; 8353 : 
; 8354 :     *value = NULL;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], 0

; 8355 :     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN2@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN2@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN2@xmlParseAt:

; 8356 :     name = xmlParseName(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 8357 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN3@xmlParseAt

; 8358 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0BO@BHLKDNI@error?5parsing?5attribute?5name?6@
	push	68					; 00000044H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 8359 : 	               "error parsing attribute name\n");
; 8360 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN3@xmlParseAt:

; 8361 :     }
; 8362 : 
; 8363 :     /*
; 8364 :      * read the value
; 8365 :      */
; 8366 :     SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 8367 :     if (RAW == '=') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 61					; 0000003dH
	jne	SHORT $LN4@xmlParseAt

; 8368 :         NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 8369 : 	SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 8370 : 	val = xmlParseAttValue(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseAttValue
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 8371 : 	ctxt->instate = XML_PARSER_CONTENT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 7

; 8372 :     } else {

	jmp	SHORT $LN5@xmlParseAt
$LN4@xmlParseAt:

; 8373 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CP@LHHGCLP@Specification?5mandates?5value?5fo@
	push	41					; 00000029H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 8374 : 	       "Specification mandates value for attribute %s\n", name);
; 8375 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseAt
$LN5@xmlParseAt:

; 8376 :     }
; 8377 : 
; 8378 :     /*
; 8379 :      * Check that xml:lang conforms to the specification
; 8380 :      * No more registered as an error, just generate a warning now
; 8381 :      * since this was deprecated in XML second edition
; 8382 :      */
; 8383 :     if ((ctxt->pedantic) && (xmlStrEqual(name, BAD_CAST "xml:lang"))) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+268], 0
	je	SHORT $LN6@xmlParseAt
	push	OFFSET ??_C@_08EHDJCMMM@xml?3lang@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlParseAt

; 8384 : 	if (!xmlCheckLanguageID(val)) {

	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_xmlCheckLanguageID
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@xmlParseAt

; 8385 : 	    xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,

	push	0
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@OAOAJGL@Malformed?5value?5for?5xml?3lang?5?3?5@
	push	98					; 00000062H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN6@xmlParseAt:

; 8386 : 		          "Malformed value for xml:lang : %s\n",
; 8387 : 			  val, NULL);
; 8388 : 	}
; 8389 :     }
; 8390 : 
; 8391 :     /*
; 8392 :      * Check that xml:space conforms to the specification
; 8393 :      */
; 8394 :     if (xmlStrEqual(name, BAD_CAST "xml:space")) {

	push	OFFSET ??_C@_09HKHFJOKD@xml?3space@
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlParseAt

; 8395 : 	if (xmlStrEqual(val, BAD_CAST "default"))

	push	OFFSET ??_C@_07DLHCIBDH@default@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@xmlParseAt

; 8396 : 	    *(ctxt->space) = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN8@xmlParseAt
$LN9@xmlParseAt:

; 8397 : 	else if (xmlStrEqual(val, BAD_CAST "preserve"))

	push	OFFSET ??_C@_08ILAKLJGO@preserve@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlParseAt

; 8398 : 	    *(ctxt->space) = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	mov	DWORD PTR [edx], 1
	jmp	SHORT $LN8@xmlParseAt
$LN11@xmlParseAt:

; 8399 : 	else {
; 8400 : 		xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,

	push	0
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	OFFSET ??_C@_0EF@GNALPKCP@Invalid?5value?5?$CC?$CFs?$CC?5for?5xml?3spac@
	push	102					; 00000066H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN8@xmlParseAt:

; 8401 : "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
; 8402 :                                  val, NULL);
; 8403 : 	}
; 8404 :     }
; 8405 : 
; 8406 :     *value = val;

	mov	edx, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 8407 :     return(name);

	mov	eax, DWORD PTR _name$[ebp]
$LN1@xmlParseAt:

; 8408 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseDocTypeDecl
_TEXT	SEGMENT
_URI$ = -20						; size = 4
_ExternalID$ = -12					; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseDocTypeDecl PROC				; COMDAT

; 8196 : xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 8197 :     const xmlChar *name = NULL;

	mov	DWORD PTR _name$[ebp], 0

; 8198 :     xmlChar *ExternalID = NULL;

	mov	DWORD PTR _ExternalID$[ebp], 0

; 8199 :     xmlChar *URI = NULL;

	mov	DWORD PTR _URI$[ebp], 0
$LN4@xmlParseDo:

; 8200 : 
; 8201 :     /*
; 8202 :      * We know that '<!DOCTYPE' has been detected.
; 8203 :      */
; 8204 :     SKIP(9);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 9
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 9
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 9
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@xmlParseDo
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseDo:
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseDo

; 8205 : 
; 8206 :     SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 8207 : 
; 8208 :     /*
; 8209 :      * Parse the DOCTYPE name.
; 8210 :      */
; 8211 :     name = xmlParseName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 8212 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN6@xmlParseDo

; 8213 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CJ@JPAMJNGL@xmlParseDocTypeDecl?5?3?5no?5DOCTYP@
	push	68					; 00000044H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN6@xmlParseDo:

; 8214 : 		       "xmlParseDocTypeDecl : no DOCTYPE name !\n");
; 8215 :     }
; 8216 :     ctxt->intSubName = name;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR [edx+220], eax

; 8217 : 
; 8218 :     SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 8219 : 
; 8220 :     /*
; 8221 :      * Check for SystemID and ExternalID
; 8222 :      */
; 8223 :     URI = xmlParseExternalID(ctxt, &ExternalID, 1);

	push	1
	lea	edx, DWORD PTR _ExternalID$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseExternalID
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URI$[ebp], eax

; 8224 : 
; 8225 :     if ((URI != NULL) || (ExternalID != NULL)) {

	cmp	DWORD PTR _URI$[ebp], 0
	jne	SHORT $LN8@xmlParseDo
	cmp	DWORD PTR _ExternalID$[ebp], 0
	je	SHORT $LN7@xmlParseDo
$LN8@xmlParseDo:

; 8226 :         ctxt->hasExternalSubset = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+88], 1
$LN7@xmlParseDo:

; 8227 :     }
; 8228 :     ctxt->extSubURI = URI;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _URI$[ebp]
	mov	DWORD PTR [edx+224], eax

; 8229 :     ctxt->extSubSystem = ExternalID;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ExternalID$[ebp]
	mov	DWORD PTR [ecx+228], edx

; 8230 : 
; 8231 :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 8232 : 
; 8233 :     /*
; 8234 :      * Create and update the internal subset.
; 8235 :      */
; 8236 :     if ((ctxt->sax != NULL) && (ctxt->sax->internalSubset != NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN9@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN9@xmlParseDo

; 8237 : 	(!ctxt->disableSAX))
; 8238 : 	ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);

	mov	esi, esp
	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	mov	eax, DWORD PTR _ExternalID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlParseDo:

; 8239 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN10@xmlParseDo

; 8240 : 	return;

	jmp	SHORT $LN1@xmlParseDo
$LN10@xmlParseDo:

; 8241 : 
; 8242 :     /*
; 8243 :      * Is there any internal subset declarations ?
; 8244 :      * they are handled separately in xmlParseInternalSubset()
; 8245 :      */
; 8246 :     if (RAW == '[')

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 91					; 0000005bH
	jne	SHORT $LN11@xmlParseDo

; 8247 : 	return;

	jmp	SHORT $LN1@xmlParseDo
$LN11@xmlParseDo:

; 8248 : 
; 8249 :     /*
; 8250 :      * We should be at the end of the DOCTYPE declaration.
; 8251 :      */
; 8252 :     if (RAW != '>') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN12@xmlParseDo

; 8253 : 	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);

	push	0
	push	61					; 0000003dH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN12@xmlParseDo:

; 8254 :     }
; 8255 :     NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4
$LN1@xmlParseDo:

; 8256 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@xmlParseDo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@xmlParseDo:
	DD	1
	DD	$LN15@xmlParseDo
$LN15@xmlParseDo:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN14@xmlParseDo
$LN14@xmlParseDo:
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	73					; 00000049H
	DB	68					; 00000044H
	DB	0
_xmlParseDocTypeDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParsePEReference
_TEXT	SEGMENT
_enc$1 = -28						; size = 4
_start$2 = -20						; size = 4
_input$ = -12						; size = 4
_entity$ = -8						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParsePEReference PROC				; COMDAT

; 7832 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 7833 :     const xmlChar *name;
; 7834 :     xmlEntityPtr entity = NULL;

	mov	DWORD PTR _entity$[ebp], 0

; 7835 :     xmlParserInputPtr input;
; 7836 : 
; 7837 :     if (RAW != '%')

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN2@xmlParsePE

; 7838 :         return;

	jmp	$LN1@xmlParsePE
$LN2@xmlParsePE:

; 7839 :     NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 7840 :     name = xmlParseName(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 7841 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN3@xmlParsePE

; 7842 : 	xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, "PEReference: no name\n");

	push	OFFSET ??_C@_0BG@DIAKGNKN@PEReference?3?5no?5name?6@
	push	24					; 00000018H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 7843 : 	return;

	jmp	$LN1@xmlParsePE
$LN3@xmlParsePE:

; 7844 :     }
; 7845 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlParsePE

; 7846 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BB@MFPJKDDB@PEReference?3?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlParsePE:

; 7847 : 		"PEReference: %s\n", name);
; 7848 :     if (RAW != ';') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	je	SHORT $LN5@xmlParsePE

; 7849 : 	xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);

	push	0
	push	25					; 00000019H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 7850 :         return;

	jmp	$LN1@xmlParsePE
$LN5@xmlParsePE:

; 7851 :     }
; 7852 : 
; 7853 :     NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 7854 : 
; 7855 :     /*
; 7856 :      * Increate the number of entity references parsed
; 7857 :      */
; 7858 :     ctxt->nbentities++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+440]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+440], edx

; 7859 : 
; 7860 :     /*
; 7861 :      * Request the entity from SAX
; 7862 :      */
; 7863 :     if ((ctxt->sax != NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN6@xmlParsePE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+96], 0
	je	SHORT $LN6@xmlParsePE

; 7864 : 	(ctxt->sax->getParameterEntity != NULL))
; 7865 : 	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+96]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _entity$[ebp], eax
$LN6@xmlParsePE:

; 7866 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN7@xmlParsePE

; 7867 : 	return;

	jmp	$LN1@xmlParsePE
$LN7@xmlParsePE:

; 7868 :     if (entity == NULL) {

	cmp	DWORD PTR _entity$[ebp], 0
	jne	$LN8@xmlParsePE

; 7869 : 	/*
; 7870 : 	 * [ WFC: Entity Declared ]
; 7871 : 	 * In a document without any DTD, a document with only an
; 7872 : 	 * internal DTD subset which contains no parameter entity
; 7873 : 	 * references, or a document with "standalone='yes'", ...
; 7874 : 	 * ... The declaration of a parameter entity must precede
; 7875 : 	 * any reference to it...
; 7876 : 	 */
; 7877 : 	if ((ctxt->standalone == 1) ||

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+28], 1
	je	SHORT $LN12@xmlParsePE
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+88], 0
	jne	SHORT $LN10@xmlParsePE
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	jne	SHORT $LN10@xmlParsePE
$LN12@xmlParsePE:

; 7878 : 	    ((ctxt->hasExternalSubset == 0) &&
; 7879 : 	     (ctxt->hasPErefs == 0))) {
; 7880 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
	push	26					; 0000001aH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7881 : 			      "PEReference: %%%s; not found\n",
; 7882 : 			      name);
; 7883 : 	} else {

	jmp	SHORT $LN11@xmlParsePE
$LN10@xmlParsePE:

; 7884 : 	    /*
; 7885 : 	     * [ VC: Entity Declared ]
; 7886 : 	     * In a document with an external subset or external
; 7887 : 	     * parameter entities with "standalone='no'", ...
; 7888 : 	     * ... The declaration of a parameter entity must
; 7889 : 	     * precede any reference to it...
; 7890 : 	     */
; 7891 :             if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+104], 0
	je	SHORT $LN13@xmlParsePE
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+112], 0
	je	SHORT $LN13@xmlParsePE

; 7892 :                 xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlValidityError
	add	esp, 20					; 00000014H

; 7893 :                                  "PEReference: %%%s; not found\n",
; 7894 :                                  name, NULL);
; 7895 :             } else

	jmp	SHORT $LN14@xmlParsePE
$LN13@xmlParsePE:

; 7896 :                 xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0BO@KINMDPMC@PEReference?3?5?$CF?$CF?$CFs?$DL?5not?5found?6@
	push	27					; 0000001bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN14@xmlParsePE:

; 7897 :                               "PEReference: %%%s; not found\n",
; 7898 :                               name, NULL);
; 7899 :             ctxt->valid = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+100], 0
$LN11@xmlParsePE:

; 7900 : 	}
; 7901 : 	xmlParserEntityCheck(ctxt, 0, NULL, 0);

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H

; 7902 :     } else {

	jmp	$LN9@xmlParsePE
$LN8@xmlParsePE:

; 7903 : 	/*
; 7904 : 	 * Internal checking in case the entity quest barfed
; 7905 : 	 */
; 7906 : 	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&

	mov	eax, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [eax+48], 4
	je	SHORT $LN15@xmlParsePE
	mov	ecx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [ecx+48], 5
	je	SHORT $LN15@xmlParsePE

; 7907 : 	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
; 7908 : 	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,

	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0CL@BLGDJGPF@Internal?3?5?$CF?$CF?$CFs?$DL?5is?5not?5a?5parame@
	push	27					; 0000001bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H

; 7909 : 		  "Internal: %%%s; is not a parameter entity\n",
; 7910 : 			  name, NULL);
; 7911 : 	} else {

	jmp	$LN9@xmlParsePE
$LN15@xmlParsePE:

; 7912 :             xmlChar start[4];
; 7913 :             xmlCharEncoding enc;
; 7914 : 
; 7915 : 	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
; 7916 : 	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
; 7917 : 		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
; 7918 : 		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
; 7919 : 		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
; 7920 : 		(ctxt->replaceEntities == 0) &&

	mov	ecx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [ecx+48], 5
	jne	SHORT $LN17@xmlParsePE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	and	eax, 2
	jne	SHORT $LN17@xmlParsePE
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 16					; 00000010H
	jne	SHORT $LN17@xmlParsePE
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 4
	jne	SHORT $LN17@xmlParsePE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	and	eax, 8
	jne	SHORT $LN17@xmlParsePE
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN17@xmlParsePE
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+104], 0
	jne	SHORT $LN17@xmlParsePE

; 7921 : 		(ctxt->validate == 0))
; 7922 : 		return;

	jmp	$LN1@xmlParsePE
$LN17@xmlParsePE:

; 7923 : 
; 7924 : 	    input = xmlNewEntityInputStream(ctxt, entity);

	mov	eax, DWORD PTR _entity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNewEntityInputStream
	add	esp, 8
	mov	DWORD PTR _input$[ebp], eax

; 7925 : 	    if (xmlPushInput(ctxt, input) < 0) {

	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlPushInput
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN18@xmlParsePE

; 7926 :                 xmlFreeInputStream(input);

	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	call	_xmlFreeInputStream
	add	esp, 4

; 7927 : 		return;

	jmp	$LN1@xmlParsePE
$LN18@xmlParsePE:

; 7928 :             }
; 7929 : 
; 7930 : 	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+48], 5
	jne	$LN9@xmlParsePE

; 7931 :                 /*
; 7932 :                  * Get the 4 first bytes and decode the charset
; 7933 :                  * if enc != XML_CHAR_ENCODING_NONE
; 7934 :                  * plug some encoding conversion routines.
; 7935 :                  * Note that, since we may have some non-UTF8
; 7936 :                  * encoding (like UTF16, bug 135229), the 'length'
; 7937 :                  * is not known, but we can calculate based upon
; 7938 :                  * the amount of data in the buffer.
; 7939 :                  */
; 7940 :                 GROW

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN20@xmlParsePE
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN20@xmlParsePE
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN20@xmlParsePE:

; 7941 :                 if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN21@xmlParsePE

; 7942 :                     return;

	jmp	$LN1@xmlParsePE
$LN21@xmlParsePE:

; 7943 :                 if ((ctxt->input->end - ctxt->input->cur)>=4) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 4
	jl	$LN22@xmlParsePE

; 7944 :                     start[0] = RAW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR _start$2[ebp+edx], al

; 7945 :                     start[1] = NXT(1);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR [eax+ecx]
	mov	BYTE PTR _start$2[ebp+edx], al

; 7946 :                     start[2] = NXT(2);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, 1
	shl	edx, 1
	mov	al, BYTE PTR [eax+ecx]
	mov	BYTE PTR _start$2[ebp+edx], al

; 7947 :                     start[3] = NXT(3);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	mov	eax, 1
	imul	eax, eax, 3
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR _start$2[ebp+eax], cl

; 7948 :                     enc = xmlDetectCharEncoding(start, 4);

	push	4
	lea	edx, DWORD PTR _start$2[ebp]
	push	edx
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$1[ebp], eax

; 7949 :                     if (enc != XML_CHAR_ENCODING_NONE) {

	cmp	DWORD PTR _enc$1[ebp], 0
	je	SHORT $LN22@xmlParsePE

; 7950 :                         xmlSwitchEncoding(ctxt, enc);

	mov	eax, DWORD PTR _enc$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSwitchEncoding
	add	esp, 8
$LN22@xmlParsePE:

; 7951 :                     }
; 7952 :                 }
; 7953 : 
; 7954 :                 if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 60					; 0000003cH
	jne	$LN9@xmlParsePE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 63					; 0000003fH
	jne	$LN9@xmlParsePE
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	jne	$LN9@xmlParsePE
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 109				; 0000006dH
	jne	$LN9@xmlParsePE
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 108				; 0000006cH
	jne	SHORT $LN9@xmlParsePE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN25@xmlParsePE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 9
	jl	SHORT $LN26@xmlParsePE
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN25@xmlParsePE
$LN26@xmlParsePE:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN9@xmlParsePE
$LN25@xmlParsePE:

; 7955 :                     (IS_BLANK_CH(NXT(5)))) {
; 7956 :                     xmlParseTextDecl(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseTextDecl
	add	esp, 4
$LN9@xmlParsePE:

; 7957 :                 }
; 7958 :             }
; 7959 : 	}
; 7960 :     }
; 7961 :     ctxt->hasPErefs = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+92], 1
$LN1@xmlParsePE:

; 7962 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@xmlParsePE
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN30@xmlParsePE:
	DD	1
	DD	$LN29@xmlParsePE
$LN29@xmlParsePE:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN28@xmlParsePE
$LN28@xmlParsePE:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
_xmlParsePEReference ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseReference
_TEXT	SEGMENT
_nbktext$1 = -108					; size = 4
_firstChild$2 = -104					; size = 4
_last$3 = -100						; size = 4
_next$4 = -96						; size = 4
_cur$5 = -92						; size = 4
_nw$6 = -88						; size = 4
_firstChild$7 = -84					; size = 4
_cur$8 = -80						; size = 4
_nw$9 = -76						; size = 4
_user_data$10 = -72					; size = 4
_user_data$11 = -68					; size = 4
_oldnbent$12 = -64					; size = 4
_value$13 = -60						; size = 4
_hex$14 = -56						; size = 4
_out$15 = -48						; size = 10
_i$16 = -32						; size = 4
_ret$ = -28						; size = 4
_list$ = -20						; size = 4
_was_checked$ = -12					; size = 4
_val$ = -8						; size = 4
_ent$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseReference PROC					; COMDAT

; 6998 : xmlParseReference(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-108]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 6999 :     xmlEntityPtr ent;
; 7000 :     xmlChar *val;
; 7001 :     int was_checked;
; 7002 :     xmlNodePtr list = NULL;

	mov	DWORD PTR _list$[ebp], 0

; 7003 :     xmlParserErrors ret = XML_ERR_OK;

	mov	DWORD PTR _ret$[ebp], 0

; 7004 : 
; 7005 : 
; 7006 :     if (RAW != '&')

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN10@xmlParseRe

; 7007 :         return;

	jmp	$LN1@xmlParseRe
$LN10@xmlParseRe:

; 7008 : 
; 7009 :     /*
; 7010 :      * Simple case of a CharRef
; 7011 :      */
; 7012 :     if (NXT(1) == '#') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 35					; 00000023H
	jne	$LN11@xmlParseRe

; 7013 : 	int i = 0;

	mov	DWORD PTR _i$16[ebp], 0

; 7014 : 	xmlChar out[10];
; 7015 : 	int hex = NXT(2);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _hex$14[ebp], ecx

; 7016 : 	int value = xmlParseCharRef(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseCharRef
	add	esp, 4
	mov	DWORD PTR _value$13[ebp], eax

; 7017 : 
; 7018 : 	if (value == 0)

	cmp	DWORD PTR _value$13[ebp], 0
	jne	SHORT $LN12@xmlParseRe

; 7019 : 	    return;

	jmp	$LN1@xmlParseRe
$LN12@xmlParseRe:

; 7020 : 	if (ctxt->charset != XML_CHAR_ENCODING_UTF8) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+256], 1
	je	$LN13@xmlParseRe

; 7021 : 	    /*
; 7022 : 	     * So we are using non-UTF-8 buffers
; 7023 : 	     * Check that the char fit on 8bits, if not
; 7024 : 	     * generate a CharRef.
; 7025 : 	     */
; 7026 : 	    if (value <= 0xFF) {

	cmp	DWORD PTR _value$13[ebp], 255		; 000000ffH
	jg	SHORT $LN15@xmlParseRe

; 7027 : 		out[0] = value;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _value$13[ebp]
	mov	BYTE PTR _out$15[ebp+edx], al

; 7028 : 		out[1] = 0;

	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR _out$15[ebp+ecx], 0

; 7029 : 		if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN17@xmlParseRe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN17@xmlParseRe
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN17@xmlParseRe

; 7030 : 		    (!ctxt->disableSAX))
; 7031 : 		    ctxt->sax->characters(ctxt->userData, out, 1);

	mov	esi, esp
	push	1
	lea	eax, DWORD PTR _out$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+68]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@xmlParseRe:

; 7032 : 	    } else {

	jmp	SHORT $LN16@xmlParseRe
$LN15@xmlParseRe:

; 7033 : 		if ((hex == 'x') || (hex == 'X'))

	cmp	DWORD PTR _hex$14[ebp], 120		; 00000078H
	je	SHORT $LN20@xmlParseRe
	cmp	DWORD PTR _hex$14[ebp], 88		; 00000058H
	jne	SHORT $LN18@xmlParseRe
$LN20@xmlParseRe:

; 7034 : 		    snprintf((char *)out, sizeof(out), "#x%X", value);

	mov	eax, DWORD PTR _value$13[ebp]
	push	eax
	push	OFFSET ??_C@_04FNNDIGBC@?$CDx?$CFX@
	push	10					; 0000000aH
	lea	ecx, DWORD PTR _out$15[ebp]
	push	ecx
	call	_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN19@xmlParseRe
$LN18@xmlParseRe:

; 7035 : 		else
; 7036 : 		    snprintf((char *)out, sizeof(out), "#%d", value);

	mov	edx, DWORD PTR _value$13[ebp]
	push	edx
	push	OFFSET ??_C@_03FDCLAKJL@?$CD?$CFd@
	push	10					; 0000000aH
	lea	eax, DWORD PTR _out$15[ebp]
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN19@xmlParseRe:

; 7037 : 		if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN16@xmlParseRe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN16@xmlParseRe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN16@xmlParseRe

; 7038 : 		    (!ctxt->disableSAX))
; 7039 : 		    ctxt->sax->reference(ctxt->userData, out);

	mov	esi, esp
	lea	edx, DWORD PTR _out$15[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+64]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlParseRe:

; 7040 : 	    }
; 7041 : 	} else {

	jmp	SHORT $LN14@xmlParseRe
$LN13@xmlParseRe:

; 7042 : 	    /*
; 7043 : 	     * Just encode the value in UTF-8
; 7044 : 	     */
; 7045 : 	    COPY_BUF(0 ,out, i, value);

	xor	edx, edx
	je	SHORT $LN22@xmlParseRe
	mov	eax, DWORD PTR _i$16[ebp]
	mov	cl, BYTE PTR _value$13[ebp]
	mov	BYTE PTR _out$15[ebp+eax], cl
	mov	edx, DWORD PTR _i$16[ebp]
	add	edx, 1
	mov	DWORD PTR _i$16[ebp], edx
	jmp	SHORT $LN23@xmlParseRe
$LN22@xmlParseRe:
	mov	eax, DWORD PTR _value$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$16[ebp]
	lea	edx, DWORD PTR _out$15[ebp+ecx]
	push	edx
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _i$16[ebp]
	mov	DWORD PTR _i$16[ebp], eax
$LN23@xmlParseRe:

; 7046 : 	    out[i] = 0;

	mov	eax, DWORD PTR _i$16[ebp]
	mov	BYTE PTR _out$15[ebp+eax], 0

; 7047 : 	    if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN14@xmlParseRe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN14@xmlParseRe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN14@xmlParseRe

; 7048 : 		(!ctxt->disableSAX))
; 7049 : 		ctxt->sax->characters(ctxt->userData, out, i);

	mov	esi, esp
	mov	edx, DWORD PTR _i$16[ebp]
	push	edx
	lea	eax, DWORD PTR _out$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+68]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlParseRe:

; 7050 : 	}
; 7051 : 	return;

	jmp	$LN1@xmlParseRe
$LN11@xmlParseRe:

; 7052 :     }
; 7053 : 
; 7054 :     /*
; 7055 :      * We are seeing an entity reference
; 7056 :      */
; 7057 :     ent = xmlParseEntityRef(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseEntityRef
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 7058 :     if (ent == NULL) return;

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN25@xmlParseRe
	jmp	$LN1@xmlParseRe
$LN25@xmlParseRe:

; 7059 :     if (!ctxt->wellFormed)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN26@xmlParseRe

; 7060 : 	return;

	jmp	$LN1@xmlParseRe
$LN26@xmlParseRe:

; 7061 :     was_checked = ent->checked;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR _was_checked$[ebp], eax

; 7062 : 
; 7063 :     /* special case of predefined entities */
; 7064 :     if ((ent->name == NULL) ||

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN28@xmlParseRe
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+48], 6
	jne	SHORT $LN27@xmlParseRe
$LN28@xmlParseRe:

; 7065 :         (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
; 7066 : 	val = ent->content;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _val$[ebp], ecx

; 7067 : 	if (val == NULL) return;

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN29@xmlParseRe
	jmp	$LN1@xmlParseRe
$LN29@xmlParseRe:

; 7068 : 	/*
; 7069 : 	 * inline the entity.
; 7070 : 	 */
; 7071 : 	if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN30@xmlParseRe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN30@xmlParseRe
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN30@xmlParseRe

; 7072 : 	    (!ctxt->disableSAX))
; 7073 : 	    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+68]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN30@xmlParseRe:

; 7074 : 	return;

	jmp	$LN1@xmlParseRe
$LN27@xmlParseRe:

; 7075 :     }
; 7076 : 
; 7077 :     /*
; 7078 :      * The first reference to the entity trigger a parsing phase
; 7079 :      * where the ent->children is filled with the result from
; 7080 :      * the parsing.
; 7081 :      * Note: external parsed entities will not be loaded, it is not
; 7082 :      * required for a non-validating parser, unless the parsing option
; 7083 :      * of validating, or substituting entities were given. Doing so is
; 7084 :      * far more secure as the parser will only process data coming from
; 7085 :      * the document entity by default.
; 7086 :      */
; 7087 :     if (((ent->checked == 0) ||
; 7088 :          ((ent->children == NULL) && (ctxt->options & XML_PARSE_NOENT))) &&

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	je	SHORT $LN33@xmlParseRe
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	$LN31@xmlParseRe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 2
	je	$LN31@xmlParseRe
$LN33@xmlParseRe:
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+48], 2
	jne	SHORT $LN34@xmlParseRe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 18					; 00000012H
	je	$LN31@xmlParseRe
$LN34@xmlParseRe:

; 7089 :         ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
; 7090 :          (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
; 7091 : 	unsigned long oldnbent = ctxt->nbentities;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+440]
	mov	DWORD PTR _oldnbent$12[ebp], eax

; 7092 : 
; 7093 : 	/*
; 7094 : 	 * This is a bit hackish but this seems the best
; 7095 : 	 * way to make sure both SAX and DOM entity support
; 7096 : 	 * behaves okay.
; 7097 : 	 */
; 7098 : 	void *user_data;
; 7099 : 	if (ctxt->userData == ctxt)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _ctxt$[ebp]
	jne	SHORT $LN35@xmlParseRe

; 7100 : 	    user_data = NULL;

	mov	DWORD PTR _user_data$11[ebp], 0
	jmp	SHORT $LN36@xmlParseRe
$LN35@xmlParseRe:

; 7101 : 	else
; 7102 : 	    user_data = ctxt->userData;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _user_data$11[ebp], ecx
$LN36@xmlParseRe:

; 7103 : 
; 7104 : 	/*
; 7105 : 	 * Check that this entity is well formed
; 7106 : 	 * 4.3.2: An internal general parsed entity is well-formed
; 7107 : 	 * if its replacement text matches the production labeled
; 7108 : 	 * content.
; 7109 : 	 */
; 7110 : 	if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+48], 1
	jne	SHORT $LN37@xmlParseRe

; 7111 : 	    ctxt->depth++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+248]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+248], ecx

; 7112 : 	    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,

	lea	eax, DWORD PTR _list$[ebp]
	push	eax
	mov	ecx, DWORD PTR _user_data$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseBalancedChunkMemoryInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 7113 : 	                                              user_data, &list);
; 7114 : 	    ctxt->depth--;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	sub	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+248], eax
	jmp	$LN38@xmlParseRe
$LN37@xmlParseRe:

; 7115 : 
; 7116 : 	} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+48], 2
	jne	SHORT $LN39@xmlParseRe

; 7117 : 	    ctxt->depth++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+248]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+248], ecx

; 7118 : 	    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,

	lea	eax, DWORD PTR _list$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	push	eax
	mov	ecx, DWORD PTR _user_data$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlParseExternalEntityPrivate
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ret$[ebp], eax

; 7119 : 	                                   user_data, ctxt->depth, ent->URI,
; 7120 : 					   ent->ExternalID, &list);
; 7121 : 	    ctxt->depth--;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+248]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+248], edx

; 7122 : 	} else {

	jmp	SHORT $LN38@xmlParseRe
$LN39@xmlParseRe:

; 7123 : 	    ret = XML_ERR_ENTITY_PE_INTERNAL;

	mov	DWORD PTR _ret$[ebp], 88		; 00000058H

; 7124 : 	    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	0
	push	OFFSET ??_C@_0BL@EBFCDHBG@invalid?5entity?5type?5found?6@
	push	1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMsgStr
	add	esp, 16					; 00000010H
$LN38@xmlParseRe:

; 7125 : 			 "invalid entity type found\n", NULL);
; 7126 : 	}
; 7127 : 
; 7128 : 	/*
; 7129 : 	 * Store the number of entities needing parsing for this entity
; 7130 : 	 * content and do checkings
; 7131 : 	 */
; 7132 : 	ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+440]
	sub	eax, DWORD PTR _oldnbent$12[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+72], ecx

; 7133 : 	if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN41@xmlParseRe
	push	60					; 0000003cH
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN41@xmlParseRe

; 7134 : 	    ent->checked |= 1;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	or	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+72], ecx
$LN41@xmlParseRe:

; 7135 : 	if (ret == XML_ERR_ENTITY_LOOP) {

	cmp	DWORD PTR _ret$[ebp], 89		; 00000059H
	jne	SHORT $LN42@xmlParseRe

; 7136 : 	    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);

	push	0
	push	89					; 00000059H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 7137 : 	    xmlFreeNodeList(list);

	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_xmlFreeNodeList
	add	esp, 4

; 7138 : 	    return;

	jmp	$LN1@xmlParseRe
$LN42@xmlParseRe:

; 7139 : 	}
; 7140 : 	if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {

	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN43@xmlParseRe

; 7141 : 	    xmlFreeNodeList(list);

	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_xmlFreeNodeList
	add	esp, 4

; 7142 : 	    return;

	jmp	$LN1@xmlParseRe
$LN43@xmlParseRe:

; 7143 : 	}
; 7144 : 
; 7145 : 	if ((ret == XML_ERR_OK) && (list != NULL)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN44@xmlParseRe
	cmp	DWORD PTR _list$[ebp], 0
	je	$LN44@xmlParseRe

; 7146 : 	    if (((ent->etype == XML_INTERNAL_GENERAL_ENTITY) ||
; 7147 : 	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&&

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+48], 1
	je	SHORT $LN48@xmlParseRe
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+48], 2
	jne	$LN46@xmlParseRe
$LN48@xmlParseRe:
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	$LN46@xmlParseRe

; 7148 : 		(ent->children == NULL)) {
; 7149 : 		ent->children = list;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx+12], eax

; 7150 : 		if (ctxt->replaceEntities) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	$LN49@xmlParseRe

; 7151 : 		    /*
; 7152 : 		     * Prune it directly in the generated document
; 7153 : 		     * except for single text nodes.
; 7154 : 		     */
; 7155 : 		    if (((list->type == XML_TEXT_NODE) &&
; 7156 : 			 (list->next == NULL)) ||

	mov	edx, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [edx+4], 3
	jne	SHORT $LN54@xmlParseRe
	mov	eax, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN53@xmlParseRe
$LN54@xmlParseRe:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+436], 5
	jne	SHORT $LN51@xmlParseRe
$LN53@xmlParseRe:

; 7157 : 			(ctxt->parseMode == XML_PARSE_READER)) {
; 7158 : 			list->parent = (xmlNodePtr) ent;

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+20], eax

; 7159 : 			list = NULL;

	mov	DWORD PTR _list$[ebp], 0

; 7160 : 			ent->owner = 1;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+68], 1

; 7161 : 		    } else {

	jmp	SHORT $LN52@xmlParseRe
$LN51@xmlParseRe:

; 7162 : 			ent->owner = 0;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+68], 0
$LN2@xmlParseRe:

; 7163 : 			while (list != NULL) {

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN3@xmlParseRe

; 7164 : 			    list->parent = (xmlNodePtr) ctxt->node;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+20], edx

; 7165 : 			    list->doc = ctxt->myDoc;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+32], edx

; 7166 : 			    if (list->next == NULL)

	mov	eax, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN55@xmlParseRe

; 7167 : 				ent->last = list;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [ecx+16], edx
$LN55@xmlParseRe:

; 7168 : 			    list = list->next;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _list$[ebp], ecx

; 7169 : 			}

	jmp	SHORT $LN2@xmlParseRe
$LN3@xmlParseRe:

; 7170 : 			list = ent->children;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _list$[ebp], eax

; 7171 : #ifdef LIBXML_LEGACY_ENABLED
; 7172 : 			if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+48], 2
	jne	SHORT $LN52@xmlParseRe

; 7173 : 			  xmlAddEntityReference(ent, list, NULL);

	push	0
	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_xmlAddEntityReference
	add	esp, 12					; 0000000cH
$LN52@xmlParseRe:

; 7174 : #endif /* LIBXML_LEGACY_ENABLED */
; 7175 : 		    }
; 7176 : 		} else {

	jmp	SHORT $LN50@xmlParseRe
$LN49@xmlParseRe:

; 7177 : 		    ent->owner = 1;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+68], 1
$LN4@xmlParseRe:

; 7178 : 		    while (list != NULL) {

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN50@xmlParseRe

; 7179 : 			list->parent = (xmlNodePtr) ent;

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+20], eax

; 7180 : 			xmlSetTreeDoc(list, ent->doc);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_xmlSetTreeDoc
	add	esp, 8

; 7181 : 			if (list->next == NULL)

	mov	ecx, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN57@xmlParseRe

; 7182 : 			    ent->last = list;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN57@xmlParseRe:

; 7183 : 			list = list->next;

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _list$[ebp], edx

; 7184 : 		    }

	jmp	SHORT $LN4@xmlParseRe
$LN50@xmlParseRe:

; 7185 : 		}
; 7186 : 	    } else {

	jmp	SHORT $LN47@xmlParseRe
$LN46@xmlParseRe:

; 7187 : 		xmlFreeNodeList(list);

	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_xmlFreeNodeList
	add	esp, 4

; 7188 : 		list = NULL;

	mov	DWORD PTR _list$[ebp], 0
$LN47@xmlParseRe:

; 7189 : 	    }

	jmp	SHORT $LN45@xmlParseRe
$LN44@xmlParseRe:

; 7190 : 	} else if ((ret != XML_ERR_OK) &&

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN58@xmlParseRe
	cmp	DWORD PTR _ret$[ebp], 27		; 0000001bH
	je	SHORT $LN58@xmlParseRe

; 7191 : 		   (ret != XML_WAR_UNDECLARED_ENTITY)) {
; 7192 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_0BN@EOPGEOPH@Entity?5?8?$CFs?8?5failed?5to?5parse?6@
	push	26					; 0000001aH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7193 : 		     "Entity '%s' failed to parse\n", ent->name);
; 7194 :             if (ent->content != NULL)

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN60@xmlParseRe

; 7195 :                 ent->content[0] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	BYTE PTR [eax+edx], 0
$LN60@xmlParseRe:

; 7196 : 	    xmlParserEntityCheck(ctxt, 0, ent, 0);

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	jmp	SHORT $LN45@xmlParseRe
$LN58@xmlParseRe:

; 7197 : 	} else if (list != NULL) {

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN45@xmlParseRe

; 7198 : 	    xmlFreeNodeList(list);

	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	call	_xmlFreeNodeList
	add	esp, 4

; 7199 : 	    list = NULL;

	mov	DWORD PTR _list$[ebp], 0
$LN45@xmlParseRe:

; 7200 : 	}
; 7201 : 	if (ent->checked == 0)

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+72], 0
	jne	SHORT $LN62@xmlParseRe

; 7202 : 	    ent->checked = 2;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+72], 2
$LN62@xmlParseRe:

; 7203 : 
; 7204 :         /* Prevent entity from being parsed and expanded twice (Bug 760367). */
; 7205 :         was_checked = 0;

	mov	DWORD PTR _was_checked$[ebp], 0
	jmp	SHORT $LN32@xmlParseRe
$LN31@xmlParseRe:

; 7206 :     } else if (ent->checked != 1) {

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+72], 1
	je	SHORT $LN32@xmlParseRe

; 7207 : 	ctxt->nbentities += ent->checked / 2;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [eax+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	eax, DWORD PTR [ecx+440]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+440], eax
$LN32@xmlParseRe:

; 7208 :     }
; 7209 : 
; 7210 :     /*
; 7211 :      * Now that the entity content has been gathered
; 7212 :      * provide it to the application, this can take different forms based
; 7213 :      * on the parsing modes.
; 7214 :      */
; 7215 :     if (ent->children == NULL) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	$LN64@xmlParseRe

; 7216 : 	/*
; 7217 : 	 * Probably running in SAX mode and the callbacks don't
; 7218 : 	 * build the entity content. So unless we already went
; 7219 : 	 * though parsing for first checking go though the entity
; 7220 : 	 * content to generate callbacks associated to the entity
; 7221 : 	 */
; 7222 : 	if (was_checked != 0) {

	cmp	DWORD PTR _was_checked$[ebp], 0
	je	$LN65@xmlParseRe

; 7223 : 	    void *user_data;
; 7224 : 	    /*
; 7225 : 	     * This is a bit hackish but this seems the best
; 7226 : 	     * way to make sure both SAX and DOM entity support
; 7227 : 	     * behaves okay.
; 7228 : 	     */
; 7229 : 	    if (ctxt->userData == ctxt)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _ctxt$[ebp]
	jne	SHORT $LN66@xmlParseRe

; 7230 : 		user_data = NULL;

	mov	DWORD PTR _user_data$10[ebp], 0
	jmp	SHORT $LN67@xmlParseRe
$LN66@xmlParseRe:

; 7231 : 	    else
; 7232 : 		user_data = ctxt->userData;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _user_data$10[ebp], ecx
$LN67@xmlParseRe:

; 7233 : 
; 7234 : 	    if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+48], 1
	jne	SHORT $LN68@xmlParseRe

; 7235 : 		ctxt->depth++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+248]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+248], ecx

; 7236 : 		ret = xmlParseBalancedChunkMemoryInternal(ctxt,

	push	0
	mov	eax, DWORD PTR _user_data$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseBalancedChunkMemoryInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 7237 : 				   ent->content, user_data, NULL);
; 7238 : 		ctxt->depth--;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+248]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+248], edx
	jmp	$LN69@xmlParseRe
$LN68@xmlParseRe:

; 7239 : 	    } else if (ent->etype ==

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+48], 2
	jne	SHORT $LN70@xmlParseRe

; 7240 : 		       XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
; 7241 : 		ctxt->depth++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+248], eax

; 7242 : 		ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,

	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+248]
	push	ecx
	mov	edx, DWORD PTR _user_data$10[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlParseExternalEntityPrivate
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ret$[ebp], eax

; 7243 : 			   ctxt->sax, user_data, ctxt->depth,
; 7244 : 			   ent->URI, ent->ExternalID, NULL);
; 7245 : 		ctxt->depth--;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	sub	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+248], eax

; 7246 : 	    } else {

	jmp	SHORT $LN69@xmlParseRe
$LN70@xmlParseRe:

; 7247 : 		ret = XML_ERR_ENTITY_PE_INTERNAL;

	mov	DWORD PTR _ret$[ebp], 88		; 00000058H

; 7248 : 		xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	0
	push	OFFSET ??_C@_0BL@EBFCDHBG@invalid?5entity?5type?5found?6@
	push	1
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMsgStr
	add	esp, 16					; 00000010H
$LN69@xmlParseRe:

; 7249 : 			     "invalid entity type found\n", NULL);
; 7250 : 	    }
; 7251 : 	    if (ret == XML_ERR_ENTITY_LOOP) {

	cmp	DWORD PTR _ret$[ebp], 89		; 00000059H
	jne	SHORT $LN65@xmlParseRe

; 7252 : 		xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);

	push	0
	push	89					; 00000059H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 7253 : 		return;

	jmp	$LN1@xmlParseRe
$LN65@xmlParseRe:

; 7254 : 	    }
; 7255 : 	}
; 7256 : 	if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
; 7257 : 	    (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN73@xmlParseRe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN73@xmlParseRe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN73@xmlParseRe
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN73@xmlParseRe

; 7258 : 	    /*
; 7259 : 	     * Entity reference callback comes second, it's somewhat
; 7260 : 	     * superfluous but a compatibility to historical behaviour
; 7261 : 	     */
; 7262 : 	    ctxt->sax->reference(ctxt->userData, ent->name);

	mov	esi, esp
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+64]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN73@xmlParseRe:

; 7263 : 	}
; 7264 : 	return;

	jmp	$LN1@xmlParseRe
$LN64@xmlParseRe:

; 7265 :     }
; 7266 : 
; 7267 :     /*
; 7268 :      * If we didn't get any children for the entity being built
; 7269 :      */
; 7270 :     if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
; 7271 : 	(ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN74@xmlParseRe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN74@xmlParseRe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN74@xmlParseRe
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN74@xmlParseRe

; 7272 : 	/*
; 7273 : 	 * Create a node.
; 7274 : 	 */
; 7275 : 	ctxt->sax->reference(ctxt->userData, ent->name);

	mov	esi, esp
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+64]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7276 : 	return;

	jmp	$LN1@xmlParseRe
$LN74@xmlParseRe:

; 7277 :     }
; 7278 : 
; 7279 :     if ((ctxt->replaceEntities) || (ent->children == NULL))  {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN76@xmlParseRe
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	$LN1@xmlParseRe
$LN76@xmlParseRe:

; 7280 : 	/*
; 7281 : 	 * There is a problem on the handling of _private for entities
; 7282 : 	 * (bug 155816): Should we copy the content of the field from
; 7283 : 	 * the entity (possibly overwriting some value set by the user
; 7284 : 	 * when a copy is created), should we leave it alone, or should
; 7285 : 	 * we try to take care of different situations?  The problem
; 7286 : 	 * is exacerbated by the usage of this field by the xmlReader.
; 7287 : 	 * To fix this bug, we look at _private on the created node
; 7288 : 	 * and, if it's NULL, we copy in whatever was in the entity.
; 7289 : 	 * If it's not NULL we leave it alone.  This is somewhat of a
; 7290 : 	 * hack - maybe we should have further tests to determine
; 7291 : 	 * what to do.
; 7292 : 	 */
; 7293 : 	if ((ctxt->node != NULL) && (ent->children != NULL)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$LN1@xmlParseRe
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	$LN1@xmlParseRe

; 7294 : 	    /*
; 7295 : 	     * Seems we are generating the DOM content, do
; 7296 : 	     * a simple tree copy for all references except the first
; 7297 : 	     * In the first occurrence list contains the replacement.
; 7298 : 	     */
; 7299 : 	    if (((list == NULL) && (ent->owner == 0)) ||

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN81@xmlParseRe
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN80@xmlParseRe
$LN81@xmlParseRe:
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+436], 5
	jne	$LN78@xmlParseRe
$LN80@xmlParseRe:

; 7300 : 		(ctxt->parseMode == XML_PARSE_READER)) {
; 7301 : 		xmlNodePtr nw = NULL, cur, firstChild = NULL;

	mov	DWORD PTR _nw$9[ebp], 0
	mov	DWORD PTR _firstChild$7[ebp], 0

; 7302 : 
; 7303 : 		/*
; 7304 : 		 * We are copying here, make sure there is no abuse
; 7305 : 		 */
; 7306 : 		ctxt->sizeentcopy += ent->length + 5;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+468]
	lea	edx, DWORD PTR [edx+ecx+5]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+468], edx

; 7307 : 		if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN82@xmlParseRe

; 7308 : 		    return;

	jmp	$LN1@xmlParseRe
$LN82@xmlParseRe:

; 7309 : 
; 7310 : 		/*
; 7311 : 		 * when operating on a reader, the entities definitions
; 7312 : 		 * are always owning the entities subtree.
; 7313 : 		if (ctxt->parseMode == XML_PARSE_READER)
; 7314 : 		    ent->owner = 1;
; 7315 : 		 */
; 7316 : 
; 7317 : 		cur = ent->children;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$8[ebp], eax
$LN6@xmlParseRe:

; 7318 : 		while (cur != NULL) {

	cmp	DWORD PTR _cur$8[ebp], 0
	je	$LN7@xmlParseRe

; 7319 : 		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);

	push	1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _cur$8[ebp]
	push	eax
	call	_xmlDocCopyNode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nw$9[ebp], eax

; 7320 : 		    if (nw != NULL) {

	cmp	DWORD PTR _nw$9[ebp], 0
	je	SHORT $LN83@xmlParseRe

; 7321 : 			if (nw->_private == NULL)

	mov	ecx, DWORD PTR _nw$9[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN84@xmlParseRe

; 7322 : 			    nw->_private = cur->_private;

	mov	edx, DWORD PTR _nw$9[ebp]
	mov	eax, DWORD PTR _cur$8[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
$LN84@xmlParseRe:

; 7323 : 			if (firstChild == NULL){

	cmp	DWORD PTR _firstChild$7[ebp], 0
	jne	SHORT $LN85@xmlParseRe

; 7324 : 			    firstChild = nw;

	mov	edx, DWORD PTR _nw$9[ebp]
	mov	DWORD PTR _firstChild$7[ebp], edx
$LN85@xmlParseRe:

; 7325 : 			}
; 7326 : 			nw = xmlAddChild(ctxt->node, nw);

	mov	eax, DWORD PTR _nw$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _nw$9[ebp], eax
$LN83@xmlParseRe:

; 7327 : 		    }
; 7328 : 		    if (cur == ent->last) {

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _cur$8[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN86@xmlParseRe

; 7329 : 			/*
; 7330 : 			 * needed to detect some strange empty
; 7331 : 			 * node cases in the reader tests
; 7332 : 			 */
; 7333 : 			if ((ctxt->parseMode == XML_PARSE_READER) &&
; 7334 : 			    (nw != NULL) &&
; 7335 : 			    (nw->type == XML_ELEMENT_NODE) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+436], 5
	jne	SHORT $LN87@xmlParseRe
	cmp	DWORD PTR _nw$9[ebp], 0
	je	SHORT $LN87@xmlParseRe
	mov	eax, DWORD PTR _nw$9[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN87@xmlParseRe
	mov	ecx, DWORD PTR _nw$9[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN87@xmlParseRe

; 7336 : 			    (nw->children == NULL))
; 7337 : 			    nw->extra = 1;

	mov	edx, 1
	mov	eax, DWORD PTR _nw$9[ebp]
	mov	WORD PTR [eax+58], dx
$LN87@xmlParseRe:

; 7338 : 
; 7339 : 			break;

	jmp	SHORT $LN7@xmlParseRe
$LN86@xmlParseRe:

; 7340 : 		    }
; 7341 : 		    cur = cur->next;

	mov	ecx, DWORD PTR _cur$8[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$8[ebp], edx

; 7342 : 		}

	jmp	$LN6@xmlParseRe
$LN7@xmlParseRe:

; 7343 : #ifdef LIBXML_LEGACY_ENABLED
; 7344 : 		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+48], 2
	jne	SHORT $LN88@xmlParseRe

; 7345 : 		  xmlAddEntityReference(ent, firstChild, nw);

	mov	ecx, DWORD PTR _nw$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _firstChild$7[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_xmlAddEntityReference
	add	esp, 12					; 0000000cH
$LN88@xmlParseRe:

; 7346 : #endif /* LIBXML_LEGACY_ENABLED */
; 7347 : 	    } else if ((list == NULL) || (ctxt->inputNr > 0)) {

	jmp	$LN79@xmlParseRe
$LN78@xmlParseRe:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN91@xmlParseRe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	jle	$LN89@xmlParseRe
$LN91@xmlParseRe:

; 7348 : 		xmlNodePtr nw = NULL, cur, next, last,

	mov	DWORD PTR _nw$6[ebp], 0

; 7349 : 			   firstChild = NULL;

	mov	DWORD PTR _firstChild$2[ebp], 0

; 7350 : 
; 7351 : 		/*
; 7352 : 		 * We are copying here, make sure there is no abuse
; 7353 : 		 */
; 7354 : 		ctxt->sizeentcopy += ent->length + 5;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+468]
	lea	eax, DWORD PTR [eax+edx+5]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+468], eax

; 7355 : 		if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+468]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN92@xmlParseRe

; 7356 : 		    return;

	jmp	$LN1@xmlParseRe
$LN92@xmlParseRe:

; 7357 : 
; 7358 : 		/*
; 7359 : 		 * Copy the entity child list and make it the new
; 7360 : 		 * entity child list. The goal is to make sure any
; 7361 : 		 * ID or REF referenced will be the one from the
; 7362 : 		 * document content and not the entity copy.
; 7363 : 		 */
; 7364 : 		cur = ent->children;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$5[ebp], ecx

; 7365 : 		ent->children = NULL;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+12], 0

; 7366 : 		last = ent->last;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _last$3[ebp], ecx

; 7367 : 		ent->last = NULL;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+16], 0
$LN8@xmlParseRe:

; 7368 : 		while (cur != NULL) {

	cmp	DWORD PTR _cur$5[ebp], 0
	je	$LN9@xmlParseRe

; 7369 : 		    next = cur->next;

	mov	eax, DWORD PTR _cur$5[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _next$4[ebp], ecx

; 7370 : 		    cur->next = NULL;

	mov	edx, DWORD PTR _cur$5[ebp]
	mov	DWORD PTR [edx+24], 0

; 7371 : 		    cur->parent = NULL;

	mov	eax, DWORD PTR _cur$5[ebp]
	mov	DWORD PTR [eax+20], 0

; 7372 : 		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);

	push	1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _cur$5[ebp]
	push	eax
	call	_xmlDocCopyNode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nw$6[ebp], eax

; 7373 : 		    if (nw != NULL) {

	cmp	DWORD PTR _nw$6[ebp], 0
	je	SHORT $LN93@xmlParseRe

; 7374 : 			if (nw->_private == NULL)

	mov	ecx, DWORD PTR _nw$6[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN94@xmlParseRe

; 7375 : 			    nw->_private = cur->_private;

	mov	edx, DWORD PTR _nw$6[ebp]
	mov	eax, DWORD PTR _cur$5[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
$LN94@xmlParseRe:

; 7376 : 			if (firstChild == NULL){

	cmp	DWORD PTR _firstChild$2[ebp], 0
	jne	SHORT $LN95@xmlParseRe

; 7377 : 			    firstChild = cur;

	mov	edx, DWORD PTR _cur$5[ebp]
	mov	DWORD PTR _firstChild$2[ebp], edx
$LN95@xmlParseRe:

; 7378 : 			}
; 7379 : 			xmlAddChild((xmlNodePtr) ent, nw);

	mov	eax, DWORD PTR _nw$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8

; 7380 : 			xmlAddChild(ctxt->node, cur);

	mov	edx, DWORD PTR _cur$5[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
$LN93@xmlParseRe:

; 7381 : 		    }
; 7382 : 		    if (cur == last)

	mov	edx, DWORD PTR _cur$5[ebp]
	cmp	edx, DWORD PTR _last$3[ebp]
	jne	SHORT $LN96@xmlParseRe

; 7383 : 			break;

	jmp	SHORT $LN9@xmlParseRe
$LN96@xmlParseRe:

; 7384 : 		    cur = next;

	mov	eax, DWORD PTR _next$4[ebp]
	mov	DWORD PTR _cur$5[ebp], eax

; 7385 : 		}

	jmp	$LN8@xmlParseRe
$LN9@xmlParseRe:

; 7386 : 		if (ent->owner == 0)

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN97@xmlParseRe

; 7387 : 		    ent->owner = 1;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+68], 1
$LN97@xmlParseRe:

; 7388 : #ifdef LIBXML_LEGACY_ENABLED
; 7389 : 		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+48], 2
	jne	SHORT $LN98@xmlParseRe

; 7390 : 		  xmlAddEntityReference(ent, firstChild, nw);

	mov	ecx, DWORD PTR _nw$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _firstChild$2[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_xmlAddEntityReference
	add	esp, 12					; 0000000cH
$LN98@xmlParseRe:

; 7391 : #endif /* LIBXML_LEGACY_ENABLED */
; 7392 : 	    } else {

	jmp	SHORT $LN79@xmlParseRe
$LN89@xmlParseRe:

; 7393 : 		const xmlChar *nbktext;
; 7394 : 
; 7395 : 		/*
; 7396 : 		 * the name change is to avoid coalescing of the
; 7397 : 		 * node with a possible previous text one which
; 7398 : 		 * would make ent->children a dangling pointer
; 7399 : 		 */
; 7400 : 		nbktext = xmlDictLookup(ctxt->dict, BAD_CAST "nbktext",

	push	-1
	push	OFFSET ??_C@_07DALNPEGO@nbktext@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nbktext$1[ebp], eax

; 7401 : 					-1);
; 7402 : 		if (ent->children->type == XML_TEXT_NODE)

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN99@xmlParseRe

; 7403 : 		    ent->children->name = nbktext;

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _nbktext$1[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN99@xmlParseRe:

; 7404 : 		if ((ent->last != ent->children) &&

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	cmp	ecx, DWORD PTR [eax+12]
	je	SHORT $LN100@xmlParseRe
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN100@xmlParseRe

; 7405 : 		    (ent->last->type == XML_TEXT_NODE))
; 7406 : 		    ent->last->name = nbktext;

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _nbktext$1[ebp]
	mov	DWORD PTR [edx+8], eax
$LN100@xmlParseRe:

; 7407 : 		xmlAddChildList(ctxt->node, ent->children);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_xmlAddChildList
	add	esp, 8
$LN79@xmlParseRe:

; 7408 : 	    }
; 7409 : 
; 7410 : 	    /*
; 7411 : 	     * This is to avoid a nasty side effect, see
; 7412 : 	     * characters() in SAX.c
; 7413 : 	     */
; 7414 : 	    ctxt->nodemem = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+264], 0

; 7415 : 	    ctxt->nodelen = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+260], 0
$LN1@xmlParseRe:

; 7416 : 	    return;
; 7417 : 	}
; 7418 :     }
; 7419 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN105@xmlParseRe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 108				; 0000006cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN105@xmlParseRe:
	DD	2
	DD	$LN104@xmlParseRe
$LN104@xmlParseRe:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN102@xmlParseRe
	DD	-48					; ffffffd0H
	DD	10					; 0000000aH
	DD	$LN103@xmlParseRe
$LN103@xmlParseRe:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$LN102@xmlParseRe:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_xmlParseReference ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEntityRef
_TEXT	SEGMENT
tv235 = -12						; size = 4
_ent$ = -8						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseEntityRef PROC					; COMDAT

; 7450 : xmlParseEntityRef(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 7451 :     const xmlChar *name;
; 7452 :     xmlEntityPtr ent = NULL;

	mov	DWORD PTR _ent$[ebp], 0

; 7453 : 
; 7454 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN4@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN4@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseEn:

; 7455 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN5@xmlParseEn

; 7456 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN5@xmlParseEn:

; 7457 : 
; 7458 :     if (RAW != '&')

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 38					; 00000026H
	je	SHORT $LN6@xmlParseEn

; 7459 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN6@xmlParseEn:

; 7460 :     NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 7461 :     name = xmlParseName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 7462 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN7@xmlParseEn

; 7463 : 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0BM@NMGBIIDP@xmlParseEntityRef?3?5no?5name?6@
	push	68					; 00000044H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 7464 : 		       "xmlParseEntityRef: no name\n");
; 7465 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN7@xmlParseEn:

; 7466 :     }
; 7467 :     if (RAW != ';') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 59					; 0000003bH
	je	SHORT $LN8@xmlParseEn

; 7468 : 	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);

	push	0
	push	23					; 00000017H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 7469 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN8@xmlParseEn:

; 7470 :     }
; 7471 :     NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 7472 : 
; 7473 :     /*
; 7474 :      * Predefined entities override any extra definition
; 7475 :      */
; 7476 :     if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 1048576				; 00100000H
	jne	SHORT $LN9@xmlParseEn

; 7477 :         ent = xmlGetPredefinedEntity(name);

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlGetPredefinedEntity
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 7478 :         if (ent != NULL)

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN9@xmlParseEn

; 7479 :             return(ent);

	mov	eax, DWORD PTR _ent$[ebp]
	jmp	$LN1@xmlParseEn
$LN9@xmlParseEn:

; 7480 :     }
; 7481 : 
; 7482 :     /*
; 7483 :      * Increase the number of entity references parsed
; 7484 :      */
; 7485 :     ctxt->nbentities++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+440]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+440], ecx

; 7486 : 
; 7487 :     /*
; 7488 :      * Ask first SAX for entity resolution, otherwise try the
; 7489 :      * entities which may have stored in the parser context.
; 7490 :      */
; 7491 :     if (ctxt->sax != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN11@xmlParseEn

; 7492 : 	if (ctxt->sax->getEntity != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN12@xmlParseEn

; 7493 : 	    ent = ctxt->sax->getEntity(ctxt->userData, name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ent$[ebp], eax
$LN12@xmlParseEn:

; 7494 : 	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+12], 1
	jne	SHORT $LN13@xmlParseEn
	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN13@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 1048576				; 00100000H
	je	SHORT $LN13@xmlParseEn

; 7495 : 	    (ctxt->options & XML_PARSE_OLDSAX))
; 7496 : 	    ent = xmlGetPredefinedEntity(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlGetPredefinedEntity
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax
$LN13@xmlParseEn:

; 7497 : 	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+12], 1
	jne	SHORT $LN11@xmlParseEn
	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN11@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _ctxt$[ebp]
	jne	SHORT $LN11@xmlParseEn

; 7498 : 	    (ctxt->userData==ctxt)) {
; 7499 : 	    ent = xmlSAX2GetEntity(ctxt, name);

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSAX2GetEntity
	add	esp, 8
	mov	DWORD PTR _ent$[ebp], eax
$LN11@xmlParseEn:

; 7500 : 	}
; 7501 :     }
; 7502 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN15@xmlParseEn

; 7503 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN15@xmlParseEn:

; 7504 :     /*
; 7505 :      * [ WFC: Entity Declared ]
; 7506 :      * In a document without any DTD, a document with only an
; 7507 :      * internal DTD subset which contains no parameter entity
; 7508 :      * references, or a document with "standalone='yes'", the
; 7509 :      * Name given in the entity reference must match that in an
; 7510 :      * entity declaration, except that well-formed documents
; 7511 :      * need not declare any of the following entities: amp, lt,
; 7512 :      * gt, apos, quot.
; 7513 :      * The declaration of a parameter entity must precede any
; 7514 :      * reference to it.
; 7515 :      * Similarly, the declaration of a general entity must
; 7516 :      * precede any reference to it which appears in a default
; 7517 :      * value in an attribute-list declaration. Note that if
; 7518 :      * entities are declared in the external subset or in
; 7519 :      * external parameter entities, a non-validating processor
; 7520 :      * is not obligated to read and process their declarations;
; 7521 :      * for such documents, the rule that an entity must be
; 7522 :      * declared is a well-formedness constraint only if
; 7523 :      * standalone='yes'.
; 7524 :      */
; 7525 :     if (ent == NULL) {

	cmp	DWORD PTR _ent$[ebp], 0
	jne	$LN16@xmlParseEn

; 7526 : 	if ((ctxt->standalone == 1) ||

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+28], 1
	je	SHORT $LN20@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+88], 0
	jne	SHORT $LN18@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+92], 0
	jne	SHORT $LN18@xmlParseEn
$LN20@xmlParseEn:

; 7527 : 	    ((ctxt->hasExternalSubset == 0) &&
; 7528 : 	     (ctxt->hasPErefs == 0))) {
; 7529 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@
	push	26					; 0000001aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7530 : 		     "Entity '%s' not defined\n", name);
; 7531 : 	} else {

	jmp	SHORT $LN19@xmlParseEn
$LN18@xmlParseEn:

; 7532 : 	    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@KIKIJMLK@Entity?5?8?$CFs?8?5not?5defined?6@
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMsgStr
	add	esp, 16					; 00000010H

; 7533 : 		     "Entity '%s' not defined\n", name);
; 7534 : 	    if ((ctxt->inSubset == 0) &&
; 7535 : 		(ctxt->sax != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+216], 0
	jne	SHORT $LN19@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN19@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $LN19@xmlParseEn

; 7536 : 		(ctxt->sax->reference != NULL)) {
; 7537 : 		ctxt->sax->reference(ctxt->userData, name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+64]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@xmlParseEn:

; 7538 : 	    }
; 7539 : 	}
; 7540 : 	xmlParserEntityCheck(ctxt, 0, ent, 0);

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParserEntityCheck
	add	esp, 16					; 00000010H

; 7541 : 	ctxt->valid = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+100], 0

; 7542 :     }

	jmp	$LN17@xmlParseEn
$LN16@xmlParseEn:

; 7543 : 
; 7544 :     /*
; 7545 :      * [ WFC: Parsed Entity ]
; 7546 :      * An entity reference must not contain the name of an
; 7547 :      * unparsed entity
; 7548 :      */
; 7549 :     else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+48], 3
	jne	SHORT $LN22@xmlParseEn

; 7550 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@ILCMJJAO@Entity?5reference?5to?5unparsed?5en@
	push	28					; 0000001cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7551 : 		 "Entity reference to unparsed entity %s\n", name);
; 7552 :     }

	jmp	$LN17@xmlParseEn
$LN22@xmlParseEn:

; 7553 : 
; 7554 :     /*
; 7555 :      * [ WFC: No External Entity References ]
; 7556 :      * Attribute values cannot contain direct or indirect
; 7557 :      * entity references to external entities.
; 7558 :      */
; 7559 :     else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], 12			; 0000000cH
	jne	SHORT $LN24@xmlParseEn
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+48], 2
	jne	SHORT $LN24@xmlParseEn

; 7560 : 	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
; 7561 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0CL@HLODLGOA@Attribute?5references?5external?5e@
	push	29					; 0000001dH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 7562 : 	     "Attribute references external entity '%s'\n", name);
; 7563 :     }

	jmp	$LN17@xmlParseEn
$LN24@xmlParseEn:

; 7564 :     /*
; 7565 :      * [ WFC: No < in Attribute Values ]
; 7566 :      * The replacement text of any entity referred to directly or
; 7567 :      * indirectly in an attribute value (other than "&lt;") must
; 7568 :      * not contain a <.
; 7569 :      */
; 7570 :     else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
; 7571 : 	     (ent != NULL) && 

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], 12			; 0000000cH
	jne	SHORT $LN26@xmlParseEn
	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN26@xmlParseEn
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+48], 6
	je	SHORT $LN26@xmlParseEn

; 7572 : 	     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
; 7573 : 	if (((ent->checked & 1) || (ent->checked == 0)) &&
; 7574 : 	     (ent->content != NULL) && (xmlStrchr(ent->content, '<'))) {

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	and	ecx, 1
	jne	SHORT $LN29@xmlParseEn
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+72], 0
	jne	SHORT $LN28@xmlParseEn
$LN29@xmlParseEn:
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN28@xmlParseEn
	push	60					; 0000003cH
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@xmlParseEn

; 7575 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DI@FDECCCAO@?8?$DM?8?5in?5entity?5?8?$CFs?8?5is?5not?5allow@
	push	38					; 00000026H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN28@xmlParseEn:

; 7576 : 	"'<' in entity '%s' is not allowed in attributes values\n", name);
; 7577 :         }
; 7578 :     }

	jmp	SHORT $LN17@xmlParseEn
$LN26@xmlParseEn:

; 7579 : 
; 7580 :     /*
; 7581 :      * Internal check, no parameter entities here ...
; 7582 :      */
; 7583 :     else {
; 7584 : 	switch (ent->etype) {

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR tv235[ebp], eax
	cmp	DWORD PTR tv235[ebp], 4
	jl	SHORT $LN17@xmlParseEn
	cmp	DWORD PTR tv235[ebp], 5
	jle	SHORT $LN30@xmlParseEn
	jmp	SHORT $LN17@xmlParseEn
$LN30@xmlParseEn:

; 7585 : 	    case XML_INTERNAL_PARAMETER_ENTITY:
; 7586 : 	    case XML_EXTERNAL_PARAMETER_ENTITY:
; 7587 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DA@CCPGIFBP@Attempt?5to?5reference?5the?5parame@
	push	30					; 0000001eH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN17@xmlParseEn:

; 7588 : 	     "Attempt to reference the parameter entity '%s'\n",
; 7589 : 			      name);
; 7590 : 	    break;
; 7591 : 	    default:
; 7592 : 	    break;
; 7593 : 	}
; 7594 :     }
; 7595 : 
; 7596 :     /*
; 7597 :      * [ WFC: No Recursion ]
; 7598 :      * A parsed entity must not contain a recursive reference
; 7599 :      * to itself, either directly or indirectly.
; 7600 :      * Done somewhere else
; 7601 :      */
; 7602 :     return(ent);

	mov	eax, DWORD PTR _ent$[ebp]
$LN1@xmlParseEn:

; 7603 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseEntityRef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCharRef
_TEXT	SEGMENT
tv372 = -40						; size = 4
tv374 = -36						; size = 4
tv373 = -32						; size = 4
tv299 = -28						; size = 4
tv298 = -24						; size = 4
tv152 = -20						; size = 4
tv151 = -16						; size = 4
_outofrange$ = -12					; size = 4
_count$ = -8						; size = 4
_val$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseCharRef PROC					; COMDAT

; 2285 : xmlParseCharRef(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2286 :     unsigned int val = 0;

	mov	DWORD PTR _val$[ebp], 0

; 2287 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 2288 :     unsigned int outofrange = 0;

	mov	DWORD PTR _outofrange$[ebp], 0

; 2289 : 
; 2290 :     /*
; 2291 :      * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
; 2292 :      */
; 2293 :     if ((RAW == '&') && (NXT(1) == '#') &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 38					; 00000026H
	jne	$LN12@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 35					; 00000023H
	jne	$LN12@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 120				; 00000078H
	jne	$LN12@xmlParseCh
$LN4@xmlParseCh:

; 2294 :         (NXT(2) == 'x')) {
; 2295 : 	SKIP(3);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN2@xmlParseCh
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseCh:
	xor	eax, eax
	jne	SHORT $LN4@xmlParseCh

; 2296 : 	GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN5@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN5@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN5@xmlParseCh:

; 2297 : 	while (RAW != ';') { /* loop blocked by count */

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	$LN6@xmlParseCh

; 2298 : 	    if (count++ > 20) {

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv151[ebp], eax
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	cmp	DWORD PTR tv151[ebp], 20		; 00000014H
	jle	SHORT $LN41@xmlParseCh
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN42@xmlParseCh
$LN41@xmlParseCh:
	mov	DWORD PTR tv152[ebp], 0
$LN42@xmlParseCh:
	cmp	DWORD PTR tv152[ebp], 0
	je	SHORT $LN16@xmlParseCh

; 2299 : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 2300 : 		GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN17@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN17@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN17@xmlParseCh:

; 2301 :                 if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN16@xmlParseCh

; 2302 :                     return(0);

	xor	eax, eax
	jmp	$LN1@xmlParseCh
$LN16@xmlParseCh:

; 2303 : 	    }
; 2304 : 	    if ((RAW >= '0') && (RAW <= '9'))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN19@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN19@xmlParseCh

; 2305 : 	        val = val * 16 + (CUR - '0');

	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-48]
	mov	DWORD PTR _val$[ebp], eax
	jmp	$LN20@xmlParseCh
$LN19@xmlParseCh:

; 2306 : 	    else if ((RAW >= 'a') && (RAW <= 'f') && (count < 20))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN21@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 102				; 00000066H
	jg	SHORT $LN21@xmlParseCh
	cmp	DWORD PTR _count$[ebp], 20		; 00000014H
	jge	SHORT $LN21@xmlParseCh

; 2307 : 	        val = val * 16 + (CUR - 'a') + 10;

	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-87]
	mov	DWORD PTR _val$[ebp], eax
	jmp	SHORT $LN20@xmlParseCh
$LN21@xmlParseCh:

; 2308 : 	    else if ((RAW >= 'A') && (RAW <= 'F') && (count < 20))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN23@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 70					; 00000046H
	jg	SHORT $LN23@xmlParseCh
	cmp	DWORD PTR _count$[ebp], 20		; 00000014H
	jge	SHORT $LN23@xmlParseCh

; 2309 : 	        val = val * 16 + (CUR - 'A') + 10;

	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-55]
	mov	DWORD PTR _val$[ebp], eax
	jmp	SHORT $LN20@xmlParseCh
$LN23@xmlParseCh:

; 2310 : 	    else {
; 2311 : 		xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);

	push	0
	push	6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2312 : 		val = 0;

	mov	DWORD PTR _val$[ebp], 0

; 2313 : 		break;

	jmp	SHORT $LN6@xmlParseCh
$LN20@xmlParseCh:

; 2314 : 	    }
; 2315 : 	    if (val > 0x10FFFF)

	cmp	DWORD PTR _val$[ebp], 1114111		; 0010ffffH
	jbe	SHORT $LN25@xmlParseCh

; 2316 : 	        outofrange = val;

	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _outofrange$[ebp], edx
$LN25@xmlParseCh:

; 2317 : 
; 2318 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 2319 : 	    count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 2320 : 	}

	jmp	$LN5@xmlParseCh
$LN6@xmlParseCh:

; 2321 : 	if (RAW == ';') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	jne	SHORT $LN26@xmlParseCh

; 2322 : 	    /* on purpose to avoid reentrancy problems with NEXT and SKIP */
; 2323 : 	    ctxt->input->col++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx

; 2324 : 	    ctxt->nbChars ++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax

; 2325 : 	    ctxt->input->cur++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
$LN26@xmlParseCh:

; 2326 : 	}

	jmp	$LN13@xmlParseCh
$LN12@xmlParseCh:

; 2327 :     } else if  ((RAW == '&') && (NXT(1) == '#')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 38					; 00000026H
	jne	$LN27@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	jne	$LN27@xmlParseCh
$LN9@xmlParseCh:

; 2328 : 	SKIP(2);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN7@xmlParseCh
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN7@xmlParseCh:
	xor	edx, edx
	jne	SHORT $LN9@xmlParseCh

; 2329 : 	GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN10@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN10@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN10@xmlParseCh:

; 2330 : 	while (RAW != ';') { /* loop blocked by count */

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	je	$LN11@xmlParseCh

; 2331 : 	    if (count++ > 20) {

	mov	edx, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv298[ebp], edx
	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
	cmp	DWORD PTR tv298[ebp], 20		; 00000014H
	jle	SHORT $LN43@xmlParseCh
	mov	DWORD PTR tv299[ebp], 1
	jmp	SHORT $LN44@xmlParseCh
$LN43@xmlParseCh:
	mov	DWORD PTR tv299[ebp], 0
$LN44@xmlParseCh:
	cmp	DWORD PTR tv299[ebp], 0
	je	SHORT $LN31@xmlParseCh

; 2332 : 		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 2333 : 		GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN32@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN32@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN32@xmlParseCh:

; 2334 :                 if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN31@xmlParseCh

; 2335 :                     return(0);

	xor	eax, eax
	jmp	$LN1@xmlParseCh
$LN31@xmlParseCh:

; 2336 : 	    }
; 2337 : 	    if ((RAW >= '0') && (RAW <= '9'))

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN34@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN34@xmlParseCh

; 2338 : 	        val = val * 10 + (CUR - '0');

	imul	edx, DWORD PTR _val$[ebp], 10
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax]
	lea	edx, DWORD PTR [edx+ecx-48]
	mov	DWORD PTR _val$[ebp], edx
	jmp	SHORT $LN35@xmlParseCh
$LN34@xmlParseCh:

; 2339 : 	    else {
; 2340 : 		xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);

	push	0
	push	7
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 2341 : 		val = 0;

	mov	DWORD PTR _val$[ebp], 0

; 2342 : 		break;

	jmp	SHORT $LN11@xmlParseCh
$LN35@xmlParseCh:

; 2343 : 	    }
; 2344 : 	    if (val > 0x10FFFF)

	cmp	DWORD PTR _val$[ebp], 1114111		; 0010ffffH
	jbe	SHORT $LN36@xmlParseCh

; 2345 : 	        outofrange = val;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _outofrange$[ebp], ecx
$LN36@xmlParseCh:

; 2346 : 
; 2347 : 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 2348 : 	    count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 2349 : 	}

	jmp	$LN10@xmlParseCh
$LN11@xmlParseCh:

; 2350 : 	if (RAW == ';') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	jne	SHORT $LN37@xmlParseCh

; 2351 : 	    /* on purpose to avoid reentrancy problems with NEXT and SKIP */
; 2352 : 	    ctxt->input->col++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx

; 2353 : 	    ctxt->nbChars ++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx

; 2354 : 	    ctxt->input->cur++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
$LN37@xmlParseCh:

; 2355 : 	}
; 2356 :     } else {

	jmp	SHORT $LN13@xmlParseCh
$LN27@xmlParseCh:

; 2357 :         xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);

	push	0
	push	8
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN13@xmlParseCh:

; 2358 :     }
; 2359 : 
; 2360 :     /*
; 2361 :      * [ WFC: Legal Character ]
; 2362 :      * Characters referred to using character references must match the
; 2363 :      * production for Char.
; 2364 :      */
; 2365 :     if ((IS_CHAR(val) && (outofrange == 0))) {

	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jae	SHORT $LN53@xmlParseCh
	cmp	DWORD PTR _val$[ebp], 9
	jb	SHORT $LN45@xmlParseCh
	cmp	DWORD PTR _val$[ebp], 10		; 0000000aH
	jbe	SHORT $LN46@xmlParseCh
$LN45@xmlParseCh:
	cmp	DWORD PTR _val$[ebp], 13		; 0000000dH
	je	SHORT $LN46@xmlParseCh
	cmp	DWORD PTR _val$[ebp], 32		; 00000020H
	jae	SHORT $LN46@xmlParseCh
	mov	DWORD PTR tv373[ebp], 0
	jmp	SHORT $LN52@xmlParseCh
$LN46@xmlParseCh:
	mov	DWORD PTR tv373[ebp], 1
$LN52@xmlParseCh:
	mov	ecx, DWORD PTR tv373[ebp]
	mov	DWORD PTR tv374[ebp], ecx
	jmp	SHORT $LN54@xmlParseCh
$LN53@xmlParseCh:
	cmp	DWORD PTR _val$[ebp], 256		; 00000100H
	jb	SHORT $LN47@xmlParseCh
	cmp	DWORD PTR _val$[ebp], 55295		; 0000d7ffH
	jbe	SHORT $LN49@xmlParseCh
$LN47@xmlParseCh:
	cmp	DWORD PTR _val$[ebp], 57344		; 0000e000H
	jb	SHORT $LN48@xmlParseCh
	cmp	DWORD PTR _val$[ebp], 65533		; 0000fffdH
	jbe	SHORT $LN49@xmlParseCh
$LN48@xmlParseCh:
	cmp	DWORD PTR _val$[ebp], 65536		; 00010000H
	jb	SHORT $LN50@xmlParseCh
	cmp	DWORD PTR _val$[ebp], 1114111		; 0010ffffH
	jbe	SHORT $LN49@xmlParseCh
$LN50@xmlParseCh:
	mov	DWORD PTR tv372[ebp], 0
	jmp	SHORT $LN51@xmlParseCh
$LN49@xmlParseCh:
	mov	DWORD PTR tv372[ebp], 1
$LN51@xmlParseCh:
	mov	edx, DWORD PTR tv372[ebp]
	mov	DWORD PTR tv374[ebp], edx
$LN54@xmlParseCh:
	cmp	DWORD PTR tv374[ebp], 0
	je	SHORT $LN38@xmlParseCh
	cmp	DWORD PTR _outofrange$[ebp], 0
	jne	SHORT $LN38@xmlParseCh

; 2366 :         return(val);

	mov	eax, DWORD PTR _val$[ebp]
	jmp	SHORT $LN1@xmlParseCh

; 2367 :     } else {

	jmp	SHORT $LN39@xmlParseCh
$LN38@xmlParseCh:

; 2368 :         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@KEGPHPPF@xmlParseCharRef?3?5invalid?5xmlCha@
	push	9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H
$LN39@xmlParseCh:

; 2369 :                           "xmlParseCharRef: invalid xmlChar value %d\n",
; 2370 : 	                  val);
; 2371 :     }
; 2372 :     return(0);

	xor	eax, eax
$LN1@xmlParseCh:

; 2373 : }

	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCharRef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseMarkupDecl
_TEXT	SEGMENT
tv89 = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseMarkupDecl PROC				; COMDAT

; 6784 : xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 6785 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN4@xmlParseMa
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN4@xmlParseMa
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseMa:

; 6786 :     if (CUR == '<') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	$LN5@xmlParseMa

; 6787 :         if (NXT(1) == '!') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	jne	$LN6@xmlParseMa

; 6788 : 	    switch (NXT(2)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR tv89[ebp], edx
	mov	eax, DWORD PTR tv89[ebp]
	sub	eax, 45					; 0000002dH
	mov	DWORD PTR tv89[ebp], eax
	cmp	DWORD PTR tv89[ebp], 33			; 00000021H
	ja	$LN2@xmlParseMa
	mov	ecx, DWORD PTR tv89[ebp]
	movzx	edx, BYTE PTR $LN21@xmlParseMa[ecx]
	jmp	DWORD PTR $LN22@xmlParseMa[edx*4]
$LN8@xmlParseMa:

; 6789 : 	        case 'E':
; 6790 : 		    if (NXT(3) == 'L')

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 76					; 0000004cH
	jne	SHORT $LN9@xmlParseMa

; 6791 : 			xmlParseElementDecl(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseElementDecl
	add	esp, 4
	jmp	SHORT $LN10@xmlParseMa
$LN9@xmlParseMa:

; 6792 : 		    else if (NXT(3) == 'N')

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 78					; 0000004eH
	jne	SHORT $LN10@xmlParseMa

; 6793 : 			xmlParseEntityDecl(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseEntityDecl
	add	esp, 4
$LN10@xmlParseMa:

; 6794 : 		    break;

	jmp	SHORT $LN2@xmlParseMa
$LN12@xmlParseMa:

; 6795 : 	        case 'A':
; 6796 : 		    xmlParseAttributeListDecl(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseAttributeListDecl
	add	esp, 4

; 6797 : 		    break;

	jmp	SHORT $LN2@xmlParseMa
$LN13@xmlParseMa:

; 6798 : 	        case 'N':
; 6799 : 		    xmlParseNotationDecl(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseNotationDecl
	add	esp, 4

; 6800 : 		    break;

	jmp	SHORT $LN2@xmlParseMa
$LN14@xmlParseMa:

; 6801 : 	        case '-':
; 6802 : 		    xmlParseComment(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseComment
	add	esp, 4
$LN2@xmlParseMa:

; 6803 : 		    break;
; 6804 : 		default:
; 6805 : 		    /* there is an error but it will be detected later */
; 6806 : 		    break;
; 6807 : 	    }
; 6808 : 	} else if (NXT(1) == '?') {

	jmp	SHORT $LN5@xmlParseMa
$LN6@xmlParseMa:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN5@xmlParseMa

; 6809 : 	    xmlParsePI(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParsePI
	add	esp, 4
$LN5@xmlParseMa:

; 6810 : 	}
; 6811 :     }
; 6812 : 
; 6813 :     /*
; 6814 :      * detect requirement to exit there and act accordingly
; 6815 :      * and avoid having instate overriden later on
; 6816 :      */
; 6817 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN17@xmlParseMa

; 6818 :         return;

	jmp	SHORT $LN1@xmlParseMa
$LN17@xmlParseMa:

; 6819 : 
; 6820 :     /*
; 6821 :      * Conditional sections are allowed from entities included
; 6822 :      * by PE References in the internal subset.
; 6823 :      */
; 6824 :     if ((ctxt->external == 0) && (ctxt->inputNr > 1)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+96], 0
	jne	SHORT $LN18@xmlParseMa
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 1
	jle	SHORT $LN18@xmlParseMa

; 6825 :         if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 60					; 0000003cH
	jne	SHORT $LN18@xmlParseMa
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	SHORT $LN18@xmlParseMa
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 91					; 0000005bH
	jne	SHORT $LN18@xmlParseMa

; 6826 : 	    xmlParseConditionalSections(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseConditionalSections
	add	esp, 4
$LN18@xmlParseMa:

; 6827 : 	}
; 6828 :     }
; 6829 : 
; 6830 :     ctxt->instate = XML_PARSER_DTD;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 3
$LN1@xmlParseMa:

; 6831 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@xmlParseMa:
	DD	$LN14@xmlParseMa
	DD	$LN12@xmlParseMa
	DD	$LN8@xmlParseMa
	DD	$LN13@xmlParseMa
	DD	$LN2@xmlParseMa
$LN21@xmlParseMa:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_xmlParseMarkupDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElementDecl
_TEXT	SEGMENT
_inputid$1 = -24					; size = 4
_content$ = -16						; size = 4
_ret$ = -8						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseElementDecl PROC				; COMDAT

; 6510 : xmlParseElementDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 6511 :     const xmlChar *name;
; 6512 :     int ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 6513 :     xmlElementContentPtr content  = NULL;

	mov	DWORD PTR _content$[ebp], 0

; 6514 : 
; 6515 :     /* GROW; done in the caller */
; 6516 :     if (CMP9(CUR_PTR, '<', '!', 'E', 'L', 'E', 'M', 'E', 'N', 'T')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 60					; 0000003cH
	jne	$LN11@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	$LN11@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 69					; 00000045H
	jne	$LN11@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 76					; 0000004cH
	jne	$LN11@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 69					; 00000045H
	jne	$LN11@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 77					; 0000004dH
	jne	$LN11@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 69					; 00000045H
	jne	$LN11@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 7
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 78					; 0000004eH
	jne	$LN11@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 84					; 00000054H
	jne	$LN11@xmlParseEl

; 6517 : 	int inputid = ctxt->input->id;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _inputid$1[ebp], ecx
$LN4@xmlParseEl:

; 6518 : 
; 6519 : 	SKIP(9);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 9
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN2@xmlParseEl
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEl:
	xor	eax, eax
	jne	SHORT $LN4@xmlParseEl

; 6520 : 	if (SKIP_BLANKS == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@xmlParseEl

; 6521 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CA@CIGPNPNK@Space?5required?5after?5?8ELEMENT?8?6@
	push	65					; 00000041H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 6522 : 		           "Space required after 'ELEMENT'\n");
; 6523 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseEl
$LN13@xmlParseEl:

; 6524 : 	}
; 6525 :         name = xmlParseName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 6526 : 	if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN14@xmlParseEl

; 6527 : 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CK@LMDMNJGO@xmlParseElementDecl?3?5no?5name?5fo@
	push	68					; 00000044H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 6528 : 			   "xmlParseElementDecl: no name for Element\n");
; 6529 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseEl
$LN14@xmlParseEl:

; 6530 : 	}
; 6531 : 	if (SKIP_BLANKS == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@xmlParseEl

; 6532 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CH@MFBAJJC@Space?5required?5after?5the?5elemen@
	push	65					; 00000041H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN15@xmlParseEl:

; 6533 : 			   "Space required after the element name\n");
; 6534 : 	}
; 6535 : 	if (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 69					; 00000045H
	jne	$LN16@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 77					; 0000004dH
	jne	$LN16@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 80					; 00000050H
	jne	$LN16@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 84					; 00000054H
	jne	$LN16@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN16@xmlParseEl
$LN7@xmlParseEl:

; 6536 : 	    SKIP(5);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 5
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 5
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 5
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN5@xmlParseEl
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseEl:
	xor	edx, edx
	jne	SHORT $LN7@xmlParseEl

; 6537 : 	    /*
; 6538 : 	     * Element must always be empty.
; 6539 : 	     */
; 6540 : 	    ret = XML_ELEMENT_TYPE_EMPTY;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	$LN17@xmlParseEl
$LN16@xmlParseEl:

; 6541 : 	} else if ((RAW == 'A') && (NXT(1) == 'N') &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 65					; 00000041H
	jne	$LN19@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 78					; 0000004eH
	jne	$LN19@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN19@xmlParseEl
$LN10@xmlParseEl:

; 6542 : 	           (NXT(2) == 'Y')) {
; 6543 : 	    SKIP(3);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 3
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN8@xmlParseEl
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN8@xmlParseEl:
	xor	eax, eax
	jne	SHORT $LN10@xmlParseEl

; 6544 : 	    /*
; 6545 : 	     * Element is a generic container.
; 6546 : 	     */
; 6547 : 	    ret = XML_ELEMENT_TYPE_ANY;

	mov	DWORD PTR _ret$[ebp], 2
	jmp	SHORT $LN17@xmlParseEl
$LN19@xmlParseEl:

; 6548 : 	} else if (RAW == '(') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	jne	SHORT $LN22@xmlParseEl

; 6549 : 	    ret = xmlParseElementContentDecl(ctxt, name, &content);

	lea	edx, DWORD PTR _content$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseElementContentDecl
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 6550 : 	} else {

	jmp	SHORT $LN17@xmlParseEl
$LN22@xmlParseEl:

; 6551 : 	    /*
; 6552 : 	     * [ WFC: PEs in Internal Subset ] error handling.
; 6553 : 	     */
; 6554 : 	    if ((RAW == '%') && (ctxt->external == 0) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	SHORT $LN24@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+96], 0
	jne	SHORT $LN24@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 1
	jne	SHORT $LN24@xmlParseEl

; 6555 : 	        (ctxt->inputNr == 1)) {
; 6556 : 		xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,

	push	OFFSET ??_C@_0DO@COHAOPDG@PEReference?3?5forbidden?5within?5m@
	push	21					; 00000015H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 6557 : 	  "PEReference: forbidden within markup decl in internal subset\n");
; 6558 : 	    } else {

	jmp	SHORT $LN25@xmlParseEl
$LN24@xmlParseEl:

; 6559 : 		xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,

	push	OFFSET ??_C@_0DF@CHNHOLDO@xmlParseElementDecl?3?5?8EMPTY?8?0?5?8@
	push	54					; 00000036H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN25@xmlParseEl:

; 6560 : 		      "xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n");
; 6561 :             }
; 6562 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseEl
$LN17@xmlParseEl:

; 6563 : 	}
; 6564 : 
; 6565 : 	SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6566 : 
; 6567 : 	if (RAW != '>') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	je	SHORT $LN26@xmlParseEl

; 6568 : 	    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);

	push	0
	push	73					; 00000049H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6569 : 	    if (content != NULL) {

	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN28@xmlParseEl

; 6570 : 		xmlFreeDocElementContent(ctxt->myDoc, content);

	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN28@xmlParseEl:

; 6571 : 	    }
; 6572 : 	} else {

	jmp	$LN11@xmlParseEl
$LN26@xmlParseEl:

; 6573 : 	    if (inputid != ctxt->input->id) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _inputid$1[ebp]
	cmp	eax, DWORD PTR [edx+56]
	je	SHORT $LN29@xmlParseEl

; 6574 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DP@KIKIPMFE@Element?5declaration?5doesn?8t?5sta@
	push	90					; 0000005aH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN29@xmlParseEl:

; 6575 :                                "Element declaration doesn't start and stop in"
; 6576 :                                " the same entity\n");
; 6577 : 	    }
; 6578 : 
; 6579 : 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 6580 : 	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN30@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN30@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN30@xmlParseEl

; 6581 : 		(ctxt->sax->elementDecl != NULL)) {
; 6582 : 		if (content != NULL)

	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN32@xmlParseEl

; 6583 : 		    content->parent = NULL;

	mov	ecx, DWORD PTR _content$[ebp]
	mov	DWORD PTR [ecx+20], 0
$LN32@xmlParseEl:

; 6584 : 	        ctxt->sax->elementDecl(ctxt->userData, name, ret,

	mov	esi, esp
	mov	edx, DWORD PTR _content$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6585 : 		                       content);
; 6586 : 		if ((content != NULL) && (content->parent == NULL)) {

	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN33@xmlParseEl
	mov	ecx, DWORD PTR _content$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN33@xmlParseEl

; 6587 : 		    /*
; 6588 : 		     * this is a trick: if xmlAddElementDecl is called,
; 6589 : 		     * instead of copying the full tree it is plugged directly
; 6590 : 		     * if called from the parser. Avoid duplicating the
; 6591 : 		     * interfaces or change the API/ABI
; 6592 : 		     */
; 6593 : 		    xmlFreeDocElementContent(ctxt->myDoc, content);

	mov	edx, DWORD PTR _content$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN33@xmlParseEl:

; 6594 : 		}

	jmp	SHORT $LN11@xmlParseEl
$LN30@xmlParseEl:

; 6595 : 	    } else if (content != NULL) {

	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN11@xmlParseEl

; 6596 : 		xmlFreeDocElementContent(ctxt->myDoc, content);

	mov	edx, DWORD PTR _content$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8
$LN11@xmlParseEl:

; 6597 : 	    }
; 6598 : 	}
; 6599 :     }
; 6600 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseEl:

; 6601 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN38@xmlParseEl
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN38@xmlParseEl:
	DD	1
	DD	$LN37@xmlParseEl
$LN37@xmlParseEl:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN36@xmlParseEl
$LN36@xmlParseEl:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
_xmlParseElementDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElementContentDecl
_TEXT	SEGMENT
_res$ = -12						; size = 4
_inputid$ = -8						; size = 4
_tree$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_result$ = 16						; size = 4
_xmlParseElementContentDecl PROC			; COMDAT

; 6466 :                            xmlElementContentPtr *result) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 6467 : 
; 6468 :     xmlElementContentPtr tree = NULL;

	mov	DWORD PTR _tree$[ebp], 0

; 6469 :     int inputid = ctxt->input->id;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _inputid$[ebp], edx

; 6470 :     int res;
; 6471 : 
; 6472 :     *result = NULL;

	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax], 0

; 6473 : 
; 6474 :     if (RAW != '(') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	je	SHORT $LN2@xmlParseEl

; 6475 : 	xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0CO@FLMKOMHK@xmlParseElementContentDecl?5?3?5?$CFs@
	push	54					; 00000036H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 6476 : 		"xmlParseElementContentDecl : %s '(' expected\n", name);
; 6477 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseEl
$LN2@xmlParseEl:

; 6478 :     }
; 6479 :     NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 6480 :     GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN3@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN3@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN3@xmlParseEl:

; 6481 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN4@xmlParseEl

; 6482 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseEl
$LN4@xmlParseEl:

; 6483 :     SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 6484 :     if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 35					; 00000023H
	jne	$LN5@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 80					; 00000050H
	jne	$LN5@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 67					; 00000043H
	jne	$LN5@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 68					; 00000044H
	jne	SHORT $LN5@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 65					; 00000041H
	jne	SHORT $LN5@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 84					; 00000054H
	jne	SHORT $LN5@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 65					; 00000041H
	jne	SHORT $LN5@xmlParseEl

; 6485 :         tree = xmlParseElementMixedContentDecl(ctxt, inputid);

	mov	edx, DWORD PTR _inputid$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseElementMixedContentDecl
	add	esp, 8
	mov	DWORD PTR _tree$[ebp], eax

; 6486 : 	res = XML_ELEMENT_TYPE_MIXED;

	mov	DWORD PTR _res$[ebp], 3

; 6487 :     } else {

	jmp	SHORT $LN6@xmlParseEl
$LN5@xmlParseEl:

; 6488 :         tree = xmlParseElementChildrenContentDeclPriv(ctxt, inputid, 1);

	push	1
	mov	ecx, DWORD PTR _inputid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseElementChildrenContentDeclPriv
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tree$[ebp], eax

; 6489 : 	res = XML_ELEMENT_TYPE_ELEMENT;

	mov	DWORD PTR _res$[ebp], 4
$LN6@xmlParseEl:

; 6490 :     }
; 6491 :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 6492 :     *result = tree;

	mov	ecx, DWORD PTR _result$[ebp]
	mov	edx, DWORD PTR _tree$[ebp]
	mov	DWORD PTR [ecx], edx

; 6493 :     return(res);

	mov	eax, DWORD PTR _res$[ebp]
$LN1@xmlParseEl:

; 6494 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseElementContentDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElementChildrenContentDecl
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_inputchk$ = 12						; size = 4
_xmlParseElementChildrenContentDecl PROC		; COMDAT

; 6445 : xmlParseElementChildrenContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 6446 :     /* stub left for API/ABI compat */
; 6447 :     return(xmlParseElementChildrenContentDeclPriv(ctxt, inputchk, 1));

	push	1
	mov	eax, DWORD PTR _inputchk$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseElementChildrenContentDeclPriv
	add	esp, 12					; 0000000cH

; 6448 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseElementChildrenContentDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseElementMixedContentDecl
_TEXT	SEGMENT
_elem$ = -16						; size = 4
_n$ = -12						; size = 4
_cur$ = -8						; size = 4
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_inputchk$ = 12						; size = 4
_xmlParseElementMixedContentDecl PROC			; COMDAT

; 6029 : xmlParseElementMixedContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 6030 :     xmlElementContentPtr ret = NULL, cur = NULL, n;

	mov	DWORD PTR _ret$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0

; 6031 :     const xmlChar *elem = NULL;

	mov	DWORD PTR _elem$[ebp], 0

; 6032 : 
; 6033 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN10@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN10@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN10@xmlParseEl:

; 6034 :     if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	jne	$LN11@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 80					; 00000050H
	jne	$LN11@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 67					; 00000043H
	jne	$LN11@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 68					; 00000044H
	jne	$LN11@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 65					; 00000041H
	jne	$LN11@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 84					; 00000054H
	jne	$LN11@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 65					; 00000041H
	jne	$LN11@xmlParseEl
$LN4@xmlParseEl:

; 6035 : 	SKIP(7);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 7
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 7
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 7
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN2@xmlParseEl
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEl:
	xor	edx, edx
	jne	SHORT $LN4@xmlParseEl

; 6036 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 6037 : 	SHRINK;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN14@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN14@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 500				; 000001f4H
	jge	SHORT $LN14@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSHRINK
	add	esp, 4
$LN14@xmlParseEl:

; 6038 : 	if (RAW == ')') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 41					; 00000029H
	jne	SHORT $LN15@xmlParseEl

; 6039 : 	    if (ctxt->input->id != inputchk) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+56]
	cmp	ecx, DWORD PTR _inputchk$[ebp]
	je	SHORT $LN16@xmlParseEl

; 6040 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@
	push	90					; 0000005aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN16@xmlParseEl:

; 6041 :                                "Element content declaration doesn't start and"
; 6042 :                                " stop in the same entity\n");
; 6043 : 	    }
; 6044 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 6045 : 	    ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);

	push	1
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 6046 : 	    if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN17@xmlParseEl

; 6047 : 	        return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN17@xmlParseEl:

; 6048 : 	    if (RAW == '*') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN18@xmlParseEl

; 6049 : 		ret->ocur = XML_ELEMENT_CONTENT_MULT;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+4], 3

; 6050 : 		NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4
$LN18@xmlParseEl:

; 6051 : 	    }
; 6052 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParseEl
$LN15@xmlParseEl:

; 6053 : 	}
; 6054 : 	if ((RAW == '(') || (RAW == '|')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN20@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 124				; 0000007cH
	jne	SHORT $LN5@xmlParseEl
$LN20@xmlParseEl:

; 6055 : 	    ret = cur = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);

	push	1
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cur$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx

; 6056 : 	    if (ret == NULL) return(NULL);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN5@xmlParseEl
	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN5@xmlParseEl:

; 6057 : 	}
; 6058 : 	while ((RAW == '|') && (ctxt->instate != XML_PARSER_EOF)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 124				; 0000007cH
	jne	$LN6@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	je	$LN6@xmlParseEl

; 6059 : 	    NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 6060 : 	    if (elem == NULL) {

	cmp	DWORD PTR _elem$[ebp], 0
	jne	SHORT $LN22@xmlParseEl

; 6061 : 	        ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);

	push	4
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 6062 : 		if (ret == NULL) return(NULL);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN24@xmlParseEl
	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN24@xmlParseEl:

; 6063 : 		ret->c1 = cur;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 6064 : 		if (cur != NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN25@xmlParseEl

; 6065 : 		    cur->parent = ret;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN25@xmlParseEl:

; 6066 : 		cur = ret;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 6067 : 	    } else {

	jmp	SHORT $LN23@xmlParseEl
$LN22@xmlParseEl:

; 6068 : 	        n = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);

	push	4
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _n$[ebp], eax

; 6069 : 		if (n == NULL) return(NULL);

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN26@xmlParseEl
	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN26@xmlParseEl:

; 6070 : 		n->c1 = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);

	push	2
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+12], eax

; 6071 : 		if (n->c1 != NULL)

	mov	eax, DWORD PTR _n$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN27@xmlParseEl

; 6072 : 		    n->c1->parent = n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+20], eax
$LN27@xmlParseEl:

; 6073 : 	        cur->c2 = n;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 6074 : 		if (n != NULL)

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN28@xmlParseEl

; 6075 : 		    n->parent = cur;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN28@xmlParseEl:

; 6076 : 		cur = n;

	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _cur$[ebp], edx
$LN23@xmlParseEl:

; 6077 : 	    }
; 6078 : 	    SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 6079 : 	    elem = xmlParseName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _elem$[ebp], eax

; 6080 : 	    if (elem == NULL) {

	cmp	DWORD PTR _elem$[ebp], 0
	jne	SHORT $LN29@xmlParseEl

; 6081 : 		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0DB@BEFMOJIK@xmlParseElementMixedContentDecl@
	push	68					; 00000044H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 6082 : 			"xmlParseElementMixedContentDecl : Name expected\n");
; 6083 : 		xmlFreeDocElementContent(ctxt->myDoc, ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlFreeDocElementContent
	add	esp, 8

; 6084 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEl
$LN29@xmlParseEl:

; 6085 : 	    }
; 6086 : 	    SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 6087 : 	    GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN30@xmlParseEl
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN30@xmlParseEl
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN30@xmlParseEl:

; 6088 : 	}

	jmp	$LN5@xmlParseEl
$LN6@xmlParseEl:

; 6089 : 	if ((RAW == ')') && (NXT(1) == '*')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	jne	$LN31@xmlParseEl
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 42					; 0000002aH
	jne	$LN31@xmlParseEl

; 6090 : 	    if (elem != NULL) {

	cmp	DWORD PTR _elem$[ebp], 0
	je	SHORT $LN33@xmlParseEl

; 6091 : 		cur->c2 = xmlNewDocElementContent(ctxt->myDoc, elem,

	push	2
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlNewDocElementContent
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+16], eax

; 6092 : 		                               XML_ELEMENT_CONTENT_ELEMENT);
; 6093 : 		if (cur->c2 != NULL)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN33@xmlParseEl

; 6094 : 		    cur->c2->parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+20], eax
$LN33@xmlParseEl:

; 6095 :             }
; 6096 :             if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN35@xmlParseEl

; 6097 :                 ret->ocur = XML_ELEMENT_CONTENT_MULT;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+4], 3
$LN35@xmlParseEl:

; 6098 : 	    if (ctxt->input->id != inputchk) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+56]
	cmp	ecx, DWORD PTR _inputchk$[ebp]
	je	SHORT $LN9@xmlParseEl

; 6099 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EH@KGLJHJPD@Element?5content?5declaration?5doe@
	push	90					; 0000005aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN9@xmlParseEl:

; 6100 :                                "Element content declaration doesn't start and"
; 6101 :                                " stop in the same entity\n");
; 6102 : 	    }
; 6103 : 	    SKIP(2);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN7@xmlParseEl
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN7@xmlParseEl:
	xor	ecx, ecx
	jne	SHORT $LN9@xmlParseEl

; 6104 : 	} else {

	jmp	SHORT $LN32@xmlParseEl
$LN31@xmlParseEl:

; 6105 : 	    xmlFreeDocElementContent(ctxt->myDoc, ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDocElementContent
	add	esp, 8

; 6106 : 	    xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);

	push	0
	push	52					; 00000034H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 6107 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseEl
$LN32@xmlParseEl:

; 6108 : 	}
; 6109 : 
; 6110 :     } else {

	jmp	SHORT $LN12@xmlParseEl
$LN11@xmlParseEl:

; 6111 : 	xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);

	push	0
	push	69					; 00000045H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN12@xmlParseEl:

; 6112 :     }
; 6113 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseEl:

; 6114 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseElementMixedContentDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttributeListDecl
_TEXT	SEGMENT
_defaultValue$1 = -40					; size = 4
_def$2 = -32						; size = 4
_type$3 = -28						; size = 4
_inputid$4 = -24					; size = 4
_tree$ = -16						; size = 4
_attrName$ = -8						; size = 4
_elemName$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseAttributeListDecl PROC				; COMDAT

; 5901 : xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 5902 :     const xmlChar *elemName;
; 5903 :     const xmlChar *attrName;
; 5904 :     xmlEnumerationPtr tree;
; 5905 : 
; 5906 :     if (CMP9(CUR_PTR, '<', '!', 'A', 'T', 'T', 'L', 'I', 'S', 'T')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 60					; 0000003cH
	jne	$LN1@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	$LN1@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 65					; 00000041H
	jne	$LN1@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 84					; 00000054H
	jne	$LN1@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 84					; 00000054H
	jne	$LN1@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 76					; 0000004cH
	jne	$LN1@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	$LN1@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 7
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 83					; 00000053H
	jne	$LN1@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 84					; 00000054H
	jne	$LN1@xmlParseAt

; 5907 : 	int inputid = ctxt->input->id;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _inputid$4[ebp], ecx
$LN4@xmlParseAt:

; 5908 : 
; 5909 : 	SKIP(9);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 9
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 9
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN2@xmlParseAt
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseAt:
	xor	eax, eax
	jne	SHORT $LN4@xmlParseAt

; 5910 : 	if (SKIP_BLANKS == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@xmlParseAt

; 5911 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CC@DODLEJBN@Space?5required?5after?5?8?$DM?$CBATTLIST@
	push	65					; 00000041H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN9@xmlParseAt:

; 5912 : 		                 "Space required after '<!ATTLIST'\n");
; 5913 : 	}
; 5914 :         elemName = xmlParseName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _elemName$[ebp], eax

; 5915 : 	if (elemName == NULL) {

	cmp	DWORD PTR _elemName$[ebp], 0
	jne	SHORT $LN10@xmlParseAt

; 5916 : 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0BO@PIKFFONH@ATTLIST?3?5no?5name?5for?5Element?6@
	push	68					; 00000044H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5917 : 			   "ATTLIST: no name for Element\n");
; 5918 : 	    return;

	jmp	$LN1@xmlParseAt
$LN10@xmlParseAt:

; 5919 : 	}
; 5920 : 	SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 5921 : 	GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN5@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN5@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN5@xmlParseAt:

; 5922 : 	while ((RAW != '>') && (ctxt->instate != XML_PARSER_EOF)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 62					; 0000003eH
	je	$LN6@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	je	$LN6@xmlParseAt

; 5923 : 	    int type;
; 5924 : 	    int def;
; 5925 : 	    xmlChar *defaultValue = NULL;

	mov	DWORD PTR _defaultValue$1[ebp], 0

; 5926 : 
; 5927 : 	    GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN12@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN12@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN12@xmlParseAt:

; 5928 :             tree = NULL;

	mov	DWORD PTR _tree$[ebp], 0

; 5929 : 	    attrName = xmlParseName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _attrName$[ebp], eax

; 5930 : 	    if (attrName == NULL) {

	cmp	DWORD PTR _attrName$[ebp], 0
	jne	SHORT $LN13@xmlParseAt

; 5931 : 		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CA@GKDLKFPE@ATTLIST?3?5no?5name?5for?5Attribute?6@
	push	68					; 00000044H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5932 : 			       "ATTLIST: no name for Attribute\n");
; 5933 : 		break;

	jmp	$LN6@xmlParseAt
$LN13@xmlParseAt:

; 5934 : 	    }
; 5935 : 	    GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN14@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN14@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN14@xmlParseAt:

; 5936 : 	    if (SKIP_BLANKS == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@xmlParseAt

; 5937 : 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CJ@BMNHNBNL@Space?5required?5after?5the?5attrib@
	push	65					; 00000041H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5938 : 		        "Space required after the attribute name\n");
; 5939 : 		break;

	jmp	$LN6@xmlParseAt
$LN15@xmlParseAt:

; 5940 : 	    }
; 5941 : 
; 5942 : 	    type = xmlParseAttributeType(ctxt, &tree);

	lea	eax, DWORD PTR _tree$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseAttributeType
	add	esp, 8
	mov	DWORD PTR _type$3[ebp], eax

; 5943 : 	    if (type <= 0) {

	cmp	DWORD PTR _type$3[ebp], 0
	jg	SHORT $LN16@xmlParseAt

; 5944 : 	        break;

	jmp	$LN6@xmlParseAt
$LN16@xmlParseAt:

; 5945 : 	    }
; 5946 : 
; 5947 : 	    GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN17@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN17@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN17@xmlParseAt:

; 5948 : 	    if (SKIP_BLANKS == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@xmlParseAt

; 5949 : 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CJ@EMHJKDCH@Space?5required?5after?5the?5attrib@
	push	65					; 00000041H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5950 : 			       "Space required after the attribute type\n");
; 5951 : 	        if (tree != NULL)

	cmp	DWORD PTR _tree$[ebp], 0
	je	SHORT $LN19@xmlParseAt

; 5952 : 		    xmlFreeEnumeration(tree);

	mov	edx, DWORD PTR _tree$[ebp]
	push	edx
	call	_xmlFreeEnumeration
	add	esp, 4
$LN19@xmlParseAt:

; 5953 : 		break;

	jmp	$LN6@xmlParseAt
$LN18@xmlParseAt:

; 5954 : 	    }
; 5955 : 
; 5956 : 	    def = xmlParseDefaultDecl(ctxt, &defaultValue);

	lea	eax, DWORD PTR _defaultValue$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseDefaultDecl
	add	esp, 8
	mov	DWORD PTR _def$2[ebp], eax

; 5957 : 	    if (def <= 0) {

	cmp	DWORD PTR _def$2[ebp], 0
	jg	SHORT $LN20@xmlParseAt

; 5958 :                 if (defaultValue != NULL)

	cmp	DWORD PTR _defaultValue$1[ebp], 0
	je	SHORT $LN21@xmlParseAt

; 5959 : 		    xmlFree(defaultValue);

	mov	esi, esp
	mov	edx, DWORD PTR _defaultValue$1[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@xmlParseAt:

; 5960 : 	        if (tree != NULL)

	cmp	DWORD PTR _tree$[ebp], 0
	je	SHORT $LN22@xmlParseAt

; 5961 : 		    xmlFreeEnumeration(tree);

	mov	eax, DWORD PTR _tree$[ebp]
	push	eax
	call	_xmlFreeEnumeration
	add	esp, 4
$LN22@xmlParseAt:

; 5962 : 	        break;

	jmp	$LN6@xmlParseAt
$LN20@xmlParseAt:

; 5963 : 	    }
; 5964 : 	    if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))

	cmp	DWORD PTR _type$3[ebp], 1
	je	SHORT $LN23@xmlParseAt
	cmp	DWORD PTR _defaultValue$1[ebp], 0
	je	SHORT $LN23@xmlParseAt

; 5965 : 	        xmlAttrNormalizeSpace(defaultValue, defaultValue);

	mov	ecx, DWORD PTR _defaultValue$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _defaultValue$1[ebp]
	push	edx
	call	_xmlAttrNormalizeSpace
	add	esp, 8
$LN23@xmlParseAt:

; 5966 : 
; 5967 : 	    GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN24@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN24@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN24@xmlParseAt:

; 5968 :             if (RAW != '>') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 62					; 0000003eH
	je	SHORT $LN25@xmlParseAt

; 5969 : 		if (SKIP_BLANKS == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN25@xmlParseAt

; 5970 : 		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0DC@NGABIAJF@Space?5required?5after?5the?5attrib@
	push	65					; 00000041H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5971 : 			"Space required after the attribute default value\n");
; 5972 : 		    if (defaultValue != NULL)

	cmp	DWORD PTR _defaultValue$1[ebp], 0
	je	SHORT $LN27@xmlParseAt

; 5973 : 			xmlFree(defaultValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _defaultValue$1[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN27@xmlParseAt:

; 5974 : 		    if (tree != NULL)

	cmp	DWORD PTR _tree$[ebp], 0
	je	SHORT $LN28@xmlParseAt

; 5975 : 			xmlFreeEnumeration(tree);

	mov	edx, DWORD PTR _tree$[ebp]
	push	edx
	call	_xmlFreeEnumeration
	add	esp, 4
$LN28@xmlParseAt:

; 5976 : 		    break;

	jmp	$LN6@xmlParseAt
$LN25@xmlParseAt:

; 5977 : 		}
; 5978 : 	    }
; 5979 : 	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN29@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN29@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN29@xmlParseAt

; 5980 : 		(ctxt->sax->attributeDecl != NULL))
; 5981 : 		ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,

	mov	esi, esp
	mov	ecx, DWORD PTR _tree$[ebp]
	push	ecx
	mov	edx, DWORD PTR _defaultValue$1[ebp]
	push	edx
	mov	eax, DWORD PTR _def$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _attrName$[ebp]
	push	edx
	mov	eax, DWORD PTR _elemName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	call	edx
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN30@xmlParseAt
$LN29@xmlParseAt:

; 5982 : 	                        type, def, defaultValue, tree);
; 5983 : 	    else if (tree != NULL)

	cmp	DWORD PTR _tree$[ebp], 0
	je	SHORT $LN30@xmlParseAt

; 5984 : 		xmlFreeEnumeration(tree);

	mov	eax, DWORD PTR _tree$[ebp]
	push	eax
	call	_xmlFreeEnumeration
	add	esp, 4
$LN30@xmlParseAt:

; 5985 : 
; 5986 : 	    if ((ctxt->sax2) && (defaultValue != NULL) &&
; 5987 : 	        (def != XML_ATTRIBUTE_IMPLIED) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+324], 0
	je	SHORT $LN32@xmlParseAt
	cmp	DWORD PTR _defaultValue$1[ebp], 0
	je	SHORT $LN32@xmlParseAt
	cmp	DWORD PTR _def$2[ebp], 3
	je	SHORT $LN32@xmlParseAt
	cmp	DWORD PTR _def$2[ebp], 2
	je	SHORT $LN32@xmlParseAt

; 5988 : 		(def != XML_ATTRIBUTE_REQUIRED)) {
; 5989 : 		xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);

	mov	edx, DWORD PTR _defaultValue$1[ebp]
	push	edx
	mov	eax, DWORD PTR _attrName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _elemName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlAddDefAttrs
	add	esp, 16					; 00000010H
$LN32@xmlParseAt:

; 5990 : 	    }
; 5991 : 	    if (ctxt->sax2) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+324], 0
	je	SHORT $LN33@xmlParseAt

; 5992 : 		xmlAddSpecialAttr(ctxt, elemName, attrName, type);

	mov	ecx, DWORD PTR _type$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _attrName$[ebp]
	push	edx
	mov	eax, DWORD PTR _elemName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlAddSpecialAttr
	add	esp, 16					; 00000010H
$LN33@xmlParseAt:

; 5993 : 	    }
; 5994 : 	    if (defaultValue != NULL)

	cmp	DWORD PTR _defaultValue$1[ebp], 0
	je	SHORT $LN34@xmlParseAt

; 5995 : 	        xmlFree(defaultValue);

	mov	esi, esp
	mov	edx, DWORD PTR _defaultValue$1[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN34@xmlParseAt:

; 5996 : 	    GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN35@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN35@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN35@xmlParseAt:

; 5997 : 	}

	jmp	$LN5@xmlParseAt
$LN6@xmlParseAt:

; 5998 : 	if (RAW == '>') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 62					; 0000003eH
	jne	SHORT $LN1@xmlParseAt

; 5999 : 	    if (inputid != ctxt->input->id) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _inputid$4[ebp]
	cmp	ecx, DWORD PTR [eax+56]
	je	SHORT $LN37@xmlParseAt

; 6000 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EG@JGLJABBC@Attribute?5list?5declaration?5does@
	push	90					; 0000005aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN37@xmlParseAt:

; 6001 :                                "Attribute list declaration doesn't start and"
; 6002 :                                " stop in the same entity\n");
; 6003 : 	    }
; 6004 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4
$LN1@xmlParseAt:

; 6005 : 	}
; 6006 :     }
; 6007 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN42@xmlParseAt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN42@xmlParseAt:
	DD	2
	DD	$LN41@xmlParseAt
$LN41@xmlParseAt:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN39@xmlParseAt
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN40@xmlParseAt
$LN40@xmlParseAt:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	97					; 00000061H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN39@xmlParseAt:
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	101					; 00000065H
	DB	0
_xmlParseAttributeListDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttributeType
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_tree$ = 12						; size = 4
_xmlParseAttributeType PROC				; COMDAT

; 5859 : xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 5860 :     SHRINK;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN26@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	cmp	edx, 500				; 000001f4H
	jle	SHORT $LN26@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 500				; 000001f4H
	jge	SHORT $LN26@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSHRINK
	add	esp, 4
$LN26@xmlParseAt:

; 5861 :     if (CMP5(CUR_PTR, 'C', 'D', 'A', 'T', 'A')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 67					; 00000043H
	jne	$LN27@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 68					; 00000044H
	jne	$LN27@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 65					; 00000041H
	jne	$LN27@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 84					; 00000054H
	jne	$LN27@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jne	SHORT $LN27@xmlParseAt
$LN4@xmlParseAt:

; 5862 : 	SKIP(5);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 5
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 5
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 5
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@xmlParseAt
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseAt:
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseAt

; 5863 : 	return(XML_ATTRIBUTE_CDATA);

	mov	eax, 1
	jmp	$LN1@xmlParseAt
	jmp	$LN28@xmlParseAt
$LN27@xmlParseAt:

; 5864 :      } else if (CMP6(CUR_PTR, 'I', 'D', 'R', 'E', 'F', 'S')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 73					; 00000049H
	jne	$LN30@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 68					; 00000044H
	jne	$LN30@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 82					; 00000052H
	jne	$LN30@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 69					; 00000045H
	jne	$LN30@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 70					; 00000046H
	jne	$LN30@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN30@xmlParseAt
$LN7@xmlParseAt:

; 5865 : 	SKIP(6);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 6
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN5@xmlParseAt
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseAt:
	xor	eax, eax
	jne	SHORT $LN7@xmlParseAt

; 5866 : 	return(XML_ATTRIBUTE_IDREFS);

	mov	eax, 4
	jmp	$LN1@xmlParseAt
	jmp	$LN28@xmlParseAt
$LN30@xmlParseAt:

; 5867 :      } else if (CMP5(CUR_PTR, 'I', 'D', 'R', 'E', 'F')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 73					; 00000049H
	jne	$LN33@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 68					; 00000044H
	jne	$LN33@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 82					; 00000052H
	jne	$LN33@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 69					; 00000045H
	jne	$LN33@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 70					; 00000046H
	jne	SHORT $LN33@xmlParseAt
$LN10@xmlParseAt:

; 5868 : 	SKIP(5);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 5
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 5
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 5
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN8@xmlParseAt
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN8@xmlParseAt:
	xor	edx, edx
	jne	SHORT $LN10@xmlParseAt

; 5869 : 	return(XML_ATTRIBUTE_IDREF);

	mov	eax, 3
	jmp	$LN1@xmlParseAt
	jmp	$LN28@xmlParseAt
$LN33@xmlParseAt:

; 5870 :      } else if ((RAW == 'I') && (NXT(1) == 'D')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 73					; 00000049H
	jne	$LN36@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 68					; 00000044H
	jne	SHORT $LN36@xmlParseAt
$LN13@xmlParseAt:

; 5871 :         SKIP(2);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN11@xmlParseAt
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN11@xmlParseAt:
	xor	ecx, ecx
	jne	SHORT $LN13@xmlParseAt

; 5872 : 	return(XML_ATTRIBUTE_ID);

	mov	eax, 2
	jmp	$LN1@xmlParseAt
	jmp	$LN28@xmlParseAt
$LN36@xmlParseAt:

; 5873 :      } else if (CMP6(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'Y')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 69					; 00000045H
	jne	$LN39@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 78					; 0000004eH
	jne	$LN39@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 84					; 00000054H
	jne	$LN39@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	$LN39@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 84					; 00000054H
	jne	$LN39@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN39@xmlParseAt
$LN16@xmlParseAt:

; 5874 : 	SKIP(6);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 6
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN14@xmlParseAt
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN14@xmlParseAt:
	xor	eax, eax
	jne	SHORT $LN16@xmlParseAt

; 5875 : 	return(XML_ATTRIBUTE_ENTITY);

	mov	eax, 5
	jmp	$LN1@xmlParseAt
	jmp	$LN28@xmlParseAt
$LN39@xmlParseAt:

; 5876 :      } else if (CMP8(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'I', 'E', 'S')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 69					; 00000045H
	jne	$LN42@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 78					; 0000004eH
	jne	$LN42@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 84					; 00000054H
	jne	$LN42@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 73					; 00000049H
	jne	$LN42@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 84					; 00000054H
	jne	$LN42@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 73					; 00000049H
	jne	$LN42@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 69					; 00000045H
	jne	$LN42@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN42@xmlParseAt
$LN19@xmlParseAt:

; 5877 : 	SKIP(8);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 8
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 8
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN17@xmlParseAt
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN17@xmlParseAt:
	xor	edx, edx
	jne	SHORT $LN19@xmlParseAt

; 5878 : 	return(XML_ATTRIBUTE_ENTITIES);

	mov	eax, 6
	jmp	$LN1@xmlParseAt
	jmp	$LN28@xmlParseAt
$LN42@xmlParseAt:

; 5879 :      } else if (CMP8(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N', 'S')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 78					; 0000004eH
	jne	$LN45@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 77					; 0000004dH
	jne	$LN45@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 84					; 00000054H
	jne	$LN45@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 79					; 0000004fH
	jne	$LN45@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 75					; 0000004bH
	jne	$LN45@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 69					; 00000045H
	jne	$LN45@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 78					; 0000004eH
	jne	$LN45@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 7
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 83					; 00000053H
	jne	SHORT $LN45@xmlParseAt
$LN22@xmlParseAt:

; 5880 : 	SKIP(8);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 8
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN20@xmlParseAt
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN20@xmlParseAt:
	xor	ecx, ecx
	jne	SHORT $LN22@xmlParseAt

; 5881 : 	return(XML_ATTRIBUTE_NMTOKENS);

	mov	eax, 8
	jmp	$LN1@xmlParseAt
	jmp	$LN28@xmlParseAt
$LN45@xmlParseAt:

; 5882 :      } else if (CMP7(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 78					; 0000004eH
	jne	$LN28@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 77					; 0000004dH
	jne	$LN28@xmlParseAt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 84					; 00000054H
	jne	$LN28@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 79					; 0000004fH
	jne	$LN28@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 75					; 0000004bH
	jne	$LN28@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 69					; 00000045H
	jne	$LN28@xmlParseAt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 78					; 0000004eH
	jne	SHORT $LN28@xmlParseAt
$LN25@xmlParseAt:

; 5883 : 	SKIP(7);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 7
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 7
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 7
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN23@xmlParseAt
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN23@xmlParseAt:
	xor	eax, eax
	jne	SHORT $LN25@xmlParseAt

; 5884 : 	return(XML_ATTRIBUTE_NMTOKEN);

	mov	eax, 7
	jmp	SHORT $LN1@xmlParseAt
$LN28@xmlParseAt:

; 5885 :      }
; 5886 :      return(xmlParseEnumeratedType(ctxt, tree));

	mov	ecx, DWORD PTR _tree$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseEnumeratedType
	add	esp, 8
$LN1@xmlParseAt:

; 5887 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseAttributeType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEnumeratedType
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_tree$ = 12						; size = 4
_xmlParseEnumeratedType PROC				; COMDAT

; 5796 : xmlParseEnumeratedType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 5797 :     if (CMP8(CUR_PTR, 'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 78					; 0000004eH
	jne	$LN5@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 79					; 0000004fH
	jne	$LN5@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 84					; 00000054H
	jne	$LN5@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 65					; 00000041H
	jne	$LN5@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 84					; 00000054H
	jne	$LN5@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	$LN5@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 79					; 0000004fH
	jne	$LN5@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 7
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 78					; 0000004eH
	jne	$LN5@xmlParseEn
$LN4@xmlParseEn:

; 5798 : 	SKIP(8);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 8
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@xmlParseEn
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEn:
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseEn

; 5799 : 	if (SKIP_BLANKS == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@xmlParseEn

; 5800 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CB@FOEKPMO@Space?5required?5after?5?8NOTATION?8@
	push	65					; 00000041H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5801 : 			   "Space required after 'NOTATION'\n");
; 5802 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseEn
$LN7@xmlParseEn:

; 5803 : 	}
; 5804 : 	*tree = xmlParseNotationType(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseNotationType
	add	esp, 4
	mov	edx, DWORD PTR _tree$[ebp]
	mov	DWORD PTR [edx], eax

; 5805 : 	if (*tree == NULL) return(0);

	mov	eax, DWORD PTR _tree$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@xmlParseEn
	xor	eax, eax
	jmp	SHORT $LN1@xmlParseEn
$LN8@xmlParseEn:

; 5806 : 	return(XML_ATTRIBUTE_NOTATION);

	mov	eax, 10					; 0000000aH
	jmp	SHORT $LN1@xmlParseEn
$LN5@xmlParseEn:

; 5807 :     }
; 5808 :     *tree = xmlParseEnumerationType(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseEnumerationType
	add	esp, 4
	mov	edx, DWORD PTR _tree$[ebp]
	mov	DWORD PTR [edx], eax

; 5809 :     if (*tree == NULL) return(0);

	mov	eax, DWORD PTR _tree$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN9@xmlParseEn
	xor	eax, eax
	jmp	SHORT $LN1@xmlParseEn
$LN9@xmlParseEn:

; 5810 :     return(XML_ATTRIBUTE_ENUMERATION);

	mov	eax, 9
$LN1@xmlParseEn:

; 5811 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseEnumeratedType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEnumerationType
_TEXT	SEGMENT
_tmp$ = -20						; size = 4
_cur$ = -16						; size = 4
_last$ = -12						; size = 4
_ret$ = -8						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseEnumerationType PROC				; COMDAT

; 5727 : xmlParseEnumerationType(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 5728 :     xmlChar *name;
; 5729 :     xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;

	mov	DWORD PTR _ret$[ebp], 0
	mov	DWORD PTR _last$[ebp], 0

; 5730 : 
; 5731 :     if (RAW != '(') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN7@xmlParseEn

; 5732 : 	xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED, NULL);

	push	0
	push	50					; 00000032H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 5733 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN7@xmlParseEn:

; 5734 :     }
; 5735 :     SHRINK;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN4@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	cmp	ecx, 500				; 000001f4H
	jle	SHORT $LN4@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN4@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSHRINK
	add	esp, 4
$LN4@xmlParseEn:

; 5736 :     do {
; 5737 :         NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 5738 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 5739 :         name = xmlParseNmtoken(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseNmtoken
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 5740 : 	if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN9@xmlParseEn

; 5741 : 	    xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED, NULL);

	push	0
	push	67					; 00000043H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 5742 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParseEn
$LN9@xmlParseEn:

; 5743 : 	}
; 5744 : 	tmp = ret;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax
$LN5@xmlParseEn:

; 5745 : 	while (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN6@xmlParseEn

; 5746 : 	    if (xmlStrEqual(name, tmp->name)) {

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlParseEn

; 5747 : 		xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,

	push	0
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DN@GKJDABEM@standalone?3?5attribute?5enumerati@
	push	541					; 0000021dH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlValidityError
	add	esp, 20					; 00000014H

; 5748 : 	  "standalone: attribute enumeration value token %s duplicated\n",
; 5749 : 				 name, NULL);
; 5750 : 		if (!xmlDictOwns(ctxt->dict, name))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlParseEn

; 5751 : 		    xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlParseEn:

; 5752 : 		break;

	jmp	SHORT $LN6@xmlParseEn
$LN10@xmlParseEn:

; 5753 : 	    }
; 5754 : 	    tmp = tmp->next;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _tmp$[ebp], edx

; 5755 : 	}

	jmp	SHORT $LN5@xmlParseEn
$LN6@xmlParseEn:

; 5756 : 	if (tmp == NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN12@xmlParseEn

; 5757 : 	    cur = xmlCreateEnumeration(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlCreateEnumeration
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 5758 : 	    if (!xmlDictOwns(ctxt->dict, name))

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlParseEn

; 5759 : 		xmlFree(name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlParseEn:

; 5760 : 	    if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN14@xmlParseEn

; 5761 :                 xmlFreeEnumeration(ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlFreeEnumeration
	add	esp, 4

; 5762 :                 return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseEn
$LN14@xmlParseEn:

; 5763 :             }
; 5764 : 	    if (last == NULL) ret = last = cur;

	cmp	DWORD PTR _last$[ebp], 0
	jne	SHORT $LN15@xmlParseEn
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], eax
	mov	ecx, DWORD PTR _last$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
	jmp	SHORT $LN12@xmlParseEn
$LN15@xmlParseEn:

; 5765 : 	    else {
; 5766 : 		last->next = cur;

	mov	edx, DWORD PTR _last$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 5767 : 		last = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], ecx
$LN12@xmlParseEn:

; 5768 : 	    }
; 5769 : 	}
; 5770 : 	SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 5771 :     } while (RAW == '|');

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 124				; 0000007cH
	je	$LN4@xmlParseEn

; 5772 :     if (RAW != ')') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 41					; 00000029H
	je	SHORT $LN17@xmlParseEn

; 5773 : 	xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED, NULL);

	push	0
	push	51					; 00000033H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 5774 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParseEn
$LN17@xmlParseEn:

; 5775 :     }
; 5776 :     NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 5777 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseEn:

; 5778 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseEnumerationType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNotationType
_TEXT	SEGMENT
_tmp$ = -20						; size = 4
_cur$ = -16						; size = 4
_last$ = -12						; size = 4
_ret$ = -8						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseNotationType PROC				; COMDAT

; 5657 : xmlParseNotationType(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 5658 :     const xmlChar *name;
; 5659 :     xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;

	mov	DWORD PTR _ret$[ebp], 0
	mov	DWORD PTR _last$[ebp], 0

; 5660 : 
; 5661 :     if (RAW != '(') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN7@xmlParseNo

; 5662 : 	xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);

	push	0
	push	48					; 00000030H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 5663 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNo
$LN7@xmlParseNo:

; 5664 :     }
; 5665 :     SHRINK;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN4@xmlParseNo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	cmp	ecx, 500				; 000001f4H
	jle	SHORT $LN4@xmlParseNo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN4@xmlParseNo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSHRINK
	add	esp, 4
$LN4@xmlParseNo:

; 5666 :     do {
; 5667 :         NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 5668 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 5669 :         name = xmlParseName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 5670 : 	if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN9@xmlParseNo

; 5671 : 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0CH@MHDABFNP@Name?5expected?5in?5NOTATION?5decla@
	push	68					; 00000044H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5672 : 			   "Name expected in NOTATION declaration\n");
; 5673 :             xmlFreeEnumeration(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlFreeEnumeration
	add	esp, 4

; 5674 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNo
$LN9@xmlParseNo:

; 5675 : 	}
; 5676 : 	tmp = ret;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _tmp$[ebp], ecx
$LN5@xmlParseNo:

; 5677 : 	while (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN6@xmlParseNo

; 5678 : 	    if (xmlStrEqual(name, tmp->name)) {

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlParseNo

; 5679 : 		xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,

	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0DK@HOPAGHFB@standalone?3?5attribute?5notation?5@
	push	541					; 0000021dH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlValidityError
	add	esp, 20					; 00000014H

; 5680 : 	  "standalone: attribute notation value token %s duplicated\n",
; 5681 : 				 name, NULL);
; 5682 : 		if (!xmlDictOwns(ctxt->dict, name))

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlParseNo

; 5683 : 		    xmlFree((xmlChar *) name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlParseNo:

; 5684 : 		break;

	jmp	SHORT $LN6@xmlParseNo
$LN10@xmlParseNo:

; 5685 : 	    }
; 5686 : 	    tmp = tmp->next;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _tmp$[ebp], eax

; 5687 : 	}

	jmp	SHORT $LN5@xmlParseNo
$LN6@xmlParseNo:

; 5688 : 	if (tmp == NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN12@xmlParseNo

; 5689 : 	    cur = xmlCreateEnumeration(name);

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlCreateEnumeration
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 5690 : 	    if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN13@xmlParseNo

; 5691 :                 xmlFreeEnumeration(ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlFreeEnumeration
	add	esp, 4

; 5692 :                 return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNo
$LN13@xmlParseNo:

; 5693 :             }
; 5694 : 	    if (last == NULL) ret = last = cur;

	cmp	DWORD PTR _last$[ebp], 0
	jne	SHORT $LN14@xmlParseNo
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], eax
	mov	ecx, DWORD PTR _last$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
	jmp	SHORT $LN12@xmlParseNo
$LN14@xmlParseNo:

; 5695 : 	    else {
; 5696 : 		last->next = cur;

	mov	edx, DWORD PTR _last$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 5697 : 		last = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], ecx
$LN12@xmlParseNo:

; 5698 : 	    }
; 5699 : 	}
; 5700 : 	SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 5701 :     } while (RAW == '|');

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 124				; 0000007cH
	je	$LN4@xmlParseNo

; 5702 :     if (RAW != ')') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 41					; 00000029H
	je	SHORT $LN16@xmlParseNo

; 5703 : 	xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);

	push	0
	push	49					; 00000031H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 5704 :         xmlFreeEnumeration(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlFreeEnumeration
	add	esp, 4

; 5705 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseNo
$LN16@xmlParseNo:

; 5706 :     }
; 5707 :     NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 5708 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseNo:

; 5709 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseNotationType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseDefaultDecl
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_val$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlParseDefaultDecl PROC				; COMDAT

; 5607 : xmlParseDefaultDecl(xmlParserCtxtPtr ctxt, xmlChar **value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 5608 :     int val;
; 5609 :     xmlChar *ret;
; 5610 : 
; 5611 :     *value = NULL;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], 0

; 5612 :     if (CMP9(CUR_PTR, '#', 'R', 'E', 'Q', 'U', 'I', 'R', 'E', 'D')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	jne	$LN11@xmlParseDe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 82					; 00000052H
	jne	$LN11@xmlParseDe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 69					; 00000045H
	jne	$LN11@xmlParseDe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 81					; 00000051H
	jne	$LN11@xmlParseDe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 85					; 00000055H
	jne	$LN11@xmlParseDe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 73					; 00000049H
	jne	$LN11@xmlParseDe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 82					; 00000052H
	jne	$LN11@xmlParseDe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 69					; 00000045H
	jne	$LN11@xmlParseDe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 68					; 00000044H
	jne	SHORT $LN11@xmlParseDe
$LN4@xmlParseDe:

; 5613 : 	SKIP(9);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 9
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 9
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 9
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@xmlParseDe
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseDe:
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseDe

; 5614 : 	return(XML_ATTRIBUTE_REQUIRED);

	mov	eax, 2
	jmp	$LN1@xmlParseDe
$LN11@xmlParseDe:

; 5615 :     }
; 5616 :     if (CMP8(CUR_PTR, '#', 'I', 'M', 'P', 'L', 'I', 'E', 'D')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 35					; 00000023H
	jne	$LN13@xmlParseDe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 73					; 00000049H
	jne	$LN13@xmlParseDe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 77					; 0000004dH
	jne	$LN13@xmlParseDe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 80					; 00000050H
	jne	$LN13@xmlParseDe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 76					; 0000004cH
	jne	$LN13@xmlParseDe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 73					; 00000049H
	jne	$LN13@xmlParseDe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 69					; 00000045H
	jne	$LN13@xmlParseDe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 7
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 68					; 00000044H
	jne	SHORT $LN13@xmlParseDe
$LN7@xmlParseDe:

; 5617 : 	SKIP(8);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 8
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN5@xmlParseDe
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseDe:
	xor	eax, eax
	jne	SHORT $LN7@xmlParseDe

; 5618 : 	return(XML_ATTRIBUTE_IMPLIED);

	mov	eax, 3
	jmp	$LN1@xmlParseDe
$LN13@xmlParseDe:

; 5619 :     }
; 5620 :     val = XML_ATTRIBUTE_NONE;

	mov	DWORD PTR _val$[ebp], 1

; 5621 :     if (CMP6(CUR_PTR, '#', 'F', 'I', 'X', 'E', 'D')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	jne	$LN15@xmlParseDe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 70					; 00000046H
	jne	$LN15@xmlParseDe
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 73					; 00000049H
	jne	$LN15@xmlParseDe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 88					; 00000058H
	jne	$LN15@xmlParseDe
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 69					; 00000045H
	jne	$LN15@xmlParseDe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 68					; 00000044H
	jne	$LN15@xmlParseDe
$LN10@xmlParseDe:

; 5622 : 	SKIP(6);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 6
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 6
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN8@xmlParseDe
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN8@xmlParseDe:
	xor	edx, edx
	jne	SHORT $LN10@xmlParseDe

; 5623 : 	val = XML_ATTRIBUTE_FIXED;

	mov	DWORD PTR _val$[ebp], 4

; 5624 : 	if (SKIP_BLANKS == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@xmlParseDe

; 5625 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BP@LOJANMBO@Space?5required?5after?5?8?$CDFIXED?8?6@
	push	65					; 00000041H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN15@xmlParseDe:

; 5626 : 			   "Space required after '#FIXED'\n");
; 5627 : 	}
; 5628 :     }
; 5629 :     ret = xmlParseAttValue(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseAttValue
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 5630 :     ctxt->instate = XML_PARSER_DTD;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 3

; 5631 :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN18@xmlParseDe

; 5632 : 	xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt->errNo,

	push	OFFSET ??_C@_0CL@MHGJEBGE@Attribute?5default?5value?5declara@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5633 : 		       "Attribute default value declaration error\n");
; 5634 :     } else

	jmp	SHORT $LN19@xmlParseDe
$LN18@xmlParseDe:

; 5635 :         *value = ret;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], edx
$LN19@xmlParseDe:

; 5636 :     return(val);

	mov	eax, DWORD PTR _val$[ebp]
$LN1@xmlParseDe:

; 5637 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseDefaultDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEntityDecl
_TEXT	SEGMENT
_cur$1 = -60						; size = 4
_uri$2 = -56						; size = 4
_uri$3 = -52						; size = 4
_inputid$4 = -48					; size = 4
_orig$ = -40						; size = 4
_isParameter$ = -32					; size = 4
_ndata$ = -28						; size = 4
_literal$ = -20						; size = 4
_URI$ = -12						; size = 4
_value$ = -8						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseEntityDecl PROC				; COMDAT

; 5334 : xmlParseEntityDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 5335 :     const xmlChar *name = NULL;

	mov	DWORD PTR _name$[ebp], 0

; 5336 :     xmlChar *value = NULL;

	mov	DWORD PTR _value$[ebp], 0

; 5337 :     xmlChar *URI = NULL, *literal = NULL;

	mov	DWORD PTR _URI$[ebp], 0
	mov	DWORD PTR _literal$[ebp], 0

; 5338 :     const xmlChar *ndata = NULL;

	mov	DWORD PTR _ndata$[ebp], 0

; 5339 :     int isParameter = 0;

	mov	DWORD PTR _isParameter$[ebp], 0

; 5340 :     xmlChar *orig = NULL;

	mov	DWORD PTR _orig$[ebp], 0

; 5341 : 
; 5342 :     /* GROW; done in the caller */
; 5343 :     if (CMP8(CUR_PTR, '<', '!', 'E', 'N', 'T', 'I', 'T', 'Y')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 60					; 0000003cH
	jne	$LN1@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	$LN1@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 69					; 00000045H
	jne	$LN1@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 78					; 0000004eH
	jne	$LN1@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 84					; 00000054H
	jne	$LN1@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	$LN1@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 84					; 00000054H
	jne	$LN1@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 7
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 89					; 00000059H
	jne	$LN1@xmlParseEn

; 5344 : 	int inputid = ctxt->input->id;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _inputid$4[ebp], edx

; 5345 : 	SHRINK;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN4@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	cmp	edx, 500				; 000001f4H
	jle	SHORT $LN4@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 500				; 000001f4H
	jge	SHORT $LN4@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSHRINK
	add	esp, 4
$LN4@xmlParseEn:

; 5346 : 	SKIP(8);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 8
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 8
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@xmlParseEn
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEn:
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParseEn

; 5347 : 	if (SKIP_BLANKS == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@xmlParseEn

; 5348 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CB@NEOBPNBE@Space?5required?5after?5?8?$DM?$CBENTITY?8@
	push	65					; 00000041H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN11@xmlParseEn:

; 5349 : 			   "Space required after '<!ENTITY'\n");
; 5350 : 	}
; 5351 : 
; 5352 : 	if (RAW == '%') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	jne	SHORT $LN12@xmlParseEn

; 5353 : 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 5354 : 	    if (SKIP_BLANKS == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@xmlParseEn

; 5355 : 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BL@KGADBCMF@Space?5required?5after?5?8?$CF?$CF?8?6@
	push	65					; 00000041H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN13@xmlParseEn:

; 5356 : 			       "Space required after '%%'\n");
; 5357 : 	    }
; 5358 : 	    isParameter = 1;

	mov	DWORD PTR _isParameter$[ebp], 1
$LN12@xmlParseEn:

; 5359 : 	}
; 5360 : 
; 5361 :         name = xmlParseName(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 5362 : 	if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN14@xmlParseEn

; 5363 : 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,

	push	OFFSET ??_C@_0BN@GJOFDJCB@xmlParseEntityDecl?3?5no?5name?6@
	push	68					; 00000044H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5364 : 	                   "xmlParseEntityDecl: no name\n");
; 5365 :             return;

	jmp	$LN1@xmlParseEn
$LN14@xmlParseEn:

; 5366 : 	}
; 5367 : 	if (xmlStrchr(name, ':') != NULL) {

	push	58					; 0000003aH
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@xmlParseEn

; 5368 : 	    xmlNsErr(ctxt, XML_NS_ERR_COLON,

	push	0
	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0CP@IEOCAMEB@colons?5are?5forbidden?5from?5entit@
	push	205					; 000000cdH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN15@xmlParseEn:

; 5369 : 		     "colons are forbidden from entities names '%s'\n",
; 5370 : 		     name, NULL, NULL);
; 5371 : 	}
; 5372 : 	if (SKIP_BLANKS == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@xmlParseEn

; 5373 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CG@IGJCKADK@Space?5required?5after?5the?5entity@
	push	65					; 00000041H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN16@xmlParseEn:

; 5374 : 			   "Space required after the entity name\n");
; 5375 : 	}
; 5376 : 
; 5377 : 	ctxt->instate = XML_PARSER_ENTITY_DECL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 10			; 0000000aH

; 5378 : 	/*
; 5379 : 	 * handle the various case of definitions...
; 5380 : 	 */
; 5381 : 	if (isParameter) {

	cmp	DWORD PTR _isParameter$[ebp], 0
	je	$LN17@xmlParseEn

; 5382 : 	    if ((RAW == '"') || (RAW == '\'')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN21@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 39					; 00000027H
	jne	SHORT $LN19@xmlParseEn
$LN21@xmlParseEn:

; 5383 : 	        value = xmlParseEntityValue(ctxt, &orig);

	lea	eax, DWORD PTR _orig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseEntityValue
	add	esp, 8
	mov	DWORD PTR _value$[ebp], eax

; 5384 : 		if (value) {

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN22@xmlParseEn

; 5385 : 		    if ((ctxt->sax != NULL) &&
; 5386 : 			(!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN22@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN22@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN22@xmlParseEn

; 5387 : 			ctxt->sax->entityDecl(ctxt->userData, name,

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	0
	push	0
	push	4
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@xmlParseEn:

; 5388 : 		                    XML_INTERNAL_PARAMETER_ENTITY,
; 5389 : 				    NULL, NULL, value);
; 5390 : 		}
; 5391 : 	    } else {

	jmp	$LN20@xmlParseEn
$LN19@xmlParseEn:

; 5392 : 	        URI = xmlParseExternalID(ctxt, &literal, 1);

	push	1
	lea	ecx, DWORD PTR _literal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseExternalID
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URI$[ebp], eax

; 5393 : 		if ((URI == NULL) && (literal == NULL)) {

	cmp	DWORD PTR _URI$[ebp], 0
	jne	SHORT $LN24@xmlParseEn
	cmp	DWORD PTR _literal$[ebp], 0
	jne	SHORT $LN24@xmlParseEn

; 5394 : 		    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);

	push	0
	push	84					; 00000054H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN24@xmlParseEn:

; 5395 : 		}
; 5396 : 		if (URI) {

	cmp	DWORD PTR _URI$[ebp], 0
	je	$LN20@xmlParseEn

; 5397 : 		    xmlURIPtr uri;
; 5398 : 
; 5399 : 		    uri = xmlParseURI((const char *) URI);

	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$3[ebp], eax

; 5400 : 		    if (uri == NULL) {

	cmp	DWORD PTR _uri$3[ebp], 0
	jne	SHORT $LN26@xmlParseEn

; 5401 : 		        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,

	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	push	OFFSET ??_C@_0BB@JHEINHI@Invalid?5URI?3?5?$CFs?6@
	push	91					; 0000005bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMsgStr
	add	esp, 16					; 00000010H

; 5402 : 				     "Invalid URI: %s\n", URI);
; 5403 : 			/*
; 5404 : 			 * This really ought to be a well formedness error
; 5405 : 			 * but the XML Core WG decided otherwise c.f. issue
; 5406 : 			 * E26 of the XML erratas.
; 5407 : 			 */
; 5408 : 		    } else {

	jmp	SHORT $LN20@xmlParseEn
$LN26@xmlParseEn:

; 5409 : 			if (uri->fragment != NULL) {

	mov	ecx, DWORD PTR _uri$3[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN28@xmlParseEn

; 5410 : 			    /*
; 5411 : 			     * Okay this is foolish to block those but not
; 5412 : 			     * invalid URIs.
; 5413 : 			     */
; 5414 : 			    xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);

	push	0
	push	92					; 0000005cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 5415 : 			} else {

	jmp	SHORT $LN29@xmlParseEn
$LN28@xmlParseEn:

; 5416 : 			    if ((ctxt->sax != NULL) &&
; 5417 : 				(!ctxt->disableSAX) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN29@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN29@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN29@xmlParseEn

; 5418 : 				(ctxt->sax->entityDecl != NULL))
; 5419 : 				ctxt->sax->entityDecl(ctxt->userData, name,

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _literal$[ebp]
	push	edx
	push	5
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN29@xmlParseEn:

; 5420 : 					    XML_EXTERNAL_PARAMETER_ENTITY,
; 5421 : 					    literal, URI, NULL);
; 5422 : 			}
; 5423 : 			xmlFreeURI(uri);

	mov	eax, DWORD PTR _uri$3[ebp]
	push	eax
	call	_xmlFreeURI
	add	esp, 4
$LN20@xmlParseEn:

; 5424 : 		    }
; 5425 : 		}
; 5426 : 	    }
; 5427 : 	} else {

	jmp	$LN18@xmlParseEn
$LN17@xmlParseEn:

; 5428 : 	    if ((RAW == '"') || (RAW == '\'')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN33@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 39					; 00000027H
	jne	$LN31@xmlParseEn
$LN33@xmlParseEn:

; 5429 : 	        value = xmlParseEntityValue(ctxt, &orig);

	lea	eax, DWORD PTR _orig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseEntityValue
	add	esp, 8
	mov	DWORD PTR _value$[ebp], eax

; 5430 : 		if ((ctxt->sax != NULL) &&
; 5431 : 		    (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN34@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN34@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN34@xmlParseEn

; 5432 : 		    ctxt->sax->entityDecl(ctxt->userData, name,

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN34@xmlParseEn:

; 5433 : 				XML_INTERNAL_GENERAL_ENTITY,
; 5434 : 				NULL, NULL, value);
; 5435 : 		/*
; 5436 : 		 * For expat compatibility in SAX mode.
; 5437 : 		 */
; 5438 : 		if ((ctxt->myDoc == NULL) ||

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN36@xmlParseEn
	push	OFFSET ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN35@xmlParseEn
$LN36@xmlParseEn:

; 5439 : 		    (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
; 5440 : 		    if (ctxt->myDoc == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN37@xmlParseEn

; 5441 : 			ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);

	push	OFFSET ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
	call	_xmlNewDoc
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 5442 : 			if (ctxt->myDoc == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN38@xmlParseEn

; 5443 : 			    xmlErrMemory(ctxt, "New Doc failed");

	push	OFFSET ??_C@_0P@IDBIGKBI@New?5Doc?5failed@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 5444 : 			    return;

	jmp	$LN1@xmlParseEn
$LN38@xmlParseEn:

; 5445 : 			}
; 5446 : 			ctxt->myDoc->properties = XML_DOC_INTERNAL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+92], 64			; 00000040H
$LN37@xmlParseEn:

; 5447 : 		    }
; 5448 : 		    if (ctxt->myDoc->intSubset == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+44], 0
	jne	SHORT $LN39@xmlParseEn

; 5449 : 			ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,

	push	0
	push	0
	push	OFFSET ??_C@_04PADNKBEK@fake@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlNewDtd
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+44], eax
$LN39@xmlParseEn:

; 5450 : 					    BAD_CAST "fake", NULL, NULL);
; 5451 : 
; 5452 : 		    xmlSAX2EntityDecl(ctxt, name, XML_INTERNAL_GENERAL_ENTITY,

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSAX2EntityDecl
	add	esp, 24					; 00000018H
$LN35@xmlParseEn:

; 5453 : 			              NULL, NULL, value);
; 5454 : 		}
; 5455 : 	    } else {

	jmp	$LN18@xmlParseEn
$LN31@xmlParseEn:

; 5456 : 	        URI = xmlParseExternalID(ctxt, &literal, 1);

	push	1
	lea	eax, DWORD PTR _literal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseExternalID
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _URI$[ebp], eax

; 5457 : 		if ((URI == NULL) && (literal == NULL)) {

	cmp	DWORD PTR _URI$[ebp], 0
	jne	SHORT $LN40@xmlParseEn
	cmp	DWORD PTR _literal$[ebp], 0
	jne	SHORT $LN40@xmlParseEn

; 5458 : 		    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);

	push	0
	push	84					; 00000054H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN40@xmlParseEn:

; 5459 : 		}
; 5460 : 		if (URI) {

	cmp	DWORD PTR _URI$[ebp], 0
	je	SHORT $LN41@xmlParseEn

; 5461 : 		    xmlURIPtr uri;
; 5462 : 
; 5463 : 		    uri = xmlParseURI((const char *)URI);

	mov	eax, DWORD PTR _URI$[ebp]
	push	eax
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$2[ebp], eax

; 5464 : 		    if (uri == NULL) {

	cmp	DWORD PTR _uri$2[ebp], 0
	jne	SHORT $LN42@xmlParseEn

; 5465 : 		        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,

	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BB@JHEINHI@Invalid?5URI?3?5?$CFs?6@
	push	91					; 0000005bH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMsgStr
	add	esp, 16					; 00000010H

; 5466 : 				     "Invalid URI: %s\n", URI);
; 5467 : 			/*
; 5468 : 			 * This really ought to be a well formedness error
; 5469 : 			 * but the XML Core WG decided otherwise c.f. issue
; 5470 : 			 * E26 of the XML erratas.
; 5471 : 			 */
; 5472 : 		    } else {

	jmp	SHORT $LN41@xmlParseEn
$LN42@xmlParseEn:

; 5473 : 			if (uri->fragment != NULL) {

	mov	eax, DWORD PTR _uri$2[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN44@xmlParseEn

; 5474 : 			    /*
; 5475 : 			     * Okay this is foolish to block those but not
; 5476 : 			     * invalid URIs.
; 5477 : 			     */
; 5478 : 			    xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);

	push	0
	push	92					; 0000005cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN44@xmlParseEn:

; 5479 : 			}
; 5480 : 			xmlFreeURI(uri);

	mov	edx, DWORD PTR _uri$2[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4
$LN41@xmlParseEn:

; 5481 : 		    }
; 5482 : 		}
; 5483 : 		if ((RAW != '>') && (SKIP_BLANKS == 0)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN45@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN45@xmlParseEn

; 5484 : 		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BP@NPDMAEIM@Space?5required?5before?5?8NDATA?8?6@
	push	65					; 00000041H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN45@xmlParseEn:

; 5485 : 				   "Space required before 'NDATA'\n");
; 5486 : 		}
; 5487 : 		if (CMP5(CUR_PTR, 'N', 'D', 'A', 'T', 'A')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 78					; 0000004eH
	jne	$LN46@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 68					; 00000044H
	jne	$LN46@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 65					; 00000041H
	jne	$LN46@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 84					; 00000054H
	jne	$LN46@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jne	$LN46@xmlParseEn
$LN7@xmlParseEn:

; 5488 : 		    SKIP(5);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 5
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 5
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 5
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@xmlParseEn
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseEn:
	xor	ecx, ecx
	jne	SHORT $LN7@xmlParseEn

; 5489 : 		    if (SKIP_BLANKS == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN49@xmlParseEn

; 5490 : 			xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BO@GLBCJEIC@Space?5required?5after?5?8NDATA?8?6@
	push	65					; 00000041H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN49@xmlParseEn:

; 5491 : 				       "Space required after 'NDATA'\n");
; 5492 : 		    }
; 5493 : 		    ndata = xmlParseName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _ndata$[ebp], eax

; 5494 : 		    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN50@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN50@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN50@xmlParseEn

; 5495 : 		        (ctxt->sax->unparsedEntityDecl != NULL))
; 5496 : 			ctxt->sax->unparsedEntityDecl(ctxt->userData, name,

	mov	esi, esp
	mov	eax, DWORD PTR _ndata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _literal$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN50@xmlParseEn:

; 5497 : 				    literal, URI, ndata);
; 5498 : 		} else {

	jmp	$LN18@xmlParseEn
$LN46@xmlParseEn:

; 5499 : 		    if ((ctxt->sax != NULL) &&
; 5500 : 		        (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN51@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN51@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN51@xmlParseEn

; 5501 : 			ctxt->sax->entityDecl(ctxt->userData, name,

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _literal$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	call	edx
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN51@xmlParseEn:

; 5502 : 				    XML_EXTERNAL_GENERAL_PARSED_ENTITY,
; 5503 : 				    literal, URI, NULL);
; 5504 : 		    /*
; 5505 : 		     * For expat compatibility in SAX mode.
; 5506 : 		     * assuming the entity repalcement was asked for
; 5507 : 		     */
; 5508 : 		    if ((ctxt->replaceEntities != 0) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN18@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN53@xmlParseEn
	push	OFFSET ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN18@xmlParseEn
$LN53@xmlParseEn:

; 5509 : 			((ctxt->myDoc == NULL) ||
; 5510 : 			(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE)))) {
; 5511 : 			if (ctxt->myDoc == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN54@xmlParseEn

; 5512 : 			    ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);

	push	OFFSET ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
	call	_xmlNewDoc
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 5513 : 			    if (ctxt->myDoc == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN55@xmlParseEn

; 5514 : 			        xmlErrMemory(ctxt, "New Doc failed");

	push	OFFSET ??_C@_0P@IDBIGKBI@New?5Doc?5failed@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 5515 : 				return;

	jmp	$LN1@xmlParseEn
$LN55@xmlParseEn:

; 5516 : 			    }
; 5517 : 			    ctxt->myDoc->properties = XML_DOC_INTERNAL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+92], 64			; 00000040H
$LN54@xmlParseEn:

; 5518 : 			}
; 5519 : 
; 5520 : 			if (ctxt->myDoc->intSubset == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+44], 0
	jne	SHORT $LN56@xmlParseEn

; 5521 : 			    ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,

	push	0
	push	0
	push	OFFSET ??_C@_04PADNKBEK@fake@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlNewDtd
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+44], eax
$LN56@xmlParseEn:

; 5522 : 						BAD_CAST "fake", NULL, NULL);
; 5523 : 			xmlSAX2EntityDecl(ctxt, name,

	push	0
	mov	eax, DWORD PTR _URI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _literal$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSAX2EntityDecl
	add	esp, 24					; 00000018H
$LN18@xmlParseEn:

; 5524 : 				          XML_EXTERNAL_GENERAL_PARSED_ENTITY,
; 5525 : 				          literal, URI, NULL);
; 5526 : 		    }
; 5527 : 		}
; 5528 : 	    }
; 5529 : 	}
; 5530 : 	if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN57@xmlParseEn

; 5531 : 	    goto done;

	jmp	$done$77
$LN57@xmlParseEn:

; 5532 : 	SKIP_BLANKS;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4

; 5533 : 	if (RAW != '>') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN58@xmlParseEn

; 5534 : 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CO@GFOAPJBJ@xmlParseEntityDecl?3?5entity?5?$CFs?5n@
	push	37					; 00000025H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 5535 : 	            "xmlParseEntityDecl: entity %s not terminated\n", name);
; 5536 : 	    xmlHaltParser(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlHaltParser
	add	esp, 4

; 5537 : 	} else {

	jmp	SHORT $LN59@xmlParseEn
$LN58@xmlParseEn:

; 5538 : 	    if (inputid != ctxt->input->id) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _inputid$4[ebp]
	cmp	eax, DWORD PTR [edx+56]
	je	SHORT $LN60@xmlParseEn

; 5539 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DO@BLCODNOK@Entity?5declaration?5doesn?8t?5star@
	push	90					; 0000005aH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN60@xmlParseEn:

; 5540 : 	                       "Entity declaration doesn't start and stop in"
; 5541 :                                " the same entity\n");
; 5542 : 	    }
; 5543 : 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4
$LN59@xmlParseEn:

; 5544 : 	}
; 5545 : 	if (orig != NULL) {

	cmp	DWORD PTR _orig$[ebp], 0
	je	$done$77

; 5546 : 	    /*
; 5547 : 	     * Ugly mechanism to save the raw entity value.
; 5548 : 	     */
; 5549 : 	    xmlEntityPtr cur = NULL;

	mov	DWORD PTR _cur$1[ebp], 0

; 5550 : 
; 5551 : 	    if (isParameter) {

	cmp	DWORD PTR _isParameter$[ebp], 0
	je	SHORT $LN62@xmlParseEn

; 5552 : 	        if ((ctxt->sax != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN64@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+96], 0
	je	SHORT $LN64@xmlParseEn

; 5553 : 		    (ctxt->sax->getParameterEntity != NULL))
; 5554 : 		    cur = ctxt->sax->getParameterEntity(ctxt->userData, name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+96]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cur$1[ebp], eax
$LN64@xmlParseEn:

; 5555 : 	    } else {

	jmp	SHORT $LN63@xmlParseEn
$LN62@xmlParseEn:

; 5556 : 	        if ((ctxt->sax != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN65@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN65@xmlParseEn

; 5557 : 		    (ctxt->sax->getEntity != NULL))
; 5558 : 		    cur = ctxt->sax->getEntity(ctxt->userData, name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cur$1[ebp], eax
$LN65@xmlParseEn:

; 5559 : 		if ((cur == NULL) && (ctxt->userData==ctxt)) {

	cmp	DWORD PTR _cur$1[ebp], 0
	jne	SHORT $LN63@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _ctxt$[ebp]
	jne	SHORT $LN63@xmlParseEn

; 5560 : 		    cur = xmlSAX2GetEntity(ctxt, name);

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSAX2GetEntity
	add	esp, 8
	mov	DWORD PTR _cur$1[ebp], eax
$LN63@xmlParseEn:

; 5561 : 		}
; 5562 : 	    }
; 5563 :             if ((cur != NULL) && (cur->orig == NULL)) {

	cmp	DWORD PTR _cur$1[ebp], 0
	je	SHORT $done$77
	mov	ecx, DWORD PTR _cur$1[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $done$77

; 5564 : 		cur->orig = orig;

	mov	edx, DWORD PTR _cur$1[ebp]
	mov	eax, DWORD PTR _orig$[ebp]
	mov	DWORD PTR [edx+36], eax

; 5565 :                 orig = NULL;

	mov	DWORD PTR _orig$[ebp], 0
$done$77:

; 5566 : 	    }
; 5567 : 	}
; 5568 : 
; 5569 : done:
; 5570 : 	if (value != NULL) xmlFree(value);

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN68@xmlParseEn
	mov	esi, esp
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN68@xmlParseEn:

; 5571 : 	if (URI != NULL) xmlFree(URI);

	cmp	DWORD PTR _URI$[ebp], 0
	je	SHORT $LN69@xmlParseEn
	mov	esi, esp
	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN69@xmlParseEn:

; 5572 : 	if (literal != NULL) xmlFree(literal);

	cmp	DWORD PTR _literal$[ebp], 0
	je	SHORT $LN70@xmlParseEn
	mov	esi, esp
	mov	eax, DWORD PTR _literal$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN70@xmlParseEn:

; 5573 :         if (orig != NULL) xmlFree(orig);

	cmp	DWORD PTR _orig$[ebp], 0
	je	SHORT $LN1@xmlParseEn
	mov	esi, esp
	mov	ecx, DWORD PTR _orig$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlParseEn:

; 5574 :     }
; 5575 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN76@xmlParseEn
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN76@xmlParseEn:
	DD	2
	DD	$LN75@xmlParseEn
$LN75@xmlParseEn:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN73@xmlParseEn
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN74@xmlParseEn
$LN74@xmlParseEn:
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
$LN73@xmlParseEn:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
_xmlParseEntityDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNotationDecl
_TEXT	SEGMENT
_inputid$1 = -24					; size = 4
_Systemid$ = -20					; size = 4
_Pubid$ = -12						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseNotationDecl PROC				; COMDAT

; 5256 : xmlParseNotationDecl(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 5257 :     const xmlChar *name;
; 5258 :     xmlChar *Pubid;
; 5259 :     xmlChar *Systemid;
; 5260 : 
; 5261 :     if (CMP10(CUR_PTR, '<', '!', 'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 60					; 0000003cH
	jne	$LN1@xmlParseNo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	$LN1@xmlParseNo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 78					; 0000004eH
	jne	$LN1@xmlParseNo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 79					; 0000004fH
	jne	$LN1@xmlParseNo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 84					; 00000054H
	jne	$LN1@xmlParseNo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jne	$LN1@xmlParseNo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 84					; 00000054H
	jne	$LN1@xmlParseNo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 7
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 73					; 00000049H
	jne	$LN1@xmlParseNo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 79					; 0000004fH
	jne	$LN1@xmlParseNo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 9
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 78					; 0000004eH
	jne	$LN1@xmlParseNo

; 5262 : 	int inputid = ctxt->input->id;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _inputid$1[ebp], ecx

; 5263 : 	SHRINK;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN4@xmlParseNo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	cmp	ecx, 500				; 000001f4H
	jle	SHORT $LN4@xmlParseNo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN4@xmlParseNo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSHRINK
	add	esp, 4
$LN4@xmlParseNo:

; 5264 : 	SKIP(10);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN2@xmlParseNo
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseNo:
	xor	eax, eax
	jne	SHORT $LN4@xmlParseNo

; 5265 : 	if (SKIP_BLANKS == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@xmlParseNo

; 5266 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CD@ILKLDDEI@Space?5required?5after?5?8?$DM?$CBNOTATIO@
	push	65					; 00000041H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5267 : 			   "Space required after '<!NOTATION'\n");
; 5268 : 	    return;

	jmp	$LN1@xmlParseNo
$LN8@xmlParseNo:

; 5269 : 	}
; 5270 : 
; 5271 :         name = xmlParseName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 5272 : 	if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN9@xmlParseNo

; 5273 : 	    xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);

	push	0
	push	48					; 00000030H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 5274 : 	    return;

	jmp	$LN1@xmlParseNo
$LN9@xmlParseNo:

; 5275 : 	}
; 5276 : 	if (xmlStrchr(name, ':') != NULL) {

	push	58					; 0000003aH
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlParseNo

; 5277 : 	    xmlNsErr(ctxt, XML_NS_ERR_COLON,

	push	0
	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@BOHPCDLP@colons?5are?5forbidden?5from?5notat@
	push	205					; 000000cdH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN10@xmlParseNo:

; 5278 : 		     "colons are forbidden from notation names '%s'\n",
; 5279 : 		     name, NULL, NULL);
; 5280 : 	}
; 5281 : 	if (SKIP_BLANKS == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@xmlParseNo

; 5282 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CJ@PMDGLIHG@Space?5required?5after?5the?5NOTATI@
	push	65					; 00000041H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 5283 : 		     "Space required after the NOTATION name'\n");
; 5284 : 	    return;

	jmp	$LN1@xmlParseNo
$LN11@xmlParseNo:

; 5285 : 	}
; 5286 : 
; 5287 : 	/*
; 5288 : 	 * Parse the IDs.
; 5289 : 	 */
; 5290 : 	Systemid = xmlParseExternalID(ctxt, &Pubid, 0);

	push	0
	lea	ecx, DWORD PTR _Pubid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseExternalID
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _Systemid$[ebp], eax

; 5291 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 5292 : 
; 5293 : 	if (RAW == '>') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 62					; 0000003eH
	jne	SHORT $LN12@xmlParseNo

; 5294 : 	    if (inputid != ctxt->input->id) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _inputid$1[ebp]
	cmp	ecx, DWORD PTR [eax+56]
	je	SHORT $LN14@xmlParseNo

; 5295 : 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0EA@DCHCOJDP@Notation?5declaration?5doesn?8t?5st@
	push	90					; 0000005aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN14@xmlParseNo:

; 5296 : 	                       "Notation declaration doesn't start and stop"
; 5297 :                                " in the same entity\n");
; 5298 : 	    }
; 5299 : 	    NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 5300 : 	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN15@xmlParseNo
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN15@xmlParseNo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN15@xmlParseNo

; 5301 : 		(ctxt->sax->notationDecl != NULL))
; 5302 : 		ctxt->sax->notationDecl(ctxt->userData, name, Pubid, Systemid);

	mov	esi, esp
	mov	edx, DWORD PTR _Systemid$[ebp]
	push	edx
	mov	eax, DWORD PTR _Pubid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlParseNo:

; 5303 : 	} else {

	jmp	SHORT $LN13@xmlParseNo
$LN12@xmlParseNo:

; 5304 : 	    xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);

	push	0
	push	49					; 00000031H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN13@xmlParseNo:

; 5305 : 	}
; 5306 : 	if (Systemid != NULL) xmlFree(Systemid);

	cmp	DWORD PTR _Systemid$[ebp], 0
	je	SHORT $LN16@xmlParseNo
	mov	esi, esp
	mov	edx, DWORD PTR _Systemid$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlParseNo:

; 5307 : 	if (Pubid != NULL) xmlFree(Pubid);

	cmp	DWORD PTR _Pubid$[ebp], 0
	je	SHORT $LN1@xmlParseNo
	mov	esi, esp
	mov	eax, DWORD PTR _Pubid$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlParseNo:

; 5308 :     }
; 5309 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@xmlParseNo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlParseNo:
	DD	1
	DD	$LN20@xmlParseNo
$LN20@xmlParseNo:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN19@xmlParseNo
$LN19@xmlParseNo:
	DB	80					; 00000050H
	DB	117					; 00000075H
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
_xmlParseNotationDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParsePI
_TEXT	SEGMENT
tv233 = -68						; size = 4
tv235 = -64						; size = 4
tv234 = -60						; size = 4
_allow$1 = -56						; size = 4
_new_size$2 = -52					; size = 4
_tmp$3 = -48						; size = 4
_inputid$4 = -44					; size = 4
_count$ = -40						; size = 4
_state$ = -36						; size = 4
_target$ = -32						; size = 4
_l$ = -24						; size = 4
_cur$ = -16						; size = 4
_size$ = -12						; size = 4
_len$ = -8						; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParsePI PROC					; COMDAT

; 5094 : xmlParsePI(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 5095 :     xmlChar *buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 5096 :     size_t len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 5097 :     size_t size = XML_PARSER_BUFFER_SIZE;

	mov	DWORD PTR _size$[ebp], 100		; 00000064H

; 5098 :     int cur, l;
; 5099 :     const xmlChar *target;
; 5100 :     xmlParserInputState state;
; 5101 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 5102 : 
; 5103 :     if ((RAW == '<') && (NXT(1) == '?')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	$LN1@xmlParsePI
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 63					; 0000003fH
	jne	$LN1@xmlParsePI

; 5104 : 	int inputid = ctxt->input->id;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _inputid$4[ebp], edx

; 5105 : 	state = ctxt->instate;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	mov	DWORD PTR _state$[ebp], ecx

; 5106 :         ctxt->instate = XML_PARSER_PI;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 2
$LN4@xmlParsePI:

; 5107 : 	/*
; 5108 : 	 * this is a Processing Instruction.
; 5109 : 	 */
; 5110 : 	SKIP(2);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@xmlParsePI
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParsePI:
	xor	ecx, ecx
	jne	SHORT $LN4@xmlParsePI

; 5111 : 	SHRINK;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN18@xmlParsePI
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	cmp	ecx, 500				; 000001f4H
	jle	SHORT $LN18@xmlParsePI
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN18@xmlParsePI
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSHRINK
	add	esp, 4
$LN18@xmlParsePI:

; 5112 : 
; 5113 : 	/*
; 5114 : 	 * Parse the target name and check for special support like
; 5115 : 	 * namespace.
; 5116 : 	 */
; 5117 :         target = xmlParsePITarget(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParsePITarget
	add	esp, 4
	mov	DWORD PTR _target$[ebp], eax

; 5118 : 	if (target != NULL) {

	cmp	DWORD PTR _target$[ebp], 0
	je	$LN19@xmlParsePI

; 5119 : 	    if ((RAW == '?') && (NXT(1) == '>')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 63					; 0000003fH
	jne	$LN21@xmlParsePI
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 62					; 0000003eH
	jne	$LN21@xmlParsePI

; 5120 : 		if (inputid != ctxt->input->id) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _inputid$4[ebp]
	cmp	edx, DWORD PTR [ecx+56]
	je	SHORT $LN7@xmlParsePI

; 5121 : 		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DK@LAKAFNGA@PI?5declaration?5doesn?8t?5start?5an@
	push	90					; 0000005aH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN7@xmlParsePI:

; 5122 : 	                           "PI declaration doesn't start and stop in"
; 5123 :                                    " the same entity\n");
; 5124 : 		}
; 5125 : 		SKIP(2);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 2
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN5@xmlParsePI
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParsePI:
	xor	edx, edx
	jne	SHORT $LN7@xmlParsePI

; 5126 : 
; 5127 : 		/*
; 5128 : 		 * SAX: PI detected.
; 5129 : 		 */
; 5130 : 		if ((ctxt->sax) && (!ctxt->disableSAX) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN24@xmlParsePI
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN24@xmlParsePI
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $LN24@xmlParsePI

; 5131 : 		    (ctxt->sax->processingInstruction != NULL))
; 5132 : 		    ctxt->sax->processingInstruction(ctxt->userData,

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+76]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN24@xmlParsePI:

; 5133 : 		                                     target, NULL);
; 5134 : 		if (ctxt->instate != XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	je	SHORT $LN25@xmlParsePI

; 5135 : 		    ctxt->instate = state;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+172], eax
$LN25@xmlParsePI:

; 5136 : 		return;

	jmp	$LN1@xmlParsePI
$LN21@xmlParsePI:

; 5137 : 	    }
; 5138 : 	    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	mov	esi, esp
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$[ebp], eax

; 5139 : 	    if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN26@xmlParsePI

; 5140 : 		xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 5141 : 		ctxt->instate = state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+172], ecx

; 5142 : 		return;

	jmp	$LN1@xmlParsePI
$LN26@xmlParsePI:

; 5143 : 	    }
; 5144 : 	    if (SKIP_BLANKS == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN27@xmlParsePI

; 5145 : 		xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,

	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@KBNJPEOK@ParsePI?3?5PI?5?$CFs?5space?5expected?6@
	push	65					; 00000041H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN27@xmlParsePI:

; 5146 : 			  "ParsePI: PI %s space expected\n", target);
; 5147 : 	    }
; 5148 : 	    cur = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$LN8@xmlParsePI:

; 5149 : 	    while (IS_CHAR(cur) && /* checked */

	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jge	SHORT $LN62@xmlParsePI
	cmp	DWORD PTR _cur$[ebp], 9
	jl	SHORT $LN54@xmlParsePI
	cmp	DWORD PTR _cur$[ebp], 10		; 0000000aH
	jle	SHORT $LN55@xmlParsePI
$LN54@xmlParsePI:
	cmp	DWORD PTR _cur$[ebp], 13		; 0000000dH
	je	SHORT $LN55@xmlParsePI
	cmp	DWORD PTR _cur$[ebp], 32		; 00000020H
	jge	SHORT $LN55@xmlParsePI
	mov	DWORD PTR tv234[ebp], 0
	jmp	SHORT $LN61@xmlParsePI
$LN55@xmlParsePI:
	mov	DWORD PTR tv234[ebp], 1
$LN61@xmlParsePI:
	mov	ecx, DWORD PTR tv234[ebp]
	mov	DWORD PTR tv235[ebp], ecx
	jmp	SHORT $LN63@xmlParsePI
$LN62@xmlParsePI:
	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jl	SHORT $LN56@xmlParsePI
	cmp	DWORD PTR _cur$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN58@xmlParsePI
$LN56@xmlParsePI:
	cmp	DWORD PTR _cur$[ebp], 57344		; 0000e000H
	jl	SHORT $LN57@xmlParsePI
	cmp	DWORD PTR _cur$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN58@xmlParsePI
$LN57@xmlParsePI:
	cmp	DWORD PTR _cur$[ebp], 65536		; 00010000H
	jl	SHORT $LN59@xmlParsePI
	cmp	DWORD PTR _cur$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN58@xmlParsePI
$LN59@xmlParsePI:
	mov	DWORD PTR tv233[ebp], 0
	jmp	SHORT $LN60@xmlParsePI
$LN58@xmlParsePI:
	mov	DWORD PTR tv233[ebp], 1
$LN60@xmlParsePI:
	mov	edx, DWORD PTR tv233[ebp]
	mov	DWORD PTR tv235[ebp], edx
$LN63@xmlParsePI:
	cmp	DWORD PTR tv235[ebp], 0
	je	$LN9@xmlParsePI
	cmp	DWORD PTR _cur$[ebp], 63		; 0000003fH
	jne	SHORT $LN28@xmlParsePI
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 62					; 0000003eH
	je	$LN9@xmlParsePI
$LN28@xmlParsePI:

; 5150 : 		   ((cur != '?') || (NXT(1) != '>'))) {
; 5151 : 		if (len + 5 >= size) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 5
	cmp	edx, DWORD PTR _size$[ebp]
	jb	SHORT $LN29@xmlParsePI

; 5152 : 		    xmlChar *tmp;
; 5153 :                     size_t new_size = size * 2;

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 1
	mov	DWORD PTR _new_size$2[ebp], eax

; 5154 : 		    tmp = (xmlChar *) xmlRealloc(buf, new_size);

	mov	esi, esp
	mov	ecx, DWORD PTR _new_size$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$3[ebp], eax

; 5155 : 		    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$3[ebp], 0
	jne	SHORT $LN30@xmlParsePI

; 5156 : 			xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 5157 : 			xmlFree(buf);

	mov	esi, esp
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5158 : 			ctxt->instate = state;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+172], eax

; 5159 : 			return;

	jmp	$LN1@xmlParsePI
$LN30@xmlParsePI:

; 5160 : 		    }
; 5161 : 		    buf = tmp;

	mov	ecx, DWORD PTR _tmp$3[ebp]
	mov	DWORD PTR _buf$[ebp], ecx

; 5162 :                     size = new_size;

	mov	edx, DWORD PTR _new_size$2[ebp]
	mov	DWORD PTR _size$[ebp], edx
$LN29@xmlParsePI:

; 5163 : 		}
; 5164 : 		count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 5165 : 		if (count > 50) {

	cmp	DWORD PTR _count$[ebp], 50		; 00000032H
	jle	$LN31@xmlParsePI

; 5166 : 		    GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN32@xmlParsePI
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN32@xmlParsePI
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN32@xmlParsePI:

; 5167 :                     if (ctxt->instate == XML_PARSER_EOF) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN33@xmlParsePI

; 5168 :                         xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5169 :                         return;

	jmp	$LN1@xmlParsePI
$LN33@xmlParsePI:

; 5170 :                     }
; 5171 : 		    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 5172 :                     if ((len > XML_MAX_TEXT_LENGTH) &&

	cmp	DWORD PTR _len$[ebp], 10000000		; 00989680H
	jbe	SHORT $LN31@xmlParsePI
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN31@xmlParsePI

; 5173 :                         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 5174 :                         xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,

	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@KDNCGJGM@PI?5?$CFs?5too?5big?5found@
	push	47					; 0000002fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 5175 :                                           "PI %s too big found", target);
; 5176 :                         xmlFree(buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5177 :                         ctxt->instate = state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+172], ecx

; 5178 :                         return;

	jmp	$LN1@xmlParsePI
$LN31@xmlParsePI:

; 5179 :                     }
; 5180 : 		}
; 5181 : 		COPY_BUF(l,buf,len,cur);

	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN35@xmlParsePI
	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	al, BYTE PTR _cur$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	jmp	SHORT $LN12@xmlParsePI
$LN35@xmlParsePI:
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	push	eax
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN12@xmlParsePI:

; 5182 : 		NEXTL(l);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN37@xmlParsePI
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], 1
	jmp	SHORT $LN38@xmlParsePI
$LN37@xmlParsePI:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
$LN38@xmlParsePI:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	xor	ecx, ecx
	jne	SHORT $LN12@xmlParsePI

; 5183 : 		cur = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5184 : 		if (cur == 0) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	$LN39@xmlParsePI

; 5185 : 		    SHRINK;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN40@xmlParsePI
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN40@xmlParsePI
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 500				; 000001f4H
	jge	SHORT $LN40@xmlParsePI
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSHRINK
	add	esp, 4
$LN40@xmlParsePI:

; 5186 : 		    GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN41@xmlParsePI
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN41@xmlParsePI
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN41@xmlParsePI:

; 5187 : 		    cur = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$LN39@xmlParsePI:

; 5188 : 		}
; 5189 : 	    }

	jmp	$LN8@xmlParsePI
$LN9@xmlParsePI:

; 5190 :             if ((len > XML_MAX_TEXT_LENGTH) &&

	cmp	DWORD PTR _len$[ebp], 10000000		; 00989680H
	jbe	SHORT $LN42@xmlParsePI
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN42@xmlParsePI

; 5191 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 5192 :                 xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,

	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@KDNCGJGM@PI?5?$CFs?5too?5big?5found@
	push	47					; 0000002fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 5193 :                                   "PI %s too big found", target);
; 5194 :                 xmlFree(buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5195 :                 ctxt->instate = state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+172], ecx

; 5196 :                 return;

	jmp	$LN1@xmlParsePI
$LN42@xmlParsePI:

; 5197 :             }
; 5198 : 	    buf[len] = 0;

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 0

; 5199 : 	    if (cur != '?') {

	cmp	DWORD PTR _cur$[ebp], 63		; 0000003fH
	je	SHORT $LN43@xmlParsePI

; 5200 : 		xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,

	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@OGPJFKEP@ParsePI?3?5PI?5?$CFs?5never?5end?5?4?4?4?6@
	push	47					; 0000002fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 5201 : 		      "ParsePI: PI %s never end ...\n", target);
; 5202 : 	    } else {

	jmp	$LN44@xmlParsePI
$LN43@xmlParsePI:

; 5203 : 		if (inputid != ctxt->input->id) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _inputid$4[ebp]
	cmp	ecx, DWORD PTR [eax+56]
	je	SHORT $LN15@xmlParsePI

; 5204 : 		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DK@LAKAFNGA@PI?5declaration?5doesn?8t?5start?5an@
	push	90					; 0000005aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN15@xmlParsePI:

; 5205 : 	                           "PI declaration doesn't start and stop in"
; 5206 :                                    " the same entity\n");
; 5207 : 		}
; 5208 : 		SKIP(2);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 2
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN13@xmlParsePI
	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN13@xmlParsePI:
	xor	ecx, ecx
	jne	SHORT $LN15@xmlParsePI

; 5209 : 
; 5210 : #ifdef LIBXML_CATALOG_ENABLED
; 5211 : 		if (((state == XML_PARSER_MISC) ||
; 5212 : 	             (state == XML_PARSER_START)) &&

	cmp	DWORD PTR _state$[ebp], 1
	je	SHORT $LN48@xmlParsePI
	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN47@xmlParsePI
$LN48@xmlParsePI:
	push	OFFSET ??_C@_0BC@IDENENGP@oasis?9xml?9catalog@
	mov	edx, DWORD PTR _target$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN47@xmlParsePI

; 5213 : 		    (xmlStrEqual(target, XML_CATALOG_PI))) {
; 5214 : 		    xmlCatalogAllow allow = xmlCatalogGetDefaults();

	call	_xmlCatalogGetDefaults
	mov	DWORD PTR _allow$1[ebp], eax

; 5215 : 		    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||

	cmp	DWORD PTR _allow$1[ebp], 2
	je	SHORT $LN50@xmlParsePI
	cmp	DWORD PTR _allow$1[ebp], 3
	jne	SHORT $LN47@xmlParsePI
$LN50@xmlParsePI:

; 5216 : 			(allow == XML_CATA_ALLOW_ALL))
; 5217 : 			xmlParseCatalogPI(ctxt, buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseCatalogPI
	add	esp, 8
$LN47@xmlParsePI:

; 5218 : 		}
; 5219 : #endif
; 5220 : 
; 5221 : 
; 5222 : 		/*
; 5223 : 		 * SAX: PI detected.
; 5224 : 		 */
; 5225 : 		if ((ctxt->sax) && (!ctxt->disableSAX) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN44@xmlParsePI
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN44@xmlParsePI
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+76], 0
	je	SHORT $LN44@xmlParsePI

; 5226 : 		    (ctxt->sax->processingInstruction != NULL))
; 5227 : 		    ctxt->sax->processingInstruction(ctxt->userData,

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+76]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN44@xmlParsePI:

; 5228 : 		                                     target, buf);
; 5229 : 	    }
; 5230 : 	    xmlFree(buf);

	mov	esi, esp
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5231 : 	} else {

	jmp	SHORT $LN20@xmlParsePI
$LN19@xmlParsePI:

; 5232 : 	    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);

	push	0
	push	46					; 0000002eH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN20@xmlParsePI:

; 5233 : 	}
; 5234 : 	if (ctxt->instate != XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	je	SHORT $LN1@xmlParsePI

; 5235 : 	    ctxt->instate = state;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+172], edx
$LN1@xmlParsePI:

; 5236 :     }
; 5237 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN66@xmlParsePI
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@xmlParsePI:
	DD	1
	DD	$LN65@xmlParsePI
$LN65@xmlParsePI:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN64@xmlParsePI
$LN64@xmlParsePI:
	DB	108					; 0000006cH
	DB	0
_xmlParsePI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParsePITarget
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_name$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParsePITarget PROC					; COMDAT

; 4986 : xmlParsePITarget(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 4987 :     const xmlChar *name;
; 4988 : 
; 4989 :     name = xmlParseName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 4990 :     if ((name != NULL) &&
; 4991 :         ((name[0] == 'x') || (name[0] == 'X')) &&
; 4992 :         ((name[1] == 'm') || (name[1] == 'M')) &&

	cmp	DWORD PTR _name$[ebp], 0
	je	$LN5@xmlParsePI
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 120				; 00000078H
	je	SHORT $LN6@xmlParsePI
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 88					; 00000058H
	jne	$LN5@xmlParsePI
$LN6@xmlParsePI:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 109				; 0000006dH
	je	SHORT $LN7@xmlParsePI
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 77					; 0000004dH
	jne	$LN5@xmlParsePI
$LN7@xmlParsePI:
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 108				; 0000006cH
	je	SHORT $LN8@xmlParsePI
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 76					; 0000004cH
	jne	$LN5@xmlParsePI
$LN8@xmlParsePI:

; 4993 :         ((name[2] == 'l') || (name[2] == 'L'))) {
; 4994 : 	int i;
; 4995 : 	if ((name[0] == 'x') && (name[1] == 'm') &&
; 4996 : 	    (name[2] == 'l') && (name[3] == 0)) {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 120				; 00000078H
	jne	SHORT $LN9@xmlParsePI
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 109				; 0000006dH
	jne	SHORT $LN9@xmlParsePI
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 108				; 0000006cH
	jne	SHORT $LN9@xmlParsePI
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN9@xmlParsePI

; 4997 : 	    xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,

	push	OFFSET ??_C@_0DL@PMHMGOPA@XML?5declaration?5allowed?5only?5at@
	push	64					; 00000040H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 4998 : 		 "XML declaration allowed only at the start of the document\n");
; 4999 : 	    return(name);

	mov	eax, DWORD PTR _name$[ebp]
	jmp	$LN1@xmlParsePI
	jmp	SHORT $LN10@xmlParsePI
$LN9@xmlParsePI:

; 5000 : 	} else if (name[3] == 0) {

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN10@xmlParsePI

; 5001 : 	    xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);

	push	0
	push	64					; 00000040H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 5002 : 	    return(name);

	mov	eax, DWORD PTR _name$[ebp]
	jmp	$LN1@xmlParsePI
$LN10@xmlParsePI:

; 5003 : 	}
; 5004 : 	for (i = 0;;i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@xmlParsePI
$LN2@xmlParsePI:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@xmlParsePI:

; 5005 : 	    if (xmlW3CPIs[i] == NULL) break;

	mov	eax, DWORD PTR _i$1[ebp]
	cmp	DWORD PTR _xmlW3CPIs[eax*4], 0
	jne	SHORT $LN12@xmlParsePI
	jmp	SHORT $LN3@xmlParsePI
$LN12@xmlParsePI:

; 5006 : 	    if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))

	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _xmlW3CPIs[ecx*4]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlParsePI

; 5007 : 	        return(name);

	mov	eax, DWORD PTR _name$[ebp]
	jmp	SHORT $LN1@xmlParsePI
$LN13@xmlParsePI:

; 5008 : 	}

	jmp	SHORT $LN2@xmlParsePI
$LN3@xmlParsePI:

; 5009 : 	xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,

	push	0
	push	0
	push	OFFSET ??_C@_0CN@KJOCGNCM@xmlParsePITarget?3?5invalid?5name?5@
	push	64					; 00000040H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlWarningMsg
	add	esp, 20					; 00000014H
$LN5@xmlParsePI:

; 5010 : 		      "xmlParsePITarget: invalid name prefix 'xml'\n",
; 5011 : 		      NULL, NULL);
; 5012 :     }
; 5013 :     if ((name != NULL) && (xmlStrchr(name, ':') != NULL)) {

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN14@xmlParsePI
	push	58					; 0000003aH
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlParsePI

; 5014 : 	xmlNsErr(ctxt, XML_NS_ERR_COLON,

	push	0
	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0CJ@KOKAGEDL@colons?5are?5forbidden?5from?5PI?5na@
	push	205					; 000000cdH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNsErr
	add	esp, 24					; 00000018H
$LN14@xmlParsePI:

; 5015 : 		 "colons are forbidden from PI names '%s'\n", name, NULL, NULL);
; 5016 :     }
; 5017 :     return(name);

	mov	eax, DWORD PTR _name$[ebp]
$LN1@xmlParsePI:

; 5018 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParsePITarget ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseComment
_TEXT	SEGMENT
_new_buf$1 = -36					; size = 4
_inputid$ = -32						; size = 4
_ccol$ = -28						; size = 4
_nbchar$ = -24						; size = 4
_in$ = -20						; size = 4
_state$ = -16						; size = 4
_len$ = -12						; size = 4
_size$ = -8						; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseComment PROC					; COMDAT

; 4814 : xmlParseComment(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 4815 :     xmlChar *buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 4816 :     size_t size = XML_PARSER_BUFFER_SIZE;

	mov	DWORD PTR _size$[ebp], 100		; 00000064H

; 4817 :     size_t len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 4818 :     xmlParserInputState state;
; 4819 :     const xmlChar *in;
; 4820 :     size_t nbchar = 0;

	mov	DWORD PTR _nbchar$[ebp], 0

; 4821 :     int ccol;
; 4822 :     int inputid;
; 4823 : 
; 4824 :     /*
; 4825 :      * Check that there is a comment right here.
; 4826 :      */
; 4827 :     if ((RAW != '<') || (NXT(1) != '!') ||
; 4828 :         (NXT(2) != '-') || (NXT(3) != '-')) return;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN20@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 33					; 00000021H
	jne	SHORT $LN20@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN20@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN19@xmlParseCo
$LN20@xmlParseCo:
	jmp	$LN1@xmlParseCo
$LN19@xmlParseCo:

; 4829 :     state = ctxt->instate;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+172]
	mov	DWORD PTR _state$[ebp], eax

; 4830 :     ctxt->instate = XML_PARSER_COMMENT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 5

; 4831 :     inputid = ctxt->input->id;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _inputid$[ebp], ecx
$LN4@xmlParseCo:

; 4832 :     SKIP(4);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+200]
	add	eax, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+200], eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN2@xmlParseCo
	push	250					; 000000faH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseCo:
	xor	eax, eax
	jne	SHORT $LN4@xmlParseCo

; 4833 :     SHRINK;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN22@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN22@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 500				; 000001f4H
	jge	SHORT $LN22@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSHRINK
	add	esp, 4
$LN22@xmlParseCo:

; 4834 :     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN23@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN23@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN23@xmlParseCo:

; 4835 : 
; 4836 :     /*
; 4837 :      * Accelerated common case where input don't need to be
; 4838 :      * modified before passing it to the handler.
; 4839 :      */
; 4840 :     in = ctxt->input->cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _in$[ebp], ecx
$LN7@xmlParseCo:

; 4841 :     do {
; 4842 : 	if (*in == 0xA) {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $get_more$61
$LN10@xmlParseCo:

; 4843 : 	    do {
; 4844 : 		ctxt->input->line++; ctxt->input->col = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1

; 4845 : 		in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx

; 4846 : 	    } while (*in == 0xA);

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN10@xmlParseCo
$get_more$61:

; 4847 : 	}
; 4848 : get_more:
; 4849 :         ccol = ctxt->input->col;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _ccol$[ebp], ecx
$LN11@xmlParseCo:

; 4850 : 	while (((*in > '-') && (*in <= 0x7F)) ||
; 4851 : 	       ((*in >= 0x20) && (*in < '-')) ||

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jle	SHORT $LN26@xmlParseCo
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 127				; 0000007fH
	jle	SHORT $LN25@xmlParseCo
$LN26@xmlParseCo:
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN27@xmlParseCo
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jl	SHORT $LN25@xmlParseCo
$LN27@xmlParseCo:
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN12@xmlParseCo
$LN25@xmlParseCo:

; 4852 : 	       (*in == 0x09)) {
; 4853 : 		    in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 4854 : 		    ccol++;

	mov	ecx, DWORD PTR _ccol$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ccol$[ebp], ecx

; 4855 : 	}

	jmp	SHORT $LN11@xmlParseCo
$LN12@xmlParseCo:

; 4856 : 	ctxt->input->col = ccol;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ccol$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 4857 : 	if (*in == 0xA) {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN28@xmlParseCo
$LN15@xmlParseCo:

; 4858 : 	    do {
; 4859 : 		ctxt->input->line++; ctxt->input->col = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1

; 4860 : 		in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx

; 4861 : 	    } while (*in == 0xA);

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN15@xmlParseCo

; 4862 : 	    goto get_more;

	jmp	$get_more$61
$LN28@xmlParseCo:

; 4863 : 	}
; 4864 : 	nbchar = in - ctxt->input->cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _in$[ebp]
	sub	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _nbchar$[ebp], ecx

; 4865 : 	/*
; 4866 : 	 * save current set of data
; 4867 : 	 */
; 4868 : 	if (nbchar > 0) {

	je	$LN29@xmlParseCo

; 4869 : 	    if ((ctxt->sax != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN29@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+80], 0
	je	$LN29@xmlParseCo

; 4870 : 		(ctxt->sax->comment != NULL)) {
; 4871 : 		if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN31@xmlParseCo

; 4872 : 		    if ((*in == '-') && (in[1] == '-'))

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN33@xmlParseCo
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN33@xmlParseCo

; 4873 : 		        size = nbchar + 1;

	mov	ecx, DWORD PTR _nbchar$[ebp]
	add	ecx, 1
	mov	DWORD PTR _size$[ebp], ecx
	jmp	SHORT $LN34@xmlParseCo
$LN33@xmlParseCo:

; 4874 : 		    else
; 4875 : 		        size = XML_PARSER_BUFFER_SIZE + nbchar;

	mov	edx, DWORD PTR _nbchar$[ebp]
	add	edx, 100				; 00000064H
	mov	DWORD PTR _size$[ebp], edx
$LN34@xmlParseCo:

; 4876 : 		    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$[ebp], eax

; 4877 : 		    if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN35@xmlParseCo

; 4878 : 		        xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 4879 : 			ctxt->instate = state;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+172], eax

; 4880 : 			return;

	jmp	$LN1@xmlParseCo
$LN35@xmlParseCo:

; 4881 : 		    }
; 4882 : 		    len = 0;

	mov	DWORD PTR _len$[ebp], 0
	jmp	SHORT $LN32@xmlParseCo
$LN31@xmlParseCo:

; 4883 : 		} else if (len + nbchar + 1 >= size) {

	mov	ecx, DWORD PTR _nbchar$[ebp]
	mov	edx, DWORD PTR _len$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	cmp	eax, DWORD PTR _size$[ebp]
	jb	SHORT $LN32@xmlParseCo

; 4884 : 		    xmlChar *new_buf;
; 4885 : 		    size  += len + nbchar + XML_PARSER_BUFFER_SIZE;

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, DWORD PTR _nbchar$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	lea	eax, DWORD PTR [edx+ecx+100]
	mov	DWORD PTR _size$[ebp], eax

; 4886 : 		    new_buf = (xmlChar *) xmlRealloc(buf,

	mov	esi, esp
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _new_buf$1[ebp], eax

; 4887 : 		                                     size * sizeof(xmlChar));
; 4888 : 		    if (new_buf == NULL) {

	cmp	DWORD PTR _new_buf$1[ebp], 0
	jne	SHORT $LN37@xmlParseCo

; 4889 : 		        xmlFree (buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4890 : 			xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 4891 : 			ctxt->instate = state;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+172], eax

; 4892 : 			return;

	jmp	$LN1@xmlParseCo
$LN37@xmlParseCo:

; 4893 : 		    }
; 4894 : 		    buf = new_buf;

	mov	ecx, DWORD PTR _new_buf$1[ebp]
	mov	DWORD PTR _buf$[ebp], ecx
$LN32@xmlParseCo:

; 4895 : 		}
; 4896 : 		memcpy(&buf[len], ctxt->input->cur, nbchar);

	mov	edx, DWORD PTR _nbchar$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4897 : 		len += nbchar;

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, DWORD PTR _nbchar$[ebp]
	mov	DWORD PTR _len$[ebp], ecx

; 4898 : 		buf[len] = 0;

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 0
$LN29@xmlParseCo:

; 4899 : 	    }
; 4900 : 	}
; 4901 :         if ((len > XML_MAX_TEXT_LENGTH) &&

	cmp	DWORD PTR _len$[ebp], 10000000		; 00989680H
	jbe	SHORT $LN38@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	jne	SHORT $LN38@xmlParseCo

; 4902 :             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 4903 :             xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,

	push	0
	push	OFFSET ??_C@_0BG@BAOBDEOI@Comment?5too?5big?5found@
	push	45					; 0000002dH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 4904 :                          "Comment too big found", NULL);
; 4905 :             xmlFree (buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4906 :             return;

	jmp	$LN1@xmlParseCo
$LN38@xmlParseCo:

; 4907 :         }
; 4908 : 	ctxt->input->cur = in;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR [edx+16], eax

; 4909 : 	if (*in == 0xA) {

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN39@xmlParseCo

; 4910 : 	    in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 4911 : 	    ctxt->input->line++; ctxt->input->col = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
$LN39@xmlParseCo:

; 4912 : 	}
; 4913 : 	if (*in == 0xD) {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN40@xmlParseCo

; 4914 : 	    in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 4915 : 	    if (*in == 0xA) {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN41@xmlParseCo

; 4916 : 		ctxt->input->cur = in;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR [edx+16], eax

; 4917 : 		in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 4918 : 		ctxt->input->line++; ctxt->input->col = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], 1

; 4919 : 		continue; /* while */

	jmp	$LN5@xmlParseCo
$LN41@xmlParseCo:

; 4920 : 	    }
; 4921 : 	    in--;

	mov	eax, DWORD PTR _in$[ebp]
	sub	eax, 1
	mov	DWORD PTR _in$[ebp], eax
$LN40@xmlParseCo:

; 4922 : 	}
; 4923 : 	SHRINK;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN42@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN42@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 500				; 000001f4H
	jge	SHORT $LN42@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSHRINK
	add	esp, 4
$LN42@xmlParseCo:

; 4924 : 	GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN43@xmlParseCo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN43@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN43@xmlParseCo:

; 4925 :         if (ctxt->instate == XML_PARSER_EOF) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN44@xmlParseCo

; 4926 :             xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4927 :             return;

	jmp	$LN1@xmlParseCo
$LN44@xmlParseCo:

; 4928 :         }
; 4929 : 	in = ctxt->input->cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _in$[ebp], eax

; 4930 : 	if (*in == '-') {

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	$LN5@xmlParseCo

; 4931 : 	    if (in[1] == '-') {

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	$LN46@xmlParseCo

; 4932 : 	        if (in[2] == '>') {

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 62					; 0000003eH
	jne	$LN47@xmlParseCo

; 4933 : 		    if (ctxt->input->id != inputid) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+56]
	cmp	edx, DWORD PTR _inputid$[ebp]
	je	SHORT $LN18@xmlParseCo

; 4934 : 			xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,

	push	OFFSET ??_C@_0DD@DDHAOEGP@comment?5doesn?8t?5start?5and?5stop?5@
	push	90					; 0000005aH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN18@xmlParseCo:

; 4935 : 			               "comment doesn't start and stop in the"
; 4936 :                                        " same entity\n");
; 4937 : 		    }
; 4938 : 		    SKIP(3);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 3
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 3
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN16@xmlParseCo
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN16@xmlParseCo:
	xor	edx, edx
	jne	SHORT $LN18@xmlParseCo

; 4939 : 		    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN50@xmlParseCo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+80], 0
	je	SHORT $LN50@xmlParseCo
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN50@xmlParseCo

; 4940 : 		        (!ctxt->disableSAX)) {
; 4941 : 			if (buf != NULL)

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN51@xmlParseCo

; 4942 : 			    ctxt->sax->comment(ctxt->userData, buf);

	mov	esi, esp
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+80]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN50@xmlParseCo
$LN51@xmlParseCo:

; 4943 : 			else
; 4944 : 			    ctxt->sax->comment(ctxt->userData, BAD_CAST "");

	mov	esi, esp
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+80]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN50@xmlParseCo:

; 4945 : 		    }
; 4946 : 		    if (buf != NULL)

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN53@xmlParseCo

; 4947 : 		        xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN53@xmlParseCo:

; 4948 : 		    if (ctxt->instate != XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	je	SHORT $LN54@xmlParseCo

; 4949 : 			ctxt->instate = state;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+172], eax
$LN54@xmlParseCo:

; 4950 : 		    return;

	jmp	$LN1@xmlParseCo
$LN47@xmlParseCo:

; 4951 : 		}
; 4952 : 		if (buf != NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN55@xmlParseCo

; 4953 : 		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CJ@CBOBCJAG@Double?5hyphen?5within?5comment?3?5?$DM@
	push	80					; 00000050H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H

; 4954 : 		                      "Double hyphen within comment: "
; 4955 :                                       "<!--%.50s\n",
; 4956 : 				      buf);
; 4957 : 		} else

	jmp	SHORT $LN56@xmlParseCo
$LN55@xmlParseCo:

; 4958 : 		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,

	push	0
	push	OFFSET ??_C@_0BO@PENANJHM@Double?5hyphen?5within?5comment?6@
	push	80					; 00000050H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN56@xmlParseCo:

; 4959 : 		                      "Double hyphen within comment\n", NULL);
; 4960 : 		in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 4961 : 		ctxt->input->col++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN46@xmlParseCo:

; 4962 : 	    }
; 4963 : 	    in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 4964 : 	    ctxt->input->col++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx

; 4965 : 	    goto get_more;

	jmp	$get_more$61
$LN5@xmlParseCo:

; 4966 : 	}
; 4967 :     } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09));

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jl	SHORT $LN57@xmlParseCo
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	jle	$LN7@xmlParseCo
$LN57@xmlParseCo:
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	je	$LN7@xmlParseCo

; 4968 :     xmlParseCommentComplex(ctxt, buf, len, size);

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseCommentComplex
	add	esp, 16					; 00000010H

; 4969 :     ctxt->instate = state;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+172], eax
$LN1@xmlParseCo:

; 4970 :     return;
; 4971 : }

	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseComment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseExternalID
_TEXT	SEGMENT
_URI$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_publicID$ = 12						; size = 4
_strict$ = 16						; size = 4
_xmlParseExternalID PROC				; COMDAT

; 4613 : xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 4614 :     xmlChar *URI = NULL;

	mov	DWORD PTR _URI$[ebp], 0

; 4615 : 
; 4616 :     SHRINK;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN8@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	cmp	edx, 500				; 000001f4H
	jle	SHORT $LN8@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 500				; 000001f4H
	jge	SHORT $LN8@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSHRINK
	add	esp, 4
$LN8@xmlParseEx:

; 4617 : 
; 4618 :     *publicID = NULL;

	mov	eax, DWORD PTR _publicID$[ebp]
	mov	DWORD PTR [eax], 0

; 4619 :     if (CMP6(CUR_PTR, 'S', 'Y', 'S', 'T', 'E', 'M')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 83					; 00000053H
	jne	$LN9@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 89					; 00000059H
	jne	$LN9@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 83					; 00000053H
	jne	$LN9@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 84					; 00000054H
	jne	$LN9@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 69					; 00000045H
	jne	$LN9@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 77					; 0000004dH
	jne	$LN9@xmlParseEx
$LN4@xmlParseEx:

; 4620 :         SKIP(6);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 6
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 6
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN2@xmlParseEx
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN2@xmlParseEx:
	xor	edx, edx
	jne	SHORT $LN4@xmlParseEx

; 4621 : 	if (SKIP_BLANKS == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@xmlParseEx

; 4622 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BP@CCMMHADN@Space?5required?5after?5?8SYSTEM?8?6@
	push	65					; 00000041H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN12@xmlParseEx:

; 4623 : 	                   "Space required after 'SYSTEM'\n");
; 4624 : 	}
; 4625 : 	URI = xmlParseSystemLiteral(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseSystemLiteral
	add	esp, 4
	mov	DWORD PTR _URI$[ebp], eax

; 4626 : 	if (URI == NULL) {

	cmp	DWORD PTR _URI$[ebp], 0
	jne	SHORT $LN13@xmlParseEx

; 4627 : 	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);

	push	0
	push	70					; 00000046H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN13@xmlParseEx:

; 4628 :         }

	jmp	$LN10@xmlParseEx
$LN9@xmlParseEx:

; 4629 :     } else if (CMP6(CUR_PTR, 'P', 'U', 'B', 'L', 'I', 'C')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 80					; 00000050H
	jne	$LN10@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 85					; 00000055H
	jne	$LN10@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 66					; 00000042H
	jne	$LN10@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 76					; 0000004cH
	jne	$LN10@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 73					; 00000049H
	jne	$LN10@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 67					; 00000043H
	jne	$LN10@xmlParseEx
$LN7@xmlParseEx:

; 4630 :         SKIP(6);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, 6
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 6
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN5@xmlParseEx
	push	250					; 000000faH
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_xmlParserInputGrow
	add	esp, 8
$LN5@xmlParseEx:
	xor	edx, edx
	jne	SHORT $LN7@xmlParseEx

; 4631 : 	if (SKIP_BLANKS == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@xmlParseEx

; 4632 : 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0BP@EHONNEAJ@Space?5required?5after?5?8PUBLIC?8?6@
	push	65					; 00000041H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN16@xmlParseEx:

; 4633 : 		    "Space required after 'PUBLIC'\n");
; 4634 : 	}
; 4635 : 	*publicID = xmlParsePubidLiteral(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParsePubidLiteral
	add	esp, 4
	mov	ecx, DWORD PTR _publicID$[ebp]
	mov	DWORD PTR [ecx], eax

; 4636 : 	if (*publicID == NULL) {

	mov	edx, DWORD PTR _publicID$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN17@xmlParseEx

; 4637 : 	    xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);

	push	0
	push	71					; 00000047H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN17@xmlParseEx:

; 4638 : 	}
; 4639 : 	if (strict) {

	cmp	DWORD PTR _strict$[ebp], 0
	je	SHORT $LN18@xmlParseEx

; 4640 : 	    /*
; 4641 : 	     * We don't handle [83] so "S SystemLiteral" is required.
; 4642 : 	     */
; 4643 : 	    if (SKIP_BLANKS == 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN20@xmlParseEx

; 4644 : 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,

	push	OFFSET ??_C@_0CM@PJLPICDD@Space?5required?5after?5the?5Public@
	push	65					; 00000041H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN20@xmlParseEx:

; 4645 : 			"Space required after the Public Identifier\n");
; 4646 : 	    }
; 4647 : 	} else {

	jmp	SHORT $LN19@xmlParseEx
$LN18@xmlParseEx:

; 4648 : 	    /*
; 4649 : 	     * We handle [83] so we return immediately, if
; 4650 : 	     * "S SystemLiteral" is not detected. We skip blanks if no
; 4651 :              * system literal was found, but this is harmless since we must
; 4652 :              * be at the end of a NotationDecl.
; 4653 : 	     */
; 4654 : 	    if (SKIP_BLANKS == 0) return(NULL);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN21@xmlParseEx
	xor	eax, eax
	jmp	SHORT $LN1@xmlParseEx
$LN21@xmlParseEx:

; 4655 : 	    if ((CUR != '\'') && (CUR != '"')) return(NULL);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	je	SHORT $LN19@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	je	SHORT $LN19@xmlParseEx
	xor	eax, eax
	jmp	SHORT $LN1@xmlParseEx
$LN19@xmlParseEx:

; 4656 : 	}
; 4657 : 	URI = xmlParseSystemLiteral(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseSystemLiteral
	add	esp, 4
	mov	DWORD PTR _URI$[ebp], eax

; 4658 : 	if (URI == NULL) {

	cmp	DWORD PTR _URI$[ebp], 0
	jne	SHORT $LN10@xmlParseEx

; 4659 : 	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);

	push	0
	push	70					; 00000046H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN10@xmlParseEx:

; 4660 :         }
; 4661 :     }
; 4662 :     return(URI);

	mov	eax, DWORD PTR _URI$[ebp]
$LN1@xmlParseEx:

; 4663 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseExternalID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCharData
_TEXT	SEGMENT
_tmp$1 = -28						; size = 4
_tmp$2 = -24						; size = 4
_ccol$ = -20						; size = 4
_col$ = -16						; size = 4
_line$ = -12						; size = 4
_nbchar$ = -8						; size = 4
_in$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cdata$ = 12						; size = 4
_xmlParseCharData PROC					; COMDAT

; 4357 : xmlParseCharData(xmlParserCtxtPtr ctxt, int cdata) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 4358 :     const xmlChar *in;
; 4359 :     int nbchar = 0;

	mov	DWORD PTR _nbchar$[ebp], 0

; 4360 :     int line = ctxt->input->line;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _line$[ebp], edx

; 4361 :     int col = ctxt->input->col;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _col$[ebp], edx

; 4362 :     int ccol;
; 4363 : 
; 4364 :     SHRINK;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN15@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	cmp	edx, 500				; 000001f4H
	jle	SHORT $LN15@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 500				; 000001f4H
	jge	SHORT $LN15@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSHRINK
	add	esp, 4
$LN15@xmlParseCh:

; 4365 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN16@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN16@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN16@xmlParseCh:

; 4366 :     /*
; 4367 :      * Accelerated common case where input don't need to be
; 4368 :      * modified before passing it to the handler.
; 4369 :      */
; 4370 :     if (!cdata) {

	cmp	DWORD PTR _cdata$[ebp], 0
	jne	$LN17@xmlParseCh

; 4371 : 	in = ctxt->input->cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _in$[ebp], eax
$get_more_space$56:

; 4372 : 	do {
; 4373 : get_more_space:
; 4374 : 	    while (*in == 0x20) { in++; ctxt->input->col++; }

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN6@xmlParseCh
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax
	jmp	SHORT $get_more_space$56
$LN6@xmlParseCh:

; 4375 : 	    if (*in == 0xA) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN18@xmlParseCh
$LN9@xmlParseCh:

; 4376 : 		do {
; 4377 : 		    ctxt->input->line++; ctxt->input->col = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], 1

; 4378 : 		    in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 4379 : 		} while (*in == 0xA);

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN9@xmlParseCh

; 4380 : 		goto get_more_space;

	jmp	SHORT $get_more_space$56
$LN18@xmlParseCh:

; 4381 : 	    }
; 4382 : 	    if (*in == '<') {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	$get_more$57

; 4383 : 		nbchar = in - ctxt->input->cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _in$[ebp]
	sub	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _nbchar$[ebp], ecx

; 4384 : 		if (nbchar > 0) {

	cmp	DWORD PTR _nbchar$[ebp], 0
	jle	$LN20@xmlParseCh

; 4385 : 		    const xmlChar *tmp = ctxt->input->cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _tmp$2[ebp], ecx

; 4386 : 		    ctxt->input->cur = in;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 4387 : 
; 4388 : 		    if ((ctxt->sax != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN21@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+72]
	cmp	ecx, DWORD PTR [eax+68]
	je	$LN21@xmlParseCh

; 4389 : 		        (ctxt->sax->ignorableWhitespace !=
; 4390 : 		         ctxt->sax->characters)) {
; 4391 : 			if (areBlanks(ctxt, tmp, nbchar, 1)) {

	push	1
	mov	edx, DWORD PTR _nbchar$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_areBlanks
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN23@xmlParseCh

; 4392 : 			    if (ctxt->sax->ignorableWhitespace != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $LN25@xmlParseCh

; 4393 : 				ctxt->sax->ignorableWhitespace(ctxt->userData,

	mov	esi, esp
	mov	ecx, DWORD PTR _nbchar$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+72]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN25@xmlParseCh:

; 4394 : 						       tmp, nbchar);
; 4395 : 			} else {

	jmp	SHORT $LN24@xmlParseCh
$LN23@xmlParseCh:

; 4396 : 			    if (ctxt->sax->characters != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN26@xmlParseCh

; 4397 : 				ctxt->sax->characters(ctxt->userData,

	mov	esi, esp
	mov	ecx, DWORD PTR _nbchar$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+68]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@xmlParseCh:

; 4398 : 						      tmp, nbchar);
; 4399 : 			    if (*ctxt->space == -1)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+232]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN24@xmlParseCh

; 4400 : 			        *ctxt->space = -2;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	mov	DWORD PTR [edx], -2			; fffffffeH
$LN24@xmlParseCh:

; 4401 : 			}

	jmp	SHORT $LN20@xmlParseCh
$LN21@xmlParseCh:

; 4402 : 		    } else if ((ctxt->sax != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN20@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN20@xmlParseCh

; 4403 : 		               (ctxt->sax->characters != NULL)) {
; 4404 : 			ctxt->sax->characters(ctxt->userData,

	mov	esi, esp
	mov	eax, DWORD PTR _nbchar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmp$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+68]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@xmlParseCh:

; 4405 : 					      tmp, nbchar);
; 4406 : 		    }
; 4407 : 		}
; 4408 : 		return;

	jmp	$LN1@xmlParseCh
$get_more$57:

; 4409 : 	    }
; 4410 : 
; 4411 : get_more:
; 4412 :             ccol = ctxt->input->col;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _ccol$[ebp], eax
$LN10@xmlParseCh:

; 4413 : 	    while (test_char_data[*in]) {

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _test_char_data[edx]
	test	eax, eax
	je	SHORT $LN11@xmlParseCh

; 4414 : 		in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 4415 : 		ccol++;

	mov	edx, DWORD PTR _ccol$[ebp]
	add	edx, 1
	mov	DWORD PTR _ccol$[ebp], edx

; 4416 : 	    }

	jmp	SHORT $LN10@xmlParseCh
$LN11@xmlParseCh:

; 4417 : 	    ctxt->input->col = ccol;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ccol$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 4418 : 	    if (*in == 0xA) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN29@xmlParseCh
$LN14@xmlParseCh:

; 4419 : 		do {
; 4420 : 		    ctxt->input->line++; ctxt->input->col = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], 1

; 4421 : 		    in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 4422 : 		} while (*in == 0xA);

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN14@xmlParseCh

; 4423 : 		goto get_more;

	jmp	SHORT $get_more$57
$LN29@xmlParseCh:

; 4424 : 	    }
; 4425 : 	    if (*in == ']') {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	jne	SHORT $LN30@xmlParseCh

; 4426 : 		if ((in[1] == ']') && (in[2] == '>')) {

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 93					; 0000005dH
	jne	SHORT $LN31@xmlParseCh
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 62					; 0000003eH
	jne	SHORT $LN31@xmlParseCh

; 4427 : 		    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);

	push	0
	push	62					; 0000003eH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 4428 : 		    ctxt->input->cur = in + 1;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax

; 4429 : 		    return;

	jmp	$LN1@xmlParseCh
$LN31@xmlParseCh:

; 4430 : 		}
; 4431 : 		in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 4432 : 		ctxt->input->col++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+32], eax

; 4433 : 		goto get_more;

	jmp	$get_more$57
$LN30@xmlParseCh:

; 4434 : 	    }
; 4435 : 	    nbchar = in - ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _in$[ebp]
	sub	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _nbchar$[ebp], edx

; 4436 : 	    if (nbchar > 0) {

	cmp	DWORD PTR _nbchar$[ebp], 0
	jle	$LN32@xmlParseCh

; 4437 : 		if ((ctxt->sax != NULL) &&
; 4438 : 		    (ctxt->sax->ignorableWhitespace !=
; 4439 : 		     ctxt->sax->characters) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN33@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+72]
	cmp	edx, DWORD PTR [ecx+68]
	je	$LN33@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN35@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN36@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN35@xmlParseCh
$LN36@xmlParseCh:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	$LN33@xmlParseCh
$LN35@xmlParseCh:

; 4440 : 		    (IS_BLANK_CH(*ctxt->input->cur))) {
; 4441 : 		    const xmlChar *tmp = ctxt->input->cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _tmp$1[ebp], eax

; 4442 : 		    ctxt->input->cur = in;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR [edx+16], eax

; 4443 : 
; 4444 : 		    if (areBlanks(ctxt, tmp, nbchar, 0)) {

	push	0
	mov	ecx, DWORD PTR _nbchar$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmp$1[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_areBlanks
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN37@xmlParseCh

; 4445 : 		        if (ctxt->sax->ignorableWhitespace != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+72], 0
	je	SHORT $LN39@xmlParseCh

; 4446 : 			    ctxt->sax->ignorableWhitespace(ctxt->userData,

	mov	esi, esp
	mov	eax, DWORD PTR _nbchar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmp$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+72]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN39@xmlParseCh:

; 4447 : 							   tmp, nbchar);
; 4448 : 		    } else {

	jmp	SHORT $LN38@xmlParseCh
$LN37@xmlParseCh:

; 4449 : 		        if (ctxt->sax->characters != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+68], 0
	je	SHORT $LN40@xmlParseCh

; 4450 : 			    ctxt->sax->characters(ctxt->userData,

	mov	esi, esp
	mov	eax, DWORD PTR _nbchar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmp$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+68]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN40@xmlParseCh:

; 4451 : 						  tmp, nbchar);
; 4452 : 			if (*ctxt->space == -1)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $LN38@xmlParseCh

; 4453 : 			    *ctxt->space = -2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+232]
	mov	DWORD PTR [ecx], -2			; fffffffeH
$LN38@xmlParseCh:

; 4454 : 		    }
; 4455 :                     line = ctxt->input->line;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _line$[ebp], ecx

; 4456 :                     col = ctxt->input->col;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _col$[ebp], ecx
	jmp	SHORT $LN34@xmlParseCh
$LN33@xmlParseCh:

; 4457 : 		} else if (ctxt->sax != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN34@xmlParseCh

; 4458 : 		    if (ctxt->sax->characters != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN43@xmlParseCh

; 4459 : 			ctxt->sax->characters(ctxt->userData,

	mov	esi, esp
	mov	edx, DWORD PTR _nbchar$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+68]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN43@xmlParseCh:

; 4460 : 					      ctxt->input->cur, nbchar);
; 4461 :                     line = ctxt->input->line;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _line$[ebp], ecx

; 4462 :                     col = ctxt->input->col;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _col$[ebp], ecx
$LN34@xmlParseCh:

; 4463 : 		}
; 4464 :                 /* something really bad happened in the SAX callback */
; 4465 :                 if (ctxt->instate != XML_PARSER_CONTENT)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], 7
	je	SHORT $LN32@xmlParseCh

; 4466 :                     return;

	jmp	$LN1@xmlParseCh
$LN32@xmlParseCh:

; 4467 : 	    }
; 4468 : 	    ctxt->input->cur = in;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 4469 : 	    if (*in == 0xD) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN45@xmlParseCh

; 4470 : 		in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx

; 4471 : 		if (*in == 0xA) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN46@xmlParseCh

; 4472 : 		    ctxt->input->cur = in;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 4473 : 		    in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx

; 4474 : 		    ctxt->input->line++; ctxt->input->col = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+28], edx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], 1

; 4475 : 		    continue; /* while */

	jmp	$LN2@xmlParseCh
$LN46@xmlParseCh:

; 4476 : 		}
; 4477 : 		in--;

	mov	ecx, DWORD PTR _in$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
$LN45@xmlParseCh:

; 4478 : 	    }
; 4479 : 	    if (*in == '<') {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN47@xmlParseCh

; 4480 : 		return;

	jmp	$LN1@xmlParseCh
$LN47@xmlParseCh:

; 4481 : 	    }
; 4482 : 	    if (*in == '&') {

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 38					; 00000026H
	jne	SHORT $LN48@xmlParseCh

; 4483 : 		return;

	jmp	$LN1@xmlParseCh
$LN48@xmlParseCh:

; 4484 : 	    }
; 4485 : 	    SHRINK;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN49@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	cmp	edx, 500				; 000001f4H
	jle	SHORT $LN49@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 500				; 000001f4H
	jge	SHORT $LN49@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSHRINK
	add	esp, 4
$LN49@xmlParseCh:

; 4486 : 	    GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN50@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN50@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN50@xmlParseCh:

; 4487 :             if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN51@xmlParseCh

; 4488 : 		return;

	jmp	SHORT $LN1@xmlParseCh
$LN51@xmlParseCh:

; 4489 : 	    in = ctxt->input->cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _in$[ebp], ecx
$LN2@xmlParseCh:

; 4490 : 	} while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09));

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN52@xmlParseCh
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 127				; 0000007fH
	jle	$get_more_space$56
$LN52@xmlParseCh:
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	je	$get_more_space$56

; 4491 : 	nbchar = 0;

	mov	DWORD PTR _nbchar$[ebp], 0
$LN17@xmlParseCh:

; 4492 :     }
; 4493 :     ctxt->input->line = line;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 4494 :     ctxt->input->col = col;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 4495 :     xmlParseCharDataComplex(ctxt, cdata);

	mov	edx, DWORD PTR _cdata$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseCharDataComplex
	add	esp, 8
$LN1@xmlParseCh:

; 4496 : }

	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseCharData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParsePubidLiteral
_TEXT	SEGMENT
_tmp$1 = -28						; size = 4
_oldstate$ = -24					; size = 4
_count$ = -20						; size = 4
_stop$ = -14						; size = 1
_cur$ = -13						; size = 1
_size$ = -12						; size = 4
_len$ = -8						; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParsePubidLiteral PROC				; COMDAT

; 4226 : xmlParsePubidLiteral(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 4227 :     xmlChar *buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 4228 :     int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 4229 :     int size = XML_PARSER_BUFFER_SIZE;

	mov	DWORD PTR _size$[ebp], 100		; 00000064H

; 4230 :     xmlChar cur;
; 4231 :     xmlChar stop;
; 4232 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 4233 :     xmlParserInputState oldstate = ctxt->instate;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	mov	DWORD PTR _oldstate$[ebp], ecx

; 4234 : 
; 4235 :     SHRINK;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN4@xmlParsePu
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	cmp	ecx, 500				; 000001f4H
	jle	SHORT $LN4@xmlParsePu
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN4@xmlParsePu
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSHRINK
	add	esp, 4
$LN4@xmlParsePu:

; 4236 :     if (RAW == '"') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN5@xmlParsePu

; 4237 :         NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 4238 : 	stop = '"';

	mov	BYTE PTR _stop$[ebp], 34		; 00000022H
	jmp	SHORT $LN6@xmlParsePu
$LN5@xmlParsePu:

; 4239 :     } else if (RAW == '\'') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $LN7@xmlParsePu

; 4240 :         NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 4241 : 	stop = '\'';

	mov	BYTE PTR _stop$[ebp], 39		; 00000027H

; 4242 :     } else {

	jmp	SHORT $LN6@xmlParsePu
$LN7@xmlParsePu:

; 4243 : 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);

	push	0
	push	43					; 0000002bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 4244 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParsePu
$LN6@xmlParsePu:

; 4245 :     }
; 4246 :     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	mov	esi, esp
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$[ebp], eax

; 4247 :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN9@xmlParsePu

; 4248 : 	xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 4249 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParsePu
$LN9@xmlParsePu:

; 4250 :     }
; 4251 :     ctxt->instate = XML_PARSER_PUBLIC_LITERAL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 16			; 00000010H

; 4252 :     cur = CUR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cur$[ebp], cl
$LN2@xmlParsePu:

; 4253 :     while ((IS_PUBIDCHAR_CH(cur)) && (cur != stop)) { /* checked */

	movzx	edx, BYTE PTR _cur$[ebp]
	movzx	eax, BYTE PTR _xmlIsPubidChar_tab[edx]
	test	eax, eax
	je	$LN3@xmlParsePu
	movzx	ecx, BYTE PTR _cur$[ebp]
	movzx	edx, BYTE PTR _stop$[ebp]
	cmp	ecx, edx
	je	$LN3@xmlParsePu

; 4254 : 	if (len + 1 >= size) {

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _size$[ebp]
	jl	$LN10@xmlParsePu

; 4255 : 	    xmlChar *tmp;
; 4256 : 
; 4257 :             if ((size > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _size$[ebp], 50000		; 0000c350H
	jle	SHORT $LN11@xmlParsePu
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN11@xmlParsePu

; 4258 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 4259 :                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Public ID");

	push	OFFSET ??_C@_09HLIINGHD@Public?5ID@
	push	110					; 0000006eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 4260 :                 xmlFree(buf);

	mov	esi, esp
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4261 :                 return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParsePu
$LN11@xmlParsePu:

; 4262 :             }
; 4263 : 	    size *= 2;

	mov	edx, DWORD PTR _size$[ebp]
	shl	edx, 1
	mov	DWORD PTR _size$[ebp], edx

; 4264 : 	    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 4265 : 	    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN12@xmlParsePu

; 4266 : 		xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 4267 : 		xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4268 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParsePu
$LN12@xmlParsePu:

; 4269 : 	    }
; 4270 : 	    buf = tmp;

	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _buf$[ebp], ecx
$LN10@xmlParsePu:

; 4271 : 	}
; 4272 : 	buf[len++] = cur;

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	al, BYTE PTR _cur$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 4273 : 	count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 4274 : 	if (count > 50) {

	cmp	DWORD PTR _count$[ebp], 50		; 00000032H
	jle	SHORT $LN13@xmlParsePu

; 4275 : 	    GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN14@xmlParsePu
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN14@xmlParsePu
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN14@xmlParsePu:

; 4276 : 	    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 4277 :             if (ctxt->instate == XML_PARSER_EOF) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN13@xmlParsePu

; 4278 : 		xmlFree(buf);

	mov	esi, esp
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4279 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParsePu
$LN13@xmlParsePu:

; 4280 :             }
; 4281 : 	}
; 4282 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 4283 : 	cur = CUR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cur$[ebp], cl

; 4284 : 	if (cur == 0) {

	movzx	edx, BYTE PTR _cur$[ebp]
	test	edx, edx
	jne	$LN16@xmlParsePu

; 4285 : 	    GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN17@xmlParsePu
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN17@xmlParsePu
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN17@xmlParsePu:

; 4286 : 	    SHRINK;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN18@xmlParsePu
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN18@xmlParsePu
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 500				; 000001f4H
	jge	SHORT $LN18@xmlParsePu
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSHRINK
	add	esp, 4
$LN18@xmlParsePu:

; 4287 : 	    cur = CUR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cur$[ebp], cl
$LN16@xmlParsePu:

; 4288 : 	}
; 4289 :     }

	jmp	$LN2@xmlParsePu
$LN3@xmlParsePu:

; 4290 :     buf[len] = 0;

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 0

; 4291 :     if (cur != stop) {

	movzx	eax, BYTE PTR _cur$[ebp]
	movzx	ecx, BYTE PTR _stop$[ebp]
	cmp	eax, ecx
	je	SHORT $LN19@xmlParsePu

; 4292 : 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);

	push	0
	push	44					; 0000002cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 4293 :     } else {

	jmp	SHORT $LN20@xmlParsePu
$LN19@xmlParsePu:

; 4294 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4
$LN20@xmlParsePu:

; 4295 :     }
; 4296 :     ctxt->instate = oldstate;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _oldstate$[ebp]
	mov	DWORD PTR [ecx+172], edx

; 4297 :     return(buf);

	mov	eax, DWORD PTR _buf$[ebp]
$LN1@xmlParsePu:

; 4298 : }

	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParsePubidLiteral ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseSystemLiteral
_TEXT	SEGMENT
tv269 = -68						; size = 4
tv271 = -64						; size = 4
tv270 = -60						; size = 4
tv147 = -56						; size = 4
tv149 = -52						; size = 4
tv148 = -48						; size = 4
_tmp$1 = -44						; size = 4
_count$ = -40						; size = 4
_state$ = -36						; size = 4
_stop$ = -29						; size = 1
_l$ = -24						; size = 4
_cur$ = -16						; size = 4
_size$ = -12						; size = 4
_len$ = -8						; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseSystemLiteral PROC				; COMDAT

; 4137 : xmlParseSystemLiteral(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 4138 :     xmlChar *buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 4139 :     int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 4140 :     int size = XML_PARSER_BUFFER_SIZE;

	mov	DWORD PTR _size$[ebp], 100		; 00000064H

; 4141 :     int cur, l;
; 4142 :     xmlChar stop;
; 4143 :     int state = ctxt->instate;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	mov	DWORD PTR _state$[ebp], ecx

; 4144 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 4145 : 
; 4146 :     SHRINK;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN7@xmlParseSy
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	cmp	ecx, 500				; 000001f4H
	jle	SHORT $LN7@xmlParseSy
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 500				; 000001f4H
	jge	SHORT $LN7@xmlParseSy
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSHRINK
	add	esp, 4
$LN7@xmlParseSy:

; 4147 :     if (RAW == '"') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN8@xmlParseSy

; 4148 :         NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4

; 4149 : 	stop = '"';

	mov	BYTE PTR _stop$[ebp], 34		; 00000022H
	jmp	SHORT $LN9@xmlParseSy
$LN8@xmlParseSy:

; 4150 :     } else if (RAW == '\'') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $LN10@xmlParseSy

; 4151 :         NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 4152 : 	stop = '\'';

	mov	BYTE PTR _stop$[ebp], 39		; 00000027H

; 4153 :     } else {

	jmp	SHORT $LN9@xmlParseSy
$LN10@xmlParseSy:

; 4154 : 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);

	push	0
	push	43					; 0000002bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 4155 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSy
$LN9@xmlParseSy:

; 4156 :     }
; 4157 : 
; 4158 :     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	mov	esi, esp
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$[ebp], eax

; 4159 :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN12@xmlParseSy

; 4160 :         xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 4161 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSy
$LN12@xmlParseSy:

; 4162 :     }
; 4163 :     ctxt->instate = XML_PARSER_SYSTEM_LITERAL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 13			; 0000000dH

; 4164 :     cur = CUR_CHAR(l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$LN2@xmlParseSy:

; 4165 :     while ((IS_CHAR(cur)) && (cur != stop)) { /* checked */

	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jge	SHORT $LN37@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 9
	jl	SHORT $LN29@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 10		; 0000000aH
	jle	SHORT $LN30@xmlParseSy
$LN29@xmlParseSy:
	cmp	DWORD PTR _cur$[ebp], 13		; 0000000dH
	je	SHORT $LN30@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 32		; 00000020H
	jge	SHORT $LN30@xmlParseSy
	mov	DWORD PTR tv148[ebp], 0
	jmp	SHORT $LN36@xmlParseSy
$LN30@xmlParseSy:
	mov	DWORD PTR tv148[ebp], 1
$LN36@xmlParseSy:
	mov	eax, DWORD PTR tv148[ebp]
	mov	DWORD PTR tv149[ebp], eax
	jmp	SHORT $LN38@xmlParseSy
$LN37@xmlParseSy:
	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jl	SHORT $LN31@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN33@xmlParseSy
$LN31@xmlParseSy:
	cmp	DWORD PTR _cur$[ebp], 57344		; 0000e000H
	jl	SHORT $LN32@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN33@xmlParseSy
$LN32@xmlParseSy:
	cmp	DWORD PTR _cur$[ebp], 65536		; 00010000H
	jl	SHORT $LN34@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN33@xmlParseSy
$LN34@xmlParseSy:
	mov	DWORD PTR tv147[ebp], 0
	jmp	SHORT $LN35@xmlParseSy
$LN33@xmlParseSy:
	mov	DWORD PTR tv147[ebp], 1
$LN35@xmlParseSy:
	mov	ecx, DWORD PTR tv147[ebp]
	mov	DWORD PTR tv149[ebp], ecx
$LN38@xmlParseSy:
	cmp	DWORD PTR tv149[ebp], 0
	je	$LN3@xmlParseSy
	movzx	edx, BYTE PTR _stop$[ebp]
	cmp	DWORD PTR _cur$[ebp], edx
	je	$LN3@xmlParseSy

; 4166 : 	if (len + 5 >= size) {

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 5
	cmp	eax, DWORD PTR _size$[ebp]
	jl	$LN13@xmlParseSy

; 4167 : 	    xmlChar *tmp;
; 4168 : 
; 4169 :             if ((size > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _size$[ebp], 50000		; 0000c350H
	jle	SHORT $LN14@xmlParseSy
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN14@xmlParseSy

; 4170 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 4171 :                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "SystemLiteral");

	push	OFFSET ??_C@_0O@CPJEEBHF@SystemLiteral@
	push	110					; 0000006eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 4172 :                 xmlFree(buf);

	mov	esi, esp
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4173 : 		ctxt->instate = (xmlParserInputState) state;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+172], eax

; 4174 :                 return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSy
$LN14@xmlParseSy:

; 4175 :             }
; 4176 : 	    size *= 2;

	mov	ecx, DWORD PTR _size$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _size$[ebp], ecx

; 4177 : 	    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	mov	esi, esp
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 4178 : 	    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN15@xmlParseSy

; 4179 : 	        xmlFree(buf);

	mov	esi, esp
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4180 : 		xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 4181 : 		ctxt->instate = (xmlParserInputState) state;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+172], ecx

; 4182 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSy
$LN15@xmlParseSy:

; 4183 : 	    }
; 4184 : 	    buf = tmp;

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _buf$[ebp], edx
$LN13@xmlParseSy:

; 4185 : 	}
; 4186 : 	count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 4187 : 	if (count > 50) {

	cmp	DWORD PTR _count$[ebp], 50		; 00000032H
	jle	SHORT $LN16@xmlParseSy

; 4188 : 	    GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN17@xmlParseSy
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN17@xmlParseSy
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN17@xmlParseSy:

; 4189 : 	    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 4190 :             if (ctxt->instate == XML_PARSER_EOF) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN16@xmlParseSy

; 4191 : 	        xmlFree(buf);

	mov	esi, esp
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4192 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseSy
$LN16@xmlParseSy:

; 4193 :             }
; 4194 : 	}
; 4195 : 	COPY_BUF(l,buf,len,cur);

	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN19@xmlParseSy
	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	dl, BYTE PTR _cur$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN6@xmlParseSy
$LN19@xmlParseSy:
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	push	edx
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN6@xmlParseSy:

; 4196 : 	NEXTL(l);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN21@xmlParseSy
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
	jmp	SHORT $LN22@xmlParseSy
$LN21@xmlParseSy:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN22@xmlParseSy:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	xor	eax, eax
	jne	SHORT $LN6@xmlParseSy

; 4197 : 	cur = CUR_CHAR(l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4198 : 	if (cur == 0) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	$LN23@xmlParseSy

; 4199 : 	    GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN24@xmlParseSy
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN24@xmlParseSy
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN24@xmlParseSy:

; 4200 : 	    SHRINK;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN25@xmlParseSy
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 500				; 000001f4H
	jle	SHORT $LN25@xmlParseSy
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 500				; 000001f4H
	jge	SHORT $LN25@xmlParseSy
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSHRINK
	add	esp, 4
$LN25@xmlParseSy:

; 4201 : 	    cur = CUR_CHAR(l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$LN23@xmlParseSy:

; 4202 : 	}
; 4203 :     }

	jmp	$LN2@xmlParseSy
$LN3@xmlParseSy:

; 4204 :     buf[len] = 0;

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0

; 4205 :     ctxt->instate = (xmlParserInputState) state;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+172], edx

; 4206 :     if (!IS_CHAR(cur)) {

	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jge	SHORT $LN47@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 9
	jl	SHORT $LN39@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 10		; 0000000aH
	jle	SHORT $LN40@xmlParseSy
$LN39@xmlParseSy:
	cmp	DWORD PTR _cur$[ebp], 13		; 0000000dH
	je	SHORT $LN40@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 32		; 00000020H
	jge	SHORT $LN40@xmlParseSy
	mov	DWORD PTR tv270[ebp], 0
	jmp	SHORT $LN46@xmlParseSy
$LN40@xmlParseSy:
	mov	DWORD PTR tv270[ebp], 1
$LN46@xmlParseSy:
	mov	eax, DWORD PTR tv270[ebp]
	mov	DWORD PTR tv271[ebp], eax
	jmp	SHORT $LN48@xmlParseSy
$LN47@xmlParseSy:
	cmp	DWORD PTR _cur$[ebp], 256		; 00000100H
	jl	SHORT $LN41@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN43@xmlParseSy
$LN41@xmlParseSy:
	cmp	DWORD PTR _cur$[ebp], 57344		; 0000e000H
	jl	SHORT $LN42@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN43@xmlParseSy
$LN42@xmlParseSy:
	cmp	DWORD PTR _cur$[ebp], 65536		; 00010000H
	jl	SHORT $LN44@xmlParseSy
	cmp	DWORD PTR _cur$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN43@xmlParseSy
$LN44@xmlParseSy:
	mov	DWORD PTR tv269[ebp], 0
	jmp	SHORT $LN45@xmlParseSy
$LN43@xmlParseSy:
	mov	DWORD PTR tv269[ebp], 1
$LN45@xmlParseSy:
	mov	ecx, DWORD PTR tv269[ebp]
	mov	DWORD PTR tv271[ebp], ecx
$LN48@xmlParseSy:
	cmp	DWORD PTR tv271[ebp], 0
	jne	SHORT $LN26@xmlParseSy

; 4207 : 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);

	push	0
	push	44					; 0000002cH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 4208 :     } else {

	jmp	SHORT $LN27@xmlParseSy
$LN26@xmlParseSy:

; 4209 : 	NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNextChar
	add	esp, 4
$LN27@xmlParseSy:

; 4210 :     }
; 4211 :     return(buf);

	mov	eax, DWORD PTR _buf$[ebp]
$LN1@xmlParseSy:

; 4212 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN51@xmlParseSy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN51@xmlParseSy:
	DD	1
	DD	$LN50@xmlParseSy
$LN50@xmlParseSy:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN49@xmlParseSy
$LN49@xmlParseSy:
	DB	108					; 0000006cH
	DB	0
_xmlParseSystemLiteral ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseAttValue
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlParseAttValue PROC					; COMDAT

; 4120 : xmlParseAttValue(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 4121 :     if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlParseAt
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN2@xmlParseAt
$LN3@xmlParseAt:
	xor	eax, eax
	jmp	SHORT $LN1@xmlParseAt
$LN2@xmlParseAt:

; 4122 :     return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseAttValueInternal
	add	esp, 16					; 00000010H
$LN1@xmlParseAt:

; 4123 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseAttValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEntityValue
_TEXT	SEGMENT
tv142 = -80						; size = 4
tv144 = -76						; size = 4
tv143 = -72						; size = 4
_nameOk$1 = -68						; size = 4
_tmp$2 = -61						; size = 1
_name$3 = -60						; size = 4
_tmp$4 = -56						; size = 4
_input$ = -52						; size = 4
_cur$ = -44						; size = 4
_ret$ = -36						; size = 4
_stop$ = -29						; size = 1
_l$ = -24						; size = 4
_c$ = -16						; size = 4
_size$ = -12						; size = 4
_len$ = -8						; size = 4
_buf$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_orig$ = 12						; size = 4
_xmlParseEntityValue PROC				; COMDAT

; 3704 : xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 3705 :     xmlChar *buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 3706 :     int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 3707 :     int size = XML_PARSER_BUFFER_SIZE;

	mov	DWORD PTR _size$[ebp], 100		; 00000064H

; 3708 :     int c, l;
; 3709 :     xmlChar stop;
; 3710 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 3711 :     const xmlChar *cur = NULL;

	mov	DWORD PTR _cur$[ebp], 0

; 3712 :     xmlParserInputPtr input;
; 3713 : 
; 3714 :     if (RAW == '"') stop = '"';

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN9@xmlParseEn
	mov	BYTE PTR _stop$[ebp], 34		; 00000022H
	jmp	SHORT $LN10@xmlParseEn
$LN9@xmlParseEn:

; 3715 :     else if (RAW == '\'') stop = '\'';

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $LN11@xmlParseEn
	mov	BYTE PTR _stop$[ebp], 39		; 00000027H
	jmp	SHORT $LN10@xmlParseEn
$LN11@xmlParseEn:

; 3716 :     else {
; 3717 : 	xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_STARTED, NULL);

	push	0
	push	36					; 00000024H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3718 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN10@xmlParseEn:

; 3719 :     }
; 3720 :     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));

	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$[ebp], eax

; 3721 :     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN13@xmlParseEn

; 3722 : 	xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 3723 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseEn
$LN13@xmlParseEn:

; 3724 :     }
; 3725 : 
; 3726 :     /*
; 3727 :      * The content of the entity definition is copied in a buffer.
; 3728 :      */
; 3729 : 
; 3730 :     ctxt->instate = XML_PARSER_ENTITY_VALUE;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 11			; 0000000bH

; 3731 :     input = ctxt->input;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _input$[ebp], ecx

; 3732 :     GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN14@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN14@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN14@xmlParseEn:

; 3733 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN15@xmlParseEn

; 3734 :         goto error;

	jmp	$error$52
$LN15@xmlParseEn:

; 3735 :     NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNextChar
	add	esp, 4

; 3736 :     c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
$LN2@xmlParseEn:

; 3737 :     /*
; 3738 :      * NOTE: 4.4.5 Included in Literal
; 3739 :      * When a parameter entity reference appears in a literal entity
; 3740 :      * value, ... a single or double quote character in the replacement
; 3741 :      * text is always treated as a normal data character and will not
; 3742 :      * terminate the literal.
; 3743 :      * In practice it means we stop the loop only when back at parsing
; 3744 :      * the initial entity and the quote is found
; 3745 :      */
; 3746 :     while (((IS_CHAR(c)) && ((c != stop) || /* checked */
; 3747 : 	    (ctxt->input != input))) && (ctxt->instate != XML_PARSER_EOF)) {

	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jge	SHORT $LN46@xmlParseEn
	cmp	DWORD PTR _c$[ebp], 9
	jl	SHORT $LN38@xmlParseEn
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	jle	SHORT $LN39@xmlParseEn
$LN38@xmlParseEn:
	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $LN39@xmlParseEn
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jge	SHORT $LN39@xmlParseEn
	mov	DWORD PTR tv143[ebp], 0
	jmp	SHORT $LN45@xmlParseEn
$LN39@xmlParseEn:
	mov	DWORD PTR tv143[ebp], 1
$LN45@xmlParseEn:
	mov	ecx, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv144[ebp], ecx
	jmp	SHORT $LN47@xmlParseEn
$LN46@xmlParseEn:
	cmp	DWORD PTR _c$[ebp], 256			; 00000100H
	jl	SHORT $LN40@xmlParseEn
	cmp	DWORD PTR _c$[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN42@xmlParseEn
$LN40@xmlParseEn:
	cmp	DWORD PTR _c$[ebp], 57344		; 0000e000H
	jl	SHORT $LN41@xmlParseEn
	cmp	DWORD PTR _c$[ebp], 65533		; 0000fffdH
	jle	SHORT $LN42@xmlParseEn
$LN41@xmlParseEn:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jl	SHORT $LN43@xmlParseEn
	cmp	DWORD PTR _c$[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN42@xmlParseEn
$LN43@xmlParseEn:
	mov	DWORD PTR tv142[ebp], 0
	jmp	SHORT $LN44@xmlParseEn
$LN42@xmlParseEn:
	mov	DWORD PTR tv142[ebp], 1
$LN44@xmlParseEn:
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR tv144[ebp], edx
$LN47@xmlParseEn:
	cmp	DWORD PTR tv144[ebp], 0
	je	$LN3@xmlParseEn
	movzx	eax, BYTE PTR _stop$[ebp]
	cmp	DWORD PTR _c$[ebp], eax
	jne	SHORT $LN16@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR _input$[ebp]
	je	$LN3@xmlParseEn
$LN16@xmlParseEn:
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	je	$LN3@xmlParseEn

; 3748 : 	if (len + 5 >= size) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 5
	cmp	ecx, DWORD PTR _size$[ebp]
	jl	SHORT $LN17@xmlParseEn

; 3749 : 	    xmlChar *tmp;
; 3750 : 
; 3751 : 	    size *= 2;

	mov	edx, DWORD PTR _size$[ebp]
	shl	edx, 1
	mov	DWORD PTR _size$[ebp], edx

; 3752 : 	    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));

	mov	esi, esp
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$4[ebp], eax

; 3753 : 	    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$4[ebp], 0
	jne	SHORT $LN18@xmlParseEn

; 3754 : 		xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 3755 :                 goto error;

	jmp	$error$52
$LN18@xmlParseEn:

; 3756 : 	    }
; 3757 : 	    buf = tmp;

	mov	eax, DWORD PTR _tmp$4[ebp]
	mov	DWORD PTR _buf$[ebp], eax
$LN17@xmlParseEn:

; 3758 : 	}
; 3759 : 	COPY_BUF(l,buf,len,c);

	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN19@xmlParseEn
	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN6@xmlParseEn
$LN19@xmlParseEn:
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	push	edx
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN6@xmlParseEn:

; 3760 : 	NEXTL(l);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN21@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
	jmp	SHORT $LN22@xmlParseEn
$LN21@xmlParseEn:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN22@xmlParseEn:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	xor	eax, eax
	jne	SHORT $LN6@xmlParseEn

; 3761 : 
; 3762 : 	GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN23@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN23@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN23@xmlParseEn:

; 3763 : 	c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 3764 : 	if (c == 0) {

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN24@xmlParseEn

; 3765 : 	    GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN25@xmlParseEn
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN25@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN25@xmlParseEn:

; 3766 : 	    c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
$LN24@xmlParseEn:

; 3767 : 	}
; 3768 :     }

	jmp	$LN2@xmlParseEn
$LN3@xmlParseEn:

; 3769 :     buf[len] = 0;

	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 0

; 3770 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN26@xmlParseEn

; 3771 :         goto error;

	jmp	$error$52
$LN26@xmlParseEn:

; 3772 :     if (c != stop) {

	movzx	eax, BYTE PTR _stop$[ebp]
	cmp	DWORD PTR _c$[ebp], eax
	je	SHORT $LN27@xmlParseEn

; 3773 :         xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_FINISHED, NULL);

	push	0
	push	37					; 00000025H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3774 :         goto error;

	jmp	$error$52
$LN27@xmlParseEn:

; 3775 :     }
; 3776 :     NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNextChar
	add	esp, 4

; 3777 : 
; 3778 :     /*
; 3779 :      * Raise problem w.r.t. '&' and '%' being used in non-entities
; 3780 :      * reference constructs. Note Charref will be handled in
; 3781 :      * xmlStringDecodeEntities()
; 3782 :      */
; 3783 :     cur = buf;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _cur$[ebp], eax
$LN7@xmlParseEn:

; 3784 :     while (*cur != 0) { /* non input consuming */

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN8@xmlParseEn

; 3785 : 	if ((*cur == '%') || ((*cur == '&') && (cur[1] != '#'))) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	je	SHORT $LN29@xmlParseEn
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 38					; 00000026H
	jne	$LN28@xmlParseEn
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	je	$LN28@xmlParseEn
$LN29@xmlParseEn:

; 3786 : 	    xmlChar *name;
; 3787 : 	    xmlChar tmp = *cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _tmp$2[ebp], dl

; 3788 :             int nameOk = 0;

	mov	DWORD PTR _nameOk$1[ebp], 0

; 3789 : 
; 3790 : 	    cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 3791 : 	    name = xmlParseStringName(ctxt, &cur);

	lea	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseStringName
	add	esp, 8
	mov	DWORD PTR _name$3[ebp], eax

; 3792 :             if (name != NULL) {

	cmp	DWORD PTR _name$3[ebp], 0
	je	SHORT $LN30@xmlParseEn

; 3793 :                 nameOk = 1;

	mov	DWORD PTR _nameOk$1[ebp], 1

; 3794 :                 xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$3[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN30@xmlParseEn:

; 3795 :             }
; 3796 :             if ((nameOk == 0) || (*cur != ';')) {

	cmp	DWORD PTR _nameOk$1[ebp], 0
	je	SHORT $LN32@xmlParseEn
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN31@xmlParseEn
$LN32@xmlParseEn:

; 3797 : 		xmlFatalErrMsgInt(ctxt, XML_ERR_ENTITY_CHAR_ERROR,

	movzx	eax, BYTE PTR _tmp$2[ebp]
	push	eax
	push	OFFSET ??_C@_0DM@GJGLHMKL@EntityValue?3?5?8?$CFc?8?5forbidden?5exc@
	push	87					; 00000057H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsgInt
	add	esp, 16					; 00000010H

; 3798 : 	    "EntityValue: '%c' forbidden except for entities references\n",
; 3799 : 	                          tmp);
; 3800 :                 goto error;

	jmp	$error$52
$LN31@xmlParseEn:

; 3801 : 	    }
; 3802 : 	    if ((tmp == '%') && (ctxt->inSubset == 1) &&

	movzx	edx, BYTE PTR _tmp$2[ebp]
	cmp	edx, 37					; 00000025H
	jne	SHORT $LN33@xmlParseEn
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+216], 1
	jne	SHORT $LN33@xmlParseEn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 1
	jne	SHORT $LN33@xmlParseEn

; 3803 : 		(ctxt->inputNr == 1)) {
; 3804 : 		xmlFatalErr(ctxt, XML_ERR_ENTITY_PE_INTERNAL, NULL);

	push	0
	push	88					; 00000058H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3805 :                 goto error;

	jmp	SHORT $error$52
$LN33@xmlParseEn:

; 3806 : 	    }
; 3807 : 	    if (*cur == 0)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN28@xmlParseEn

; 3808 : 	        break;

	jmp	SHORT $LN8@xmlParseEn
$LN28@xmlParseEn:

; 3809 : 	}
; 3810 : 	cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 3811 :     }

	jmp	$LN7@xmlParseEn
$LN8@xmlParseEn:

; 3812 : 
; 3813 :     /*
; 3814 :      * Then PEReference entities are substituted.
; 3815 :      *
; 3816 :      * NOTE: 4.4.7 Bypassed
; 3817 :      * When a general entity reference appears in the EntityValue in
; 3818 :      * an entity declaration, it is bypassed and left as is.
; 3819 :      * so XML_SUBSTITUTE_REF is not set here.
; 3820 :      */
; 3821 :     ++ctxt->depth;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+248]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+248], ecx

; 3822 :     ret = xmlStringDecodeEntities(ctxt, buf, XML_SUBSTITUTE_PEREF,

	push	0
	push	0
	push	0
	push	2
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlStringDecodeEntities
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 3823 :                                   0, 0, 0);
; 3824 :     --ctxt->depth;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+248]
	sub	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+248], eax

; 3825 :     if (orig != NULL) {

	cmp	DWORD PTR _orig$[ebp], 0
	je	SHORT $error$52

; 3826 :         *orig = buf;

	mov	edx, DWORD PTR _orig$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx], eax

; 3827 :         buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0
$error$52:

; 3828 :     }
; 3829 : 
; 3830 : error:
; 3831 :     if (buf != NULL)

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN36@xmlParseEn

; 3832 :         xmlFree(buf);

	mov	esi, esp
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN36@xmlParseEn:

; 3833 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseEn:

; 3834 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN51@xmlParseEn
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@xmlParseEn:
	DD	2
	DD	$LN50@xmlParseEn
$LN50@xmlParseEn:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN48@xmlParseEn
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN49@xmlParseEn
$LN49@xmlParseEn:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
$LN48@xmlParseEn:
	DB	108					; 0000006cH
	DB	0
_xmlParseEntityValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseNmtoken
_TEXT	SEGMENT
tv200 = -168						; size = 4
tv199 = -164						; size = 4
tv85 = -160						; size = 4
tv84 = -156						; size = 4
_tmp$1 = -152						; size = 4
_max$2 = -148						; size = 4
_buffer$3 = -144					; size = 4
_count$ = -140						; size = 4
_c$ = -136						; size = 4
_l$ = -128						; size = 4
_len$ = -120						; size = 4
_buf$ = -112						; size = 105
_ctxt$ = 8						; size = 4
_xmlParseNmtoken PROC					; COMDAT

; 3600 : xmlParseNmtoken(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-168]
	mov	ecx, 42					; 0000002aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 3601 :     xmlChar buf[XML_MAX_NAMELEN + 5];
; 3602 :     int len = 0, l;

	mov	DWORD PTR _len$[ebp], 0

; 3603 :     int c;
; 3604 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3605 : 
; 3606 : #ifdef DEBUG
; 3607 :     nbParseNmToken++;
; 3608 : #endif
; 3609 : 
; 3610 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN12@xmlParseNm
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN12@xmlParseNm
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN12@xmlParseNm:

; 3611 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN13@xmlParseNm

; 3612 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNm
$LN13@xmlParseNm:

; 3613 :     c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
$LN2@xmlParseNm:

; 3614 : 
; 3615 :     while (xmlIsNameChar(ctxt, c)) {

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlIsNameChar
	add	esp, 8
	test	eax, eax
	je	$LN3@xmlParseNm

; 3616 : 	if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv84[ebp], eax
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	cmp	DWORD PTR tv84[ebp], 100		; 00000064H
	jle	SHORT $LN38@xmlParseNm
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN39@xmlParseNm
$LN38@xmlParseNm:
	mov	DWORD PTR tv85[ebp], 0
$LN39@xmlParseNm:
	cmp	DWORD PTR tv85[ebp], 0
	je	SHORT $LN14@xmlParseNm

; 3617 : 	    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3618 : 	    GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN14@xmlParseNm
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN14@xmlParseNm
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN14@xmlParseNm:

; 3619 : 	}
; 3620 : 	COPY_BUF(l,buf,len,c);

	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN16@xmlParseNm
	mov	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR _buf$[ebp+eax], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
	jmp	SHORT $LN6@xmlParseNm
$LN16@xmlParseNm:
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	lea	edx, DWORD PTR _buf$[ebp+ecx]
	push	edx
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN6@xmlParseNm:

; 3621 : 	NEXTL(l);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN18@xmlParseNm
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
	jmp	SHORT $LN19@xmlParseNm
$LN18@xmlParseNm:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN19@xmlParseNm:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	xor	eax, eax
	jne	SHORT $LN6@xmlParseNm

; 3622 : 	c = CUR_CHAR(l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 3623 : 	if (c == 0) {

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN20@xmlParseNm

; 3624 : 	    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3625 : 	    GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN21@xmlParseNm
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN21@xmlParseNm
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN21@xmlParseNm:

; 3626 : 	    if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN22@xmlParseNm

; 3627 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNm
$LN22@xmlParseNm:

; 3628 :             c = CUR_CHAR(l);

	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
$LN20@xmlParseNm:

; 3629 : 	}
; 3630 : 	if (len >= XML_MAX_NAMELEN) {

	cmp	DWORD PTR _len$[ebp], 100		; 00000064H
	jl	$LN23@xmlParseNm

; 3631 : 	    /*
; 3632 : 	     * Okay someone managed to make a huge token, so he's ready to pay
; 3633 : 	     * for the processing speed.
; 3634 : 	     */
; 3635 : 	    xmlChar *buffer;
; 3636 : 	    int max = len * 2;

	mov	ecx, DWORD PTR _len$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _max$2[ebp], ecx

; 3637 : 
; 3638 : 	    buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));

	mov	esi, esp
	mov	edx, DWORD PTR _max$2[ebp]
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buffer$3[ebp], eax

; 3639 : 	    if (buffer == NULL) {

	cmp	DWORD PTR _buffer$3[ebp], 0
	jne	SHORT $LN24@xmlParseNm

; 3640 : 	        xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 3641 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNm
$LN24@xmlParseNm:

; 3642 : 	    }
; 3643 : 	    memcpy(buffer, buf, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$3[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN7@xmlParseNm:

; 3644 : 	    while (xmlIsNameChar(ctxt, c)) {

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlIsNameChar
	add	esp, 8
	test	eax, eax
	je	$LN8@xmlParseNm

; 3645 : 		if (count++ > XML_PARSER_CHUNK_SIZE) {

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv199[ebp], eax
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	cmp	DWORD PTR tv199[ebp], 100		; 00000064H
	jle	SHORT $LN40@xmlParseNm
	mov	DWORD PTR tv200[ebp], 1
	jmp	SHORT $LN41@xmlParseNm
$LN40@xmlParseNm:
	mov	DWORD PTR tv200[ebp], 0
$LN41@xmlParseNm:
	cmp	DWORD PTR tv200[ebp], 0
	je	SHORT $LN25@xmlParseNm

; 3646 : 		    count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3647 : 		    GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN26@xmlParseNm
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN26@xmlParseNm
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN26@xmlParseNm:

; 3648 :                     if (ctxt->instate == XML_PARSER_EOF) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN25@xmlParseNm

; 3649 :                         xmlFree(buffer);

	mov	esi, esp
	mov	ecx, DWORD PTR _buffer$3[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3650 :                         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNm
$LN25@xmlParseNm:

; 3651 :                     }
; 3652 : 		}
; 3653 : 		if (len + 10 > max) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 10					; 0000000aH
	cmp	edx, DWORD PTR _max$2[ebp]
	jle	$LN28@xmlParseNm

; 3654 : 		    xmlChar *tmp;
; 3655 : 
; 3656 :                     if ((max > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _max$2[ebp], 50000		; 0000c350H
	jle	SHORT $LN29@xmlParseNm
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	jne	SHORT $LN29@xmlParseNm

; 3657 :                         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3658 :                         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NmToken");

	push	OFFSET ??_C@_07JJJDEIPB@NmToken@
	push	110					; 0000006eH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3659 :                         xmlFree(buffer);

	mov	esi, esp
	mov	eax, DWORD PTR _buffer$3[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3660 :                         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNm
$LN29@xmlParseNm:

; 3661 :                     }
; 3662 : 		    max *= 2;

	mov	ecx, DWORD PTR _max$2[ebp]
	shl	ecx, 1
	mov	DWORD PTR _max$2[ebp], ecx

; 3663 : 		    tmp = (xmlChar *) xmlRealloc(buffer,

	mov	esi, esp
	mov	edx, DWORD PTR _max$2[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$3[ebp]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 3664 : 			                            max * sizeof(xmlChar));
; 3665 : 		    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN30@xmlParseNm

; 3666 : 			xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 3667 : 			xmlFree(buffer);

	mov	esi, esp
	mov	edx, DWORD PTR _buffer$3[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3668 : 			return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlParseNm
$LN30@xmlParseNm:

; 3669 : 		    }
; 3670 : 		    buffer = tmp;

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _buffer$3[ebp], eax
$LN28@xmlParseNm:

; 3671 : 		}
; 3672 : 		COPY_BUF(l,buffer,len,c);

	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $LN31@xmlParseNm
	mov	ecx, DWORD PTR _buffer$3[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN11@xmlParseNm
$LN31@xmlParseNm:
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$3[ebp]
	add	edx, DWORD PTR _len$[ebp]
	push	edx
	call	_xmlCopyCharMultiByte
	add	esp, 8
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN11@xmlParseNm:

; 3673 : 		NEXTL(l);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN33@xmlParseNm
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], 1
	jmp	SHORT $LN34@xmlParseNm
$LN33@xmlParseNm:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+32], ecx
$LN34@xmlParseNm:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+16], eax
	xor	eax, eax
	jne	SHORT $LN11@xmlParseNm

; 3674 : 		c = CUR_CHAR(l);

	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCurrentChar
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 3675 : 	    }

	jmp	$LN7@xmlParseNm
$LN8@xmlParseNm:

; 3676 : 	    buffer[len] = 0;

	mov	eax, DWORD PTR _buffer$3[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0

; 3677 : 	    return(buffer);

	mov	eax, DWORD PTR _buffer$3[ebp]
	jmp	SHORT $LN1@xmlParseNm
$LN23@xmlParseNm:

; 3678 : 	}
; 3679 :     }

	jmp	$LN2@xmlParseNm
$LN3@xmlParseNm:

; 3680 :     if (len == 0)

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN35@xmlParseNm

; 3681 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseNm
$LN35@xmlParseNm:

; 3682 :     if ((len > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _len$[ebp], 50000		; 0000c350H
	jle	SHORT $LN36@xmlParseNm
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN36@xmlParseNm

; 3683 :         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3684 :         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NmToken");

	push	OFFSET ??_C@_07JJJDEIPB@NmToken@
	push	110					; 0000006eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3685 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseNm
$LN36@xmlParseNm:

; 3686 :     }
; 3687 :     return(xmlStrndup(buf, len));

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
$LN1@xmlParseNm:

; 3688 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN45@xmlParseNm
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 168				; 000000a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN45@xmlParseNm:
	DD	2
	DD	$LN44@xmlParseNm
$LN44@xmlParseNm:
	DD	-112					; ffffff90H
	DD	105					; 00000069H
	DD	$LN42@xmlParseNm
	DD	-128					; ffffff80H
	DD	4
	DD	$LN43@xmlParseNm
$LN43@xmlParseNm:
	DB	108					; 0000006cH
	DB	0
$LN42@xmlParseNm:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlParseNmtoken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseName
_TEXT	SEGMENT
_count$ = -12						; size = 4
_ret$ = -8						; size = 4
_in$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseName PROC					; COMDAT

; 3283 : xmlParseName(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 3284 :     const xmlChar *in;
; 3285 :     const xmlChar *ret;
; 3286 :     int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 3287 : 
; 3288 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN4@xmlParseNa
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN4@xmlParseNa
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseNa:

; 3289 : 
; 3290 : #ifdef DEBUG
; 3291 :     nbParseName++;
; 3292 : #endif
; 3293 : 
; 3294 :     /*
; 3295 :      * Accelerator for simple ASCII names
; 3296 :      */
; 3297 :     in = ctxt->input->cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _in$[ebp], eax

; 3298 :     if (((*in >= 0x61) && (*in <= 0x7A)) ||
; 3299 : 	((*in >= 0x41) && (*in <= 0x5A)) ||
; 3300 : 	(*in == '_') || (*in == ':')) {

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN7@xmlParseNa
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 122				; 0000007aH
	jle	SHORT $LN6@xmlParseNa
$LN7@xmlParseNa:
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN8@xmlParseNa
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 90					; 0000005aH
	jle	SHORT $LN6@xmlParseNa
$LN8@xmlParseNa:
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	je	SHORT $LN6@xmlParseNa
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	jne	$LN5@xmlParseNa
$LN6@xmlParseNa:

; 3301 : 	in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
$LN2@xmlParseNa:

; 3302 : 	while (((*in >= 0x61) && (*in <= 0x7A)) ||
; 3303 : 	       ((*in >= 0x41) && (*in <= 0x5A)) ||
; 3304 : 	       ((*in >= 0x30) && (*in <= 0x39)) ||
; 3305 : 	       (*in == '_') || (*in == '-') ||
; 3306 : 	       (*in == ':') || (*in == '.'))

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN10@xmlParseNa
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jle	SHORT $LN9@xmlParseNa
$LN10@xmlParseNa:
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN11@xmlParseNa
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	jle	SHORT $LN9@xmlParseNa
$LN11@xmlParseNa:
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN12@xmlParseNa
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	SHORT $LN9@xmlParseNa
$LN12@xmlParseNa:
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN9@xmlParseNa
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN9@xmlParseNa
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	je	SHORT $LN9@xmlParseNa
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN3@xmlParseNa
$LN9@xmlParseNa:

; 3307 : 	    in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	jmp	SHORT $LN2@xmlParseNa
$LN3@xmlParseNa:

; 3308 : 	if ((*in > 0) && (*in < 0x80)) {

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jle	$LN5@xmlParseNa
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 128				; 00000080H
	jge	$LN5@xmlParseNa

; 3309 : 	    count = in - ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _in$[ebp]
	sub	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _count$[ebp], edx

; 3310 :             if ((count > XML_MAX_NAME_LENGTH) &&

	cmp	DWORD PTR _count$[ebp], 50000		; 0000c350H
	jle	SHORT $LN14@xmlParseNa
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	jne	SHORT $LN14@xmlParseNa

; 3311 :                 ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 3312 :                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");

	push	OFFSET ??_C@_04FABLJDN@Name@
	push	110					; 0000006eH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 3313 :                 return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseNa
$LN14@xmlParseNa:

; 3314 :             }
; 3315 : 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 3316 : 	    ctxt->input->cur = in;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 3317 : 	    ctxt->nbChars += count;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	add	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+200], ecx

; 3318 : 	    ctxt->input->col += count;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+32], edx

; 3319 : 	    if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN15@xmlParseNa

; 3320 : 	        xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8
$LN15@xmlParseNa:

; 3321 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParseNa
$LN5@xmlParseNa:

; 3322 : 	}
; 3323 :     }
; 3324 :     /* accelerator for special cases */
; 3325 :     return(xmlParseNameComplex(ctxt));

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseNameComplex
	add	esp, 4
$LN1@xmlParseNa:

; 3326 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSplitQName
_TEXT	SEGMENT
tv192 = -180						; size = 4
tv193 = -176						; size = 4
tv184 = -172						; size = 4
tv183 = -168						; size = 4
_tmp$1 = -164						; size = 4
_first$2 = -160						; size = 4
_l$3 = -152						; size = 4
_tmp$4 = -144						; size = 4
_c$ = -140						; size = 4
_cur$ = -136						; size = 4
_ret$ = -132						; size = 4
_max$ = -128						; size = 4
_len$ = -124						; size = 4
_buffer$ = -120						; size = 4
_buf$ = -112						; size = 105
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_prefix$ = 16						; size = 4
_xmlSplitQName PROC					; COMDAT

; 2889 : xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefix) {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-180]
	mov	ecx, 45					; 0000002dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2890 :     xmlChar buf[XML_MAX_NAMELEN + 5];
; 2891 :     xmlChar *buffer = NULL;

	mov	DWORD PTR _buffer$[ebp], 0

; 2892 :     int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 2893 :     int max = XML_MAX_NAMELEN;

	mov	DWORD PTR _max$[ebp], 100		; 00000064H

; 2894 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 2895 :     const xmlChar *cur = name;

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 2896 :     int c;
; 2897 : 
; 2898 :     if (prefix == NULL) return(NULL);

	cmp	DWORD PTR _prefix$[ebp], 0
	jne	SHORT $LN10@xmlSplitQN
	xor	eax, eax
	jmp	$LN1@xmlSplitQN
$LN10@xmlSplitQN:

; 2899 :     *prefix = NULL;

	mov	ecx, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [ecx], 0

; 2900 : 
; 2901 :     if (cur == NULL) return(NULL);

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN11@xmlSplitQN
	xor	eax, eax
	jmp	$LN1@xmlSplitQN
$LN11@xmlSplitQN:

; 2902 : 
; 2903 : #ifndef XML_XML_NAMESPACE
; 2904 :     /* xml: prefix is not really a namespace */
; 2905 :     if ((cur[0] == 'x') && (cur[1] == 'm') &&
; 2906 :         (cur[2] == 'l') && (cur[3] == ':'))
; 2907 : 	return(xmlStrdup(name));
; 2908 : #endif
; 2909 : 
; 2910 :     /* nasty but well=formed */
; 2911 :     if (cur[0] == ':')

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	jne	SHORT $LN12@xmlSplitQN

; 2912 : 	return(xmlStrdup(name));

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN1@xmlSplitQN
$LN12@xmlSplitQN:

; 2913 : 
; 2914 :     c = *cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _c$[ebp], edx
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
$LN2@xmlSplitQN:

; 2915 :     while ((c != 0) && (c != ':') && (len < max)) { /* tested bigname.xml */

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN3@xmlSplitQN
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	SHORT $LN3@xmlSplitQN
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _max$[ebp]
	jge	SHORT $LN3@xmlSplitQN

; 2916 : 	buf[len++] = c;

	mov	edx, DWORD PTR _len$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR _buf$[ebp+edx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 2917 : 	c = *cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 2918 :     }

	jmp	SHORT $LN2@xmlSplitQN
$LN3@xmlSplitQN:

; 2919 :     if (len >= max) {

	mov	edx, DWORD PTR _len$[ebp]
	cmp	edx, DWORD PTR _max$[ebp]
	jl	$LN13@xmlSplitQN

; 2920 : 	/*
; 2921 : 	 * Okay someone managed to make a huge name, so he's ready to pay
; 2922 : 	 * for the processing speed.
; 2923 : 	 */
; 2924 : 	max = len * 2;

	mov	eax, DWORD PTR _len$[ebp]
	shl	eax, 1
	mov	DWORD PTR _max$[ebp], eax

; 2925 : 
; 2926 : 	buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));

	mov	esi, esp
	mov	ecx, DWORD PTR _max$[ebp]
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buffer$[ebp], eax

; 2927 : 	if (buffer == NULL) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN14@xmlSplitQN

; 2928 : 	    xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 2929 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSplitQN
$LN14@xmlSplitQN:

; 2930 : 	}
; 2931 : 	memcpy(buffer, buf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN4@xmlSplitQN:

; 2932 : 	while ((c != 0) && (c != ':')) { /* tested bigname.xml */

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN5@xmlSplitQN
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	$LN5@xmlSplitQN

; 2933 : 	    if (len + 10 > max) {

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 10					; 0000000aH
	cmp	eax, DWORD PTR _max$[ebp]
	jle	SHORT $LN15@xmlSplitQN

; 2934 : 	        xmlChar *tmp;
; 2935 : 
; 2936 : 		max *= 2;

	mov	ecx, DWORD PTR _max$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _max$[ebp], ecx

; 2937 : 		tmp = (xmlChar *) xmlRealloc(buffer,

	mov	esi, esp
	mov	edx, DWORD PTR _max$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$4[ebp], eax

; 2938 : 						max * sizeof(xmlChar));
; 2939 : 		if (tmp == NULL) {

	cmp	DWORD PTR _tmp$4[ebp], 0
	jne	SHORT $LN16@xmlSplitQN

; 2940 : 		    xmlFree(buffer);

	mov	esi, esp
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2941 : 		    xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 2942 : 		    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSplitQN
$LN16@xmlSplitQN:

; 2943 : 		}
; 2944 : 		buffer = tmp;

	mov	eax, DWORD PTR _tmp$4[ebp]
	mov	DWORD PTR _buffer$[ebp], eax
$LN15@xmlSplitQN:

; 2945 : 	    }
; 2946 : 	    buffer[len++] = c;

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2947 : 	    c = *cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _c$[ebp], edx
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 2948 : 	}

	jmp	$LN4@xmlSplitQN
$LN5@xmlSplitQN:

; 2949 : 	buffer[len] = 0;

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 0
$LN13@xmlSplitQN:

; 2950 :     }
; 2951 : 
; 2952 :     if ((c == ':') && (*cur == 0)) {

	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	jne	SHORT $LN17@xmlSplitQN
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN17@xmlSplitQN

; 2953 :         if (buffer != NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN18@xmlSplitQN

; 2954 : 	    xmlFree(buffer);

	mov	esi, esp
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@xmlSplitQN:

; 2955 : 	*prefix = NULL;

	mov	edx, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR [edx], 0

; 2956 : 	return(xmlStrdup(name));

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN1@xmlSplitQN
$LN17@xmlSplitQN:

; 2957 :     }
; 2958 : 
; 2959 :     if (buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN19@xmlSplitQN

; 2960 : 	ret = xmlStrndup(buf, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN20@xmlSplitQN
$LN19@xmlSplitQN:

; 2961 :     else {
; 2962 : 	ret = buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 2963 : 	buffer = NULL;

	mov	DWORD PTR _buffer$[ebp], 0

; 2964 : 	max = XML_MAX_NAMELEN;

	mov	DWORD PTR _max$[ebp], 100		; 00000064H
$LN20@xmlSplitQN:

; 2965 :     }
; 2966 : 
; 2967 : 
; 2968 :     if (c == ':') {

	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	jne	$LN21@xmlSplitQN

; 2969 : 	c = *cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _c$[ebp], edx

; 2970 :         *prefix = ret;

	mov	eax, DWORD PTR _prefix$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax], ecx

; 2971 : 	if (c == 0) {

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN22@xmlSplitQN

; 2972 : 	    return(xmlStrndup(BAD_CAST "", 0));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrndup
	add	esp, 8
	jmp	$LN1@xmlSplitQN
$LN22@xmlSplitQN:

; 2973 : 	}
; 2974 : 	len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 2975 : 
; 2976 : 	/*
; 2977 : 	 * Check that the first character is proper to start
; 2978 : 	 * a new name
; 2979 : 	 */
; 2980 : 	if (!(((c >= 0x61) && (c <= 0x7A)) ||

	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN24@xmlSplitQN
	cmp	DWORD PTR _c$[ebp], 122			; 0000007aH
	jle	$LN23@xmlSplitQN
$LN24@xmlSplitQN:
	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN25@xmlSplitQN
	cmp	DWORD PTR _c$[ebp], 90			; 0000005aH
	jle	$LN23@xmlSplitQN
$LN25@xmlSplitQN:
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	je	$LN23@xmlSplitQN
	cmp	DWORD PTR _c$[ebp], 58			; 0000003aH
	je	$LN23@xmlSplitQN

; 2981 : 	      ((c >= 0x41) && (c <= 0x5A)) ||
; 2982 : 	      (c == '_') || (c == ':'))) {
; 2983 : 	    int l;
; 2984 : 	    int first = CUR_SCHAR(cur, l);

	lea	edx, DWORD PTR _l$3[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlStringCurrentChar
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _first$2[ebp], eax

; 2985 : 
; 2986 : 	    if (!IS_LETTER(first) && (first != '_')) {

	cmp	DWORD PTR _first$2[ebp], 256		; 00000100H
	jge	$LN40@xmlSplitQN
	cmp	DWORD PTR _first$2[ebp], 65		; 00000041H
	jl	SHORT $LN34@xmlSplitQN
	cmp	DWORD PTR _first$2[ebp], 90		; 0000005aH
	jle	SHORT $LN36@xmlSplitQN
$LN34@xmlSplitQN:
	cmp	DWORD PTR _first$2[ebp], 97		; 00000061H
	jl	SHORT $LN35@xmlSplitQN
	cmp	DWORD PTR _first$2[ebp], 122		; 0000007aH
	jle	SHORT $LN36@xmlSplitQN
$LN35@xmlSplitQN:
	cmp	DWORD PTR _first$2[ebp], 192		; 000000c0H
	jl	SHORT $LN37@xmlSplitQN
	cmp	DWORD PTR _first$2[ebp], 214		; 000000d6H
	jle	SHORT $LN36@xmlSplitQN
$LN37@xmlSplitQN:
	cmp	DWORD PTR _first$2[ebp], 216		; 000000d8H
	jl	SHORT $LN38@xmlSplitQN
	cmp	DWORD PTR _first$2[ebp], 246		; 000000f6H
	jle	SHORT $LN36@xmlSplitQN
$LN38@xmlSplitQN:
	cmp	DWORD PTR _first$2[ebp], 248		; 000000f8H
	jge	SHORT $LN36@xmlSplitQN
	mov	DWORD PTR tv183[ebp], 0
	jmp	SHORT $LN39@xmlSplitQN
$LN36@xmlSplitQN:
	mov	DWORD PTR tv183[ebp], 1
$LN39@xmlSplitQN:
	mov	edx, DWORD PTR tv183[ebp]
	mov	DWORD PTR tv184[ebp], edx
	jmp	SHORT $LN41@xmlSplitQN
$LN40@xmlSplitQN:
	push	OFFSET _xmlIsBaseCharGroup
	mov	eax, DWORD PTR _first$2[ebp]
	push	eax
	call	_xmlCharInRange
	add	esp, 8
	mov	DWORD PTR tv184[ebp], eax
$LN41@xmlSplitQN:
	cmp	DWORD PTR tv184[ebp], 0
	jne	$LN23@xmlSplitQN
	cmp	DWORD PTR _first$2[ebp], 256		; 00000100H
	jge	SHORT $LN46@xmlSplitQN
	mov	DWORD PTR tv193[ebp], 0
	jmp	SHORT $LN47@xmlSplitQN
$LN46@xmlSplitQN:
	cmp	DWORD PTR _first$2[ebp], 19968		; 00004e00H
	jl	SHORT $LN42@xmlSplitQN
	cmp	DWORD PTR _first$2[ebp], 40869		; 00009fa5H
	jle	SHORT $LN43@xmlSplitQN
$LN42@xmlSplitQN:
	cmp	DWORD PTR _first$2[ebp], 12295		; 00003007H
	je	SHORT $LN43@xmlSplitQN
	cmp	DWORD PTR _first$2[ebp], 12321		; 00003021H
	jl	SHORT $LN44@xmlSplitQN
	cmp	DWORD PTR _first$2[ebp], 12329		; 00003029H
	jle	SHORT $LN43@xmlSplitQN
$LN44@xmlSplitQN:
	mov	DWORD PTR tv192[ebp], 0
	jmp	SHORT $LN45@xmlSplitQN
$LN43@xmlSplitQN:
	mov	DWORD PTR tv192[ebp], 1
$LN45@xmlSplitQN:
	mov	ecx, DWORD PTR tv192[ebp]
	mov	DWORD PTR tv193[ebp], ecx
$LN47@xmlSplitQN:
	cmp	DWORD PTR tv193[ebp], 0
	jne	SHORT $LN23@xmlSplitQN
	cmp	DWORD PTR _first$2[ebp], 95		; 0000005fH
	je	SHORT $LN23@xmlSplitQN

; 2987 : 		xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0CI@GHNHPHHB@Name?5?$CFs?5is?5not?5XML?5Namespace?5co@
	push	202					; 000000caH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN23@xmlSplitQN:

; 2988 : 			    "Name %s is not XML Namespace compliant\n",
; 2989 : 				  name);
; 2990 : 	    }
; 2991 : 	}
; 2992 : 	cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
$LN6@xmlSplitQN:

; 2993 : 
; 2994 : 	while ((c != 0) && (len < max)) { /* tested bigname2.xml */

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN7@xmlSplitQN
	mov	edx, DWORD PTR _len$[ebp]
	cmp	edx, DWORD PTR _max$[ebp]
	jge	SHORT $LN7@xmlSplitQN

; 2995 : 	    buf[len++] = c;

	mov	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR _buf$[ebp+eax], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 2996 : 	    c = *cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 2997 : 	}

	jmp	SHORT $LN6@xmlSplitQN
$LN7@xmlSplitQN:

; 2998 : 	if (len >= max) {

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jl	$LN27@xmlSplitQN

; 2999 : 	    /*
; 3000 : 	     * Okay someone managed to make a huge name, so he's ready to pay
; 3001 : 	     * for the processing speed.
; 3002 : 	     */
; 3003 : 	    max = len * 2;

	mov	ecx, DWORD PTR _len$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _max$[ebp], ecx

; 3004 : 
; 3005 : 	    buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));

	mov	esi, esp
	mov	edx, DWORD PTR _max$[ebp]
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buffer$[ebp], eax

; 3006 : 	    if (buffer == NULL) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN28@xmlSplitQN

; 3007 : 	        xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 3008 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSplitQN
$LN28@xmlSplitQN:

; 3009 : 	    }
; 3010 : 	    memcpy(buffer, buf, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@xmlSplitQN:

; 3011 : 	    while (c != 0) { /* tested bigname2.xml */

	cmp	DWORD PTR _c$[ebp], 0
	je	$LN9@xmlSplitQN

; 3012 : 		if (len + 10 > max) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 10					; 0000000aH
	cmp	ecx, DWORD PTR _max$[ebp]
	jle	SHORT $LN29@xmlSplitQN

; 3013 : 		    xmlChar *tmp;
; 3014 : 
; 3015 : 		    max *= 2;

	mov	edx, DWORD PTR _max$[ebp]
	shl	edx, 1
	mov	DWORD PTR _max$[ebp], edx

; 3016 : 		    tmp = (xmlChar *) xmlRealloc(buffer,

	mov	esi, esp
	mov	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$1[ebp], eax

; 3017 : 						    max * sizeof(xmlChar));
; 3018 : 		    if (tmp == NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN30@xmlSplitQN

; 3019 : 			xmlErrMemory(ctxt, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlErrMemory
	add	esp, 8

; 3020 : 			xmlFree(buffer);

	mov	esi, esp
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3021 : 			return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSplitQN
$LN30@xmlSplitQN:

; 3022 : 		    }
; 3023 : 		    buffer = tmp;

	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _buffer$[ebp], ecx
$LN29@xmlSplitQN:

; 3024 : 		}
; 3025 : 		buffer[len++] = c;

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 3026 : 		c = *cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 3027 : 	    }

	jmp	$LN8@xmlSplitQN
$LN9@xmlSplitQN:

; 3028 : 	    buffer[len] = 0;

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 0
$LN27@xmlSplitQN:

; 3029 : 	}
; 3030 : 
; 3031 : 	if (buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN31@xmlSplitQN

; 3032 : 	    ret = xmlStrndup(buf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN21@xmlSplitQN
$LN31@xmlSplitQN:

; 3033 : 	else {
; 3034 : 	    ret = buffer;

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _ret$[ebp], edx
$LN21@xmlSplitQN:

; 3035 : 	}
; 3036 :     }
; 3037 : 
; 3038 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSplitQN:

; 3039 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN51@xmlSplitQN
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 180				; 000000b4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN51@xmlSplitQN:
	DD	2
	DD	$LN50@xmlSplitQN
$LN50@xmlSplitQN:
	DD	-112					; ffffff90H
	DD	105					; 00000069H
	DD	$LN48@xmlSplitQN
	DD	-152					; ffffff68H
	DD	4
	DD	$LN49@xmlSplitQN
$LN49@xmlSplitQN:
	DB	108					; 0000006cH
	DB	0
$LN48@xmlSplitQN:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlSplitQName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlPopInput
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlPopInput PROC					; COMDAT

; 2218 : xmlPopInput(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2219 :     if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlPopInpu
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+40], 1
	jg	SHORT $LN2@xmlPopInpu
$LN3@xmlPopInpu:
	xor	al, al
	jmp	$LN1@xmlPopInpu
$LN2@xmlPopInpu:

; 2220 :     if (xmlParserDebugEntities)

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlPopInpu

; 2221 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	push	OFFSET ??_C@_0BC@LEKDBCEK@Popping?5input?5?$CFd?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlPopInpu:

; 2222 : 		"Popping input %d\n", ctxt->inputNr);
; 2223 :     if ((ctxt->inputNr > 1) && (ctxt->inSubset == 0) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1
	jle	SHORT $LN5@xmlPopInpu
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+216], 0
	jne	SHORT $LN5@xmlPopInpu
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	je	SHORT $LN5@xmlPopInpu

; 2224 :         (ctxt->instate != XML_PARSER_EOF))
; 2225 :         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,

	push	OFFSET ??_C@_0CC@JODEMIEP@Unfinished?5entity?5outside?5the?5D@
	push	1
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN5@xmlPopInpu:

; 2226 :                     "Unfinished entity outside the DTD");
; 2227 :     xmlFreeInputStream(inputPop(ctxt));

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_inputPop
	add	esp, 4
	push	eax
	call	_xmlFreeInputStream
	add	esp, 4

; 2228 :     if (*ctxt->input->cur == 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN6@xmlPopInpu

; 2229 :         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);

	push	250					; 000000faH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlParserInputGrow
	add	esp, 8
$LN6@xmlPopInpu:

; 2230 :     return(CUR);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	al, BYTE PTR [eax]
$LN1@xmlPopInpu:

; 2231 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlPopInput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlPushInput
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_input$ = 12						; size = 4
_xmlPushInput PROC					; COMDAT

; 2243 : xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 2244 :     int ret;
; 2245 :     if (input == NULL) return(-1);

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN4@xmlPushInp
	or	eax, -1
	jmp	$LN1@xmlPushInp
$LN4@xmlPushInp:

; 2246 : 
; 2247 :     if (xmlParserDebugEntities) {

	call	___xmlParserDebugEntities
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xmlPushInp

; 2248 : 	if ((ctxt->input != NULL) && (ctxt->input->filename))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN6@xmlPushInp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN6@xmlPushInp

; 2249 : 	    xmlGenericError(xmlGenericErrorContext,

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET ??_C@_08FFIMCMGN@?$CFs?$CI?$CFd?$CJ?3?5@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlPushInp:

; 2250 : 		    "%s(%d): ", ctxt->input->filename,
; 2251 : 		    ctxt->input->line);
; 2252 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	add	edx, 1
	push	edx
	push	OFFSET ??_C@_0BK@IPLLKNJK@Pushing?5input?5?$CFd?5?3?5?$CF?430s?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlPushInp:

; 2253 : 		"Pushing input %d : %.30s\n", ctxt->inputNr+1, input->cur);
; 2254 :     }
; 2255 :     if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 40			; 00000028H
	jle	SHORT $LN9@xmlPushInp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	and	ecx, 524288				; 00080000H
	je	SHORT $LN8@xmlPushInp
$LN9@xmlPushInp:
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+40], 1024		; 00000400H
	jle	SHORT $LN7@xmlPushInp
$LN8@xmlPushInp:

; 2256 :         (ctxt->inputNr > 1024)) {
; 2257 :         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);

	push	0
	push	89					; 00000059H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN2@xmlPushInp:

; 2258 :         while (ctxt->inputNr > 1)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+40], 1
	jle	SHORT $LN3@xmlPushInp

; 2259 :             xmlFreeInputStream(inputPop(ctxt));

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_inputPop
	add	esp, 4
	push	eax
	call	_xmlFreeInputStream
	add	esp, 4
	jmp	SHORT $LN2@xmlPushInp
$LN3@xmlPushInp:

; 2260 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPushInp
$LN7@xmlPushInp:

; 2261 :     }
; 2262 :     ret = inputPush(ctxt, input);

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_inputPush
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2263 :     if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN10@xmlPushInp

; 2264 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlPushInp
$LN10@xmlPushInp:

; 2265 :     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN11@xmlPushInp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN11@xmlPushInp
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN11@xmlPushInp:

; 2266 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlPushInp:

; 2267 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPushInput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateEntityParserCtxt
_TEXT	SEGMENT
_URL$ = 8						; size = 4
_ID$ = 12						; size = 4
_base$ = 16						; size = 4
_xmlCreateEntityParserCtxt PROC				; COMDAT

; 14060: 	                  const xmlChar *base) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14061:     return xmlCreateEntityParserCtxtInternal(URL, ID, base, NULL);

	push	0
	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	_xmlCreateEntityParserCtxtInternal
	add	esp, 16					; 00000010H

; 14062: 
; 14063: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCreateEntityParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateMemoryParserCtxt
_TEXT	SEGMENT
_buf$ = -12						; size = 4
_input$ = -8						; size = 4
_ctxt$ = -4						; size = 4
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlCreateMemoryParserCtxt PROC				; COMDAT

; 14371: xmlCreateMemoryParserCtxt(const char *buffer, int size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14372:     xmlParserCtxtPtr ctxt;
; 14373:     xmlParserInputPtr input;
; 14374:     xmlParserInputBufferPtr buf;
; 14375: 
; 14376:     if (buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN2@xmlCreateM

; 14377: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateM
$LN2@xmlCreateM:

; 14378:     if (size <= 0)

	cmp	DWORD PTR _size$[ebp], 0
	jg	SHORT $LN3@xmlCreateM

; 14379: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateM
$LN3@xmlCreateM:

; 14380: 
; 14381:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 14382:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN4@xmlCreateM

; 14383: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateM
$LN4@xmlCreateM:

; 14384: 
; 14385:     /* TODO: xmlParserInputBufferCreateStatic, requires some serious changes */
; 14386:     buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);

	push	0
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlParserInputBufferCreateMem
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buf$[ebp], eax

; 14387:     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN5@xmlCreateM

; 14388: 	xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14389: 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCreateM
$LN5@xmlCreateM:

; 14390:     }
; 14391: 
; 14392:     input = xmlNewInputStream(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNewInputStream
	add	esp, 4
	mov	DWORD PTR _input$[ebp], eax

; 14393:     if (input == NULL) {

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN6@xmlCreateM

; 14394: 	xmlFreeParserInputBuffer(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 14395: 	xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14396: 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCreateM
$LN6@xmlCreateM:

; 14397:     }
; 14398: 
; 14399:     input->filename = NULL;

	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+4], 0

; 14400:     input->buf = buf;

	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx], edx

; 14401:     xmlBufResetInput(input->buf->buffer, input);

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufResetInput
	add	esp, 8

; 14402: 
; 14403:     inputPush(ctxt, input);

	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_inputPush
	add	esp, 8

; 14404:     return(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
$LN1@xmlCreateM:

; 14405: }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCreateMemoryParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateURLParserCtxt
_TEXT	SEGMENT
_directory$ = -12					; size = 4
_inputStream$ = -8					; size = 4
_ctxt$ = -4						; size = 4
_filename$ = 8						; size = 4
_options$ = 12						; size = 4
_xmlCreateURLParserCtxt PROC				; COMDAT

; 14084: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14085:     xmlParserCtxtPtr ctxt;
; 14086:     xmlParserInputPtr inputStream;
; 14087:     char *directory = NULL;

	mov	DWORD PTR _directory$[ebp], 0

; 14088: 
; 14089:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 14090:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlCreateU

; 14091: 	xmlErrMemory(NULL, "cannot allocate parser context");

	push	OFFSET ??_C@_0BP@IGCIIMIK@cannot?5allocate?5parser?5context@
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 14092: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateU
$LN2@xmlCreateU:

; 14093:     }
; 14094: 
; 14095:     if (options)

	cmp	DWORD PTR _options$[ebp], 0
	je	SHORT $LN3@xmlCreateU

; 14096: 	xmlCtxtUseOptionsInternal(ctxt, options, NULL);

	push	0
	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtUseOptionsInternal
	add	esp, 12					; 0000000cH
$LN3@xmlCreateU:

; 14097:     ctxt->linenumbers = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+280], 1

; 14098: 
; 14099:     inputStream = xmlLoadExternalEntity(filename, NULL, ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlLoadExternalEntity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _inputStream$[ebp], eax

; 14100:     if (inputStream == NULL) {

	cmp	DWORD PTR _inputStream$[ebp], 0
	jne	SHORT $LN4@xmlCreateU

; 14101: 	xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14102: 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCreateU
$LN4@xmlCreateU:

; 14103:     }
; 14104: 
; 14105:     inputPush(ctxt, inputStream);

	mov	eax, DWORD PTR _inputStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_inputPush
	add	esp, 8

; 14106:     if ((ctxt->directory == NULL) && (directory == NULL))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+180], 0
	jne	SHORT $LN5@xmlCreateU
	cmp	DWORD PTR _directory$[ebp], 0
	jne	SHORT $LN5@xmlCreateU

; 14107:         directory = xmlParserGetDirectory(filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	DWORD PTR _directory$[ebp], eax
$LN5@xmlCreateU:

; 14108:     if ((ctxt->directory == NULL) && (directory != NULL))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+180], 0
	jne	SHORT $LN6@xmlCreateU
	cmp	DWORD PTR _directory$[ebp], 0
	je	SHORT $LN6@xmlCreateU

; 14109:         ctxt->directory = directory;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _directory$[ebp]
	mov	DWORD PTR [edx+180], eax
$LN6@xmlCreateU:

; 14110: 
; 14111:     return(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
$LN1@xmlCreateU:

; 14112: }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCreateURLParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateFileParserCtxt
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlCreateFileParserCtxt PROC				; COMDAT

; 14126: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14127:     return(xmlCreateURLParserCtxt(filename, 0));

	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlCreateURLParserCtxt
	add	esp, 8

; 14128: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCreateFileParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlHasFeature
_TEXT	SEGMENT
tv64 = -4						; size = 4
_feature$ = 8						; size = 4
_xmlHasFeature PROC					; COMDAT

; 849  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 850  :     switch (feature) {

	mov	eax, DWORD PTR _feature$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 32			; 00000020H
	ja	$LN2@xmlHasFeat
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN39@xmlHasFeat[edx*4]
$LN4@xmlHasFeat:

; 851  : 	case XML_WITH_THREAD:
; 852  : #ifdef LIBXML_THREAD_ENABLED
; 853  : 	    return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN5@xmlHasFeat:

; 854  : #else
; 855  : 	    return(0);
; 856  : #endif
; 857  :         case XML_WITH_TREE:
; 858  : #ifdef LIBXML_TREE_ENABLED
; 859  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN6@xmlHasFeat:

; 860  : #else
; 861  :             return(0);
; 862  : #endif
; 863  :         case XML_WITH_OUTPUT:
; 864  : #ifdef LIBXML_OUTPUT_ENABLED
; 865  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN7@xmlHasFeat:

; 866  : #else
; 867  :             return(0);
; 868  : #endif
; 869  :         case XML_WITH_PUSH:
; 870  : #ifdef LIBXML_PUSH_ENABLED
; 871  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN8@xmlHasFeat:

; 872  : #else
; 873  :             return(0);
; 874  : #endif
; 875  :         case XML_WITH_READER:
; 876  : #ifdef LIBXML_READER_ENABLED
; 877  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN9@xmlHasFeat:

; 878  : #else
; 879  :             return(0);
; 880  : #endif
; 881  :         case XML_WITH_PATTERN:
; 882  : #ifdef LIBXML_PATTERN_ENABLED
; 883  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN10@xmlHasFeat:

; 884  : #else
; 885  :             return(0);
; 886  : #endif
; 887  :         case XML_WITH_WRITER:
; 888  : #ifdef LIBXML_WRITER_ENABLED
; 889  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN11@xmlHasFeat:

; 890  : #else
; 891  :             return(0);
; 892  : #endif
; 893  :         case XML_WITH_SAX1:
; 894  : #ifdef LIBXML_SAX1_ENABLED
; 895  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN12@xmlHasFeat:

; 896  : #else
; 897  :             return(0);
; 898  : #endif
; 899  :         case XML_WITH_FTP:
; 900  : #ifdef LIBXML_FTP_ENABLED
; 901  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN13@xmlHasFeat:

; 902  : #else
; 903  :             return(0);
; 904  : #endif
; 905  :         case XML_WITH_HTTP:
; 906  : #ifdef LIBXML_HTTP_ENABLED
; 907  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN14@xmlHasFeat:

; 908  : #else
; 909  :             return(0);
; 910  : #endif
; 911  :         case XML_WITH_VALID:
; 912  : #ifdef LIBXML_VALID_ENABLED
; 913  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN15@xmlHasFeat:

; 914  : #else
; 915  :             return(0);
; 916  : #endif
; 917  :         case XML_WITH_HTML:
; 918  : #ifdef LIBXML_HTML_ENABLED
; 919  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN16@xmlHasFeat:

; 920  : #else
; 921  :             return(0);
; 922  : #endif
; 923  :         case XML_WITH_LEGACY:
; 924  : #ifdef LIBXML_LEGACY_ENABLED
; 925  :             return(1);

	mov	eax, 1
	jmp	$LN1@xmlHasFeat
$LN17@xmlHasFeat:

; 926  : #else
; 927  :             return(0);
; 928  : #endif
; 929  :         case XML_WITH_C14N:
; 930  : #ifdef LIBXML_C14N_ENABLED
; 931  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN18@xmlHasFeat:

; 932  : #else
; 933  :             return(0);
; 934  : #endif
; 935  :         case XML_WITH_CATALOG:
; 936  : #ifdef LIBXML_CATALOG_ENABLED
; 937  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN19@xmlHasFeat:

; 938  : #else
; 939  :             return(0);
; 940  : #endif
; 941  :         case XML_WITH_XPATH:
; 942  : #ifdef LIBXML_XPATH_ENABLED
; 943  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN20@xmlHasFeat:

; 944  : #else
; 945  :             return(0);
; 946  : #endif
; 947  :         case XML_WITH_XPTR:
; 948  : #ifdef LIBXML_XPTR_ENABLED
; 949  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN21@xmlHasFeat:

; 950  : #else
; 951  :             return(0);
; 952  : #endif
; 953  :         case XML_WITH_XINCLUDE:
; 954  : #ifdef LIBXML_XINCLUDE_ENABLED
; 955  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN22@xmlHasFeat:

; 956  : #else
; 957  :             return(0);
; 958  : #endif
; 959  :         case XML_WITH_ICONV:
; 960  : #ifdef LIBXML_ICONV_ENABLED
; 961  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN23@xmlHasFeat:

; 962  : #else
; 963  :             return(0);
; 964  : #endif
; 965  :         case XML_WITH_ISO8859X:
; 966  : #ifdef LIBXML_ISO8859X_ENABLED
; 967  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN24@xmlHasFeat:

; 968  : #else
; 969  :             return(0);
; 970  : #endif
; 971  :         case XML_WITH_UNICODE:
; 972  : #ifdef LIBXML_UNICODE_ENABLED
; 973  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN25@xmlHasFeat:

; 974  : #else
; 975  :             return(0);
; 976  : #endif
; 977  :         case XML_WITH_REGEXP:
; 978  : #ifdef LIBXML_REGEXP_ENABLED
; 979  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN26@xmlHasFeat:

; 980  : #else
; 981  :             return(0);
; 982  : #endif
; 983  :         case XML_WITH_AUTOMATA:
; 984  : #ifdef LIBXML_AUTOMATA_ENABLED
; 985  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN27@xmlHasFeat:

; 986  : #else
; 987  :             return(0);
; 988  : #endif
; 989  :         case XML_WITH_EXPR:
; 990  : #ifdef LIBXML_EXPR_ENABLED
; 991  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN28@xmlHasFeat:

; 992  : #else
; 993  :             return(0);
; 994  : #endif
; 995  :         case XML_WITH_SCHEMAS:
; 996  : #ifdef LIBXML_SCHEMAS_ENABLED
; 997  :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN29@xmlHasFeat:

; 998  : #else
; 999  :             return(0);
; 1000 : #endif
; 1001 :         case XML_WITH_SCHEMATRON:
; 1002 : #ifdef LIBXML_SCHEMATRON_ENABLED
; 1003 :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN30@xmlHasFeat:

; 1004 : #else
; 1005 :             return(0);
; 1006 : #endif
; 1007 :         case XML_WITH_MODULES:
; 1008 : #ifdef LIBXML_MODULES_ENABLED
; 1009 :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN31@xmlHasFeat:

; 1010 : #else
; 1011 :             return(0);
; 1012 : #endif
; 1013 :         case XML_WITH_DEBUG:
; 1014 : #ifdef LIBXML_DEBUG_ENABLED
; 1015 :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN32@xmlHasFeat:

; 1016 : #else
; 1017 :             return(0);
; 1018 : #endif
; 1019 :         case XML_WITH_DEBUG_MEM:
; 1020 : #ifdef DEBUG_MEMORY_LOCATION
; 1021 :             return(1);
; 1022 : #else
; 1023 :             return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlHasFeat
$LN33@xmlHasFeat:

; 1024 : #endif
; 1025 :         case XML_WITH_DEBUG_RUN:
; 1026 : #ifdef LIBXML_DEBUG_RUNTIME
; 1027 :             return(1);
; 1028 : #else
; 1029 :             return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlHasFeat
$LN34@xmlHasFeat:

; 1030 : #endif
; 1031 :         case XML_WITH_ZLIB:
; 1032 : #ifdef LIBXML_ZLIB_ENABLED
; 1033 :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN35@xmlHasFeat:

; 1034 : #else
; 1035 :             return(0);
; 1036 : #endif
; 1037 :         case XML_WITH_LZMA:
; 1038 : #ifdef LIBXML_LZMA_ENABLED
; 1039 :             return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlHasFeat
$LN36@xmlHasFeat:

; 1040 : #else
; 1041 :             return(0);
; 1042 : #endif
; 1043 :         case XML_WITH_ICU:
; 1044 : #ifdef LIBXML_ICU_ENABLED
; 1045 :             return(1);
; 1046 : #else
; 1047 :             return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlHasFeat
$LN2@xmlHasFeat:

; 1048 : #endif
; 1049 :         default:
; 1050 : 	    break;
; 1051 :      }
; 1052 :      return(0);

	xor	eax, eax
$LN1@xmlHasFeat:

; 1053 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN39@xmlHasFeat:
	DD	$LN4@xmlHasFeat
	DD	$LN5@xmlHasFeat
	DD	$LN6@xmlHasFeat
	DD	$LN7@xmlHasFeat
	DD	$LN8@xmlHasFeat
	DD	$LN9@xmlHasFeat
	DD	$LN10@xmlHasFeat
	DD	$LN11@xmlHasFeat
	DD	$LN12@xmlHasFeat
	DD	$LN13@xmlHasFeat
	DD	$LN14@xmlHasFeat
	DD	$LN15@xmlHasFeat
	DD	$LN16@xmlHasFeat
	DD	$LN17@xmlHasFeat
	DD	$LN18@xmlHasFeat
	DD	$LN19@xmlHasFeat
	DD	$LN20@xmlHasFeat
	DD	$LN21@xmlHasFeat
	DD	$LN22@xmlHasFeat
	DD	$LN23@xmlHasFeat
	DD	$LN24@xmlHasFeat
	DD	$LN25@xmlHasFeat
	DD	$LN26@xmlHasFeat
	DD	$LN27@xmlHasFeat
	DD	$LN28@xmlHasFeat
	DD	$LN29@xmlHasFeat
	DD	$LN30@xmlHasFeat
	DD	$LN31@xmlHasFeat
	DD	$LN32@xmlHasFeat
	DD	$LN33@xmlHasFeat
	DD	$LN34@xmlHasFeat
	DD	$LN36@xmlHasFeat
	DD	$LN35@xmlHasFeat
_xmlHasFeature ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReadIO
_TEXT	SEGMENT
_stream$ = -8						; size = 4
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_ioread$ = 12						; size = 4
_ioclose$ = 16						; size = 4
_ioctx$ = 20						; size = 4
_URL$ = 24						; size = 4
_encoding$ = 28						; size = 4
_options$ = 32						; size = 4
_xmlCtxtReadIO PROC					; COMDAT

; 15554: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15555:     xmlParserInputBufferPtr input;
; 15556:     xmlParserInputPtr stream;
; 15557: 
; 15558:     if (ioread == NULL)

	cmp	DWORD PTR _ioread$[ebp], 0
	jne	SHORT $LN2@xmlCtxtRea

; 15559:         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlCtxtRea
$LN2@xmlCtxtRea:

; 15560:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlCtxtRea

; 15561:         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlCtxtRea
$LN3@xmlCtxtRea:

; 15562:     xmlInitParser();

	call	_xmlInitParser

; 15563: 
; 15564:     xmlCtxtReset(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtReset
	add	esp, 4

; 15565: 
; 15566:     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,

	push	0
	mov	ecx, DWORD PTR _ioctx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ioclose$[ebp]
	push	edx
	mov	eax, DWORD PTR _ioread$[ebp]
	push	eax
	call	_xmlParserInputBufferCreateIO
	add	esp, 16					; 00000010H
	mov	DWORD PTR _input$[ebp], eax

; 15567:                                          XML_CHAR_ENCODING_NONE);
; 15568:     if (input == NULL) {

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN4@xmlCtxtRea

; 15569:         if (ioclose != NULL)

	cmp	DWORD PTR _ioclose$[ebp], 0
	je	SHORT $LN5@xmlCtxtRea

; 15570:             ioclose(ioctx);

	mov	esi, esp
	mov	ecx, DWORD PTR _ioctx$[ebp]
	push	ecx
	call	DWORD PTR _ioclose$[ebp]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlCtxtRea:

; 15571:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN4@xmlCtxtRea:

; 15572:     }
; 15573:     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _stream$[ebp], eax

; 15574:     if (stream == NULL) {

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN6@xmlCtxtRea

; 15575:         xmlFreeParserInputBuffer(input);

	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 15576:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN6@xmlCtxtRea:

; 15577:     }
; 15578:     inputPush(ctxt, stream);

	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_inputPush
	add	esp, 8

; 15579:     return (xmlDoRead(ctxt, URL, encoding, options, 1));

	push	1
	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDoRead
	add	esp, 20					; 00000014H
$LN1@xmlCtxtRea:

; 15580: }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtReadIO ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReadFd
_TEXT	SEGMENT
_stream$ = -8						; size = 4
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_fd$ = 12						; size = 4
_URL$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlCtxtReadFd PROC					; COMDAT

; 15508: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15509:     xmlParserInputBufferPtr input;
; 15510:     xmlParserInputPtr stream;
; 15511: 
; 15512:     if (fd < 0)

	cmp	DWORD PTR _fd$[ebp], 0
	jge	SHORT $LN2@xmlCtxtRea

; 15513:         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlCtxtRea
$LN2@xmlCtxtRea:

; 15514:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlCtxtRea

; 15515:         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlCtxtRea
$LN3@xmlCtxtRea:

; 15516:     xmlInitParser();

	call	_xmlInitParser

; 15517: 
; 15518:     xmlCtxtReset(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtReset
	add	esp, 4

; 15519: 
; 15520: 
; 15521:     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);

	push	0
	mov	ecx, DWORD PTR _fd$[ebp]
	push	ecx
	call	_xmlParserInputBufferCreateFd
	add	esp, 8
	mov	DWORD PTR _input$[ebp], eax

; 15522:     if (input == NULL)

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN4@xmlCtxtRea

; 15523:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN4@xmlCtxtRea:

; 15524:     input->closecallback = NULL;

	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx+8], 0

; 15525:     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _stream$[ebp], eax

; 15526:     if (stream == NULL) {

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN5@xmlCtxtRea

; 15527:         xmlFreeParserInputBuffer(input);

	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 15528:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN5@xmlCtxtRea:

; 15529:     }
; 15530:     inputPush(ctxt, stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_inputPush
	add	esp, 8

; 15531:     return (xmlDoRead(ctxt, URL, encoding, options, 1));

	push	1
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDoRead
	add	esp, 20					; 00000014H
$LN1@xmlCtxtRea:

; 15532: }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtReadFd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReadMemory
_TEXT	SEGMENT
_stream$ = -8						; size = 4
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_URL$ = 20						; size = 4
_encoding$ = 24						; size = 4
_options$ = 28						; size = 4
_xmlCtxtReadMemory PROC					; COMDAT

; 15463: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15464:     xmlParserInputBufferPtr input;
; 15465:     xmlParserInputPtr stream;
; 15466: 
; 15467:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlCtxtRea

; 15468:         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlCtxtRea
$LN2@xmlCtxtRea:

; 15469:     if (buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN3@xmlCtxtRea

; 15470:         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlCtxtRea
$LN3@xmlCtxtRea:

; 15471:     xmlInitParser();

	call	_xmlInitParser

; 15472: 
; 15473:     xmlCtxtReset(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtReset
	add	esp, 4

; 15474: 
; 15475:     input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);

	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_xmlParserInputBufferCreateMem
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _input$[ebp], eax

; 15476:     if (input == NULL) {

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN4@xmlCtxtRea

; 15477: 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN4@xmlCtxtRea:

; 15478:     }
; 15479: 
; 15480:     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _stream$[ebp], eax

; 15481:     if (stream == NULL) {

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN5@xmlCtxtRea

; 15482: 	xmlFreeParserInputBuffer(input);

	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 15483: 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN5@xmlCtxtRea:

; 15484:     }
; 15485: 
; 15486:     inputPush(ctxt, stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_inputPush
	add	esp, 8

; 15487:     return (xmlDoRead(ctxt, URL, encoding, options, 1));

	push	1
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDoRead
	add	esp, 20					; 00000014H
$LN1@xmlCtxtRea:

; 15488: }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtReadMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReadFile
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_encoding$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlCtxtReadFile PROC					; COMDAT

; 15427: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15428:     xmlParserInputPtr stream;
; 15429: 
; 15430:     if (filename == NULL)

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN2@xmlCtxtRea

; 15431:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN2@xmlCtxtRea:

; 15432:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlCtxtRea

; 15433:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN3@xmlCtxtRea:

; 15434:     xmlInitParser();

	call	_xmlInitParser

; 15435: 
; 15436:     xmlCtxtReset(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtReset
	add	esp, 4

; 15437: 
; 15438:     stream = xmlLoadExternalEntity(filename, NULL, ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_xmlLoadExternalEntity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _stream$[ebp], eax

; 15439:     if (stream == NULL) {

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN4@xmlCtxtRea

; 15440:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN4@xmlCtxtRea:

; 15441:     }
; 15442:     inputPush(ctxt, stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_inputPush
	add	esp, 8

; 15443:     return (xmlDoRead(ctxt, NULL, encoding, options, 1));

	push	1
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDoRead
	add	esp, 20					; 00000014H
$LN1@xmlCtxtRea:

; 15444: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtReadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReadDoc
_TEXT	SEGMENT
_stream$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_cur$ = 12						; size = 4
_URL$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlCtxtReadDoc PROC					; COMDAT

; 15393: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15394:     xmlParserInputPtr stream;
; 15395: 
; 15396:     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlCtxtRea

; 15397:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN2@xmlCtxtRea:

; 15398:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlCtxtRea

; 15399:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN3@xmlCtxtRea:

; 15400:     xmlInitParser();

	call	_xmlInitParser

; 15401: 
; 15402:     xmlCtxtReset(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtReset
	add	esp, 4

; 15403: 
; 15404:     stream = xmlNewStringInputStream(ctxt, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNewStringInputStream
	add	esp, 8
	mov	DWORD PTR _stream$[ebp], eax

; 15405:     if (stream == NULL) {

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN4@xmlCtxtRea

; 15406:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCtxtRea
$LN4@xmlCtxtRea:

; 15407:     }
; 15408:     inputPush(ctxt, stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_inputPush
	add	esp, 8

; 15409:     return (xmlDoRead(ctxt, URL, encoding, options, 1));

	push	1
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDoRead
	add	esp, 20					; 00000014H
$LN1@xmlCtxtRea:

; 15410: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtReadDoc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlReadIO
_TEXT	SEGMENT
_stream$ = -12						; size = 4
_input$ = -8						; size = 4
_ctxt$ = -4						; size = 4
_ioread$ = 8						; size = 4
_ioclose$ = 12						; size = 4
_ioctx$ = 16						; size = 4
_URL$ = 20						; size = 4
_encoding$ = 24						; size = 4
_options$ = 28						; size = 4
_xmlReadIO PROC						; COMDAT

; 15346: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15347:     xmlParserCtxtPtr ctxt;
; 15348:     xmlParserInputBufferPtr input;
; 15349:     xmlParserInputPtr stream;
; 15350: 
; 15351:     if (ioread == NULL)

	cmp	DWORD PTR _ioread$[ebp], 0
	jne	SHORT $LN2@xmlReadIO

; 15352:         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlReadIO
$LN2@xmlReadIO:

; 15353:     xmlInitParser();

	call	_xmlInitParser

; 15354: 
; 15355:     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,

	push	0
	mov	eax, DWORD PTR _ioctx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ioclose$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ioread$[ebp]
	push	edx
	call	_xmlParserInputBufferCreateIO
	add	esp, 16					; 00000010H
	mov	DWORD PTR _input$[ebp], eax

; 15356:                                          XML_CHAR_ENCODING_NONE);
; 15357:     if (input == NULL) {

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN3@xmlReadIO

; 15358:         if (ioclose != NULL)

	cmp	DWORD PTR _ioclose$[ebp], 0
	je	SHORT $LN4@xmlReadIO

; 15359:             ioclose(ioctx);

	mov	esi, esp
	mov	eax, DWORD PTR _ioctx$[ebp]
	push	eax
	call	DWORD PTR _ioclose$[ebp]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlReadIO:

; 15360:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlReadIO
$LN3@xmlReadIO:

; 15361:     }
; 15362:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 15363:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN5@xmlReadIO

; 15364:         xmlFreeParserInputBuffer(input);

	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 15365:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlReadIO
$LN5@xmlReadIO:

; 15366:     }
; 15367:     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _stream$[ebp], eax

; 15368:     if (stream == NULL) {

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN6@xmlReadIO

; 15369:         xmlFreeParserInputBuffer(input);

	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 15370: 	xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 15371:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlReadIO
$LN6@xmlReadIO:

; 15372:     }
; 15373:     inputPush(ctxt, stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_inputPush
	add	esp, 8

; 15374:     return (xmlDoRead(ctxt, URL, encoding, options, 0));

	push	0
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDoRead
	add	esp, 20					; 00000014H
$LN1@xmlReadIO:

; 15375: }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlReadIO ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlReadFd
_TEXT	SEGMENT
_stream$ = -12						; size = 4
_input$ = -8						; size = 4
_ctxt$ = -4						; size = 4
_fd$ = 8						; size = 4
_URL$ = 12						; size = 4
_encoding$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlReadFd PROC						; COMDAT

; 15302: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15303:     xmlParserCtxtPtr ctxt;
; 15304:     xmlParserInputBufferPtr input;
; 15305:     xmlParserInputPtr stream;
; 15306: 
; 15307:     if (fd < 0)

	cmp	DWORD PTR _fd$[ebp], 0
	jge	SHORT $LN2@xmlReadFd

; 15308:         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlReadFd
$LN2@xmlReadFd:

; 15309:     xmlInitParser();

	call	_xmlInitParser

; 15310: 
; 15311:     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);

	push	0
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	call	_xmlParserInputBufferCreateFd
	add	esp, 8
	mov	DWORD PTR _input$[ebp], eax

; 15312:     if (input == NULL)

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN3@xmlReadFd

; 15313:         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlReadFd
$LN3@xmlReadFd:

; 15314:     input->closecallback = NULL;

	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 15315:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 15316:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN4@xmlReadFd

; 15317:         xmlFreeParserInputBuffer(input);

	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 15318:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlReadFd
$LN4@xmlReadFd:

; 15319:     }
; 15320:     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _stream$[ebp], eax

; 15321:     if (stream == NULL) {

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN5@xmlReadFd

; 15322:         xmlFreeParserInputBuffer(input);

	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 15323: 	xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 15324:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlReadFd
$LN5@xmlReadFd:

; 15325:     }
; 15326:     inputPush(ctxt, stream);

	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_inputPush
	add	esp, 8

; 15327:     return (xmlDoRead(ctxt, URL, encoding, options, 0));

	push	0
	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDoRead
	add	esp, 20					; 00000014H
$LN1@xmlReadFd:

; 15328: }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlReadFd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlReadMemory
_TEXT	SEGMENT
_ctxt$ = -4						; size = 4
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_URL$ = 16						; size = 4
_encoding$ = 20						; size = 4
_options$ = 24						; size = 4
_xmlReadMemory PROC					; COMDAT

; 15277: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15278:     xmlParserCtxtPtr ctxt;
; 15279: 
; 15280:     xmlInitParser();

	call	_xmlInitParser

; 15281:     ctxt = xmlCreateMemoryParserCtxt(buffer, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlCreateMemoryParserCtxt
	add	esp, 8
	mov	DWORD PTR _ctxt$[ebp], eax

; 15282:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlReadMem

; 15283:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlReadMem
$LN2@xmlReadMem:

; 15284:     return (xmlDoRead(ctxt, URL, encoding, options, 0));

	push	0
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _URL$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDoRead
	add	esp, 20					; 00000014H
$LN1@xmlReadMem:

; 15285: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlReadMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlReadFile
_TEXT	SEGMENT
_ctxt$ = -4						; size = 4
_filename$ = 8						; size = 4
_encoding$ = 12						; size = 4
_options$ = 16						; size = 4
_xmlReadFile PROC					; COMDAT

; 15253: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15254:     xmlParserCtxtPtr ctxt;
; 15255: 
; 15256:     xmlInitParser();

	call	_xmlInitParser

; 15257:     ctxt = xmlCreateURLParserCtxt(filename, options);

	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlCreateURLParserCtxt
	add	esp, 8
	mov	DWORD PTR _ctxt$[ebp], eax

; 15258:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlReadFil

; 15259:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlReadFil
$LN2@xmlReadFil:

; 15260:     return (xmlDoRead(ctxt, NULL, encoding, options, 0));

	push	0
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDoRead
	add	esp, 20					; 00000014H
$LN1@xmlReadFil:

; 15261: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlReadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlReadDoc
_TEXT	SEGMENT
_ctxt$ = -4						; size = 4
_cur$ = 8						; size = 4
_URL$ = 12						; size = 4
_encoding$ = 16						; size = 4
_options$ = 20						; size = 4
_xmlReadDoc PROC					; COMDAT

; 15228: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15229:     xmlParserCtxtPtr ctxt;
; 15230: 
; 15231:     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlReadDoc

; 15232:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlReadDoc
$LN2@xmlReadDoc:

; 15233:     xmlInitParser();

	call	_xmlInitParser

; 15234: 
; 15235:     ctxt = xmlCreateDocParserCtxt(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlCreateDocParserCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 15236:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlReadDoc

; 15237:         return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlReadDoc
$LN3@xmlReadDoc:

; 15238:     return (xmlDoRead(ctxt, URL, encoding, options, 0));

	push	0
	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _URL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDoRead
	add	esp, 20					; 00000014H
$LN1@xmlReadDoc:

; 15239: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlReadDoc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtUseOptions
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_options$ = 12						; size = 4
_xmlCtxtUseOptions PROC					; COMDAT

; 15165: {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 15166:    return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));

	push	0
	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtUseOptionsInternal
	add	esp, 12					; 0000000cH

; 15167: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtUseOptions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtResetPush
_TEXT	SEGMENT
_hdlr$1 = -24						; size = 4
_cur$2 = -20						; size = 4
_base$3 = -16						; size = 4
_enc$ = -12						; size = 4
_buf$ = -8						; size = 4
_inputStream$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_chunk$ = 12						; size = 4
_size$ = 16						; size = 4
_filename$ = 20						; size = 4
_encoding$ = 24						; size = 4
_xmlCtxtResetPush PROC					; COMDAT

; 14922: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14923:     xmlParserInputPtr inputStream;
; 14924:     xmlParserInputBufferPtr buf;
; 14925:     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;

	mov	DWORD PTR _enc$[ebp], 0

; 14926: 
; 14927:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlCtxtRes

; 14928:         return(1);

	mov	eax, 1
	jmp	$LN1@xmlCtxtRes
$LN2@xmlCtxtRes:

; 14929: 
; 14930:     if ((encoding == NULL) && (chunk != NULL) && (size >= 4))

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN3@xmlCtxtRes
	cmp	DWORD PTR _chunk$[ebp], 0
	je	SHORT $LN3@xmlCtxtRes
	cmp	DWORD PTR _size$[ebp], 4
	jl	SHORT $LN3@xmlCtxtRes

; 14931:         enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _chunk$[ebp]
	push	ecx
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$[ebp], eax
$LN3@xmlCtxtRes:

; 14932: 
; 14933:     buf = xmlAllocParserInputBuffer(enc);

	mov	edx, DWORD PTR _enc$[ebp]
	push	edx
	call	_xmlAllocParserInputBuffer
	add	esp, 4
	mov	DWORD PTR _buf$[ebp], eax

; 14934:     if (buf == NULL)

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN4@xmlCtxtRes

; 14935:         return(1);

	mov	eax, 1
	jmp	$LN1@xmlCtxtRes
$LN4@xmlCtxtRes:

; 14936: 
; 14937:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN5@xmlCtxtRes

; 14938:         xmlFreeParserInputBuffer(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 14939:         return(1);

	mov	eax, 1
	jmp	$LN1@xmlCtxtRes
$LN5@xmlCtxtRes:

; 14940:     }
; 14941: 
; 14942:     xmlCtxtReset(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtReset
	add	esp, 4

; 14943: 
; 14944:     if (ctxt->pushTab == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+344], 0
	jne	SHORT $LN6@xmlCtxtRes

; 14945:         ctxt->pushTab = (void **) xmlMalloc(ctxt->nameMax * 3 *

	mov	eax, DWORD PTR _ctxt$[ebp]
	imul	ecx, DWORD PTR [eax+192], 3
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+344], eax

; 14946: 	                                    sizeof(xmlChar *));
; 14947:         if (ctxt->pushTab == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+344], 0
	jne	SHORT $LN6@xmlCtxtRes

; 14948: 	    xmlErrMemory(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 14949:             xmlFreeParserInputBuffer(buf);

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 14950:             return(1);

	mov	eax, 1
	jmp	$LN1@xmlCtxtRes
$LN6@xmlCtxtRes:

; 14951:         }
; 14952:     }
; 14953: 
; 14954:     if (filename == NULL) {

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN8@xmlCtxtRes

; 14955:         ctxt->directory = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+180], 0

; 14956:     } else {

	jmp	SHORT $LN9@xmlCtxtRes
$LN8@xmlCtxtRes:

; 14957:         ctxt->directory = xmlParserGetDirectory(filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+180], eax
$LN9@xmlCtxtRes:

; 14958:     }
; 14959: 
; 14960:     inputStream = xmlNewInputStream(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNewInputStream
	add	esp, 4
	mov	DWORD PTR _inputStream$[ebp], eax

; 14961:     if (inputStream == NULL) {

	cmp	DWORD PTR _inputStream$[ebp], 0
	jne	SHORT $LN10@xmlCtxtRes

; 14962:         xmlFreeParserInputBuffer(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 14963:         return(1);

	mov	eax, 1
	jmp	$LN1@xmlCtxtRes
$LN10@xmlCtxtRes:

; 14964:     }
; 14965: 
; 14966:     if (filename == NULL)

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN11@xmlCtxtRes

; 14967:         inputStream->filename = NULL;

	mov	edx, DWORD PTR _inputStream$[ebp]
	mov	DWORD PTR [edx+4], 0
	jmp	SHORT $LN12@xmlCtxtRes
$LN11@xmlCtxtRes:

; 14968:     else
; 14969:         inputStream->filename = (char *)

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlCanonicPath
	add	esp, 4
	mov	ecx, DWORD PTR _inputStream$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN12@xmlCtxtRes:

; 14970:             xmlCanonicPath((const xmlChar *) filename);
; 14971:     inputStream->buf = buf;

	mov	edx, DWORD PTR _inputStream$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx], eax

; 14972:     xmlBufResetInput(buf->buffer, inputStream);

	mov	ecx, DWORD PTR _inputStream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufResetInput
	add	esp, 8

; 14973: 
; 14974:     inputPush(ctxt, inputStream);

	mov	ecx, DWORD PTR _inputStream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_inputPush
	add	esp, 8

; 14975: 
; 14976:     if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&

	cmp	DWORD PTR _size$[ebp], 0
	jle	$LN13@xmlCtxtRes
	cmp	DWORD PTR _chunk$[ebp], 0
	je	$LN13@xmlCtxtRes
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN13@xmlCtxtRes
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN13@xmlCtxtRes

; 14977:         (ctxt->input->buf != NULL)) {
; 14978: 	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufGetInputBase
	add	esp, 8
	mov	DWORD PTR _base$3[ebp], eax

; 14979:         size_t cur = ctxt->input->cur - ctxt->input->base;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$2[ebp], ecx

; 14980: 
; 14981:         xmlParserInputBufferPush(ctxt->input->buf, size, chunk);

	mov	edx, DWORD PTR _chunk$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlParserInputBufferPush
	add	esp, 12					; 0000000cH

; 14982: 
; 14983:         xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);

	mov	ecx, DWORD PTR _cur$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$3[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufSetInputBaseCur
	add	esp, 16					; 00000010H
$LN13@xmlCtxtRes:

; 14984: #ifdef DEBUG_PUSH
; 14985:         xmlGenericError(xmlGenericErrorContext, "PP: pushed %d\n", size);
; 14986: #endif
; 14987:     }
; 14988: 
; 14989:     if (encoding != NULL) {

	cmp	DWORD PTR _encoding$[ebp], 0
	je	SHORT $LN14@xmlCtxtRes

; 14990:         xmlCharEncodingHandlerPtr hdlr;
; 14991: 
; 14992:         if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN16@xmlCtxtRes

; 14993: 	    xmlFree((xmlChar *) ctxt->encoding);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlCtxtRes:

; 14994:         ctxt->encoding = xmlStrdup((const xmlChar *) encoding);

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 14995: 
; 14996:         hdlr = xmlFindCharEncodingHandler(encoding);

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _hdlr$1[ebp], eax

; 14997:         if (hdlr != NULL) {

	cmp	DWORD PTR _hdlr$1[ebp], 0
	je	SHORT $LN17@xmlCtxtRes

; 14998:             xmlSwitchToEncoding(ctxt, hdlr);

	mov	eax, DWORD PTR _hdlr$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSwitchToEncoding
	add	esp, 8

; 14999: 	} else {

	jmp	SHORT $LN18@xmlCtxtRes
$LN17@xmlCtxtRes:

; 15000: 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	push	OFFSET ??_C@_0BJ@FCHADMKI@Unsupported?5encoding?5?$CFs?6@
	push	32					; 00000020H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErrMsgStr
	add	esp, 16					; 00000010H
$LN18@xmlCtxtRes:

; 15001: 			      "Unsupported encoding %s\n", BAD_CAST encoding);
; 15002:         }

	jmp	SHORT $LN15@xmlCtxtRes
$LN14@xmlCtxtRes:

; 15003:     } else if (enc != XML_CHAR_ENCODING_NONE) {

	cmp	DWORD PTR _enc$[ebp], 0
	je	SHORT $LN15@xmlCtxtRes

; 15004:         xmlSwitchEncoding(ctxt, enc);

	mov	ecx, DWORD PTR _enc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSwitchEncoding
	add	esp, 8
$LN15@xmlCtxtRes:

; 15005:     }
; 15006: 
; 15007:     return(0);

	xor	eax, eax
$LN1@xmlCtxtRes:

; 15008: }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtResetPush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCtxtReset
_TEXT	SEGMENT
_dict$ = -8						; size = 4
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlCtxtReset PROC					; COMDAT

; 14816: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14817:     xmlParserInputPtr input;
; 14818:     xmlDictPtr dict;
; 14819: 
; 14820:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN4@xmlCtxtRes

; 14821:         return;

	jmp	$LN1@xmlCtxtRes
$LN4@xmlCtxtRes:

; 14822: 
; 14823:     dict = ctxt->dict;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	DWORD PTR _dict$[ebp], ecx
$LN2@xmlCtxtRes:

; 14824: 
; 14825:     while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_inputPop
	add	esp, 4
	mov	DWORD PTR _input$[ebp], eax
	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN3@xmlCtxtRes

; 14826:         xmlFreeInputStream(input);

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	call	_xmlFreeInputStream
	add	esp, 4

; 14827:     }

	jmp	SHORT $LN2@xmlCtxtRes
$LN3@xmlCtxtRes:

; 14828:     ctxt->inputNr = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 14829:     ctxt->input = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+36], 0

; 14830: 
; 14831:     ctxt->spaceNr = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+236], 0

; 14832:     if (ctxt->spaceTab != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+244], 0
	je	SHORT $LN5@xmlCtxtRes

; 14833: 	ctxt->spaceTab[0] = -1;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+244]
	mov	DWORD PTR [eax+edx], -1

; 14834: 	ctxt->space = &ctxt->spaceTab[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ctxt$[ebp]
	add	ecx, DWORD PTR [edx+244]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+232], ecx

; 14835:     } else {

	jmp	SHORT $LN6@xmlCtxtRes
$LN5@xmlCtxtRes:

; 14836:         ctxt->space = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+232], 0
$LN6@xmlCtxtRes:

; 14837:     }
; 14838: 
; 14839: 
; 14840:     ctxt->nodeNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+56], 0

; 14841:     ctxt->node = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+52], 0

; 14842: 
; 14843:     ctxt->nameNr = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+188], 0

; 14844:     ctxt->name = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+184], 0

; 14845: 
; 14846:     DICT_FREE(ctxt->version);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN7@xmlCtxtRes
	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN8@xmlCtxtRes
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _dict$[ebp]
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlCtxtRes
$LN8@xmlCtxtRes:
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlCtxtRes:

; 14847:     ctxt->version = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+20], 0

; 14848:     DICT_FREE(ctxt->encoding);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN9@xmlCtxtRes
	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN10@xmlCtxtRes
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _dict$[ebp]
	push	ecx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlCtxtRes
$LN10@xmlCtxtRes:
	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlCtxtRes:

; 14849:     ctxt->encoding = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 14850:     DICT_FREE(ctxt->directory);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+180], 0
	je	SHORT $LN11@xmlCtxtRes
	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN12@xmlCtxtRes
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	push	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlCtxtRes
$LN12@xmlCtxtRes:
	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlCtxtRes:

; 14851:     ctxt->directory = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+180], 0

; 14852:     DICT_FREE(ctxt->extSubURI);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+224], 0
	je	SHORT $LN13@xmlCtxtRes
	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN14@xmlCtxtRes
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	mov	eax, DWORD PTR _dict$[ebp]
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlCtxtRes
$LN14@xmlCtxtRes:
	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlCtxtRes:

; 14853:     ctxt->extSubURI = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+224], 0

; 14854:     DICT_FREE(ctxt->extSubSystem);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+228], 0
	je	SHORT $LN15@xmlCtxtRes
	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN16@xmlCtxtRes
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+228]
	push	eax
	mov	ecx, DWORD PTR _dict$[ebp]
	push	ecx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@xmlCtxtRes
$LN16@xmlCtxtRes:
	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+228]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlCtxtRes:

; 14855:     ctxt->extSubSystem = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+228], 0

; 14856:     if (ctxt->myDoc != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN17@xmlCtxtRes

; 14857:         xmlFreeDoc(ctxt->myDoc);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4
$LN17@xmlCtxtRes:

; 14858:     ctxt->myDoc = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 0

; 14859: 
; 14860:     ctxt->standalone = -1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+28], -1

; 14861:     ctxt->hasExternalSubset = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 14862:     ctxt->hasPErefs = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+92], 0

; 14863:     ctxt->html = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+32], 0

; 14864:     ctxt->external = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 14865:     ctxt->instate = XML_PARSER_START;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 0

; 14866:     ctxt->token = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+176], 0

; 14867: 
; 14868:     ctxt->wellFormed = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 14869:     ctxt->nsWellFormed = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+356], 1

; 14870:     ctxt->disableSAX = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+212], 0

; 14871:     ctxt->valid = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+100], 1

; 14872: #if 0
; 14873:     ctxt->vctxt.userData = ctxt;
; 14874:     ctxt->vctxt.error = xmlParserValidityError;
; 14875:     ctxt->vctxt.warning = xmlParserValidityWarning;
; 14876: #endif
; 14877:     ctxt->record_info = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+68], 0

; 14878:     ctxt->nbChars = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+200], 0

; 14879:     ctxt->checkIndex = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+204], 0

; 14880:     ctxt->inSubset = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+216], 0

; 14881:     ctxt->errNo = XML_ERR_OK;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+84], 0

; 14882:     ctxt->depth = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+248], 0

; 14883:     ctxt->charset = XML_CHAR_ENCODING_UTF8;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+256], 1

; 14884:     ctxt->catalogs = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+284], 0

; 14885:     ctxt->nbentities = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+440], 0

; 14886:     ctxt->sizeentities = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+444], 0

; 14887:     ctxt->sizeentcopy = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+468], 0

; 14888:     xmlInitNodeInfoSeq(&ctxt->node_seq);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	call	_xmlInitNodeInfoSeq
	add	esp, 4

; 14889: 
; 14890:     if (ctxt->attsDefault != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+348], 0
	je	SHORT $LN18@xmlCtxtRes

; 14891:         xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);

	push	OFFSET _xmlHashDefaultDeallocator
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+348]
	push	ecx
	call	_xmlHashFree
	add	esp, 8

; 14892:         ctxt->attsDefault = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+348], 0
$LN18@xmlCtxtRes:

; 14893:     }
; 14894:     if (ctxt->attsSpecial != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+352], 0
	je	SHORT $LN19@xmlCtxtRes

; 14895:         xmlHashFree(ctxt->attsSpecial, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+352]
	push	edx
	call	_xmlHashFree
	add	esp, 8

; 14896:         ctxt->attsSpecial = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+352], 0
$LN19@xmlCtxtRes:

; 14897:     }
; 14898: 
; 14899: #ifdef LIBXML_CATALOG_ENABLED
; 14900:     if (ctxt->catalogs != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+284], 0
	je	SHORT $LN20@xmlCtxtRes

; 14901: 	xmlCatalogFreeLocal(ctxt->catalogs);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+284]
	push	eax
	call	_xmlCatalogFreeLocal
	add	esp, 4
$LN20@xmlCtxtRes:

; 14902: #endif
; 14903:     if (ctxt->lastError.code != XML_ERR_OK)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+388], 0
	je	SHORT $LN1@xmlCtxtRes

; 14904:         xmlResetError(&ctxt->lastError);

	mov	edx, DWORD PTR _ctxt$[ebp]
	add	edx, 384				; 00000180H
	push	edx
	call	_xmlResetError
	add	esp, 4
$LN1@xmlCtxtRes:

; 14905: }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtReset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateIOParserCtxt
_TEXT	SEGMENT
_buf$ = -12						; size = 4
_inputStream$ = -8					; size = 4
_ctxt$ = -4						; size = 4
_sax$ = 8						; size = 4
_user_data$ = 12					; size = 4
_ioread$ = 16						; size = 4
_ioclose$ = 20						; size = 4
_ioctx$ = 24						; size = 4
_enc$ = 28						; size = 4
_xmlCreateIOParserCtxt PROC				; COMDAT

; 12509: 	void *ioctx, xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 12510:     xmlParserCtxtPtr ctxt;
; 12511:     xmlParserInputPtr inputStream;
; 12512:     xmlParserInputBufferPtr buf;
; 12513: 
; 12514:     if (ioread == NULL) return(NULL);

	cmp	DWORD PTR _ioread$[ebp], 0
	jne	SHORT $LN2@xmlCreateI
	xor	eax, eax
	jmp	$LN1@xmlCreateI
$LN2@xmlCreateI:

; 12515: 
; 12516:     buf = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, enc);

	mov	eax, DWORD PTR _enc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ioctx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ioclose$[ebp]
	push	edx
	mov	eax, DWORD PTR _ioread$[ebp]
	push	eax
	call	_xmlParserInputBufferCreateIO
	add	esp, 16					; 00000010H
	mov	DWORD PTR _buf$[ebp], eax

; 12517:     if (buf == NULL) {

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN3@xmlCreateI

; 12518:         if (ioclose != NULL)

	cmp	DWORD PTR _ioclose$[ebp], 0
	je	SHORT $LN4@xmlCreateI

; 12519:             ioclose(ioctx);

	mov	esi, esp
	mov	ecx, DWORD PTR _ioctx$[ebp]
	push	ecx
	call	DWORD PTR _ioclose$[ebp]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlCreateI:

; 12520:         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateI
$LN3@xmlCreateI:

; 12521:     }
; 12522: 
; 12523:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 12524:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN5@xmlCreateI

; 12525: 	xmlFreeParserInputBuffer(buf);

	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 12526: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateI
$LN5@xmlCreateI:

; 12527:     }
; 12528:     if (sax != NULL) {

	cmp	DWORD PTR _sax$[ebp], 0
	je	$LN6@xmlCreateI

; 12529: #ifdef LIBXML_SAX1_ENABLED
; 12530: 	if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)

	call	___xmlDefaultSAXHandler
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN7@xmlCreateI

; 12531: #endif /* LIBXML_SAX1_ENABLED */
; 12532: 	    xmlFree(ctxt->sax);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlCreateI:

; 12533: 	ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));

	mov	esi, esp
	push	128					; 00000080H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax

; 12534: 	if (ctxt->sax == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN8@xmlCreateI

; 12535: 	    xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 12536: 	    xmlFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12537: 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateI
$LN8@xmlCreateI:

; 12538: 	}
; 12539: 	memset(ctxt->sax, 0, sizeof(xmlSAXHandler));

	push	128					; 00000080H
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 12540: 	if (sax->initialized == XML_SAX2_MAGIC)

	mov	ecx, DWORD PTR _sax$[ebp]
	cmp	DWORD PTR [ecx+108], -554844497		; deedbeafH
	jne	SHORT $LN9@xmlCreateI

; 12541: 	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, 32					; 00000020H
	mov	esi, DWORD PTR _sax$[ebp]
	mov	edi, DWORD PTR [edx]
	rep movsd
	jmp	SHORT $LN10@xmlCreateI
$LN9@xmlCreateI:

; 12542: 	else
; 12543: 	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, 28					; 0000001cH
	mov	esi, DWORD PTR _sax$[ebp]
	mov	edi, DWORD PTR [eax]
	rep movsd
$LN10@xmlCreateI:

; 12544: 	if (user_data != NULL)

	cmp	DWORD PTR _user_data$[ebp], 0
	je	SHORT $LN6@xmlCreateI

; 12545: 	    ctxt->userData = user_data;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN6@xmlCreateI:

; 12546:     }
; 12547: 
; 12548:     inputStream = xmlNewIOInputStream(ctxt, buf, enc);

	mov	eax, DWORD PTR _enc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _inputStream$[ebp], eax

; 12549:     if (inputStream == NULL) {

	cmp	DWORD PTR _inputStream$[ebp], 0
	jne	SHORT $LN12@xmlCreateI

; 12550: 	xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12551: 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCreateI
$LN12@xmlCreateI:

; 12552:     }
; 12553:     inputPush(ctxt, inputStream);

	mov	ecx, DWORD PTR _inputStream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_inputPush
	add	esp, 8

; 12554: 
; 12555:     return(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
$LN1@xmlCreateI:

; 12556: }

	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCreateIOParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseChunk
_TEXT	SEGMENT
_cur_avail$1 = -60					; size = 4
_current$2 = -56					; size = 4
_base$3 = -52						; size = 4
_current$4 = -48					; size = 4
_base$5 = -44						; size = 4
_nbchars$6 = -40					; size = 4
_in$7 = -36						; size = 4
_len$8 = -32						; size = 4
_res$9 = -28						; size = 4
_cur$10 = -24						; size = 4
_base$11 = -20						; size = 4
_avail$ = -16						; size = 4
_old_avail$ = -12					; size = 4
_remain$ = -8						; size = 4
_end_in_lf$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_chunk$ = 12						; size = 4
_size$ = 16						; size = 4
_terminate$ = 20					; size = 4
_xmlParseChunk PROC					; COMDAT

; 12134:               int terminate) {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 12135:     int end_in_lf = 0;

	mov	DWORD PTR _end_in_lf$[ebp], 0

; 12136:     int remain = 0;

	mov	DWORD PTR _remain$[ebp], 0

; 12137:     size_t old_avail = 0;

	mov	DWORD PTR _old_avail$[ebp], 0

; 12138:     size_t avail = 0;

	mov	DWORD PTR _avail$[ebp], 0

; 12139: 
; 12140:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlParseCh

; 12141:         return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseCh
$LN2@xmlParseCh:

; 12142:     if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN3@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 1
	jne	SHORT $LN3@xmlParseCh

; 12143:         return(ctxt->errNo);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+84]
	jmp	$LN1@xmlParseCh
$LN3@xmlParseCh:

; 12144:     if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN4@xmlParseCh

; 12145:         return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseCh
$LN4@xmlParseCh:

; 12146:     if (ctxt->instate == XML_PARSER_START)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], 0
	jne	SHORT $LN5@xmlParseCh

; 12147:         xmlDetectSAX2(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDetectSAX2
	add	esp, 4
$LN5@xmlParseCh:

; 12148:     if ((size > 0) && (chunk != NULL) && (!terminate) &&

	cmp	DWORD PTR _size$[ebp], 0
	jle	SHORT $xmldecl_done$45
	cmp	DWORD PTR _chunk$[ebp], 0
	je	SHORT $xmldecl_done$45
	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $xmldecl_done$45
	mov	eax, DWORD PTR _chunk$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $xmldecl_done$45

; 12149:         (chunk[size - 1] == '\r')) {
; 12150: 	end_in_lf = 1;

	mov	DWORD PTR _end_in_lf$[ebp], 1

; 12151: 	size--;

	mov	edx, DWORD PTR _size$[ebp]
	sub	edx, 1
	mov	DWORD PTR _size$[ebp], edx
$xmldecl_done$45:

; 12152:     }
; 12153: 
; 12154: xmldecl_done:
; 12155: 
; 12156:     if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&
; 12157:         (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {

	cmp	DWORD PTR _size$[ebp], 0
	jle	$LN7@xmlParseCh
	cmp	DWORD PTR _chunk$[ebp], 0
	je	$LN7@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	$LN7@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	je	$LN7@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	je	$LN7@xmlParseCh

; 12158: 	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufGetInputBase
	add	esp, 8
	mov	DWORD PTR _base$11[ebp], eax

; 12159: 	size_t cur = ctxt->input->cur - ctxt->input->base;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$10[ebp], edx

; 12160: 	int res;
; 12161: 
; 12162:         old_avail = xmlBufUse(ctxt->input->buf->buffer);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufUse
	add	esp, 4
	mov	DWORD PTR _old_avail$[ebp], eax

; 12163:         /*
; 12164:          * Specific handling if we autodetected an encoding, we should not
; 12165:          * push more than the first line ... which depend on the encoding
; 12166:          * And only push the rest once the final encoding was detected
; 12167:          */
; 12168:         if ((ctxt->instate == XML_PARSER_START) && (ctxt->input != NULL) &&
; 12169:             (ctxt->input->buf != NULL) && (ctxt->input->buf->encoder != NULL)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], 0
	jne	$LN9@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	$LN9@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx], 0
	je	$LN9@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+12], 0
	je	$LN9@xmlParseCh

; 12170:             unsigned int len = 45;

	mov	DWORD PTR _len$8[ebp], 45		; 0000002dH

; 12171: 
; 12172:             if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
; 12173:                                BAD_CAST "UTF-16")) ||

	push	OFFSET ??_C@_06KNDPGIKI@UTF?916@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlStrcasestr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlParseCh
	push	OFFSET ??_C@_05MNCHLHCA@UTF16@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlStrcasestr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlParseCh
$LN12@xmlParseCh:

; 12174:                 (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
; 12175:                                BAD_CAST "UTF16")))
; 12176:                 len = 90;

	mov	DWORD PTR _len$8[ebp], 90		; 0000005aH
	jmp	SHORT $LN11@xmlParseCh
$LN10@xmlParseCh:

; 12177:             else if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
; 12178:                                     BAD_CAST "UCS-4")) ||

	push	OFFSET ??_C@_05FPCKGDIJ@UCS?94@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlStrcasestr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@xmlParseCh
	push	OFFSET ??_C@_04JFFPNMJE@UCS4@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlStrcasestr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlParseCh
$LN14@xmlParseCh:

; 12179:                      (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
; 12180:                                     BAD_CAST "UCS4")))
; 12181:                 len = 180;

	mov	DWORD PTR _len$8[ebp], 180		; 000000b4H
$LN11@xmlParseCh:

; 12182: 
; 12183:             if (ctxt->input->buf->rawconsumed < len)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _len$8[ebp]
	jae	SHORT $LN15@xmlParseCh

; 12184:                 len -= ctxt->input->buf->rawconsumed;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _len$8[ebp]
	sub	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _len$8[ebp], edx
$LN15@xmlParseCh:

; 12185: 
; 12186:             /*
; 12187:              * Change size for reading the initial declaration only
; 12188:              * if size is greater than len. Otherwise, memmove in xmlBufferAdd
; 12189:              * will blindly copy extra bytes from memory.
; 12190:              */
; 12191:             if ((unsigned int) size > len) {

	mov	eax, DWORD PTR _size$[ebp]
	cmp	eax, DWORD PTR _len$8[ebp]
	jbe	SHORT $LN16@xmlParseCh

; 12192:                 remain = size - len;

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, DWORD PTR _len$8[ebp]
	mov	DWORD PTR _remain$[ebp], ecx

; 12193:                 size = len;

	mov	edx, DWORD PTR _len$8[ebp]
	mov	DWORD PTR _size$[ebp], edx

; 12194:             } else {

	jmp	SHORT $LN9@xmlParseCh
$LN16@xmlParseCh:

; 12195:                 remain = 0;

	mov	DWORD PTR _remain$[ebp], 0
$LN9@xmlParseCh:

; 12196:             }
; 12197:         }
; 12198: 	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);

	mov	eax, DWORD PTR _chunk$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlParserInputBufferPush
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$9[ebp], eax

; 12199: 	if (res < 0) {

	cmp	DWORD PTR _res$9[ebp], 0
	jge	SHORT $LN18@xmlParseCh

; 12200: 	    ctxt->errNo = XML_PARSER_EOF;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+84], -1

; 12201: 	    xmlHaltParser(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlHaltParser
	add	esp, 4

; 12202: 	    return (XML_PARSER_EOF);

	or	eax, -1
	jmp	$LN1@xmlParseCh
$LN18@xmlParseCh:

; 12203: 	}
; 12204:         xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);

	mov	ecx, DWORD PTR _cur$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$11[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufSetInputBaseCur
	add	esp, 16					; 00000010H
	jmp	$LN8@xmlParseCh
$LN7@xmlParseCh:

; 12205: #ifdef DEBUG_PUSH
; 12206: 	xmlGenericError(xmlGenericErrorContext, "PP: pushed %d\n", size);
; 12207: #endif
; 12208: 
; 12209:     } else if (ctxt->instate != XML_PARSER_EOF) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	je	$LN8@xmlParseCh

; 12210: 	if ((ctxt->input != NULL) && ctxt->input->buf != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	$LN8@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax], 0
	je	$LN8@xmlParseCh

; 12211: 	    xmlParserInputBufferPtr in = ctxt->input->buf;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _in$7[ebp], eax

; 12212: 	    if ((in->encoder != NULL) && (in->buffer != NULL) &&

	mov	ecx, DWORD PTR _in$7[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	$LN8@xmlParseCh
	mov	edx, DWORD PTR _in$7[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	$LN8@xmlParseCh
	mov	eax, DWORD PTR _in$7[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	$LN8@xmlParseCh

; 12213: 		    (in->raw != NULL)) {
; 12214: 		int nbchars;
; 12215: 		size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _in$7[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufGetInputBase
	add	esp, 8
	mov	DWORD PTR _base$5[ebp], eax

; 12216: 		size_t current = ctxt->input->cur - ctxt->input->base;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _current$4[ebp], eax

; 12217: 
; 12218: 		nbchars = xmlCharEncInput(in, terminate);

	mov	ecx, DWORD PTR _terminate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$7[ebp]
	push	edx
	call	_xmlCharEncInput
	add	esp, 8
	mov	DWORD PTR _nbchars$6[ebp], eax

; 12219: 		if (nbchars < 0) {

	cmp	DWORD PTR _nbchars$6[ebp], 0
	jge	SHORT $LN22@xmlParseCh

; 12220: 		    /* TODO 2.6.0 */
; 12221: 		    xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0BO@IBAMLEHI@xmlParseChunk?3?5encoder?5error?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12222: 				    "xmlParseChunk: encoder error\n");
; 12223:                     xmlHaltParser(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlHaltParser
	add	esp, 4

; 12224: 		    return(XML_ERR_INVALID_ENCODING);

	mov	eax, 81					; 00000051H
	jmp	$LN1@xmlParseCh
$LN22@xmlParseCh:

; 12225: 		}
; 12226: 		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);

	mov	eax, DWORD PTR _current$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _base$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _in$7[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_xmlBufSetInputBaseCur
	add	esp, 16					; 00000010H
$LN8@xmlParseCh:

; 12227: 	    }
; 12228: 	}
; 12229:     }
; 12230:     if (remain != 0) {

	cmp	DWORD PTR _remain$[ebp], 0
	je	SHORT $LN23@xmlParseCh

; 12231:         xmlParseTryOrFinish(ctxt, 0);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseTryOrFinish
	add	esp, 8

; 12232:     } else {

	jmp	SHORT $LN24@xmlParseCh
$LN23@xmlParseCh:

; 12233:         if ((ctxt->input != NULL) && (ctxt->input->buf != NULL))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN25@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN25@xmlParseCh

; 12234:             avail = xmlBufUse(ctxt->input->buf->buffer);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufUse
	add	esp, 4
	mov	DWORD PTR _avail$[ebp], eax
$LN25@xmlParseCh:

; 12235:         /*
; 12236:          * Depending on the current state it may not be such
; 12237:          * a good idea to try parsing if there is nothing in the chunk
; 12238:          * which would be worth doing a parser state transition and we
; 12239:          * need to wait for more data
; 12240:          */
; 12241:         if ((terminate) || (avail > XML_MAX_TEXT_LENGTH) ||
; 12242:             (old_avail == 0) || (avail == 0) ||

	cmp	DWORD PTR _terminate$[ebp], 0
	jne	SHORT $LN27@xmlParseCh
	cmp	DWORD PTR _avail$[ebp], 10000000	; 00989680H
	ja	SHORT $LN27@xmlParseCh
	cmp	DWORD PTR _old_avail$[ebp], 0
	je	SHORT $LN27@xmlParseCh
	cmp	DWORD PTR _avail$[ebp], 0
	je	SHORT $LN27@xmlParseCh
	mov	edx, DWORD PTR _avail$[ebp]
	sub	edx, DWORD PTR _old_avail$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _old_avail$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseCheckTransition
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN24@xmlParseCh
$LN27@xmlParseCh:

; 12243:             (xmlParseCheckTransition(ctxt,
; 12244:                        (const char *)&ctxt->input->base[old_avail],
; 12245:                                      avail - old_avail)))
; 12246:             xmlParseTryOrFinish(ctxt, terminate);

	mov	ecx, DWORD PTR _terminate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseTryOrFinish
	add	esp, 8
$LN24@xmlParseCh:

; 12247:     }
; 12248:     if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN28@xmlParseCh

; 12249:         return(ctxt->errNo);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+84]
	jmp	$LN1@xmlParseCh
$LN28@xmlParseCh:

; 12250: 
; 12251:     if ((ctxt->input != NULL) &&
; 12252:          (((ctxt->input->end - ctxt->input->cur) > XML_MAX_LOOKUP_LIMIT) ||
; 12253:          ((ctxt->input->cur - ctxt->input->base) > XML_MAX_LOOKUP_LIMIT)) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN29@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 10000000				; 00989680H
	jg	SHORT $LN30@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	cmp	eax, 10000000				; 00989680H
	jle	SHORT $LN29@xmlParseCh
$LN30@xmlParseCh:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN29@xmlParseCh

; 12254:         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
; 12255:         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Huge input lookup");

	push	OFFSET ??_C@_0BC@BAMNGBKO@Huge?5input?5lookup@
	push	1
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 12256:         xmlHaltParser(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlHaltParser
	add	esp, 4
$LN29@xmlParseCh:

; 12257:     }
; 12258:     if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+84], 0
	je	SHORT $LN31@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 1
	jne	SHORT $LN31@xmlParseCh

; 12259:         return(ctxt->errNo);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+84]
	jmp	$LN1@xmlParseCh
$LN31@xmlParseCh:

; 12260: 
; 12261:     if (remain != 0) {

	cmp	DWORD PTR _remain$[ebp], 0
	je	SHORT $LN32@xmlParseCh

; 12262:         chunk += size;

	mov	edx, DWORD PTR _chunk$[ebp]
	add	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _chunk$[ebp], edx

; 12263:         size = remain;

	mov	eax, DWORD PTR _remain$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 12264:         remain = 0;

	mov	DWORD PTR _remain$[ebp], 0

; 12265:         goto xmldecl_done;

	jmp	$xmldecl_done$45
$LN32@xmlParseCh:

; 12266:     }
; 12267:     if ((end_in_lf == 1) && (ctxt->input != NULL) &&

	cmp	DWORD PTR _end_in_lf$[ebp], 1
	jne	$LN33@xmlParseCh
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN33@xmlParseCh
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN33@xmlParseCh

; 12268:         (ctxt->input->buf != NULL)) {
; 12269: 	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_xmlBufGetInputBase
	add	esp, 8
	mov	DWORD PTR _base$3[ebp], eax

; 12270: 					 ctxt->input);
; 12271: 	size_t current = ctxt->input->cur - ctxt->input->base;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _current$2[ebp], edx

; 12272: 
; 12273: 	xmlParserInputBufferPush(ctxt->input->buf, 1, "\r");

	push	OFFSET ??_C@_01LIIJDEN@?$AN@
	push	1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlParserInputBufferPush
	add	esp, 12					; 0000000cH

; 12274: 
; 12275: 	xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,

	mov	eax, DWORD PTR _current$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _base$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufSetInputBaseCur
	add	esp, 16					; 00000010H
$LN33@xmlParseCh:

; 12276: 			      base, current);
; 12277:     }
; 12278:     if (terminate) {

	cmp	DWORD PTR _terminate$[ebp], 0
	je	$LN34@xmlParseCh

; 12279: 	/*
; 12280: 	 * Check for termination
; 12281: 	 */
; 12282: 	int cur_avail = 0;

	mov	DWORD PTR _cur_avail$1[ebp], 0

; 12283: 
; 12284: 	if (ctxt->input != NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN35@xmlParseCh

; 12285: 	    if (ctxt->input->buf == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN36@xmlParseCh

; 12286: 		cur_avail = ctxt->input->length -

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [edx+16]
	sub	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax+24]
	sub	eax, edx
	mov	DWORD PTR _cur_avail$1[ebp], eax
	jmp	SHORT $LN35@xmlParseCh
$LN36@xmlParseCh:

; 12287: 			    (ctxt->input->cur - ctxt->input->base);
; 12288: 	    else
; 12289: 		cur_avail = xmlBufUse(ctxt->input->buf->buffer) -

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufUse
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR [edx+12]
	sub	eax, ecx
	mov	DWORD PTR _cur_avail$1[ebp], eax
$LN35@xmlParseCh:

; 12290: 			              (ctxt->input->cur - ctxt->input->base);
; 12291: 	}
; 12292: 
; 12293: 	if ((ctxt->instate != XML_PARSER_EOF) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	je	SHORT $LN38@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], 14			; 0000000eH
	je	SHORT $LN38@xmlParseCh

; 12294: 	    (ctxt->instate != XML_PARSER_EPILOG)) {
; 12295: 	    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);

	push	0
	push	5
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN38@xmlParseCh:

; 12296: 	}
; 12297: 	if ((ctxt->instate == XML_PARSER_EPILOG) && (cur_avail > 0)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], 14			; 0000000eH
	jne	SHORT $LN39@xmlParseCh
	cmp	DWORD PTR _cur_avail$1[ebp], 0
	jle	SHORT $LN39@xmlParseCh

; 12298: 	    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);

	push	0
	push	5
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN39@xmlParseCh:

; 12299: 	}
; 12300: 	if (ctxt->instate != XML_PARSER_EOF) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	je	SHORT $LN40@xmlParseCh

; 12301: 	    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN40@xmlParseCh
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN40@xmlParseCh

; 12302: 		ctxt->sax->endDocument(ctxt->userData);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN40@xmlParseCh:

; 12303: 	}
; 12304: 	ctxt->instate = XML_PARSER_EOF;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], -1
$LN34@xmlParseCh:

; 12305:     }
; 12306:     if (ctxt->wellFormed == 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN42@xmlParseCh

; 12307: 	return((xmlParserErrors) ctxt->errNo);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [eax+84]
	jmp	SHORT $LN1@xmlParseCh
	jmp	SHORT $LN1@xmlParseCh
$LN42@xmlParseCh:

; 12308:     else
; 12309:         return(0);

	xor	eax, eax
$LN1@xmlParseCh:

; 12310: }

	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseChunk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreatePushParserCtxt
_TEXT	SEGMENT
_cur$1 = -24						; size = 4
_base$2 = -20						; size = 4
_enc$ = -16						; size = 4
_buf$ = -12						; size = 4
_inputStream$ = -8					; size = 4
_ctxt$ = -4						; size = 4
_sax$ = 8						; size = 4
_user_data$ = 12					; size = 4
_chunk$ = 16						; size = 4
_size$ = 20						; size = 4
_filename$ = 24						; size = 4
_xmlCreatePushParserCtxt PROC				; COMDAT

; 12339:                         const char *chunk, int size, const char *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 12340:     xmlParserCtxtPtr ctxt;
; 12341:     xmlParserInputPtr inputStream;
; 12342:     xmlParserInputBufferPtr buf;
; 12343:     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;

	mov	DWORD PTR _enc$[ebp], 0

; 12344: 
; 12345:     /*
; 12346:      * plug some encoding conversion routines
; 12347:      */
; 12348:     if ((chunk != NULL) && (size >= 4))

	cmp	DWORD PTR _chunk$[ebp], 0
	je	SHORT $LN2@xmlCreateP
	cmp	DWORD PTR _size$[ebp], 4
	jl	SHORT $LN2@xmlCreateP

; 12349: 	enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _chunk$[ebp]
	push	ecx
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$[ebp], eax
$LN2@xmlCreateP:

; 12350: 
; 12351:     buf = xmlAllocParserInputBuffer(enc);

	mov	edx, DWORD PTR _enc$[ebp]
	push	edx
	call	_xmlAllocParserInputBuffer
	add	esp, 4
	mov	DWORD PTR _buf$[ebp], eax

; 12352:     if (buf == NULL) return(NULL);

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN3@xmlCreateP
	xor	eax, eax
	jmp	$LN1@xmlCreateP
$LN3@xmlCreateP:

; 12353: 
; 12354:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 12355:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN4@xmlCreateP

; 12356:         xmlErrMemory(NULL, "creating parser: out of memory\n");

	push	OFFSET ??_C@_0CA@CCOLJACP@creating?5parser?3?5out?5of?5memory?6@
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 12357: 	xmlFreeParserInputBuffer(buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 12358: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateP
$LN4@xmlCreateP:

; 12359:     }
; 12360:     ctxt->dictNames = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+364], 1

; 12361:     ctxt->pushTab = (void **) xmlMalloc(ctxt->nameMax * 3 * sizeof(xmlChar *));

	mov	edx, DWORD PTR _ctxt$[ebp]
	imul	eax, DWORD PTR [edx+192], 3
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+344], eax

; 12362:     if (ctxt->pushTab == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+344], 0
	jne	SHORT $LN5@xmlCreateP

; 12363:         xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 12364: 	xmlFreeParserInputBuffer(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 12365: 	xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12366: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateP
$LN5@xmlCreateP:

; 12367:     }
; 12368:     if (sax != NULL) {

	cmp	DWORD PTR _sax$[ebp], 0
	je	$LN6@xmlCreateP

; 12369: #ifdef LIBXML_SAX1_ENABLED
; 12370: 	if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)

	call	___xmlDefaultSAXHandler
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN7@xmlCreateP

; 12371: #endif /* LIBXML_SAX1_ENABLED */
; 12372: 	    xmlFree(ctxt->sax);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlCreateP:

; 12373: 	ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));

	mov	esi, esp
	push	128					; 00000080H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax

; 12374: 	if (ctxt->sax == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN8@xmlCreateP

; 12375: 	    xmlErrMemory(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 12376: 	    xmlFreeParserInputBuffer(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 12377: 	    xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12378: 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateP
$LN8@xmlCreateP:

; 12379: 	}
; 12380: 	memset(ctxt->sax, 0, sizeof(xmlSAXHandler));

	push	128					; 00000080H
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 12381: 	if (sax->initialized == XML_SAX2_MAGIC)

	mov	edx, DWORD PTR _sax$[ebp]
	cmp	DWORD PTR [edx+108], -554844497		; deedbeafH
	jne	SHORT $LN9@xmlCreateP

; 12382: 	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, 32					; 00000020H
	mov	esi, DWORD PTR _sax$[ebp]
	mov	edi, DWORD PTR [eax]
	rep movsd
	jmp	SHORT $LN10@xmlCreateP
$LN9@xmlCreateP:

; 12383: 	else
; 12384: 	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, 28					; 0000001cH
	mov	esi, DWORD PTR _sax$[ebp]
	mov	edi, DWORD PTR [edx]
	rep movsd
$LN10@xmlCreateP:

; 12385: 	if (user_data != NULL)

	cmp	DWORD PTR _user_data$[ebp], 0
	je	SHORT $LN6@xmlCreateP

; 12386: 	    ctxt->userData = user_data;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN6@xmlCreateP:

; 12387:     }
; 12388:     if (filename == NULL) {

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN12@xmlCreateP

; 12389: 	ctxt->directory = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+180], 0

; 12390:     } else {

	jmp	SHORT $LN13@xmlCreateP
$LN12@xmlCreateP:

; 12391:         ctxt->directory = xmlParserGetDirectory(filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+180], eax
$LN13@xmlCreateP:

; 12392:     }
; 12393: 
; 12394:     inputStream = xmlNewInputStream(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlNewInputStream
	add	esp, 4
	mov	DWORD PTR _inputStream$[ebp], eax

; 12395:     if (inputStream == NULL) {

	cmp	DWORD PTR _inputStream$[ebp], 0
	jne	SHORT $LN14@xmlCreateP

; 12396: 	xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12397: 	xmlFreeParserInputBuffer(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 12398: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateP
$LN14@xmlCreateP:

; 12399:     }
; 12400: 
; 12401:     if (filename == NULL)

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN15@xmlCreateP

; 12402: 	inputStream->filename = NULL;

	mov	edx, DWORD PTR _inputStream$[ebp]
	mov	DWORD PTR [edx+4], 0
	jmp	SHORT $LN16@xmlCreateP
$LN15@xmlCreateP:

; 12403:     else {
; 12404: 	inputStream->filename = (char *)

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlCanonicPath
	add	esp, 4
	mov	ecx, DWORD PTR _inputStream$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 12405: 	    xmlCanonicPath((const xmlChar *) filename);
; 12406: 	if (inputStream->filename == NULL) {

	mov	edx, DWORD PTR _inputStream$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN16@xmlCreateP

; 12407: 	    xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12408: 	    xmlFreeParserInputBuffer(buf);

	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 12409: 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateP
$LN16@xmlCreateP:

; 12410: 	}
; 12411:     }
; 12412:     inputStream->buf = buf;

	mov	edx, DWORD PTR _inputStream$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx], eax

; 12413:     xmlBufResetInput(inputStream->buf->buffer, inputStream);

	mov	ecx, DWORD PTR _inputStream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inputStream$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufResetInput
	add	esp, 8

; 12414:     inputPush(ctxt, inputStream);

	mov	edx, DWORD PTR _inputStream$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_inputPush
	add	esp, 8

; 12415: 
; 12416:     /*
; 12417:      * If the caller didn't provide an initial 'chunk' for determining
; 12418:      * the encoding, we set the context to XML_CHAR_ENCODING_NONE so
; 12419:      * that it can be automatically determined later
; 12420:      */
; 12421:     if ((size == 0) || (chunk == NULL)) {

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN20@xmlCreateP
	cmp	DWORD PTR _chunk$[ebp], 0
	jne	SHORT $LN18@xmlCreateP
$LN20@xmlCreateP:

; 12422: 	ctxt->charset = XML_CHAR_ENCODING_NONE;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+256], 0
	jmp	$LN19@xmlCreateP
$LN18@xmlCreateP:

; 12423:     } else if ((ctxt->input != NULL) && (ctxt->input->buf != NULL)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN19@xmlCreateP
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN19@xmlCreateP

; 12424: 	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufGetInputBase
	add	esp, 8
	mov	DWORD PTR _base$2[ebp], eax

; 12425: 	size_t cur = ctxt->input->cur - ctxt->input->base;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$1[ebp], eax

; 12426: 
; 12427: 	xmlParserInputBufferPush(ctxt->input->buf, size, chunk);

	mov	ecx, DWORD PTR _chunk$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlParserInputBufferPush
	add	esp, 12					; 0000000cH

; 12428: 
; 12429:         xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);

	mov	eax, DWORD PTR _cur$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _base$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlBufSetInputBaseCur
	add	esp, 16					; 00000010H
$LN19@xmlCreateP:

; 12430: #ifdef DEBUG_PUSH
; 12431: 	xmlGenericError(xmlGenericErrorContext, "PP: pushed %d\n", size);
; 12432: #endif
; 12433:     }
; 12434: 
; 12435:     if (enc != XML_CHAR_ENCODING_NONE) {

	cmp	DWORD PTR _enc$[ebp], 0
	je	SHORT $LN22@xmlCreateP

; 12436:         xmlSwitchEncoding(ctxt, enc);

	mov	edx, DWORD PTR _enc$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSwitchEncoding
	add	esp, 8
$LN22@xmlCreateP:

; 12437:     }
; 12438: 
; 12439:     return(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
$LN1@xmlCreateP:

; 12440: }

	pop	edi
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCreatePushParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCreateDocParserCtxt
_TEXT	SEGMENT
_len$ = -4						; size = 4
_cur$ = 8						; size = 4
_xmlCreateDocParserCtxt PROC				; COMDAT

; 14574: xmlCreateDocParserCtxt(const xmlChar *cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14575:     int len;
; 14576: 
; 14577:     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlCreateD

; 14578: 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCreateD
$LN2@xmlCreateD:

; 14579:     len = xmlStrlen(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 14580:     return(xmlCreateMemoryParserCtxt((const char *)cur, len));

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlCreateMemoryParserCtxt
	add	esp, 8
$LN1@xmlCreateD:

; 14581: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCreateDocParserCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSetupParserForBuffer
_TEXT	SEGMENT
_input$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filename$ = 16						; size = 4
_xmlSetupParserForBuffer PROC				; COMDAT

; 14284: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14285:     xmlParserInputPtr input;
; 14286: 
; 14287:     if ((ctxt == NULL) || (buffer == NULL))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlSetupPa
	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN2@xmlSetupPa
$LN3@xmlSetupPa:

; 14288:         return;

	jmp	$LN1@xmlSetupPa
$LN2@xmlSetupPa:

; 14289: 
; 14290:     input = xmlNewInputStream(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlNewInputStream
	add	esp, 4
	mov	DWORD PTR _input$[ebp], eax

; 14291:     if (input == NULL) {

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN4@xmlSetupPa

; 14292:         xmlErrMemory(NULL, "parsing new buffer: out of memory\n");

	push	OFFSET ??_C@_0CD@FOJADJIB@parsing?5new?5buffer?3?5out?5of?5memo@
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 14293:         xmlClearParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlClearParserCtxt
	add	esp, 4

; 14294:         return;

	jmp	SHORT $LN1@xmlSetupPa
$LN4@xmlSetupPa:

; 14295:     }
; 14296: 
; 14297:     xmlClearParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlClearParserCtxt
	add	esp, 4

; 14298:     if (filename != NULL)

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN5@xmlSetupPa

; 14299:         input->filename = (char *) xmlCanonicPath((const xmlChar *)filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlCanonicPath
	add	esp, 4
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN5@xmlSetupPa:

; 14300:     input->base = buffer;

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [edx+12], eax

; 14301:     input->cur = buffer;

	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 14302:     input->end = &buffer[xmlStrlen(buffer)];

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	add	eax, DWORD PTR _buffer$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 14303:     inputPush(ctxt, input);

	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_inputPush
	add	esp, 8
$LN1@xmlSetupPa:

; 14304: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSetupParserForBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseCtxtExternalEntity
_TEXT	SEGMENT
_cur$1 = -40						; size = 4
_enc$ = -36						; size = 4
_start$ = -28						; size = 4
_ret$ = -20						; size = 4
_oldsax$ = -16						; size = 4
_newRoot$ = -12						; size = 4
_newDoc$ = -8						; size = 4
_ctxt$ = -4						; size = 4
_ctx$ = 8						; size = 4
_URL$ = 12						; size = 4
_ID$ = 16						; size = 4
_lst$ = 20						; size = 4
_xmlParseCtxtExternalEntity PROC			; COMDAT

; 12870: 	               const xmlChar *ID, xmlNodePtr *lst) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 12871:     xmlParserCtxtPtr ctxt;
; 12872:     xmlDocPtr newDoc;
; 12873:     xmlNodePtr newRoot;
; 12874:     xmlSAXHandlerPtr oldsax = NULL;

	mov	DWORD PTR _oldsax$[ebp], 0

; 12875:     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 12876:     xmlChar start[4];
; 12877:     xmlCharEncoding enc;
; 12878: 
; 12879:     if (ctx == NULL) return(-1);

	cmp	DWORD PTR _ctx$[ebp], 0
	jne	SHORT $LN4@xmlParseCt
	or	eax, -1
	jmp	$LN1@xmlParseCt
$LN4@xmlParseCt:

; 12880: 
; 12881:     if (((ctx->depth > 40) && ((ctx->options & XML_PARSE_HUGE) == 0)) ||

	mov	eax, DWORD PTR _ctx$[ebp]
	cmp	DWORD PTR [eax+248], 40			; 00000028H
	jle	SHORT $LN7@xmlParseCt
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	and	edx, 524288				; 00080000H
	je	SHORT $LN6@xmlParseCt
$LN7@xmlParseCt:
	mov	eax, DWORD PTR _ctx$[ebp]
	cmp	DWORD PTR [eax+248], 1024		; 00000400H
	jle	SHORT $LN5@xmlParseCt
$LN6@xmlParseCt:

; 12882:         (ctx->depth > 1024)) {
; 12883: 	return(XML_ERR_ENTITY_LOOP);

	mov	eax, 89					; 00000059H
	jmp	$LN1@xmlParseCt
$LN5@xmlParseCt:

; 12884:     }
; 12885: 
; 12886:     if (lst != NULL)

	cmp	DWORD PTR _lst$[ebp], 0
	je	SHORT $LN8@xmlParseCt

; 12887:         *lst = NULL;

	mov	ecx, DWORD PTR _lst$[ebp]
	mov	DWORD PTR [ecx], 0
$LN8@xmlParseCt:

; 12888:     if ((URL == NULL) && (ID == NULL))

	cmp	DWORD PTR _URL$[ebp], 0
	jne	SHORT $LN9@xmlParseCt
	cmp	DWORD PTR _ID$[ebp], 0
	jne	SHORT $LN9@xmlParseCt

; 12889: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseCt
$LN9@xmlParseCt:

; 12890:     if (ctx->myDoc == NULL) /* @@ relax but check for dereferences */

	mov	edx, DWORD PTR _ctx$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@xmlParseCt

; 12891: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseCt
$LN10@xmlParseCt:

; 12892: 
; 12893:     ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, ctx);

	mov	eax, DWORD PTR _ctx$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	call	_xmlCreateEntityParserCtxtInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ctxt$[ebp], eax

; 12894:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN11@xmlParseCt

; 12895: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseCt
$LN11@xmlParseCt:

; 12896:     }
; 12897: 
; 12898:     oldsax = ctxt->sax;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _oldsax$[ebp], ecx

; 12899:     ctxt->sax = ctx->sax;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 12900:     xmlDetectSAX2(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDetectSAX2
	add	esp, 4

; 12901:     newDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _newDoc$[ebp], eax

; 12902:     if (newDoc == NULL) {

	cmp	DWORD PTR _newDoc$[ebp], 0
	jne	SHORT $LN12@xmlParseCt

; 12903: 	xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12904: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseCt
$LN12@xmlParseCt:

; 12905:     }
; 12906:     newDoc->properties = XML_DOC_INTERNAL;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [ecx+92], 64			; 00000040H

; 12907:     if (ctx->myDoc->dict) {

	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN13@xmlParseCt

; 12908: 	newDoc->dict = ctx->myDoc->dict;

	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	ecx, DWORD PTR [edx+80]
	mov	DWORD PTR [eax+80], ecx

; 12909: 	xmlDictReference(newDoc->dict);

	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	call	_xmlDictReference
	add	esp, 4
$LN13@xmlParseCt:

; 12910:     }
; 12911:     if (ctx->myDoc != NULL) {

	mov	ecx, DWORD PTR _ctx$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN14@xmlParseCt

; 12912: 	newDoc->intSubset = ctx->myDoc->intSubset;

	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	edx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx+44], edx

; 12913: 	newDoc->extSubset = ctx->myDoc->extSubset;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	mov	DWORD PTR [edx+48], eax
$LN14@xmlParseCt:

; 12914:     }
; 12915:     if (ctx->myDoc->URL != NULL) {

	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+72], 0
	je	SHORT $LN15@xmlParseCt

; 12916: 	newDoc->URL = xmlStrdup(ctx->myDoc->URL);

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [ecx+72], eax
$LN15@xmlParseCt:

; 12917:     }
; 12918:     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST "pseudoroot", NULL);

	push	0
	push	OFFSET ??_C@_0L@OLLEMIAI@pseudoroot@
	push	0
	mov	edx, DWORD PTR _newDoc$[ebp]
	push	edx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newRoot$[ebp], eax

; 12919:     if (newRoot == NULL) {

	cmp	DWORD PTR _newRoot$[ebp], 0
	jne	SHORT $LN16@xmlParseCt

; 12920: 	ctxt->sax = oldsax;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _oldsax$[ebp]
	mov	DWORD PTR [eax], ecx

; 12921: 	xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12922: 	newDoc->intSubset = NULL;

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [eax+44], 0

; 12923: 	newDoc->extSubset = NULL;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 12924:         xmlFreeDoc(newDoc);

	mov	edx, DWORD PTR _newDoc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 12925: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseCt
$LN16@xmlParseCt:

; 12926:     }
; 12927:     xmlAddChild((xmlNodePtr) newDoc, newRoot);

	mov	eax, DWORD PTR _newRoot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newDoc$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8

; 12928:     nodePush(ctxt, newDoc->children);

	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_nodePush
	add	esp, 8

; 12929:     if (ctx->myDoc == NULL) {

	mov	edx, DWORD PTR _ctx$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN17@xmlParseCt

; 12930: 	ctxt->myDoc = newDoc;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 12931:     } else {

	jmp	SHORT $LN18@xmlParseCt
$LN17@xmlParseCt:

; 12932: 	ctxt->myDoc = ctx->myDoc;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 12933: 	newDoc->children->doc = ctx->myDoc;

	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+32], edx
$LN18@xmlParseCt:

; 12934:     }
; 12935: 
; 12936:     /*
; 12937:      * Get the 4 first bytes and decode the charset
; 12938:      * if enc != XML_CHAR_ENCODING_NONE
; 12939:      * plug some encoding conversion routines.
; 12940:      */
; 12941:     GROW

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN19@xmlParseCt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN19@xmlParseCt
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN19@xmlParseCt:

; 12942:     if ((ctxt->input->end - ctxt->input->cur) >= 4) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 4
	jl	$LN20@xmlParseCt

; 12943: 	start[0] = RAW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR _start$[ebp+ecx], dl

; 12944: 	start[1] = NXT(1);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, 1
	shl	ecx, 0
	mov	dl, BYTE PTR [edx+eax]
	mov	BYTE PTR _start$[ebp+ecx], dl

; 12945: 	start[2] = NXT(2);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, 1
	shl	ecx, 1
	mov	dl, BYTE PTR [edx+eax]
	mov	BYTE PTR _start$[ebp+ecx], dl

; 12946: 	start[3] = NXT(3);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	mov	edx, 1
	imul	edx, edx, 3
	mov	al, BYTE PTR [eax+ecx]
	mov	BYTE PTR _start$[ebp+edx], al

; 12947: 	enc = xmlDetectCharEncoding(start, 4);

	push	4
	lea	ecx, DWORD PTR _start$[ebp]
	push	ecx
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$[ebp], eax

; 12948: 	if (enc != XML_CHAR_ENCODING_NONE) {

	cmp	DWORD PTR _enc$[ebp], 0
	je	SHORT $LN20@xmlParseCt

; 12949: 	    xmlSwitchEncoding(ctxt, enc);

	mov	edx, DWORD PTR _enc$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSwitchEncoding
	add	esp, 8
$LN20@xmlParseCt:

; 12950: 	}
; 12951:     }
; 12952: 
; 12953:     /*
; 12954:      * Parse a possible text declaration first
; 12955:      */
; 12956:     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 60					; 0000003cH
	jne	$LN22@xmlParseCt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 63					; 0000003fH
	jne	$LN22@xmlParseCt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 120				; 00000078H
	jne	$LN22@xmlParseCt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 109				; 0000006dH
	jne	$LN22@xmlParseCt
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 108				; 0000006cH
	jne	$LN22@xmlParseCt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN23@xmlParseCt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 9
	jl	SHORT $LN24@xmlParseCt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN23@xmlParseCt
$LN24@xmlParseCt:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN22@xmlParseCt
$LN23@xmlParseCt:

; 12957: 	xmlParseTextDecl(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseTextDecl
	add	esp, 4

; 12958: 	/*
; 12959: 	 * An XML-1.0 document can't reference an entity not XML-1.0
; 12960: 	 */
; 12961: 	if ((xmlStrEqual(ctx->version, BAD_CAST "1.0")) &&

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@xmlParseCt
	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@xmlParseCt

; 12962: 	    (!xmlStrEqual(ctxt->input->version, BAD_CAST "1.0"))) {
; 12963: 	    xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,

	push	OFFSET ??_C@_0CO@FDJENMMD@Version?5mismatch?5between?5docume@
	push	109					; 0000006dH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH
$LN22@xmlParseCt:

; 12964: 	                   "Version mismatch between document and entity\n");
; 12965: 	}
; 12966:     }
; 12967: 
; 12968:     /*
; 12969:      * If the user provided its own SAX callbacks then reuse the
; 12970:      * useData callback field, otherwise the expected setup in a
; 12971:      * DOM builder is to have userData == ctxt
; 12972:      */
; 12973:     if (ctx->userData == ctx)

	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _ctx$[ebp]
	jne	SHORT $LN26@xmlParseCt

; 12974:         ctxt->userData = ctxt;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN27@xmlParseCt
$LN26@xmlParseCt:

; 12975:     else
; 12976:         ctxt->userData = ctx->userData;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
$LN27@xmlParseCt:

; 12977: 
; 12978:     /*
; 12979:      * Doing validity checking on chunk doesn't make sense
; 12980:      */
; 12981:     ctxt->instate = XML_PARSER_CONTENT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 7

; 12982:     ctxt->validate = ctx->validate;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	DWORD PTR [ecx+104], eax

; 12983:     ctxt->valid = ctx->valid;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR [ecx+100], eax

; 12984:     ctxt->loadsubset = ctx->loadsubset;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [edx+276]
	mov	DWORD PTR [ecx+276], eax

; 12985:     ctxt->depth = ctx->depth + 1;

	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	edx, DWORD PTR [ecx+248]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+248], edx

; 12986:     ctxt->replaceEntities = ctx->replaceEntities;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctx$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax

; 12987:     if (ctxt->validate) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+104], 0
	je	SHORT $LN28@xmlParseCt

; 12988: 	ctxt->vctxt.error = ctx->vctxt.error;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR [edx+112], ecx

; 12989: 	ctxt->vctxt.warning = ctx->vctxt.warning;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR [edx+116], ecx

; 12990:     } else {

	jmp	SHORT $LN29@xmlParseCt
$LN28@xmlParseCt:

; 12991: 	ctxt->vctxt.error = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+112], 0

; 12992: 	ctxt->vctxt.warning = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+116], 0
$LN29@xmlParseCt:

; 12993:     }
; 12994:     ctxt->vctxt.nodeTab = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+132], 0

; 12995:     ctxt->vctxt.nodeNr = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+124], 0

; 12996:     ctxt->vctxt.nodeMax = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+128], 0

; 12997:     ctxt->vctxt.node = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+120], 0

; 12998:     if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+296], 0
	je	SHORT $LN30@xmlParseCt
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	call	_xmlDictFree
	add	esp, 4
$LN30@xmlParseCt:

; 12999:     ctxt->dict = ctx->dict;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	DWORD PTR [edx+296], ecx

; 13000:     ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);

	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+312], eax

; 13001:     ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);

	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+316], eax

; 13002:     ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);

	push	36					; 00000024H
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+320], eax

; 13003:     ctxt->dictNames = ctx->dictNames;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+364]
	mov	DWORD PTR [edx+364], ecx

; 13004:     ctxt->attsDefault = ctx->attsDefault;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+348]
	mov	DWORD PTR [edx+348], ecx

; 13005:     ctxt->attsSpecial = ctx->attsSpecial;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+352]
	mov	DWORD PTR [edx+352], ecx

; 13006:     ctxt->linenumbers = ctx->linenumbers;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	DWORD PTR [edx+280], ecx

; 13007: 
; 13008:     xmlParseContent(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseContent
	add	esp, 4

; 13009: 
; 13010:     ctx->validate = ctxt->validate;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+104], edx

; 13011:     ctx->valid = ctxt->valid;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+100], edx

; 13012:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN31@xmlParseCt
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN31@xmlParseCt

; 13013: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);

	push	0
	push	85					; 00000055H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN32@xmlParseCt
$LN31@xmlParseCt:

; 13014:     } else if (RAW != 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN32@xmlParseCt

; 13015: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);

	push	0
	push	86					; 00000056H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN32@xmlParseCt:

; 13016:     }
; 13017:     if (ctxt->node != newDoc->children) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	edx, DWORD PTR [eax+52]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN34@xmlParseCt

; 13018: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);

	push	0
	push	85					; 00000055H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN34@xmlParseCt:

; 13019:     }
; 13020: 
; 13021:     if (!ctxt->wellFormed) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN35@xmlParseCt

; 13022:         if (ctxt->errNo == 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+84], 0
	jne	SHORT $LN37@xmlParseCt

; 13023: 	    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN38@xmlParseCt
$LN37@xmlParseCt:

; 13024: 	else
; 13025: 	    ret = ctxt->errNo;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _ret$[ebp], ecx
$LN38@xmlParseCt:

; 13026:     } else {

	jmp	SHORT $LN36@xmlParseCt
$LN35@xmlParseCt:

; 13027: 	if (lst != NULL) {

	cmp	DWORD PTR _lst$[ebp], 0
	je	SHORT $LN39@xmlParseCt

; 13028: 	    xmlNodePtr cur;
; 13029: 
; 13030: 	    /*
; 13031: 	     * Return the newly created nodeset after unlinking it from
; 13032: 	     * they pseudo parent.
; 13033: 	     */
; 13034: 	    cur = newDoc->children->children;

	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$1[ebp], ecx

; 13035: 	    *lst = cur;

	mov	edx, DWORD PTR _lst$[ebp]
	mov	eax, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR [edx], eax
$LN2@xmlParseCt:

; 13036: 	    while (cur != NULL) {

	cmp	DWORD PTR _cur$1[ebp], 0
	je	SHORT $LN3@xmlParseCt

; 13037: 		cur->parent = NULL;

	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR [ecx+20], 0

; 13038: 		cur = cur->next;

	mov	edx, DWORD PTR _cur$1[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$1[ebp], eax

; 13039: 	    }

	jmp	SHORT $LN2@xmlParseCt
$LN3@xmlParseCt:

; 13040:             newDoc->children->children = NULL;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], 0
$LN39@xmlParseCt:

; 13041: 	}
; 13042: 	ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN36@xmlParseCt:

; 13043:     }
; 13044:     ctxt->sax = oldsax;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _oldsax$[ebp]
	mov	DWORD PTR [eax], ecx

; 13045:     ctxt->dict = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+296], 0

; 13046:     ctxt->attsDefault = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+348], 0

; 13047:     ctxt->attsSpecial = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+352], 0

; 13048:     xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13049:     newDoc->intSubset = NULL;

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [eax+44], 0

; 13050:     newDoc->extSubset = NULL;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 13051:     xmlFreeDoc(newDoc);

	mov	edx, DWORD PTR _newDoc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 13052: 
; 13053:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseCt:

; 13054: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN43@xmlParseCt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN43@xmlParseCt:
	DD	1
	DD	$LN42@xmlParseCt
$LN42@xmlParseCt:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN41@xmlParseCt
$LN41@xmlParseCt:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
_xmlParseCtxtExternalEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseExternalEntity
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_sax$ = 12						; size = 4
_user_data$ = 16					; size = 4
_depth$ = 20						; size = 4
_URL$ = 24						; size = 4
_ID$ = 28						; size = 4
_lst$ = 32						; size = 4
_xmlParseExternalEntity PROC				; COMDAT

; 13287: 	  int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 13288:     return(xmlParseExternalEntityPrivate(doc, NULL, sax, user_data, depth, URL,

	mov	eax, DWORD PTR _lst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _URL$[ebp]
	push	edx
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _user_data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sax$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlParseExternalEntityPrivate
	add	esp, 32					; 00000020H

; 13289: 		                       ID, lst));
; 13290: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseExternalEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseBalancedChunkMemoryRecover
_TEXT	SEGMENT
_cur$1 = -32						; size = 4
_ret$ = -28						; size = 4
_size$ = -24						; size = 4
_newRoot$ = -20						; size = 4
_content$ = -16						; size = 4
_oldsax$ = -12						; size = 4
_newDoc$ = -8						; size = 4
_ctxt$ = -4						; size = 4
_doc$ = 8						; size = 4
_sax$ = 12						; size = 4
_user_data$ = 16					; size = 4
_depth$ = 20						; size = 4
_string$ = 24						; size = 4
_lst$ = 28						; size = 4
_recover$ = 32						; size = 4
_xmlParseBalancedChunkMemoryRecover PROC		; COMDAT

; 13772:      int recover) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 13773:     xmlParserCtxtPtr ctxt;
; 13774:     xmlDocPtr newDoc;
; 13775:     xmlSAXHandlerPtr oldsax = NULL;

	mov	DWORD PTR _oldsax$[ebp], 0

; 13776:     xmlNodePtr content, newRoot;
; 13777:     int size;
; 13778:     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 13779: 
; 13780:     if (depth > 40) {

	cmp	DWORD PTR _depth$[ebp], 40		; 00000028H
	jle	SHORT $LN4@xmlParseBa

; 13781: 	return(XML_ERR_ENTITY_LOOP);

	mov	eax, 89					; 00000059H
	jmp	$LN1@xmlParseBa
$LN4@xmlParseBa:

; 13782:     }
; 13783: 
; 13784: 
; 13785:     if (lst != NULL)

	cmp	DWORD PTR _lst$[ebp], 0
	je	SHORT $LN5@xmlParseBa

; 13786:         *lst = NULL;

	mov	eax, DWORD PTR _lst$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@xmlParseBa:

; 13787:     if (string == NULL)

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN6@xmlParseBa

; 13788:         return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseBa
$LN6@xmlParseBa:

; 13789: 
; 13790:     size = xmlStrlen(string);

	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 13791: 
; 13792:     ctxt = xmlCreateMemoryParserCtxt((char *) string, size);

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_xmlCreateMemoryParserCtxt
	add	esp, 8
	mov	DWORD PTR _ctxt$[ebp], eax

; 13793:     if (ctxt == NULL) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN7@xmlParseBa
	or	eax, -1
	jmp	$LN1@xmlParseBa
$LN7@xmlParseBa:

; 13794:     ctxt->userData = ctxt;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 13795:     if (sax != NULL) {

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN8@xmlParseBa

; 13796: 	oldsax = ctxt->sax;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _oldsax$[ebp], ecx

; 13797:         ctxt->sax = sax;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [edx], eax

; 13798: 	if (user_data != NULL)

	cmp	DWORD PTR _user_data$[ebp], 0
	je	SHORT $LN8@xmlParseBa

; 13799: 	    ctxt->userData = user_data;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN8@xmlParseBa:

; 13800:     }
; 13801:     newDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _newDoc$[ebp], eax

; 13802:     if (newDoc == NULL) {

	cmp	DWORD PTR _newDoc$[ebp], 0
	jne	SHORT $LN10@xmlParseBa

; 13803: 	xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13804: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseBa
$LN10@xmlParseBa:

; 13805:     }
; 13806:     newDoc->properties = XML_DOC_INTERNAL;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [ecx+92], 64			; 00000040H

; 13807:     if ((doc != NULL) && (doc->dict != NULL)) {

	cmp	DWORD PTR _doc$[ebp], 0
	je	$LN11@xmlParseBa
	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+80], 0
	je	$LN11@xmlParseBa

; 13808:         xmlDictFree(ctxt->dict);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	call	_xmlDictFree
	add	esp, 4

; 13809: 	ctxt->dict = doc->dict;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [edx+296], ecx

; 13810: 	xmlDictReference(ctxt->dict);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictReference
	add	esp, 4

; 13811: 	ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);

	push	3
	push	OFFSET ??_C@_03PJHHNEEI@xml@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+312], eax

; 13812: 	ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);

	push	5
	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+316], eax

; 13813: 	ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);

	push	36					; 00000024H
	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+320], eax

; 13814: 	ctxt->dictNames = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+364], 1

; 13815:     } else {

	jmp	SHORT $LN12@xmlParseBa
$LN11@xmlParseBa:

; 13816: 	xmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL);

	push	0
	push	4096					; 00001000H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtUseOptionsInternal
	add	esp, 12					; 0000000cH
$LN12@xmlParseBa:

; 13817:     }
; 13818:     if (doc != NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN13@xmlParseBa

; 13819: 	newDoc->intSubset = doc->intSubset;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax

; 13820: 	newDoc->extSubset = doc->extSubset;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
$LN13@xmlParseBa:

; 13821:     }
; 13822:     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST "pseudoroot", NULL);

	push	0
	push	OFFSET ??_C@_0L@OLLEMIAI@pseudoroot@
	push	0
	mov	ecx, DWORD PTR _newDoc$[ebp]
	push	ecx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newRoot$[ebp], eax

; 13823:     if (newRoot == NULL) {

	cmp	DWORD PTR _newRoot$[ebp], 0
	jne	SHORT $LN14@xmlParseBa

; 13824: 	if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN15@xmlParseBa

; 13825: 	    ctxt->sax = oldsax;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldsax$[ebp]
	mov	DWORD PTR [edx], eax
$LN15@xmlParseBa:

; 13826: 	xmlFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13827: 	newDoc->intSubset = NULL;

	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [edx+44], 0

; 13828: 	newDoc->extSubset = NULL;

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [eax+48], 0

; 13829:         xmlFreeDoc(newDoc);

	mov	ecx, DWORD PTR _newDoc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 13830: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseBa
$LN14@xmlParseBa:

; 13831:     }
; 13832:     xmlAddChild((xmlNodePtr) newDoc, newRoot);

	mov	edx, DWORD PTR _newRoot$[ebp]
	push	edx
	mov	eax, DWORD PTR _newDoc$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8

; 13833:     nodePush(ctxt, newRoot);

	mov	ecx, DWORD PTR _newRoot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_nodePush
	add	esp, 8

; 13834:     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN16@xmlParseBa

; 13835: 	ctxt->myDoc = newDoc;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 13836:     } else {

	jmp	SHORT $LN17@xmlParseBa
$LN16@xmlParseBa:

; 13837: 	ctxt->myDoc = newDoc;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [edx+8], eax

; 13838: 	newDoc->children->doc = doc;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [edx+32], eax

; 13839: 	/* Ensure that doc has XML spec namespace */
; 13840: 	xmlSearchNsByHref(doc, (xmlNodePtr)doc, XML_XML_NAMESPACE);

	push	OFFSET ??_C@_0CF@GLDAAHFK@http?3?1?1www?4w3?4org?1XML?11998?1name@
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlSearchNsByHref
	add	esp, 12					; 0000000cH

; 13841: 	newDoc->oldNs = doc->oldNs;

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
$LN17@xmlParseBa:

; 13842:     }
; 13843:     ctxt->instate = XML_PARSER_CONTENT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 7

; 13844:     ctxt->input_id = 2;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+464], 2

; 13845:     ctxt->depth = depth;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR [edx+248], eax

; 13846: 
; 13847:     /*
; 13848:      * Doing validity checking on chunk doesn't make sense
; 13849:      */
; 13850:     ctxt->validate = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+104], 0

; 13851:     ctxt->loadsubset = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+276], 0

; 13852:     xmlDetectSAX2(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDetectSAX2
	add	esp, 4

; 13853: 
; 13854:     if ( doc != NULL ){

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN18@xmlParseBa

; 13855:         content = doc->children;

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _content$[ebp], edx

; 13856:         doc->children = NULL;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [eax+12], 0

; 13857:         xmlParseContent(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseContent
	add	esp, 4

; 13858:         doc->children = content;

	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR [edx+12], eax

; 13859:     }

	jmp	SHORT $LN19@xmlParseBa
$LN18@xmlParseBa:

; 13860:     else {
; 13861:         xmlParseContent(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseContent
	add	esp, 4
$LN19@xmlParseBa:

; 13862:     }
; 13863:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 60					; 0000003cH
	jne	SHORT $LN20@xmlParseBa
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN20@xmlParseBa

; 13864: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);

	push	0
	push	85					; 00000055H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN21@xmlParseBa
$LN20@xmlParseBa:

; 13865:     } else if (RAW != 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN21@xmlParseBa

; 13866: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);

	push	0
	push	86					; 00000056H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN21@xmlParseBa:

; 13867:     }
; 13868:     if (ctxt->node != newDoc->children) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	cmp	ecx, DWORD PTR [eax+12]
	je	SHORT $LN23@xmlParseBa

; 13869: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);

	push	0
	push	85					; 00000055H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN23@xmlParseBa:

; 13870:     }
; 13871: 
; 13872:     if (!ctxt->wellFormed) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN24@xmlParseBa

; 13873:         if (ctxt->errNo == 0)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+84], 0
	jne	SHORT $LN26@xmlParseBa

; 13874: 	    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN27@xmlParseBa
$LN26@xmlParseBa:

; 13875: 	else
; 13876: 	    ret = ctxt->errNo;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR _ret$[ebp], eax
$LN27@xmlParseBa:

; 13877:     } else {

	jmp	SHORT $LN25@xmlParseBa
$LN24@xmlParseBa:

; 13878:       ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN25@xmlParseBa:

; 13879:     }
; 13880: 
; 13881:     if ((lst != NULL) && ((ret == 0) || (recover == 1))) {

	cmp	DWORD PTR _lst$[ebp], 0
	je	SHORT $LN28@xmlParseBa
	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN29@xmlParseBa
	cmp	DWORD PTR _recover$[ebp], 1
	jne	SHORT $LN28@xmlParseBa
$LN29@xmlParseBa:

; 13882: 	xmlNodePtr cur;
; 13883: 
; 13884: 	/*
; 13885: 	 * Return the newly created nodeset after unlinking it from
; 13886: 	 * they pseudo parent.
; 13887: 	 */
; 13888: 	cur = newDoc->children->children;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$1[ebp], eax

; 13889: 	*lst = cur;

	mov	ecx, DWORD PTR _lst$[ebp]
	mov	edx, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR [ecx], edx
$LN2@xmlParseBa:

; 13890: 	while (cur != NULL) {

	cmp	DWORD PTR _cur$1[ebp], 0
	je	SHORT $LN3@xmlParseBa

; 13891: 	    xmlSetTreeDoc(cur, doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$1[ebp]
	push	ecx
	call	_xmlSetTreeDoc
	add	esp, 8

; 13892: 	    cur->parent = NULL;

	mov	edx, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR [edx+20], 0

; 13893: 	    cur = cur->next;

	mov	eax, DWORD PTR _cur$1[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$1[ebp], ecx

; 13894: 	}

	jmp	SHORT $LN2@xmlParseBa
$LN3@xmlParseBa:

; 13895: 	newDoc->children->children = NULL;

	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], 0
$LN28@xmlParseBa:

; 13896:     }
; 13897: 
; 13898:     if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN30@xmlParseBa

; 13899: 	ctxt->sax = oldsax;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _oldsax$[ebp]
	mov	DWORD PTR [ecx], edx
$LN30@xmlParseBa:

; 13900:     xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13901:     newDoc->intSubset = NULL;

	mov	ecx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 13902:     newDoc->extSubset = NULL;

	mov	edx, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [edx+48], 0

; 13903:     newDoc->oldNs = NULL;

	mov	eax, DWORD PTR _newDoc$[ebp]
	mov	DWORD PTR [eax+52], 0

; 13904:     xmlFreeDoc(newDoc);

	mov	ecx, DWORD PTR _newDoc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 13905: 
; 13906:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseBa:

; 13907: }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseBalancedChunkMemoryRecover ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseInNodeContext
_TEXT	SEGMENT
tv69 = -44						; size = 4
_ihref$1 = -40						; size = 4
_iprefix$2 = -36					; size = 4
_ns$3 = -32						; size = 4
_hdlr$4 = -28						; size = 4
_ret$ = -24						; size = 4
_nsnr$ = -20						; size = 4
_cur$ = -16						; size = 4
_fake$ = -12						; size = 4
_doc$ = -8						; size = 4
_ctxt$ = -4						; size = 4
_node$ = 8						; size = 4
_data$ = 12						; size = 4
_datalen$ = 16						; size = 4
_options$ = 20						; size = 4
_lst$ = 24						; size = 4
_xmlParseInNodeContext PROC				; COMDAT

; 13536:                       int options, xmlNodePtr *lst) {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 13537: #ifdef SAX2
; 13538:     xmlParserCtxtPtr ctxt;
; 13539:     xmlDocPtr doc = NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 13540:     xmlNodePtr fake, cur;
; 13541:     int nsnr = 0;

	mov	DWORD PTR _nsnr$[ebp], 0

; 13542: 
; 13543:     xmlParserErrors ret = XML_ERR_OK;

	mov	DWORD PTR _ret$[ebp], 0

; 13544: 
; 13545:     /*
; 13546:      * check all input parameters, grab the document
; 13547:      */
; 13548:     if ((lst == NULL) || (node == NULL) || (data == NULL) || (datalen < 0))

	cmp	DWORD PTR _lst$[ebp], 0
	je	SHORT $LN13@xmlParseIn
	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN13@xmlParseIn
	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN13@xmlParseIn
	cmp	DWORD PTR _datalen$[ebp], 0
	jge	SHORT $LN12@xmlParseIn
$LN13@xmlParseIn:

; 13549:         return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseIn
$LN12@xmlParseIn:

; 13550:     switch (node->type) {

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv69[ebp], ecx
	mov	edx, DWORD PTR tv69[ebp]
	sub	edx, 1
	mov	DWORD PTR tv69[ebp], edx
	cmp	DWORD PTR tv69[ebp], 12			; 0000000cH
	ja	SHORT $LN15@xmlParseIn
	mov	eax, DWORD PTR tv69[ebp]
	movzx	ecx, BYTE PTR $LN53@xmlParseIn[eax]
	jmp	DWORD PTR $LN54@xmlParseIn[ecx*4]
$LN14@xmlParseIn:

; 13551:         case XML_ELEMENT_NODE:
; 13552:         case XML_ATTRIBUTE_NODE:
; 13553:         case XML_TEXT_NODE:
; 13554:         case XML_CDATA_SECTION_NODE:
; 13555:         case XML_ENTITY_REF_NODE:
; 13556:         case XML_PI_NODE:
; 13557:         case XML_COMMENT_NODE:
; 13558:         case XML_DOCUMENT_NODE:
; 13559:         case XML_HTML_DOCUMENT_NODE:
; 13560: 	    break;

	jmp	SHORT $LN4@xmlParseIn
$LN15@xmlParseIn:

; 13561: 	default:
; 13562: 	    return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseIn
$LN4@xmlParseIn:

; 13563: 
; 13564:     }
; 13565:     while ((node != NULL) && (node->type != XML_ELEMENT_NODE) &&
; 13566:            (node->type != XML_DOCUMENT_NODE) &&

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN5@xmlParseIn
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	SHORT $LN5@xmlParseIn
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 9
	je	SHORT $LN5@xmlParseIn
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	je	SHORT $LN5@xmlParseIn

; 13567: 	   (node->type != XML_HTML_DOCUMENT_NODE))
; 13568: 	node = node->parent;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _node$[ebp], eax
	jmp	SHORT $LN4@xmlParseIn
$LN5@xmlParseIn:

; 13569:     if (node == NULL)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN16@xmlParseIn

; 13570: 	return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseIn
$LN16@xmlParseIn:

; 13571:     if (node->type == XML_ELEMENT_NODE)

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN17@xmlParseIn

; 13572: 	doc = node->doc;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _doc$[ebp], eax
	jmp	SHORT $LN18@xmlParseIn
$LN17@xmlParseIn:

; 13573:     else
; 13574:         doc = (xmlDocPtr) node;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _doc$[ebp], ecx
$LN18@xmlParseIn:

; 13575:     if (doc == NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN19@xmlParseIn

; 13576: 	return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseIn
$LN19@xmlParseIn:

; 13577: 
; 13578:     /*
; 13579:      * allocate a context and set-up everything not related to the
; 13580:      * node position in the tree
; 13581:      */
; 13582:     if (doc->type == XML_DOCUMENT_NODE)

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+4], 9
	jne	SHORT $LN20@xmlParseIn

; 13583: 	ctxt = xmlCreateMemoryParserCtxt((char *) data, datalen);

	mov	eax, DWORD PTR _datalen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_xmlCreateMemoryParserCtxt
	add	esp, 8
	mov	DWORD PTR _ctxt$[ebp], eax
	jmp	SHORT $LN21@xmlParseIn
$LN20@xmlParseIn:

; 13584: #ifdef LIBXML_HTML_ENABLED
; 13585:     else if (doc->type == XML_HTML_DOCUMENT_NODE) {

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+4], 13			; 0000000dH
	jne	SHORT $LN22@xmlParseIn

; 13586: 	ctxt = htmlCreateMemoryParserCtxt((char *) data, datalen);

	mov	eax, DWORD PTR _datalen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_htmlCreateMemoryParserCtxt
	add	esp, 8
	mov	DWORD PTR _ctxt$[ebp], eax

; 13587:         /*
; 13588:          * When parsing in context, it makes no sense to add implied
; 13589:          * elements like html/body/etc...
; 13590:          */
; 13591:         options |= HTML_PARSE_NOIMPLIED;

	mov	edx, DWORD PTR _options$[ebp]
	or	edx, 8192				; 00002000H
	mov	DWORD PTR _options$[ebp], edx

; 13592:     }

	jmp	SHORT $LN21@xmlParseIn
$LN22@xmlParseIn:

; 13593: #endif
; 13594:     else
; 13595:         return(XML_ERR_INTERNAL_ERROR);

	mov	eax, 1
	jmp	$LN1@xmlParseIn
$LN21@xmlParseIn:

; 13596: 
; 13597:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN24@xmlParseIn

; 13598:         return(XML_ERR_NO_MEMORY);

	mov	eax, 2
	jmp	$LN1@xmlParseIn
$LN24@xmlParseIn:

; 13599: 
; 13600:     /*
; 13601:      * Use input doc's dict if present, else assure XML_PARSE_NODICT is set.
; 13602:      * We need a dictionary for xmlDetectSAX2, so if there's no doc dict
; 13603:      * we must wait until the last moment to free the original one.
; 13604:      */
; 13605:     if (doc->dict != NULL) {

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN25@xmlParseIn

; 13606:         if (ctxt->dict != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+296], 0
	je	SHORT $LN27@xmlParseIn

; 13607: 	    xmlDictFree(ctxt->dict);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+296]
	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN27@xmlParseIn:

; 13608: 	ctxt->dict = doc->dict;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR [ecx+296], eax

; 13609:     } else

	jmp	SHORT $LN26@xmlParseIn
$LN25@xmlParseIn:

; 13610:         options |= XML_PARSE_NODICT;

	mov	ecx, DWORD PTR _options$[ebp]
	or	ecx, 4096				; 00001000H
	mov	DWORD PTR _options$[ebp], ecx
$LN26@xmlParseIn:

; 13611: 
; 13612:     if (doc->encoding != NULL) {

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+60], 0
	je	SHORT $LN28@xmlParseIn

; 13613:         xmlCharEncodingHandlerPtr hdlr;
; 13614: 
; 13615:         if (ctxt->encoding != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN29@xmlParseIn

; 13616: 	    xmlFree((xmlChar *) ctxt->encoding);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN29@xmlParseIn:

; 13617:         ctxt->encoding = xmlStrdup((const xmlChar *) doc->encoding);

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+24], eax

; 13618: 
; 13619:         hdlr = xmlFindCharEncodingHandler((const char *) doc->encoding);

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _hdlr$4[ebp], eax

; 13620:         if (hdlr != NULL) {

	cmp	DWORD PTR _hdlr$4[ebp], 0
	je	SHORT $LN30@xmlParseIn

; 13621:             xmlSwitchToEncoding(ctxt, hdlr);

	mov	edx, DWORD PTR _hdlr$4[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSwitchToEncoding
	add	esp, 8

; 13622: 	} else {

	jmp	SHORT $LN28@xmlParseIn
$LN30@xmlParseIn:

; 13623:             return(XML_ERR_UNSUPPORTED_ENCODING);

	mov	eax, 32					; 00000020H
	jmp	$LN1@xmlParseIn
$LN28@xmlParseIn:

; 13624:         }
; 13625:     }
; 13626: 
; 13627:     xmlCtxtUseOptionsInternal(ctxt, options, NULL);

	push	0
	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtUseOptionsInternal
	add	esp, 12					; 0000000cH

; 13628:     xmlDetectSAX2(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDetectSAX2
	add	esp, 4

; 13629:     ctxt->myDoc = doc;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 13630:     /* parsing in context, i.e. as within existing content */
; 13631:     ctxt->input_id = 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+464], 2

; 13632:     ctxt->instate = XML_PARSER_CONTENT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 7

; 13633: 
; 13634:     fake = xmlNewComment(NULL);

	push	0
	call	_xmlNewComment
	add	esp, 4
	mov	DWORD PTR _fake$[ebp], eax

; 13635:     if (fake == NULL) {

	cmp	DWORD PTR _fake$[ebp], 0
	jne	SHORT $LN32@xmlParseIn

; 13636:         xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13637: 	return(XML_ERR_NO_MEMORY);

	mov	eax, 2
	jmp	$LN1@xmlParseIn
$LN32@xmlParseIn:

; 13638:     }
; 13639:     xmlAddChild(node, fake);

	mov	eax, DWORD PTR _fake$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8

; 13640: 
; 13641:     if (node->type == XML_ELEMENT_NODE) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	$LN33@xmlParseIn

; 13642: 	nodePush(ctxt, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_nodePush
	add	esp, 8

; 13643: 	/*
; 13644: 	 * initialize the SAX2 namespaces stack
; 13645: 	 */
; 13646: 	cur = node;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _cur$[ebp], edx
$LN6@xmlParseIn:

; 13647: 	while ((cur != NULL) && (cur->type == XML_ELEMENT_NODE)) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN33@xmlParseIn
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	$LN33@xmlParseIn

; 13648: 	    xmlNsPtr ns = cur->nsDef;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _ns$3[ebp], edx
$LN8@xmlParseIn:

; 13649: 	    const xmlChar *iprefix, *ihref;
; 13650: 
; 13651: 	    while (ns != NULL) {

	cmp	DWORD PTR _ns$3[ebp], 0
	je	$LN9@xmlParseIn

; 13652: 		if (ctxt->dict) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+296], 0
	je	SHORT $LN34@xmlParseIn

; 13653: 		    iprefix = xmlDictLookup(ctxt->dict, ns->prefix, -1);

	push	-1
	mov	ecx, DWORD PTR _ns$3[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iprefix$2[ebp], eax

; 13654: 		    ihref = xmlDictLookup(ctxt->dict, ns->href, -1);

	push	-1
	mov	edx, DWORD PTR _ns$3[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ihref$1[ebp], eax

; 13655: 		} else {

	jmp	SHORT $LN35@xmlParseIn
$LN34@xmlParseIn:

; 13656: 		    iprefix = ns->prefix;

	mov	eax, DWORD PTR _ns$3[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iprefix$2[ebp], ecx

; 13657: 		    ihref = ns->href;

	mov	edx, DWORD PTR _ns$3[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _ihref$1[ebp], eax
$LN35@xmlParseIn:

; 13658: 		}
; 13659: 
; 13660: 	        if (xmlGetNamespace(ctxt, iprefix) == NULL) {

	mov	ecx, DWORD PTR _iprefix$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGetNamespace
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@xmlParseIn

; 13661: 		    nsPush(ctxt, iprefix, ihref);

	mov	eax, DWORD PTR _ihref$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _iprefix$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_nsPush
	add	esp, 12					; 0000000cH

; 13662: 		    nsnr++;

	mov	eax, DWORD PTR _nsnr$[ebp]
	add	eax, 1
	mov	DWORD PTR _nsnr$[ebp], eax
$LN36@xmlParseIn:

; 13663: 		}
; 13664: 		ns = ns->next;

	mov	ecx, DWORD PTR _ns$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ns$3[ebp], edx

; 13665: 	    }

	jmp	$LN8@xmlParseIn
$LN9@xmlParseIn:

; 13666: 	    cur = cur->parent;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _cur$[ebp], ecx

; 13667: 	}

	jmp	$LN6@xmlParseIn
$LN33@xmlParseIn:

; 13668:     }
; 13669: 
; 13670:     if ((ctxt->validate) || (ctxt->replaceEntities != 0)) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+104], 0
	jne	SHORT $LN38@xmlParseIn
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN37@xmlParseIn
$LN38@xmlParseIn:

; 13671: 	/*
; 13672: 	 * ID/IDREF registration will be done in xmlValidateElement below
; 13673: 	 */
; 13674: 	ctxt->loadsubset |= XML_SKIP_IDS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+276]
	or	edx, 8
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+276], edx
$LN37@xmlParseIn:

; 13675:     }
; 13676: 
; 13677: #ifdef LIBXML_HTML_ENABLED
; 13678:     if (doc->type == XML_HTML_DOCUMENT_NODE)

	mov	ecx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	jne	SHORT $LN39@xmlParseIn

; 13679:         __htmlParseContent(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	___htmlParseContent
	add	esp, 4
	jmp	SHORT $LN40@xmlParseIn
$LN39@xmlParseIn:

; 13680:     else
; 13681: #endif
; 13682: 	xmlParseContent(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseContent
	add	esp, 4
$LN40@xmlParseIn:

; 13683: 
; 13684:     nsPop(ctxt, nsnr);

	mov	ecx, DWORD PTR _nsnr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_nsPop
	add	esp, 8

; 13685:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN41@xmlParseIn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN41@xmlParseIn

; 13686: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);

	push	0
	push	85					; 00000055H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN42@xmlParseIn
$LN41@xmlParseIn:

; 13687:     } else if (RAW != 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN42@xmlParseIn

; 13688: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);

	push	0
	push	86					; 00000056H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN42@xmlParseIn:

; 13689:     }
; 13690:     if ((ctxt->node != NULL) && (ctxt->node != node)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN44@xmlParseIn
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	cmp	edx, DWORD PTR _node$[ebp]
	je	SHORT $LN44@xmlParseIn

; 13691: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);

	push	0
	push	85					; 00000055H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 13692: 	ctxt->wellFormed = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+12], 0
$LN44@xmlParseIn:

; 13693:     }
; 13694: 
; 13695:     if (!ctxt->wellFormed) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN45@xmlParseIn

; 13696:         if (ctxt->errNo == 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 0
	jne	SHORT $LN47@xmlParseIn

; 13697: 	    ret = XML_ERR_INTERNAL_ERROR;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN48@xmlParseIn
$LN47@xmlParseIn:

; 13698: 	else
; 13699: 	    ret = (xmlParserErrors)ctxt->errNo;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _ret$[ebp], edx
$LN48@xmlParseIn:

; 13700:     } else {

	jmp	SHORT $LN46@xmlParseIn
$LN45@xmlParseIn:

; 13701:         ret = XML_ERR_OK;

	mov	DWORD PTR _ret$[ebp], 0
$LN46@xmlParseIn:

; 13702:     }
; 13703: 
; 13704:     /*
; 13705:      * Return the newly created nodeset after unlinking it from
; 13706:      * the pseudo sibling.
; 13707:      */
; 13708: 
; 13709:     cur = fake->next;

	mov	eax, DWORD PTR _fake$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 13710:     fake->next = NULL;

	mov	edx, DWORD PTR _fake$[ebp]
	mov	DWORD PTR [edx+24], 0

; 13711:     node->last = fake;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _fake$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 13712: 
; 13713:     if (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN49@xmlParseIn

; 13714: 	cur->prev = NULL;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+28], 0
$LN49@xmlParseIn:

; 13715:     }
; 13716: 
; 13717:     *lst = cur;

	mov	eax, DWORD PTR _lst$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@xmlParseIn:

; 13718: 
; 13719:     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN11@xmlParseIn

; 13720: 	cur->parent = NULL;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+20], 0

; 13721: 	cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 13722:     }

	jmp	SHORT $LN10@xmlParseIn
$LN11@xmlParseIn:

; 13723: 
; 13724:     xmlUnlinkNode(fake);

	mov	edx, DWORD PTR _fake$[ebp]
	push	edx
	call	_xmlUnlinkNode
	add	esp, 4

; 13725:     xmlFreeNode(fake);

	mov	eax, DWORD PTR _fake$[ebp]
	push	eax
	call	_xmlFreeNode
	add	esp, 4

; 13726: 
; 13727: 
; 13728:     if (ret != XML_ERR_OK) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN50@xmlParseIn

; 13729:         xmlFreeNodeList(*lst);

	mov	ecx, DWORD PTR _lst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlFreeNodeList
	add	esp, 4

; 13730: 	*lst = NULL;

	mov	eax, DWORD PTR _lst$[ebp]
	mov	DWORD PTR [eax], 0
$LN50@xmlParseIn:

; 13731:     }
; 13732: 
; 13733:     if (doc->dict != NULL)

	mov	ecx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [ecx+80], 0
	je	SHORT $LN51@xmlParseIn

; 13734:         ctxt->dict = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+296], 0
$LN51@xmlParseIn:

; 13735:     xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13736: 
; 13737:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlParseIn:

; 13738: #else /* !SAX2 */
; 13739:     return(XML_ERR_INTERNAL_ERROR);
; 13740: #endif
; 13741: }

	pop	edi
	pop	esi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN54@xmlParseIn:
	DD	$LN14@xmlParseIn
	DD	$LN15@xmlParseIn
$LN53@xmlParseIn:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
_xmlParseInNodeContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseBalancedChunkMemory
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_sax$ = 12						; size = 4
_user_data$ = 16					; size = 4
_depth$ = 20						; size = 4
_string$ = 24						; size = 4
_lst$ = 28						; size = 4
_xmlParseBalancedChunkMemory PROC			; COMDAT

; 13314:      void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 13315:     return xmlParseBalancedChunkMemoryRecover( doc, sax, user_data,

	push	0
	mov	eax, DWORD PTR _lst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _depth$[ebp]
	push	edx
	mov	eax, DWORD PTR _user_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sax$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlParseBalancedChunkMemoryRecover
	add	esp, 28					; 0000001cH

; 13316:                                                 depth, string, lst, 0 );
; 13317: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseBalancedChunkMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlIOParseDTD
_TEXT	SEGMENT
_tmp$1 = -28						; size = 4
_start$ = -20						; size = 4
_pinput$ = -12						; size = 4
_ctxt$ = -8						; size = 4
_ret$ = -4						; size = 4
_sax$ = 8						; size = 4
_input$ = 12						; size = 4
_enc$ = 16						; size = 4
_xmlIOParseDTD PROC					; COMDAT

; 12579: 	      xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 12580:     xmlDtdPtr ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 12581:     xmlParserCtxtPtr ctxt;
; 12582:     xmlParserInputPtr pinput = NULL;

	mov	DWORD PTR _pinput$[ebp], 0

; 12583:     xmlChar start[4];
; 12584: 
; 12585:     if (input == NULL)

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN4@xmlIOParse

; 12586: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlIOParse
$LN4@xmlIOParse:

; 12587: 
; 12588:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 12589:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN5@xmlIOParse

; 12590:         xmlFreeParserInputBuffer(input);

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 12591: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlIOParse
$LN5@xmlIOParse:

; 12592:     }
; 12593: 
; 12594:     /* We are loading a DTD */
; 12595:     ctxt->options |= XML_PARSE_DTDLOAD;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	or	edx, 4
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+360], edx

; 12596: 
; 12597:     /*
; 12598:      * Set-up the SAX context
; 12599:      */
; 12600:     if (sax != NULL) {

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN6@xmlIOParse

; 12601: 	if (ctxt->sax != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN7@xmlIOParse

; 12602: 	    xmlFree(ctxt->sax);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlIOParse:

; 12603:         ctxt->sax = sax;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [ecx], edx

; 12604:         ctxt->userData = ctxt;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN6@xmlIOParse:

; 12605:     }
; 12606:     xmlDetectSAX2(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDetectSAX2
	add	esp, 4

; 12607: 
; 12608:     /*
; 12609:      * generate a parser input from the I/O handler
; 12610:      */
; 12611: 
; 12612:     pinput = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

	push	0
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlNewIOInputStream
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pinput$[ebp], eax

; 12613:     if (pinput == NULL) {

	cmp	DWORD PTR _pinput$[ebp], 0
	jne	SHORT $LN8@xmlIOParse

; 12614:         if (sax != NULL) ctxt->sax = NULL;

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN9@xmlIOParse
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], 0
$LN9@xmlIOParse:

; 12615:         xmlFreeParserInputBuffer(input);

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	call	_xmlFreeParserInputBuffer
	add	esp, 4

; 12616: 	xmlFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12617: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlIOParse
$LN8@xmlIOParse:

; 12618:     }
; 12619: 
; 12620:     /*
; 12621:      * plug some encoding conversion routines here.
; 12622:      */
; 12623:     if (xmlPushInput(ctxt, pinput) < 0) {

	mov	edx, DWORD PTR _pinput$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlPushInput
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN10@xmlIOParse

; 12624:         if (sax != NULL) ctxt->sax = NULL;

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN11@xmlIOParse
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], 0
$LN11@xmlIOParse:

; 12625: 	xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12626: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlIOParse
$LN10@xmlIOParse:

; 12627:     }
; 12628:     if (enc != XML_CHAR_ENCODING_NONE) {

	cmp	DWORD PTR _enc$[ebp], 0
	je	SHORT $LN12@xmlIOParse

; 12629:         xmlSwitchEncoding(ctxt, enc);

	mov	eax, DWORD PTR _enc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSwitchEncoding
	add	esp, 8
$LN12@xmlIOParse:

; 12630:     }
; 12631: 
; 12632:     pinput->filename = NULL;

	mov	edx, DWORD PTR _pinput$[ebp]
	mov	DWORD PTR [edx+4], 0

; 12633:     pinput->line = 1;

	mov	eax, DWORD PTR _pinput$[ebp]
	mov	DWORD PTR [eax+28], 1

; 12634:     pinput->col = 1;

	mov	ecx, DWORD PTR _pinput$[ebp]
	mov	DWORD PTR [ecx+32], 1

; 12635:     pinput->base = ctxt->input->cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _pinput$[ebp]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+12], edx

; 12636:     pinput->cur = ctxt->input->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _pinput$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax

; 12637:     pinput->free = NULL;

	mov	ecx, DWORD PTR _pinput$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 12638: 
; 12639:     /*
; 12640:      * let's parse that entity knowing it's an external subset.
; 12641:      */
; 12642:     ctxt->inSubset = 2;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+216], 2

; 12643:     ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 12644:     if (ctxt->myDoc == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN13@xmlIOParse

; 12645: 	xmlErrMemory(ctxt, "New Doc failed");

	push	OFFSET ??_C@_0P@IDBIGKBI@New?5Doc?5failed@
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlErrMemory
	add	esp, 8

; 12646: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlIOParse
$LN13@xmlIOParse:

; 12647:     }
; 12648:     ctxt->myDoc->properties = XML_DOC_INTERNAL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+92], 64			; 00000040H

; 12649:     ctxt->myDoc->extSubset = xmlNewDtd(ctxt->myDoc, BAD_CAST "none",

	push	OFFSET ??_C@_04CGFJFPFD@none@
	push	OFFSET ??_C@_04CGFJFPFD@none@
	push	OFFSET ??_C@_04CGFJFPFD@none@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlNewDtd
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+48], eax

; 12650: 	                               BAD_CAST "none", BAD_CAST "none");
; 12651: 
; 12652:     if ((enc == XML_CHAR_ENCODING_NONE) &&

	cmp	DWORD PTR _enc$[ebp], 0
	jne	$LN14@xmlIOParse
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 4
	jl	$LN14@xmlIOParse

; 12653:         ((ctxt->input->end - ctxt->input->cur) >= 4)) {
; 12654: 	/*
; 12655: 	 * Get the 4 first bytes and decode the charset
; 12656: 	 * if enc != XML_CHAR_ENCODING_NONE
; 12657: 	 * plug some encoding conversion routines.
; 12658: 	 */
; 12659: 	start[0] = RAW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR _start$[ebp+edx], al

; 12660: 	start[1] = NXT(1);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR [eax+ecx]
	mov	BYTE PTR _start$[ebp+edx], al

; 12661: 	start[2] = NXT(2);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, 1
	shl	edx, 1
	mov	al, BYTE PTR [eax+ecx]
	mov	BYTE PTR _start$[ebp+edx], al

; 12662: 	start[3] = NXT(3);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	mov	eax, 1
	imul	eax, eax, 3
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR _start$[ebp+eax], cl

; 12663: 	enc = xmlDetectCharEncoding(start, 4);

	push	4
	lea	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$[ebp], eax

; 12664: 	if (enc != XML_CHAR_ENCODING_NONE) {

	cmp	DWORD PTR _enc$[ebp], 0
	je	SHORT $LN14@xmlIOParse

; 12665: 	    xmlSwitchEncoding(ctxt, enc);

	mov	eax, DWORD PTR _enc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSwitchEncoding
	add	esp, 8
$LN14@xmlIOParse:

; 12666: 	}
; 12667:     }
; 12668: 
; 12669:     xmlParseExternalSubset(ctxt, BAD_CAST "none", BAD_CAST "none");

	push	OFFSET ??_C@_04CGFJFPFD@none@
	push	OFFSET ??_C@_04CGFJFPFD@none@
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseExternalSubset
	add	esp, 12					; 0000000cH

; 12670: 
; 12671:     if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN16@xmlIOParse

; 12672: 	if (ctxt->wellFormed) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN17@xmlIOParse

; 12673: 	    ret = ctxt->myDoc->extSubset;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _ret$[ebp], ecx

; 12674: 	    ctxt->myDoc->extSubset = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+48], 0

; 12675: 	    if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN19@xmlIOParse

; 12676: 		xmlNodePtr tmp;
; 12677: 
; 12678: 		ret->doc = NULL;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 12679: 		tmp = ret->children;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _tmp$1[ebp], eax
$LN2@xmlIOParse:

; 12680: 		while (tmp != NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	je	SHORT $LN19@xmlIOParse

; 12681: 		    tmp->doc = NULL;

	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [ecx+32], 0

; 12682: 		    tmp = tmp->next;

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _tmp$1[ebp], eax

; 12683: 		}

	jmp	SHORT $LN2@xmlIOParse
$LN19@xmlIOParse:

; 12684: 	    }
; 12685: 	} else {

	jmp	SHORT $LN18@xmlIOParse
$LN17@xmlIOParse:

; 12686: 	    ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0
$LN18@xmlIOParse:

; 12687: 	}
; 12688:         xmlFreeDoc(ctxt->myDoc);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 12689:         ctxt->myDoc = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN16@xmlIOParse:

; 12690:     }
; 12691:     if (sax != NULL) ctxt->sax = NULL;

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN20@xmlIOParse
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], 0
$LN20@xmlIOParse:

; 12692:     xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12693: 
; 12694:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlIOParse:

; 12695: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@xmlIOParse
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN24@xmlIOParse:
	DD	1
	DD	$LN23@xmlIOParse
$LN23@xmlIOParse:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN22@xmlIOParse
$LN22@xmlIOParse:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
_xmlIOParseDTD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseDTD
_TEXT	SEGMENT
_ExternalID$ = 8					; size = 4
_SystemID$ = 12						; size = 4
_xmlParseDTD PROC					; COMDAT

; 12840: xmlParseDTD(const xmlChar *ExternalID, const xmlChar *SystemID) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 12841:     return(xmlSAXParseDTD(NULL, ExternalID, SystemID));

	mov	eax, DWORD PTR _SystemID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ExternalID$[ebp]
	push	ecx
	push	0
	call	_xmlSAXParseDTD
	add	esp, 12					; 0000000cH

; 12842: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseDTD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseDTD
_TEXT	SEGMENT
_tmp$1 = -24						; size = 4
_systemIdCanonic$ = -20					; size = 4
_enc$ = -16						; size = 4
_input$ = -12						; size = 4
_ctxt$ = -8						; size = 4
_ret$ = -4						; size = 4
_sax$ = 8						; size = 4
_ExternalID$ = 12					; size = 4
_SystemID$ = 16						; size = 4
_xmlSAXParseDTD PROC					; COMDAT

; 12710:                           const xmlChar *SystemID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 12711:     xmlDtdPtr ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 12712:     xmlParserCtxtPtr ctxt;
; 12713:     xmlParserInputPtr input = NULL;

	mov	DWORD PTR _input$[ebp], 0

; 12714:     xmlCharEncoding enc;
; 12715:     xmlChar* systemIdCanonic;
; 12716: 
; 12717:     if ((ExternalID == NULL) && (SystemID == NULL)) return(NULL);

	cmp	DWORD PTR _ExternalID$[ebp], 0
	jne	SHORT $LN4@xmlSAXPars
	cmp	DWORD PTR _SystemID$[ebp], 0
	jne	SHORT $LN4@xmlSAXPars
	xor	eax, eax
	jmp	$LN1@xmlSAXPars
$LN4@xmlSAXPars:

; 12718: 
; 12719:     ctxt = xmlNewParserCtxt();

	call	_xmlNewParserCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 12720:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN5@xmlSAXPars

; 12721: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSAXPars
$LN5@xmlSAXPars:

; 12722:     }
; 12723: 
; 12724:     /* We are loading a DTD */
; 12725:     ctxt->options |= XML_PARSE_DTDLOAD;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	or	ecx, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+360], ecx

; 12726: 
; 12727:     /*
; 12728:      * Set-up the SAX context
; 12729:      */
; 12730:     if (sax != NULL) {

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN6@xmlSAXPars

; 12731: 	if (ctxt->sax != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@xmlSAXPars

; 12732: 	    xmlFree(ctxt->sax);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlSAXPars:

; 12733:         ctxt->sax = sax;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [eax], ecx

; 12734:         ctxt->userData = ctxt;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN6@xmlSAXPars:

; 12735:     }
; 12736: 
; 12737:     /*
; 12738:      * Canonicalise the system ID
; 12739:      */
; 12740:     systemIdCanonic = xmlCanonicPath(SystemID);

	mov	ecx, DWORD PTR _SystemID$[ebp]
	push	ecx
	call	_xmlCanonicPath
	add	esp, 4
	mov	DWORD PTR _systemIdCanonic$[ebp], eax

; 12741:     if ((SystemID != NULL) && (systemIdCanonic == NULL)) {

	cmp	DWORD PTR _SystemID$[ebp], 0
	je	SHORT $LN8@xmlSAXPars
	cmp	DWORD PTR _systemIdCanonic$[ebp], 0
	jne	SHORT $LN8@xmlSAXPars

; 12742: 	xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12743: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSAXPars
$LN8@xmlSAXPars:

; 12744:     }
; 12745: 
; 12746:     /*
; 12747:      * Ask the Entity resolver to load the damn thing
; 12748:      */
; 12749: 
; 12750:     if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@xmlSAXPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN9@xmlSAXPars

; 12751: 	input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,

	mov	esi, esp
	mov	eax, DWORD PTR _systemIdCanonic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ExternalID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _input$[ebp], eax
$LN9@xmlSAXPars:

; 12752: 	                                 systemIdCanonic);
; 12753:     if (input == NULL) {

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN10@xmlSAXPars

; 12754:         if (sax != NULL) ctxt->sax = NULL;

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN11@xmlSAXPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], 0
$LN11@xmlSAXPars:

; 12755: 	xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12756: 	if (systemIdCanonic != NULL)

	cmp	DWORD PTR _systemIdCanonic$[ebp], 0
	je	SHORT $LN12@xmlSAXPars

; 12757: 	    xmlFree(systemIdCanonic);

	mov	esi, esp
	mov	eax, DWORD PTR _systemIdCanonic$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlSAXPars:

; 12758: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSAXPars
$LN10@xmlSAXPars:

; 12759:     }
; 12760: 
; 12761:     /*
; 12762:      * plug some encoding conversion routines here.
; 12763:      */
; 12764:     if (xmlPushInput(ctxt, input) < 0) {

	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlPushInput
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN13@xmlSAXPars

; 12765:         if (sax != NULL) ctxt->sax = NULL;

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN14@xmlSAXPars
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], 0
$LN14@xmlSAXPars:

; 12766: 	xmlFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12767: 	if (systemIdCanonic != NULL)

	cmp	DWORD PTR _systemIdCanonic$[ebp], 0
	je	SHORT $LN15@xmlSAXPars

; 12768: 	    xmlFree(systemIdCanonic);

	mov	esi, esp
	mov	edx, DWORD PTR _systemIdCanonic$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlSAXPars:

; 12769: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSAXPars
$LN13@xmlSAXPars:

; 12770:     }
; 12771:     if ((ctxt->input->end - ctxt->input->cur) >= 4) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 4
	jl	SHORT $LN16@xmlSAXPars

; 12772: 	enc = xmlDetectCharEncoding(ctxt->input->cur, 4);

	push	4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$[ebp], eax

; 12773: 	xmlSwitchEncoding(ctxt, enc);

	mov	edx, DWORD PTR _enc$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSwitchEncoding
	add	esp, 8
$LN16@xmlSAXPars:

; 12774:     }
; 12775: 
; 12776:     if (input->filename == NULL)

	mov	ecx, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN17@xmlSAXPars

; 12777: 	input->filename = (char *) systemIdCanonic;

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR _systemIdCanonic$[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	SHORT $LN18@xmlSAXPars
$LN17@xmlSAXPars:

; 12778:     else
; 12779: 	xmlFree(systemIdCanonic);

	mov	esi, esp
	mov	ecx, DWORD PTR _systemIdCanonic$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@xmlSAXPars:

; 12780:     input->line = 1;

	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx+28], 1

; 12781:     input->col = 1;

	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+32], 1

; 12782:     input->base = ctxt->input->cur;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+12], ecx

; 12783:     input->cur = ctxt->input->cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx

; 12784:     input->free = NULL;

	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+40], 0

; 12785: 
; 12786:     /*
; 12787:      * let's parse that entity knowing it's an external subset.
; 12788:      */
; 12789:     ctxt->inSubset = 2;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+216], 2

; 12790:     ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0");

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlNewDoc
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], eax

; 12791:     if (ctxt->myDoc == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN19@xmlSAXPars

; 12792: 	xmlErrMemory(ctxt, "New Doc failed");

	push	OFFSET ??_C@_0P@IDBIGKBI@New?5Doc?5failed@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlErrMemory
	add	esp, 8

; 12793:         if (sax != NULL) ctxt->sax = NULL;

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN20@xmlSAXPars
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], 0
$LN20@xmlSAXPars:

; 12794: 	xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12795: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSAXPars
$LN19@xmlSAXPars:

; 12796:     }
; 12797:     ctxt->myDoc->properties = XML_DOC_INTERNAL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+92], 64			; 00000040H

; 12798:     ctxt->myDoc->extSubset = xmlNewDtd(ctxt->myDoc, BAD_CAST "none",

	mov	eax, DWORD PTR _SystemID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ExternalID$[ebp]
	push	ecx
	push	OFFSET ??_C@_04CGFJFPFD@none@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlNewDtd
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+48], eax

; 12799: 	                               ExternalID, SystemID);
; 12800:     xmlParseExternalSubset(ctxt, ExternalID, SystemID);

	mov	eax, DWORD PTR _SystemID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ExternalID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseExternalSubset
	add	esp, 12					; 0000000cH

; 12801: 
; 12802:     if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN21@xmlSAXPars

; 12803: 	if (ctxt->wellFormed) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN22@xmlSAXPars

; 12804: 	    ret = ctxt->myDoc->extSubset;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _ret$[ebp], ecx

; 12805: 	    ctxt->myDoc->extSubset = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+48], 0

; 12806: 	    if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN24@xmlSAXPars

; 12807: 		xmlNodePtr tmp;
; 12808: 
; 12809: 		ret->doc = NULL;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 12810: 		tmp = ret->children;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _tmp$1[ebp], eax
$LN2@xmlSAXPars:

; 12811: 		while (tmp != NULL) {

	cmp	DWORD PTR _tmp$1[ebp], 0
	je	SHORT $LN24@xmlSAXPars

; 12812: 		    tmp->doc = NULL;

	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [ecx+32], 0

; 12813: 		    tmp = tmp->next;

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _tmp$1[ebp], eax

; 12814: 		}

	jmp	SHORT $LN2@xmlSAXPars
$LN24@xmlSAXPars:

; 12815: 	    }
; 12816: 	} else {

	jmp	SHORT $LN23@xmlSAXPars
$LN22@xmlSAXPars:

; 12817: 	    ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0
$LN23@xmlSAXPars:

; 12818: 	}
; 12819:         xmlFreeDoc(ctxt->myDoc);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 12820:         ctxt->myDoc = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN21@xmlSAXPars:

; 12821:     }
; 12822:     if (sax != NULL) ctxt->sax = NULL;

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN25@xmlSAXPars
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], 0
$LN25@xmlSAXPars:

; 12823:     xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 12824: 
; 12825:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSAXPars:

; 12826: }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAXParseDTD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseEntity
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlParseEntity PROC					; COMDAT

; 13971: xmlParseEntity(const char *filename) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 13972:     return(xmlSAXParseEntity(NULL, filename));

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	0
	call	_xmlSAXParseEntity
	add	esp, 8

; 13973: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseEntity
_TEXT	SEGMENT
_ctxt$ = -8						; size = 4
_ret$ = -4						; size = 4
_sax$ = 8						; size = 4
_filename$ = 12						; size = 4
_xmlSAXParseEntity PROC					; COMDAT

; 13926: xmlSAXParseEntity(xmlSAXHandlerPtr sax, const char *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 13927:     xmlDocPtr ret;
; 13928:     xmlParserCtxtPtr ctxt;
; 13929: 
; 13930:     ctxt = xmlCreateFileParserCtxt(filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlCreateFileParserCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 13931:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlSAXPars

; 13932: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSAXPars
$LN2@xmlSAXPars:

; 13933:     }
; 13934:     if (sax != NULL) {

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN3@xmlSAXPars

; 13935: 	if (ctxt->sax != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@xmlSAXPars

; 13936: 	    xmlFree(ctxt->sax);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlSAXPars:

; 13937:         ctxt->sax = sax;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [ecx], edx

; 13938:         ctxt->userData = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@xmlSAXPars:

; 13939:     }
; 13940: 
; 13941:     xmlParseExtParsedEnt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseExtParsedEnt
	add	esp, 4

; 13942: 
; 13943:     if (ctxt->wellFormed)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@xmlSAXPars

; 13944: 	ret = ctxt->myDoc;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ret$[ebp], ecx
	jmp	SHORT $LN6@xmlSAXPars
$LN5@xmlSAXPars:

; 13945:     else {
; 13946:         ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 13947:         xmlFreeDoc(ctxt->myDoc);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 13948:         ctxt->myDoc = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN6@xmlSAXPars:

; 13949:     }
; 13950:     if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN7@xmlSAXPars

; 13951:         ctxt->sax = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], 0
$LN7@xmlSAXPars:

; 13952:     xmlFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeParserCtxt
	add	esp, 4

; 13953: 
; 13954:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSAXPars:

; 13955: }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAXParseEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseFileWithData
_TEXT	SEGMENT
_ctxt$ = -8						; size = 4
_ret$ = -4						; size = 4
_sax$ = 8						; size = 4
_filename$ = 12						; size = 4
_recovery$ = 16						; size = 4
_data$ = 20						; size = 4
_xmlSAXParseFileWithData PROC				; COMDAT

; 14152:                         int recovery, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14153:     xmlDocPtr ret;
; 14154:     xmlParserCtxtPtr ctxt;
; 14155: 
; 14156:     xmlInitParser();

	call	_xmlInitParser

; 14157: 
; 14158:     ctxt = xmlCreateFileParserCtxt(filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlCreateFileParserCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 14159:     if (ctxt == NULL) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlSAXPars

; 14160: 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSAXPars
$LN2@xmlSAXPars:

; 14161:     }
; 14162:     if (sax != NULL) {

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN3@xmlSAXPars

; 14163: 	if (ctxt->sax != NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@xmlSAXPars

; 14164: 	    xmlFree(ctxt->sax);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlSAXPars:

; 14165:         ctxt->sax = sax;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [ecx], edx
$LN3@xmlSAXPars:

; 14166:     }
; 14167:     xmlDetectSAX2(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDetectSAX2
	add	esp, 4

; 14168:     if (data!=NULL) {

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN5@xmlSAXPars

; 14169: 	ctxt->_private = data;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [ecx+272], edx
$LN5@xmlSAXPars:

; 14170:     }
; 14171: 
; 14172:     if (ctxt->directory == NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+180], 0
	jne	SHORT $LN6@xmlSAXPars

; 14173:         ctxt->directory = xmlParserGetDirectory(filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlParserGetDirectory
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+180], eax
$LN6@xmlSAXPars:

; 14174: 
; 14175:     ctxt->recovery = recovery;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _recovery$[ebp]
	mov	DWORD PTR [eax+288], ecx

; 14176: 
; 14177:     xmlParseDocument(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseDocument
	add	esp, 4

; 14178: 
; 14179:     if ((ctxt->wellFormed) || recovery) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN9@xmlSAXPars
	cmp	DWORD PTR _recovery$[ebp], 0
	je	SHORT $LN7@xmlSAXPars
$LN9@xmlSAXPars:

; 14180:         ret = ctxt->myDoc;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _ret$[ebp], edx

; 14181: 	if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN10@xmlSAXPars

; 14182: 	    if (ctxt->input->buf->compressed > 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+24], 0
	jle	SHORT $LN11@xmlSAXPars

; 14183: 		ret->compression = 9;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+36], 9
	jmp	SHORT $LN10@xmlSAXPars
$LN11@xmlSAXPars:

; 14184: 	    else
; 14185: 		ret->compression = ctxt->input->buf->compressed;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+36], edx
$LN10@xmlSAXPars:

; 14186: 	}
; 14187:     }

	jmp	SHORT $LN8@xmlSAXPars
$LN7@xmlSAXPars:

; 14188:     else {
; 14189:        ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 14190:        xmlFreeDoc(ctxt->myDoc);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 14191:        ctxt->myDoc = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 0
$LN8@xmlSAXPars:

; 14192:     }
; 14193:     if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN13@xmlSAXPars

; 14194:         ctxt->sax = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], 0
$LN13@xmlSAXPars:

; 14195:     xmlFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14196: 
; 14197:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSAXPars:

; 14198: }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAXParseFileWithData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseFile
_TEXT	SEGMENT
_sax$ = 8						; size = 4
_filename$ = 12						; size = 4
_recovery$ = 16						; size = 4
_xmlSAXParseFile PROC					; COMDAT

; 14217:                           int recovery) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14218:     return(xmlSAXParseFileWithData(sax,filename,recovery,NULL));

	push	0
	mov	eax, DWORD PTR _recovery$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sax$[ebp]
	push	edx
	call	_xmlSAXParseFileWithData
	add	esp, 16					; 00000010H

; 14219: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSAXParseFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseMemoryWithData
_TEXT	SEGMENT
_ctxt$ = -8						; size = 4
_ret$ = -4						; size = 4
_sax$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_recovery$ = 20						; size = 4
_data$ = 24						; size = 4
_xmlSAXParseMemoryWithData PROC				; COMDAT

; 14429: 	          int size, int recovery, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14430:     xmlDocPtr ret;
; 14431:     xmlParserCtxtPtr ctxt;
; 14432: 
; 14433:     xmlInitParser();

	call	_xmlInitParser

; 14434: 
; 14435:     ctxt = xmlCreateMemoryParserCtxt(buffer, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlCreateMemoryParserCtxt
	add	esp, 8
	mov	DWORD PTR _ctxt$[ebp], eax

; 14436:     if (ctxt == NULL) return(NULL);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlSAXPars
	xor	eax, eax
	jmp	$LN1@xmlSAXPars
$LN2@xmlSAXPars:

; 14437:     if (sax != NULL) {

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN3@xmlSAXPars

; 14438: 	if (ctxt->sax != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN4@xmlSAXPars

; 14439: 	    xmlFree(ctxt->sax);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlSAXPars:

; 14440:         ctxt->sax = sax;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [edx], eax
$LN3@xmlSAXPars:

; 14441:     }
; 14442:     xmlDetectSAX2(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDetectSAX2
	add	esp, 4

; 14443:     if (data!=NULL) {

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN5@xmlSAXPars

; 14444: 	ctxt->_private=data;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR [edx+272], eax
$LN5@xmlSAXPars:

; 14445:     }
; 14446: 
; 14447:     ctxt->recovery = recovery;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _recovery$[ebp]
	mov	DWORD PTR [ecx+288], edx

; 14448: 
; 14449:     xmlParseDocument(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseDocument
	add	esp, 4

; 14450: 
; 14451:     if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN8@xmlSAXPars
	cmp	DWORD PTR _recovery$[ebp], 0
	je	SHORT $LN6@xmlSAXPars
$LN8@xmlSAXPars:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN7@xmlSAXPars
$LN6@xmlSAXPars:

; 14452:     else {
; 14453:        ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 14454:        xmlFreeDoc(ctxt->myDoc);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 14455:        ctxt->myDoc = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN7@xmlSAXPars:

; 14456:     }
; 14457:     if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN9@xmlSAXPars

; 14458: 	ctxt->sax = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], 0
$LN9@xmlSAXPars:

; 14459:     xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14460: 
; 14461:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSAXPars:

; 14462: }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAXParseMemoryWithData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseMemory
_TEXT	SEGMENT
_sax$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_recovery$ = 20						; size = 4
_xmlSAXParseMemory PROC					; COMDAT

; 14480: 	          int size, int recovery) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14481:     return xmlSAXParseMemoryWithData(sax, buffer, size, recovery, NULL);

	push	0
	mov	eax, DWORD PTR _recovery$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _sax$[ebp]
	push	eax
	call	_xmlSAXParseMemoryWithData
	add	esp, 20					; 00000014H

; 14482: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSAXParseMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXParseDoc
_TEXT	SEGMENT
_oldsax$ = -12						; size = 4
_ctxt$ = -8						; size = 4
_ret$ = -4						; size = 4
_sax$ = 8						; size = 4
_cur$ = 12						; size = 4
_recovery$ = 16						; size = 4
_xmlSAXParseDoc PROC					; COMDAT

; 14599: xmlSAXParseDoc(xmlSAXHandlerPtr sax, const xmlChar *cur, int recovery) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14600:     xmlDocPtr ret;
; 14601:     xmlParserCtxtPtr ctxt;
; 14602:     xmlSAXHandlerPtr oldsax = NULL;

	mov	DWORD PTR _oldsax$[ebp], 0

; 14603: 
; 14604:     if (cur == NULL) return(NULL);

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlSAXPars
	xor	eax, eax
	jmp	$LN1@xmlSAXPars
$LN2@xmlSAXPars:

; 14605: 
; 14606: 
; 14607:     ctxt = xmlCreateDocParserCtxt(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlCreateDocParserCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 14608:     if (ctxt == NULL) return(NULL);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlSAXPars
	xor	eax, eax
	jmp	$LN1@xmlSAXPars
$LN3@xmlSAXPars:

; 14609:     if (sax != NULL) {

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN4@xmlSAXPars

; 14610:         oldsax = ctxt->sax;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _oldsax$[ebp], edx

; 14611:         ctxt->sax = sax;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [eax], ecx

; 14612:         ctxt->userData = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+4], 0
$LN4@xmlSAXPars:

; 14613:     }
; 14614:     xmlDetectSAX2(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDetectSAX2
	add	esp, 4

; 14615: 
; 14616:     xmlParseDocument(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseDocument
	add	esp, 4

; 14617:     if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN7@xmlSAXPars
	cmp	DWORD PTR _recovery$[ebp], 0
	je	SHORT $LN5@xmlSAXPars
$LN7@xmlSAXPars:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ret$[ebp], ecx
	jmp	SHORT $LN6@xmlSAXPars
$LN5@xmlSAXPars:

; 14618:     else {
; 14619:        ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 14620:        xmlFreeDoc(ctxt->myDoc);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 14621:        ctxt->myDoc = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN6@xmlSAXPars:

; 14622:     }
; 14623:     if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN8@xmlSAXPars

; 14624: 	ctxt->sax = oldsax;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _oldsax$[ebp]
	mov	DWORD PTR [edx], eax
$LN8@xmlSAXPars:

; 14625:     xmlFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14626: 
; 14627:     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSAXPars:

; 14628: }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAXParseDoc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXUserParseMemory
_TEXT	SEGMENT
_ctxt$ = -8						; size = 4
_ret$ = -4						; size = 4
_sax$ = 8						; size = 4
_user_data$ = 12					; size = 4
_buffer$ = 16						; size = 4
_size$ = 20						; size = 4
_xmlSAXUserParseMemory PROC				; COMDAT

; 14527: 			  const char *buffer, int size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14528:     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 14529:     xmlParserCtxtPtr ctxt;
; 14530: 
; 14531:     xmlInitParser();

	call	_xmlInitParser

; 14532: 
; 14533:     ctxt = xmlCreateMemoryParserCtxt(buffer, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_xmlCreateMemoryParserCtxt
	add	esp, 8
	mov	DWORD PTR _ctxt$[ebp], eax

; 14534:     if (ctxt == NULL) return -1;

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlSAXUser
	or	eax, -1
	jmp	$LN1@xmlSAXUser
$LN2@xmlSAXUser:

; 14535:     if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)

	call	___xmlDefaultSAXHandler
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], eax
	je	SHORT $LN3@xmlSAXUser

; 14536:         xmlFree(ctxt->sax);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlSAXUser:

; 14537:     ctxt->sax = sax;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [edx], eax

; 14538:     xmlDetectSAX2(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDetectSAX2
	add	esp, 4

; 14539: 
; 14540:     if (user_data != NULL)

	cmp	DWORD PTR _user_data$[ebp], 0
	je	SHORT $LN4@xmlSAXUser

; 14541: 	ctxt->userData = user_data;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN4@xmlSAXUser:

; 14542: 
; 14543:     xmlParseDocument(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseDocument
	add	esp, 4

; 14544: 
; 14545:     if (ctxt->wellFormed)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@xmlSAXUser

; 14546: 	ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN6@xmlSAXUser
$LN5@xmlSAXUser:

; 14547:     else {
; 14548:         if (ctxt->errNo != 0)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN7@xmlSAXUser

; 14549: 	    ret = ctxt->errNo;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _ret$[ebp], edx
	jmp	SHORT $LN6@xmlSAXUser
$LN7@xmlSAXUser:

; 14550: 	else
; 14551: 	    ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
$LN6@xmlSAXUser:

; 14552:     }
; 14553:     if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN9@xmlSAXUser

; 14554:         ctxt->sax = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], 0
$LN9@xmlSAXUser:

; 14555:     if (ctxt->myDoc != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN10@xmlSAXUser

; 14556:         xmlFreeDoc(ctxt->myDoc);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 14557: 	ctxt->myDoc = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN10@xmlSAXUser:

; 14558:     }
; 14559:     xmlFreeParserCtxt(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14560: 
; 14561:     return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSAXUser:

; 14562: }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAXUserParseMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlSAXUserParseFile
_TEXT	SEGMENT
_ctxt$ = -8						; size = 4
_ret$ = -4						; size = 4
_sax$ = 8						; size = 4
_user_data$ = 12					; size = 4
_filename$ = 16						; size = 4
_xmlSAXUserParseFile PROC				; COMDAT

; 14319:                     const char *filename) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14320:     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 14321:     xmlParserCtxtPtr ctxt;
; 14322: 
; 14323:     ctxt = xmlCreateFileParserCtxt(filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlCreateFileParserCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 14324:     if (ctxt == NULL) return -1;

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlSAXUser
	or	eax, -1
	jmp	$LN1@xmlSAXUser
$LN2@xmlSAXUser:

; 14325:     if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)

	call	___xmlDefaultSAXHandler
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN3@xmlSAXUser

; 14326: 	xmlFree(ctxt->sax);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlSAXUser:

; 14327:     ctxt->sax = sax;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _sax$[ebp]
	mov	DWORD PTR [ecx], edx

; 14328:     xmlDetectSAX2(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDetectSAX2
	add	esp, 4

; 14329: 
; 14330:     if (user_data != NULL)

	cmp	DWORD PTR _user_data$[ebp], 0
	je	SHORT $LN4@xmlSAXUser

; 14331: 	ctxt->userData = user_data;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN4@xmlSAXUser:

; 14332: 
; 14333:     xmlParseDocument(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseDocument
	add	esp, 4

; 14334: 
; 14335:     if (ctxt->wellFormed)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN5@xmlSAXUser

; 14336: 	ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN6@xmlSAXUser
$LN5@xmlSAXUser:

; 14337:     else {
; 14338:         if (ctxt->errNo != 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+84], 0
	je	SHORT $LN7@xmlSAXUser

; 14339: 	    ret = ctxt->errNo;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _ret$[ebp], ecx
	jmp	SHORT $LN6@xmlSAXUser
$LN7@xmlSAXUser:

; 14340: 	else
; 14341: 	    ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
$LN6@xmlSAXUser:

; 14342:     }
; 14343:     if (sax != NULL)

	cmp	DWORD PTR _sax$[ebp], 0
	je	SHORT $LN9@xmlSAXUser

; 14344: 	ctxt->sax = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], 0
$LN9@xmlSAXUser:

; 14345:     if (ctxt->myDoc != NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN10@xmlSAXUser

; 14346:         xmlFreeDoc(ctxt->myDoc);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 14347: 	ctxt->myDoc = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN10@xmlSAXUser:

; 14348:     }
; 14349:     xmlFreeParserCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeParserCtxt
	add	esp, 4

; 14350: 
; 14351:     return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSAXUser:

; 14352: }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSAXUserParseFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseExtParsedEnt
_TEXT	SEGMENT
_enc$ = -16						; size = 4
_start$ = -8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseExtParsedEnt PROC				; COMDAT

; 10774: xmlParseExtParsedEnt(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 10775:     xmlChar start[4];
; 10776:     xmlCharEncoding enc;
; 10777: 
; 10778:     if ((ctxt == NULL) || (ctxt->input == NULL))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN2@xmlParseEx
$LN3@xmlParseEx:

; 10779:         return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseEx
$LN2@xmlParseEx:

; 10780: 
; 10781:     xmlDefaultSAXHandlerInit();

	call	_xmlDefaultSAXHandlerInit

; 10782: 
; 10783:     xmlDetectSAX2(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDetectSAX2
	add	esp, 4

; 10784: 
; 10785:     GROW;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+292], 0
	jne	SHORT $LN4@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx+20]
	sub	ecx, DWORD PTR [eax+16]
	cmp	ecx, 250				; 000000faH
	jge	SHORT $LN4@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseEx:

; 10786: 
; 10787:     /*
; 10788:      * SAX: beginning of the document processing.
; 10789:      */
; 10790:     if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN5@xmlParseEx

; 10791:         ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);

	call	___xmlDefaultSAXLocator
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlParseEx:

; 10792: 
; 10793:     /*
; 10794:      * Get the 4 first bytes and decode the charset
; 10795:      * if enc != XML_CHAR_ENCODING_NONE
; 10796:      * plug some encoding conversion routines.
; 10797:      */
; 10798:     if ((ctxt->input->end - ctxt->input->cur) >= 4) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 4
	jl	$LN6@xmlParseEx

; 10799: 	start[0] = RAW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR _start$[ebp+edx], al

; 10800: 	start[1] = NXT(1);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR [eax+ecx]
	mov	BYTE PTR _start$[ebp+edx], al

; 10801: 	start[2] = NXT(2);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, 1
	shl	edx, 1
	mov	al, BYTE PTR [eax+ecx]
	mov	BYTE PTR _start$[ebp+edx], al

; 10802: 	start[3] = NXT(3);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR [edx+16]
	mov	eax, 1
	imul	eax, eax, 3
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR _start$[ebp+eax], cl

; 10803: 	enc = xmlDetectCharEncoding(start, 4);

	push	4
	lea	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$[ebp], eax

; 10804: 	if (enc != XML_CHAR_ENCODING_NONE) {

	cmp	DWORD PTR _enc$[ebp], 0
	je	SHORT $LN6@xmlParseEx

; 10805: 	    xmlSwitchEncoding(ctxt, enc);

	mov	eax, DWORD PTR _enc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSwitchEncoding
	add	esp, 8
$LN6@xmlParseEx:

; 10806: 	}
; 10807:     }
; 10808: 
; 10809: 
; 10810:     if (CUR == 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN8@xmlParseEx

; 10811: 	xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);

	push	0
	push	4
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN8@xmlParseEx:

; 10812:     }
; 10813: 
; 10814:     /*
; 10815:      * Check for the XMLDecl in the Prolog.
; 10816:      */
; 10817:     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN9@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN9@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN9@xmlParseEx:

; 10818:     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 60					; 0000003cH
	jne	$LN10@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 63					; 0000003fH
	jne	$LN10@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	jne	$LN10@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 109				; 0000006dH
	jne	$LN10@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 108				; 0000006cH
	jne	$LN10@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN12@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 9
	jl	SHORT $LN13@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN12@xmlParseEx
$LN13@xmlParseEx:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN10@xmlParseEx
$LN12@xmlParseEx:

; 10819: 
; 10820: 	/*
; 10821: 	 * Note that we will switch encoding on the fly.
; 10822: 	 */
; 10823: 	xmlParseXMLDecl(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseXMLDecl
	add	esp, 4

; 10824: 	if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 32			; 00000020H
	jne	SHORT $LN14@xmlParseEx

; 10825: 	    /*
; 10826: 	     * The XML REC instructs us to stop parsing right here
; 10827: 	     */
; 10828: 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseEx
$LN14@xmlParseEx:

; 10829: 	}
; 10830: 	SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlSkipBlankChars
	add	esp, 4

; 10831:     } else {

	jmp	SHORT $LN11@xmlParseEx
$LN10@xmlParseEx:

; 10832: 	ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlCharStrdup
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+20], eax
$LN11@xmlParseEx:

; 10833:     }
; 10834:     if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN15@xmlParseEx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN15@xmlParseEx
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+212], 0
	jne	SHORT $LN15@xmlParseEx

; 10835:         ctxt->sax->startDocument(ctxt->userData);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlParseEx:

; 10836:     if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN16@xmlParseEx

; 10837: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseEx
$LN16@xmlParseEx:

; 10838: 
; 10839:     /*
; 10840:      * Doing validity checking on chunk doesn't make sense
; 10841:      */
; 10842:     ctxt->instate = XML_PARSER_CONTENT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 7

; 10843:     ctxt->validate = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+104], 0

; 10844:     ctxt->loadsubset = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+276], 0

; 10845:     ctxt->depth = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+248], 0

; 10846: 
; 10847:     xmlParseContent(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseContent
	add	esp, 4

; 10848:     if (ctxt->instate == XML_PARSER_EOF)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+172], -1
	jne	SHORT $LN17@xmlParseEx

; 10849: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseEx
$LN17@xmlParseEx:

; 10850: 
; 10851:     if ((RAW == '<') && (NXT(1) == '/')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN18@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN18@xmlParseEx

; 10852: 	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);

	push	0
	push	85					; 00000055H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN19@xmlParseEx
$LN18@xmlParseEx:

; 10853:     } else if (RAW != 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN19@xmlParseEx

; 10854: 	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);

	push	0
	push	86					; 00000056H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN19@xmlParseEx:

; 10855:     }
; 10856: 
; 10857:     /*
; 10858:      * SAX: end of the document processing.
; 10859:      */
; 10860:     if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN21@xmlParseEx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN21@xmlParseEx

; 10861:         ctxt->sax->endDocument(ctxt->userData);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@xmlParseEx:

; 10862: 
; 10863:     if (! ctxt->wellFormed) return(-1);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN22@xmlParseEx
	or	eax, -1
	jmp	SHORT $LN1@xmlParseEx
$LN22@xmlParseEx:

; 10864:     return(0);

	xor	eax, eax
$LN1@xmlParseEx:

; 10865: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN26@xmlParseEx
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN26@xmlParseEx:
	DD	1
	DD	$LN25@xmlParseEx
$LN25@xmlParseEx:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN24@xmlParseEx
$LN24@xmlParseEx:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
_xmlParseExtParsedEnt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseDocument
_TEXT	SEGMENT
_enc$ = -16						; size = 4
_start$ = -8						; size = 4
_ctxt$ = 8						; size = 4
_xmlParseDocument PROC					; COMDAT

; 10581: xmlParseDocument(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 10582:     xmlChar start[4];
; 10583:     xmlCharEncoding enc;
; 10584: 
; 10585:     xmlInitParser();

	call	_xmlInitParser

; 10586: 
; 10587:     if ((ctxt == NULL) || (ctxt->input == NULL))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlParseDo
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN2@xmlParseDo
$LN3@xmlParseDo:

; 10588:         return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseDo
$LN2@xmlParseDo:

; 10589: 
; 10590:     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN4@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN4@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN4@xmlParseDo:

; 10591: 
; 10592:     /*
; 10593:      * SAX: detecting the level.
; 10594:      */
; 10595:     xmlDetectSAX2(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDetectSAX2
	add	esp, 4

; 10596: 
; 10597:     /*
; 10598:      * SAX: beginning of the document processing.
; 10599:      */
; 10600:     if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN5@xmlParseDo

; 10601:         ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);

	call	___xmlDefaultSAXLocator
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlParseDo:

; 10602:     if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN6@xmlParseDo

; 10603: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseDo
$LN6@xmlParseDo:

; 10604: 
; 10605:     if ((ctxt->encoding == NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	$LN7@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 4
	jl	$LN7@xmlParseDo

; 10606:         ((ctxt->input->end - ctxt->input->cur) >= 4)) {
; 10607: 	/*
; 10608: 	 * Get the 4 first bytes and decode the charset
; 10609: 	 * if enc != XML_CHAR_ENCODING_NONE
; 10610: 	 * plug some encoding conversion routines.
; 10611: 	 */
; 10612: 	start[0] = RAW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR _start$[ebp+ecx], dl

; 10613: 	start[1] = NXT(1);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, 1
	shl	ecx, 0
	mov	dl, BYTE PTR [edx+eax]
	mov	BYTE PTR _start$[ebp+ecx], dl

; 10614: 	start[2] = NXT(2);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, 1
	shl	ecx, 1
	mov	dl, BYTE PTR [edx+eax]
	mov	BYTE PTR _start$[ebp+ecx], dl

; 10615: 	start[3] = NXT(3);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	mov	edx, 1
	imul	edx, edx, 3
	mov	al, BYTE PTR [eax+ecx]
	mov	BYTE PTR _start$[ebp+edx], al

; 10616: 	enc = xmlDetectCharEncoding(&start[0], 4);

	push	4
	mov	ecx, 1
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _start$[ebp+edx]
	push	eax
	call	_xmlDetectCharEncoding
	add	esp, 8
	mov	DWORD PTR _enc$[ebp], eax

; 10617: 	if (enc != XML_CHAR_ENCODING_NONE) {

	cmp	DWORD PTR _enc$[ebp], 0
	je	SHORT $LN7@xmlParseDo

; 10618: 	    xmlSwitchEncoding(ctxt, enc);

	mov	ecx, DWORD PTR _enc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlSwitchEncoding
	add	esp, 8
$LN7@xmlParseDo:

; 10619: 	}
; 10620:     }
; 10621: 
; 10622: 
; 10623:     if (CUR == 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+16]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN9@xmlParseDo

; 10624: 	xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);

	push	0
	push	4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH

; 10625: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseDo
$LN9@xmlParseDo:

; 10626:     }
; 10627: 
; 10628:     /*
; 10629:      * Check for the XMLDecl in the Prolog.
; 10630:      * do not GROW here to avoid the detected encoder to decode more
; 10631:      * than just the first line, unless the amount of data is really
; 10632:      * too small to hold "<?xml version="1.0" encoding="foo"
; 10633:      */
; 10634:     if ((ctxt->input->end - ctxt->input->cur) < 35) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 35					; 00000023H
	jge	SHORT $LN10@xmlParseDo

; 10635:        GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN10@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN10@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN10@xmlParseDo:

; 10636:     }
; 10637:     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 60					; 0000003cH
	jne	$LN12@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 63					; 0000003fH
	jne	$LN12@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	jne	$LN12@xmlParseDo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR [ecx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 109				; 0000006dH
	jne	$LN12@xmlParseDo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 108				; 0000006cH
	jne	$LN12@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN14@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 9
	jl	SHORT $LN15@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN14@xmlParseDo
$LN15@xmlParseDo:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN12@xmlParseDo
$LN14@xmlParseDo:

; 10638: 
; 10639: 	/*
; 10640: 	 * Note that we will switch encoding on the fly.
; 10641: 	 */
; 10642: 	xmlParseXMLDecl(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseXMLDecl
	add	esp, 4

; 10643: 	if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+84], 32			; 00000020H
	je	SHORT $LN17@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN16@xmlParseDo
$LN17@xmlParseDo:

; 10644: 	    (ctxt->instate == XML_PARSER_EOF)) {
; 10645: 	    /*
; 10646: 	     * The XML REC instructs us to stop parsing right here
; 10647: 	     */
; 10648: 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseDo
$LN16@xmlParseDo:

; 10649: 	}
; 10650: 	ctxt->standalone = ctxt->input->standalone;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR [ecx+28], edx

; 10651: 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlSkipBlankChars
	add	esp, 4

; 10652:     } else {

	jmp	SHORT $LN13@xmlParseDo
$LN12@xmlParseDo:

; 10653: 	ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);

	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	call	_xmlCharStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN13@xmlParseDo:

; 10654:     }
; 10655:     if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN18@xmlParseDo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN18@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+212], 0
	jne	SHORT $LN18@xmlParseDo

; 10656:         ctxt->sax->startDocument(ctxt->userData);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@xmlParseDo:

; 10657:     if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN19@xmlParseDo

; 10658: 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseDo
$LN19@xmlParseDo:

; 10659:     if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&
; 10660:         (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN20@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN20@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN20@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+24], 0
	jl	SHORT $LN20@xmlParseDo

; 10661: 	ctxt->myDoc->compression = ctxt->input->buf->compressed;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+36], eax
$LN20@xmlParseDo:

; 10662:     }
; 10663: 
; 10664:     /*
; 10665:      * The Misc part of the Prolog
; 10666:      */
; 10667:     GROW;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	jne	SHORT $LN21@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	eax, 250				; 000000faH
	jge	SHORT $LN21@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlGROW
	add	esp, 4
$LN21@xmlParseDo:

; 10668:     xmlParseMisc(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseMisc
	add	esp, 4

; 10669: 
; 10670:     /*
; 10671:      * Then possibly doc type declaration(s) and more Misc
; 10672:      * (doctypedecl Misc*)?
; 10673:      */
; 10674:     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN22@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN22@xmlParseDo
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN22@xmlParseDo:

; 10675:     if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 60					; 0000003cH
	jne	$LN23@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 33					; 00000021H
	jne	$LN23@xmlParseDo
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 68					; 00000044H
	jne	$LN23@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR [eax+16]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 79					; 0000004fH
	jne	$LN23@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 67					; 00000043H
	jne	$LN23@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 84					; 00000054H
	jne	$LN23@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 89					; 00000059H
	jne	$LN23@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR [edx+16]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 80					; 00000050H
	jne	$LN23@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR [edx+16]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 69					; 00000045H
	jne	$LN23@xmlParseDo

; 10676: 
; 10677: 	ctxt->inSubset = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+216], 1

; 10678: 	xmlParseDocTypeDecl(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseDocTypeDecl
	add	esp, 4

; 10679: 	if (RAW == '[') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 91					; 0000005bH
	jne	SHORT $LN24@xmlParseDo

; 10680: 	    ctxt->instate = XML_PARSER_DTD;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 3

; 10681: 	    xmlParseInternalSubset(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseInternalSubset
	add	esp, 4

; 10682: 	    if (ctxt->instate == XML_PARSER_EOF)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+172], -1
	jne	SHORT $LN24@xmlParseDo

; 10683: 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseDo
$LN24@xmlParseDo:

; 10684: 	}
; 10685: 
; 10686: 	/*
; 10687: 	 * Create and update the external subset.
; 10688: 	 */
; 10689: 	ctxt->inSubset = 2;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+216], 2

; 10690: 	if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN26@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN26@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+212], 0
	jne	SHORT $LN26@xmlParseDo

; 10691: 	    (!ctxt->disableSAX))
; 10692: 	    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+104]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@xmlParseDo:

; 10693: 	                              ctxt->extSubSystem, ctxt->extSubURI);
; 10694: 	if (ctxt->instate == XML_PARSER_EOF)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+172], -1
	jne	SHORT $LN27@xmlParseDo

; 10695: 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlParseDo
$LN27@xmlParseDo:

; 10696: 	ctxt->inSubset = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+216], 0

; 10697: 
; 10698:         xmlCleanSpecialAttr(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCleanSpecialAttr
	add	esp, 4

; 10699: 
; 10700: 	ctxt->instate = XML_PARSER_PROLOG;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+172], 4

; 10701: 	xmlParseMisc(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlParseMisc
	add	esp, 4
$LN23@xmlParseDo:

; 10702:     }
; 10703: 
; 10704:     /*
; 10705:      * Time to start parsing the tree itself
; 10706:      */
; 10707:     GROW;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN28@xmlParseDo
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [edx+20]
	sub	edx, DWORD PTR [ecx+16]
	cmp	edx, 250				; 000000faH
	jge	SHORT $LN28@xmlParseDo
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlGROW
	add	esp, 4
$LN28@xmlParseDo:

; 10708:     if (RAW != '<') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	je	SHORT $LN29@xmlParseDo

; 10709: 	xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,

	push	OFFSET ??_C@_0CD@NCHPNICC@Start?5tag?5expected?0?5?8?$DM?8?5not?5fou@
	push	4
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErrMsg
	add	esp, 12					; 0000000cH

; 10710: 		       "Start tag expected, '<' not found\n");
; 10711:     } else {

	jmp	SHORT $LN30@xmlParseDo
$LN29@xmlParseDo:

; 10712: 	ctxt->instate = XML_PARSER_CONTENT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], 7

; 10713: 	xmlParseElement(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlParseElement
	add	esp, 4

; 10714: 	ctxt->instate = XML_PARSER_EPILOG;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+172], 14			; 0000000eH

; 10715: 
; 10716: 
; 10717: 	/*
; 10718: 	 * The Misc part at the end
; 10719: 	 */
; 10720: 	xmlParseMisc(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlParseMisc
	add	esp, 4

; 10721: 
; 10722: 	if (RAW != 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN31@xmlParseDo

; 10723: 	    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);

	push	0
	push	5
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlFatalErr
	add	esp, 12					; 0000000cH
$LN31@xmlParseDo:

; 10724: 	}
; 10725: 	ctxt->instate = XML_PARSER_EOF;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+172], -1
$LN30@xmlParseDo:

; 10726:     }
; 10727: 
; 10728:     /*
; 10729:      * SAX: end of the document processing.
; 10730:      */
; 10731:     if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN32@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN32@xmlParseDo

; 10732:         ctxt->sax->endDocument(ctxt->userData);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+52]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN32@xmlParseDo:

; 10733: 
; 10734:     /*
; 10735:      * Remove locally kept entity definitions if the tree was not built
; 10736:      */
; 10737:     if ((ctxt->myDoc != NULL) &&

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN33@xmlParseDo
	push	OFFSET ??_C@_0CA@CHJJOFGL@SAX?5compatibility?5mode?5document@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlParseDo

; 10738: 	(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
; 10739: 	xmlFreeDoc(ctxt->myDoc);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 10740: 	ctxt->myDoc = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN33@xmlParseDo:

; 10741:     }
; 10742: 
; 10743:     if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	$LN34@xmlParseDo
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN34@xmlParseDo

; 10744:         ctxt->myDoc->properties |= XML_DOC_WELLFORMED;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+92]
	or	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+92], edx

; 10745: 	if (ctxt->valid)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+100], 0
	je	SHORT $LN35@xmlParseDo

; 10746: 	    ctxt->myDoc->properties |= XML_DOC_DTDVALID;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+92]
	or	edx, 8
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+92], edx
$LN35@xmlParseDo:

; 10747: 	if (ctxt->nsWellFormed)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+356], 0
	je	SHORT $LN36@xmlParseDo

; 10748: 	    ctxt->myDoc->properties |= XML_DOC_NSVALID;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+92]
	or	edx, 2
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+92], edx
$LN36@xmlParseDo:

; 10749: 	if (ctxt->options & XML_PARSE_OLD10)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+360]
	and	eax, 131072				; 00020000H
	je	SHORT $LN34@xmlParseDo

; 10750: 	    ctxt->myDoc->properties |= XML_DOC_OLD10;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+92]
	or	eax, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+92], eax
$LN34@xmlParseDo:

; 10751:     }
; 10752:     if (! ctxt->wellFormed) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN38@xmlParseDo

; 10753: 	ctxt->valid = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 10754: 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlParseDo
$LN38@xmlParseDo:

; 10755:     }
; 10756:     return(0);

	xor	eax, eax
$LN1@xmlParseDo:

; 10757: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN42@xmlParseDo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@xmlParseDo:
	DD	1
	DD	$LN41@xmlParseDo
$LN41@xmlParseDo:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN40@xmlParseDo
$LN40@xmlParseDo:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
_xmlParseDocument ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlRecoverFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlRecoverFile PROC					; COMDAT

; 14266: xmlRecoverFile(const char *filename) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14267:     return(xmlSAXParseFile(NULL, filename, 1));

	push	1
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	0
	call	_xmlSAXParseFile
	add	esp, 12					; 0000000cH

; 14268: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRecoverFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlRecoverMemory
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlRecoverMemory PROC					; COMDAT

; 14510: xmlDocPtr xmlRecoverMemory(const char *buffer, int size) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14511:    return(xmlSAXParseMemory(NULL, buffer, size, 1));

	push	1
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	0
	call	_xmlSAXParseMemory
	add	esp, 16					; 00000010H

; 14512: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRecoverMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlRecoverDoc
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlRecoverDoc PROC					; COMDAT

; 14233: xmlRecoverDoc(const xmlChar *cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14234:     return(xmlSAXParseDoc(NULL, cur, 1));

	push	1
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	0
	call	_xmlSAXParseDoc
	add	esp, 12					; 0000000cH

; 14235: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRecoverDoc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlStopParser
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlStopParser PROC					; COMDAT

; 12485: xmlStopParser(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 12486:     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlStopPar

; 12487:         return;

	jmp	SHORT $LN1@xmlStopPar
$LN2@xmlStopPar:

; 12488:     xmlHaltParser(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlHaltParser
	add	esp, 4

; 12489:     ctxt->errNo = XML_ERR_USER_STOP;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+84], 111			; 0000006fH
$LN1@xmlStopPar:

; 12490: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlStopParser ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseMemory
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlParseMemory PROC					; COMDAT

; 14494: xmlDocPtr xmlParseMemory(const char *buffer, int size) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14495:    return(xmlSAXParseMemory(NULL, buffer, size, 0));

	push	0
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	0
	call	_xmlSAXParseMemory
	add	esp, 16					; 00000010H

; 14496: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_xmlParseFile PROC					; COMDAT

; 14249: xmlParseFile(const char *filename) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14250:     return(xmlSAXParseFile(NULL, filename, 0));

	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	0
	call	_xmlSAXParseFile
	add	esp, 12					; 0000000cH

; 14251: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlParseDoc
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlParseDoc PROC					; COMDAT

; 14640: xmlParseDoc(const xmlChar *cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14641:     return(xmlSAXParseDoc(NULL, cur, 0));

	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	push	0
	call	_xmlSAXParseDoc
	add	esp, 12					; 0000000cH

; 14642: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseDoc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlCleanupParser
_TEXT	SEGMENT
_xmlCleanupParser PROC					; COMDAT

; 14766: xmlCleanupParser(void) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14767:     if (!xmlParserInitialized)

	cmp	DWORD PTR _xmlParserInitialized, 0
	jne	SHORT $LN2@xmlCleanup

; 14768: 	return;

	jmp	SHORT $LN1@xmlCleanup
$LN2@xmlCleanup:

; 14769: 
; 14770:     xmlCleanupCharEncodingHandlers();

	call	_xmlCleanupCharEncodingHandlers

; 14771: #ifdef LIBXML_CATALOG_ENABLED
; 14772:     xmlCatalogCleanup();

	call	_xmlCatalogCleanup

; 14773: #endif
; 14774:     xmlDictCleanup();

	call	_xmlDictCleanup

; 14775:     xmlCleanupInputCallbacks();

	call	_xmlCleanupInputCallbacks

; 14776: #ifdef LIBXML_OUTPUT_ENABLED
; 14777:     xmlCleanupOutputCallbacks();

	call	_xmlCleanupOutputCallbacks

; 14778: #endif
; 14779: #ifdef LIBXML_SCHEMAS_ENABLED
; 14780:     xmlSchemaCleanupTypes();

	call	_xmlSchemaCleanupTypes

; 14781:     xmlRelaxNGCleanupTypes();

	call	_xmlRelaxNGCleanupTypes

; 14782: #endif
; 14783:     xmlResetLastError();

	call	_xmlResetLastError

; 14784:     xmlCleanupGlobals();

	call	_xmlCleanupGlobals

; 14785:     xmlCleanupThreads(); /* must be last if called not from the main thread */

	call	_xmlCleanupThreads

; 14786:     xmlCleanupMemory();

	call	_xmlCleanupMemory

; 14787:     xmlParserInitialized = 0;

	mov	DWORD PTR _xmlParserInitialized, 0
$LN1@xmlCleanup:

; 14788: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCleanupParser ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\parser.c
;	COMDAT _xmlInitParser
_TEXT	SEGMENT
_xmlInitParser PROC					; COMDAT

; 14708: xmlInitParser(void) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __B9AC27D5_parser@c
	call	@__CheckForDebuggerJustMyCode@4

; 14709:     if (xmlParserInitialized != 0)

	cmp	DWORD PTR _xmlParserInitialized, 0
	je	SHORT $LN2@xmlInitPar

; 14710: 	return;

	jmp	SHORT $LN1@xmlInitPar
$LN2@xmlInitPar:

; 14711: 
; 14712: #ifdef LIBXML_THREAD_ENABLED
; 14713:     __xmlGlobalInitMutexLock();

	call	___xmlGlobalInitMutexLock

; 14714:     if (xmlParserInitialized == 0) {

	cmp	DWORD PTR _xmlParserInitialized, 0
	jne	SHORT $LN3@xmlInitPar

; 14715: #endif
; 14716: 	xmlInitThreads();

	call	_xmlInitThreads

; 14717: 	xmlInitGlobals();

	call	_xmlInitGlobals

; 14718: 	if ((xmlGenericError == xmlGenericErrorDefaultFunc) ||

	call	___xmlGenericError
	cmp	DWORD PTR [eax], OFFSET _xmlGenericErrorDefaultFunc
	je	SHORT $LN5@xmlInitPar
	call	___xmlGenericError
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@xmlInitPar
$LN5@xmlInitPar:

; 14719: 	    (xmlGenericError == NULL))
; 14720: 	    initGenericErrorDefaultFunc(NULL);

	push	0
	call	_initGenericErrorDefaultFunc
	add	esp, 4
$LN4@xmlInitPar:

; 14721: 	xmlInitMemory();

	call	_xmlInitMemory

; 14722:         xmlInitializeDict();

	call	_xmlInitializeDict

; 14723: 	xmlInitCharEncodingHandlers();

	call	_xmlInitCharEncodingHandlers

; 14724: 	xmlDefaultSAXHandlerInit();

	call	_xmlDefaultSAXHandlerInit

; 14725: 	xmlRegisterDefaultInputCallbacks();

	call	_xmlRegisterDefaultInputCallbacks

; 14726: #ifdef LIBXML_OUTPUT_ENABLED
; 14727: 	xmlRegisterDefaultOutputCallbacks();

	call	_xmlRegisterDefaultOutputCallbacks

; 14728: #endif /* LIBXML_OUTPUT_ENABLED */
; 14729: #ifdef LIBXML_HTML_ENABLED
; 14730: 	htmlInitAutoClose();

	call	_htmlInitAutoClose

; 14731: 	htmlDefaultSAXHandlerInit();

	call	_htmlDefaultSAXHandlerInit

; 14732: #endif
; 14733: #ifdef LIBXML_XPATH_ENABLED
; 14734: 	xmlXPathInit();

	call	_xmlXPathInit

; 14735: #endif
; 14736: 	xmlParserInitialized = 1;

	mov	DWORD PTR _xmlParserInitialized, 1
$LN3@xmlInitPar:

; 14737: #ifdef LIBXML_THREAD_ENABLED
; 14738:     }
; 14739:     __xmlGlobalInitMutexUnlock();

	call	___xmlGlobalInitMutexUnlock
$LN1@xmlInitPar:

; 14740: #endif
; 14741: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlInitParser ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
