; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\hash.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__C0802A2B_corecrt_wtime@h DB 01H
__04AA828A_time@h DB 01H
__776982E1_hash@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlHashCreate
PUBLIC	_xmlHashCreateDict
PUBLIC	_xmlHashFree
PUBLIC	_xmlHashDefaultDeallocator
PUBLIC	_xmlHashAddEntry
PUBLIC	_xmlHashUpdateEntry
PUBLIC	_xmlHashAddEntry2
PUBLIC	_xmlHashUpdateEntry2
PUBLIC	_xmlHashAddEntry3
PUBLIC	_xmlHashUpdateEntry3
PUBLIC	_xmlHashRemoveEntry
PUBLIC	_xmlHashRemoveEntry2
PUBLIC	_xmlHashRemoveEntry3
PUBLIC	_xmlHashLookup
PUBLIC	_xmlHashLookup2
PUBLIC	_xmlHashLookup3
PUBLIC	_xmlHashQLookup
PUBLIC	_xmlHashQLookup2
PUBLIC	_xmlHashQLookup3
PUBLIC	_xmlHashCopy
PUBLIC	_xmlHashSize
PUBLIC	_xmlHashScan
PUBLIC	_xmlHashScan3
PUBLIC	_xmlHashScanFull
PUBLIC	_xmlHashScanFull3
PUBLIC	__JustMyCode_Default
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrQEqual:PROC
EXTRN	_xmlDictReference:PROC
EXTRN	_xmlDictFree:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictOwns:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memset:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _stubHashScannerFull
_TEXT	SEGMENT
_stubdata$ = -4						; size = 4
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_name2$ = 20						; size = 4
_name3$ = 24						; size = 4
_stubHashScannerFull PROC				; COMDAT

; 843  : 		     const xmlChar *name3 ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 844  :     stubData *stubdata = (stubData *) data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _stubdata$[ebp], eax

; 845  :     stubdata->hashscanner (payload, stubdata->data, (xmlChar *) name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stubdata$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _payload$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stubdata$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 846  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_stubHashScannerFull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashGrow
_TEXT	SEGMENT
_oldtable$ = -24					; size = 4
_next$ = -20						; size = 4
_iter$ = -16						; size = 4
_i$ = -12						; size = 4
_oldsize$ = -8						; size = 4
_key$ = -4						; size = 4
_table$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlHashGrow PROC					; COMDAT

; 229  : xmlHashGrow(xmlHashTablePtr table, int size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 230  :     unsigned long key;
; 231  :     int oldsize, i;
; 232  :     xmlHashEntryPtr iter, next;
; 233  :     struct _xmlHashEntry *oldtable;
; 234  : #ifdef DEBUG_GROW
; 235  :     unsigned long nbElem = 0;
; 236  : #endif
; 237  : 
; 238  :     if (table == NULL)

	cmp	DWORD PTR _table$[ebp], 0
	jne	SHORT $LN10@xmlHashGro

; 239  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashGro
$LN10@xmlHashGro:

; 240  :     if (size < 8)

	cmp	DWORD PTR _size$[ebp], 8
	jge	SHORT $LN11@xmlHashGro

; 241  :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashGro
$LN11@xmlHashGro:

; 242  :     if (size > 8 * 2048)

	cmp	DWORD PTR _size$[ebp], 16384		; 00004000H
	jle	SHORT $LN12@xmlHashGro

; 243  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashGro
$LN12@xmlHashGro:

; 244  : 
; 245  :     oldsize = table->size;

	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldsize$[ebp], ecx

; 246  :     oldtable = table->table;

	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _oldtable$[ebp], eax

; 247  :     if (oldtable == NULL)

	cmp	DWORD PTR _oldtable$[ebp], 0
	jne	SHORT $LN13@xmlHashGro

; 248  :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashGro
$LN13@xmlHashGro:

; 249  : 
; 250  :     table->table = xmlMalloc(size * sizeof(xmlHashEntry));

	imul	ecx, DWORD PTR _size$[ebp], 24
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _table$[ebp]
	mov	DWORD PTR [edx], eax

; 251  :     if (table->table == NULL) {

	mov	eax, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN14@xmlHashGro

; 252  : 	table->table = oldtable;

	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR _oldtable$[ebp]
	mov	DWORD PTR [ecx], edx

; 253  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashGro
$LN14@xmlHashGro:

; 254  :     }
; 255  :     memset(table->table, 0, size * sizeof(xmlHashEntry));

	imul	eax, DWORD PTR _size$[ebp], 24
	push	eax
	push	0
	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 256  :     table->size = size;

	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 257  : 
; 258  :     /*	If the two loops are merged, there would be situations where
; 259  : 	a new entry needs to allocated and data copied into it from
; 260  : 	the main table. So instead, we run through the array twice, first
; 261  : 	copying all the elements in the main array (where we can't get
; 262  : 	conflicts) and then the rest, so we only free (and don't allocate)
; 263  :     */
; 264  :     for (i = 0; i < oldsize; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlHashGro
$LN2@xmlHashGro:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@xmlHashGro:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _oldsize$[ebp]
	jge	$LN3@xmlHashGro

; 265  : 	if (oldtable[i].valid == 0)

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _oldtable$[ebp]
	cmp	DWORD PTR [edx+ecx+20], 0
	jne	SHORT $LN15@xmlHashGro

; 266  : 	    continue;

	jmp	SHORT $LN2@xmlHashGro
$LN15@xmlHashGro:

; 267  : 	key = xmlHashComputeKey(table, oldtable[i].name, oldtable[i].name2,

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _oldtable$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _oldtable$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _oldtable$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	push	edx
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashComputeKey
	add	esp, 16					; 00000010H
	mov	DWORD PTR _key$[ebp], eax

; 268  : 				oldtable[i].name3);
; 269  : 	memcpy(&(table->table[key]), &(oldtable[i]), sizeof(xmlHashEntry));

	imul	ecx, DWORD PTR _i$[ebp], 24
	add	ecx, DWORD PTR _oldtable$[ebp]
	imul	edx, DWORD PTR _key$[ebp], 24
	mov	eax, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx

; 270  : 	table->table[key].next = NULL;

	imul	edx, DWORD PTR _key$[ebp], 24
	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx], 0

; 271  :     }

	jmp	$LN2@xmlHashGro
$LN3@xmlHashGro:

; 272  : 
; 273  :     for (i = 0; i < oldsize; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@xmlHashGro
$LN5@xmlHashGro:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@xmlHashGro:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _oldsize$[ebp]
	jge	$LN6@xmlHashGro

; 274  : 	iter = oldtable[i].next;

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _oldtable$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _iter$[ebp], eax
$LN8@xmlHashGro:

; 275  : 	while (iter) {

	cmp	DWORD PTR _iter$[ebp], 0
	je	$LN9@xmlHashGro

; 276  : 	    next = iter->next;

	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _next$[ebp], edx

; 277  : 
; 278  : 	    /*
; 279  : 	     * put back the entry in the new table
; 280  : 	     */
; 281  : 
; 282  : 	    key = xmlHashComputeKey(table, iter->name, iter->name2,

	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashComputeKey
	add	esp, 16					; 00000010H
	mov	DWORD PTR _key$[ebp], eax

; 283  : 		                    iter->name3);
; 284  : 	    if (table->table[key].valid == 0) {

	imul	ecx, DWORD PTR _key$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+ecx+20], 0
	jne	SHORT $LN16@xmlHashGro

; 285  : 		memcpy(&(table->table[key]), iter, sizeof(xmlHashEntry));

	imul	ecx, DWORD PTR _key$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx

; 286  : 		table->table[key].next = NULL;

	imul	edx, DWORD PTR _key$[ebp], 24
	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx], 0

; 287  : 		xmlFree(iter);

	mov	esi, esp
	mov	edx, DWORD PTR _iter$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 288  : 	    } else {

	jmp	SHORT $LN17@xmlHashGro
$LN16@xmlHashGro:

; 289  : 		iter->next = table->table[key].next;

	imul	eax, DWORD PTR _key$[ebp], 24
	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx], edx

; 290  : 		table->table[key].next = iter;

	imul	eax, DWORD PTR _key$[ebp], 24
	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	DWORD PTR [edx+eax], ecx
$LN17@xmlHashGro:

; 291  : 	    }
; 292  : 
; 293  : #ifdef DEBUG_GROW
; 294  : 	    nbElem++;
; 295  : #endif
; 296  : 
; 297  : 	    iter = next;

	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _iter$[ebp], edx

; 298  : 	}

	jmp	$LN8@xmlHashGro
$LN9@xmlHashGro:

; 299  :     }

	jmp	$LN5@xmlHashGro
$LN6@xmlHashGro:

; 300  : 
; 301  :     xmlFree(oldtable);

	mov	esi, esp
	mov	eax, DWORD PTR _oldtable$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 302  : 
; 303  : #ifdef DEBUG_GROW
; 304  :     xmlGenericError(xmlGenericErrorContext,
; 305  : 	    "xmlHashGrow : from %d to %d, %d elems\n", oldsize, size, nbElem);
; 306  : #endif
; 307  : 
; 308  :     return(0);

	xor	eax, eax
$LN1@xmlHashGro:

; 309  : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashGrow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashComputeQKey
_TEXT	SEGMENT
tv196 = -56						; size = 4
tv195 = -52						; size = 4
tv178 = -48						; size = 4
tv177 = -44						; size = 4
tv161 = -40						; size = 4
tv160 = -36						; size = 4
tv143 = -32						; size = 4
tv142 = -28						; size = 4
tv94 = -24						; size = 4
tv93 = -20						; size = 4
tv76 = -16						; size = 4
tv75 = -12						; size = 4
_ch$ = -5						; size = 1
_value$ = -4						; size = 4
_table$ = 8						; size = 4
_prefix$ = 12						; size = 4
_name$ = 16						; size = 4
_prefix2$ = 20						; size = 4
_name2$ = 24						; size = 4
_prefix3$ = 28						; size = 4
_name3$ = 32						; size = 4
_xmlHashComputeQKey PROC				; COMDAT

; 115  : 		   const xmlChar *prefix3, const xmlChar *name3) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 116  :     unsigned long value = 0L;

	mov	DWORD PTR _value$[ebp], 0

; 117  :     char ch;
; 118  : 
; 119  : #ifdef HASH_RANDOMIZATION
; 120  :     value = table->random_seed;
; 121  : #endif
; 122  :     if (prefix != NULL)

	cmp	DWORD PTR _prefix$[ebp], 0
	je	SHORT $LN14@xmlHashCom

; 123  : 	value += 30 * (*prefix);

	mov	eax, DWORD PTR _prefix$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 30
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
	jmp	SHORT $LN15@xmlHashCom
$LN14@xmlHashCom:

; 124  :     else
; 125  : 	value += 30 * (*name);

	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 30
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN15@xmlHashCom:

; 126  : 
; 127  :     if (prefix != NULL) {

	cmp	DWORD PTR _prefix$[ebp], 0
	je	SHORT $LN16@xmlHashCom
$LN2@xmlHashCom:

; 128  : 	while ((ch = *prefix++) != 0) {

	mov	eax, DWORD PTR _prefix$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _ch$[ebp], cl
	movsx	edx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv75[ebp], edx
	mov	eax, DWORD PTR _prefix$[ebp]
	add	eax, 1
	mov	DWORD PTR _prefix$[ebp], eax
	cmp	DWORD PTR tv75[ebp], 0
	je	SHORT $LN23@xmlHashCom
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN24@xmlHashCom
$LN23@xmlHashCom:
	mov	DWORD PTR tv76[ebp], 0
$LN24@xmlHashCom:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN3@xmlHashCom

; 129  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	ecx, DWORD PTR _value$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _value$[ebp]
	shr	edx, 3
	add	ecx, edx
	movsx	eax, BYTE PTR _ch$[ebp]
	add	ecx, eax
	xor	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx

; 130  : 	}

	jmp	SHORT $LN2@xmlHashCom
$LN3@xmlHashCom:

; 131  : 	value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');

	mov	ecx, DWORD PTR _value$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _value$[ebp]
	shr	edx, 3
	lea	eax, DWORD PTR [ecx+edx+58]
	xor	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN16@xmlHashCom:

; 132  :     }
; 133  :     if (name != NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN17@xmlHashCom
$LN4@xmlHashCom:

; 134  : 	while ((ch = *name++) != 0) {

	mov	ecx, DWORD PTR _name$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _ch$[ebp], dl
	movsx	eax, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv93[ebp], eax
	mov	ecx, DWORD PTR _name$[ebp]
	add	ecx, 1
	mov	DWORD PTR _name$[ebp], ecx
	cmp	DWORD PTR tv93[ebp], 0
	je	SHORT $LN25@xmlHashCom
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN26@xmlHashCom
$LN25@xmlHashCom:
	mov	DWORD PTR tv94[ebp], 0
$LN26@xmlHashCom:
	cmp	DWORD PTR tv94[ebp], 0
	je	SHORT $LN17@xmlHashCom

; 135  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	edx, DWORD PTR _value$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _value$[ebp]
	shr	eax, 3
	add	edx, eax
	movsx	ecx, BYTE PTR _ch$[ebp]
	add	edx, ecx
	xor	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx

; 136  : 	}

	jmp	SHORT $LN4@xmlHashCom
$LN17@xmlHashCom:

; 137  :     }
; 138  :     value = value ^ ((value << 5) + (value >> 3));

	mov	edx, DWORD PTR _value$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _value$[ebp]
	shr	eax, 3
	add	edx, eax
	xor	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx

; 139  :     if (prefix2 != NULL) {

	cmp	DWORD PTR _prefix2$[ebp], 0
	je	SHORT $LN18@xmlHashCom
$LN6@xmlHashCom:

; 140  : 	while ((ch = *prefix2++) != 0) {

	mov	ecx, DWORD PTR _prefix2$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _ch$[ebp], dl
	movsx	eax, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv142[ebp], eax
	mov	ecx, DWORD PTR _prefix2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _prefix2$[ebp], ecx
	cmp	DWORD PTR tv142[ebp], 0
	je	SHORT $LN27@xmlHashCom
	mov	DWORD PTR tv143[ebp], 1
	jmp	SHORT $LN28@xmlHashCom
$LN27@xmlHashCom:
	mov	DWORD PTR tv143[ebp], 0
$LN28@xmlHashCom:
	cmp	DWORD PTR tv143[ebp], 0
	je	SHORT $LN7@xmlHashCom

; 141  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	edx, DWORD PTR _value$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _value$[ebp]
	shr	eax, 3
	add	edx, eax
	movsx	ecx, BYTE PTR _ch$[ebp]
	add	edx, ecx
	xor	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx

; 142  : 	}

	jmp	SHORT $LN6@xmlHashCom
$LN7@xmlHashCom:

; 143  : 	value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');

	mov	edx, DWORD PTR _value$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _value$[ebp]
	shr	eax, 3
	lea	ecx, DWORD PTR [edx+eax+58]
	xor	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN18@xmlHashCom:

; 144  :     }
; 145  :     if (name2 != NULL) {

	cmp	DWORD PTR _name2$[ebp], 0
	je	SHORT $LN19@xmlHashCom
$LN8@xmlHashCom:

; 146  : 	while ((ch = *name2++) != 0) {

	mov	edx, DWORD PTR _name2$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv160[ebp], ecx
	mov	edx, DWORD PTR _name2$[ebp]
	add	edx, 1
	mov	DWORD PTR _name2$[ebp], edx
	cmp	DWORD PTR tv160[ebp], 0
	je	SHORT $LN29@xmlHashCom
	mov	DWORD PTR tv161[ebp], 1
	jmp	SHORT $LN30@xmlHashCom
$LN29@xmlHashCom:
	mov	DWORD PTR tv161[ebp], 0
$LN30@xmlHashCom:
	cmp	DWORD PTR tv161[ebp], 0
	je	SHORT $LN19@xmlHashCom

; 147  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	eax, DWORD PTR _value$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _value$[ebp]
	shr	ecx, 3
	add	eax, ecx
	movsx	edx, BYTE PTR _ch$[ebp]
	add	eax, edx
	xor	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 148  : 	}

	jmp	SHORT $LN8@xmlHashCom
$LN19@xmlHashCom:

; 149  :     }
; 150  :     value = value ^ ((value << 5) + (value >> 3));

	mov	eax, DWORD PTR _value$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _value$[ebp]
	shr	ecx, 3
	add	eax, ecx
	xor	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 151  :     if (prefix3 != NULL) {

	cmp	DWORD PTR _prefix3$[ebp], 0
	je	SHORT $LN20@xmlHashCom
$LN10@xmlHashCom:

; 152  : 	while ((ch = *prefix3++) != 0) {

	mov	edx, DWORD PTR _prefix3$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _ch$[ebp], al
	movsx	ecx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	mov	edx, DWORD PTR _prefix3$[ebp]
	add	edx, 1
	mov	DWORD PTR _prefix3$[ebp], edx
	cmp	DWORD PTR tv177[ebp], 0
	je	SHORT $LN31@xmlHashCom
	mov	DWORD PTR tv178[ebp], 1
	jmp	SHORT $LN32@xmlHashCom
$LN31@xmlHashCom:
	mov	DWORD PTR tv178[ebp], 0
$LN32@xmlHashCom:
	cmp	DWORD PTR tv178[ebp], 0
	je	SHORT $LN11@xmlHashCom

; 153  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	eax, DWORD PTR _value$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _value$[ebp]
	shr	ecx, 3
	add	eax, ecx
	movsx	edx, BYTE PTR _ch$[ebp]
	add	eax, edx
	xor	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 154  : 	}

	jmp	SHORT $LN10@xmlHashCom
$LN11@xmlHashCom:

; 155  : 	value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');

	mov	eax, DWORD PTR _value$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _value$[ebp]
	shr	ecx, 3
	lea	edx, DWORD PTR [eax+ecx+58]
	xor	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN20@xmlHashCom:

; 156  :     }
; 157  :     if (name3 != NULL) {

	cmp	DWORD PTR _name3$[ebp], 0
	je	SHORT $LN21@xmlHashCom
$LN12@xmlHashCom:

; 158  : 	while ((ch = *name3++) != 0) {

	mov	eax, DWORD PTR _name3$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _ch$[ebp], cl
	movsx	edx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv195[ebp], edx
	mov	eax, DWORD PTR _name3$[ebp]
	add	eax, 1
	mov	DWORD PTR _name3$[ebp], eax
	cmp	DWORD PTR tv195[ebp], 0
	je	SHORT $LN33@xmlHashCom
	mov	DWORD PTR tv196[ebp], 1
	jmp	SHORT $LN34@xmlHashCom
$LN33@xmlHashCom:
	mov	DWORD PTR tv196[ebp], 0
$LN34@xmlHashCom:
	cmp	DWORD PTR tv196[ebp], 0
	je	SHORT $LN21@xmlHashCom

; 159  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	ecx, DWORD PTR _value$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _value$[ebp]
	shr	edx, 3
	add	ecx, edx
	movsx	eax, BYTE PTR _ch$[ebp]
	add	ecx, eax
	xor	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx

; 160  : 	}

	jmp	SHORT $LN12@xmlHashCom
$LN21@xmlHashCom:

; 161  :     }
; 162  :     return (value % table->size);

	mov	ecx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR _value$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+4]
	mov	eax, edx

; 163  : }

	pop	edi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashComputeQKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashComputeKey
_TEXT	SEGMENT
tv138 = -32						; size = 4
tv137 = -28						; size = 4
tv89 = -24						; size = 4
tv88 = -20						; size = 4
tv72 = -16						; size = 4
tv71 = -12						; size = 4
_ch$ = -5						; size = 1
_value$ = -4						; size = 4
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_xmlHashComputeKey PROC					; COMDAT

; 83   : 	          const xmlChar *name2, const xmlChar *name3) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 84   :     unsigned long value = 0L;

	mov	DWORD PTR _value$[ebp], 0

; 85   :     char ch;
; 86   : 
; 87   : #ifdef HASH_RANDOMIZATION
; 88   :     value = table->random_seed;
; 89   : #endif
; 90   :     if (name != NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN8@xmlHashCom

; 91   : 	value += 30 * (*name);

	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 30
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN2@xmlHashCom:

; 92   : 	while ((ch = *name++) != 0) {

	mov	eax, DWORD PTR _name$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _ch$[ebp], cl
	movsx	edx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	mov	eax, DWORD PTR _name$[ebp]
	add	eax, 1
	mov	DWORD PTR _name$[ebp], eax
	cmp	DWORD PTR tv71[ebp], 0
	je	SHORT $LN12@xmlHashCom
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN13@xmlHashCom
$LN12@xmlHashCom:
	mov	DWORD PTR tv72[ebp], 0
$LN13@xmlHashCom:
	cmp	DWORD PTR tv72[ebp], 0
	je	SHORT $LN8@xmlHashCom

; 93   : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	ecx, DWORD PTR _value$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _value$[ebp]
	shr	edx, 3
	add	ecx, edx
	movsx	eax, BYTE PTR _ch$[ebp]
	add	ecx, eax
	xor	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx

; 94   : 	}

	jmp	SHORT $LN2@xmlHashCom
$LN8@xmlHashCom:

; 95   :     }
; 96   :     value = value ^ ((value << 5) + (value >> 3));

	mov	ecx, DWORD PTR _value$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _value$[ebp]
	shr	edx, 3
	add	ecx, edx
	xor	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx

; 97   :     if (name2 != NULL) {

	cmp	DWORD PTR _name2$[ebp], 0
	je	SHORT $LN9@xmlHashCom
$LN4@xmlHashCom:

; 98   : 	while ((ch = *name2++) != 0) {

	mov	eax, DWORD PTR _name2$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _ch$[ebp], cl
	movsx	edx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv88[ebp], edx
	mov	eax, DWORD PTR _name2$[ebp]
	add	eax, 1
	mov	DWORD PTR _name2$[ebp], eax
	cmp	DWORD PTR tv88[ebp], 0
	je	SHORT $LN14@xmlHashCom
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN15@xmlHashCom
$LN14@xmlHashCom:
	mov	DWORD PTR tv89[ebp], 0
$LN15@xmlHashCom:
	cmp	DWORD PTR tv89[ebp], 0
	je	SHORT $LN9@xmlHashCom

; 99   : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	ecx, DWORD PTR _value$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _value$[ebp]
	shr	edx, 3
	add	ecx, edx
	movsx	eax, BYTE PTR _ch$[ebp]
	add	ecx, eax
	xor	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx

; 100  : 	}

	jmp	SHORT $LN4@xmlHashCom
$LN9@xmlHashCom:

; 101  :     }
; 102  :     value = value ^ ((value << 5) + (value >> 3));

	mov	ecx, DWORD PTR _value$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _value$[ebp]
	shr	edx, 3
	add	ecx, edx
	xor	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx

; 103  :     if (name3 != NULL) {

	cmp	DWORD PTR _name3$[ebp], 0
	je	SHORT $LN10@xmlHashCom
$LN6@xmlHashCom:

; 104  : 	while ((ch = *name3++) != 0) {

	mov	eax, DWORD PTR _name3$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _ch$[ebp], cl
	movsx	edx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	mov	eax, DWORD PTR _name3$[ebp]
	add	eax, 1
	mov	DWORD PTR _name3$[ebp], eax
	cmp	DWORD PTR tv137[ebp], 0
	je	SHORT $LN16@xmlHashCom
	mov	DWORD PTR tv138[ebp], 1
	jmp	SHORT $LN17@xmlHashCom
$LN16@xmlHashCom:
	mov	DWORD PTR tv138[ebp], 0
$LN17@xmlHashCom:
	cmp	DWORD PTR tv138[ebp], 0
	je	SHORT $LN10@xmlHashCom

; 105  : 	    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);

	mov	ecx, DWORD PTR _value$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _value$[ebp]
	shr	edx, 3
	add	ecx, edx
	movsx	eax, BYTE PTR _ch$[ebp]
	add	ecx, eax
	xor	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx

; 106  : 	}

	jmp	SHORT $LN6@xmlHashCom
$LN10@xmlHashCom:

; 107  :     }
; 108  :     return (value % table->size);

	mov	ecx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR _value$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+4]
	mov	eax, edx

; 109  : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashComputeKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashScanFull3
_TEXT	SEGMENT
_next$ = -12						; size = 4
_iter$ = -8						; size = 4
_i$ = -4						; size = 4
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_f$ = 24						; size = 4
_data$ = 28						; size = 4
_xmlHashScanFull3 PROC					; COMDAT

; 950  : 		 xmlHashScannerFull f, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 951  :     int i;
; 952  :     xmlHashEntryPtr iter;
; 953  :     xmlHashEntryPtr next;
; 954  : 
; 955  :     if (table == NULL)

	cmp	DWORD PTR _table$[ebp], 0
	jne	SHORT $LN7@xmlHashSca

; 956  : 	return;

	jmp	$LN1@xmlHashSca
$LN7@xmlHashSca:

; 957  :     if (f == NULL)

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN8@xmlHashSca

; 958  : 	return;

	jmp	$LN1@xmlHashSca
$LN8@xmlHashSca:

; 959  : 
; 960  :     if (table->table) {

	mov	eax, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN1@xmlHashSca

; 961  : 	for(i = 0; i < table->size; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlHashSca
$LN2@xmlHashSca:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlHashSca:
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	$LN1@xmlHashSca

; 962  : 	    if (table->table[i].valid == 0)

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+ecx+20], 0
	jne	SHORT $LN10@xmlHashSca

; 963  : 		continue;

	jmp	SHORT $LN2@xmlHashSca
$LN10@xmlHashSca:

; 964  : 	    iter = &(table->table[i]);

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _iter$[ebp], ecx
$LN5@xmlHashSca:

; 965  : 	    while (iter) {

	cmp	DWORD PTR _iter$[ebp], 0
	je	$LN6@xmlHashSca

; 966  : 		next = iter->next;

	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _next$[ebp], ecx

; 967  : 		if (((name == NULL) || (xmlStrEqual(name, iter->name))) &&
; 968  : 		    ((name2 == NULL) || (xmlStrEqual(name2, iter->name2))) &&
; 969  : 		    ((name3 == NULL) || (xmlStrEqual(name3, iter->name3))) &&

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN12@xmlHashSca
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlHashSca
$LN12@xmlHashSca:
	cmp	DWORD PTR _name2$[ebp], 0
	je	SHORT $LN13@xmlHashSca
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlHashSca
$LN13@xmlHashSca:
	cmp	DWORD PTR _name3$[ebp], 0
	je	SHORT $LN14@xmlHashSca
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _name3$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlHashSca
$LN14@xmlHashSca:
	mov	edx, DWORD PTR _iter$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN11@xmlHashSca

; 970  : 		    (iter->payload != NULL)) {
; 971  : 		    f(iter->payload, data, iter->name,

	mov	esi, esp
	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _f$[ebp]
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlHashSca:

; 972  : 		      iter->name2, iter->name3);
; 973  : 		}
; 974  : 		iter = next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _iter$[ebp], eax

; 975  : 	    }

	jmp	$LN5@xmlHashSca
$LN6@xmlHashSca:

; 976  : 	}

	jmp	$LN2@xmlHashSca
$LN1@xmlHashSca:

; 977  :     }
; 978  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashScanFull3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashScanFull
_TEXT	SEGMENT
_next$ = -16						; size = 4
_iter$ = -12						; size = 4
_nb$ = -8						; size = 4
_i$ = -4						; size = 4
_table$ = 8						; size = 4
_f$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlHashScanFull PROC					; COMDAT

; 873  : xmlHashScanFull(xmlHashTablePtr table, xmlHashScannerFull f, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 874  :     int i, nb;
; 875  :     xmlHashEntryPtr iter;
; 876  :     xmlHashEntryPtr next;
; 877  : 
; 878  :     if (table == NULL)

	cmp	DWORD PTR _table$[ebp], 0
	jne	SHORT $LN7@xmlHashSca

; 879  : 	return;

	jmp	$LN1@xmlHashSca
$LN7@xmlHashSca:

; 880  :     if (f == NULL)

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN8@xmlHashSca

; 881  : 	return;

	jmp	$LN1@xmlHashSca
$LN8@xmlHashSca:

; 882  : 
; 883  :     if (table->table) {

	mov	eax, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN1@xmlHashSca

; 884  : 	for(i = 0; i < table->size; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlHashSca
$LN2@xmlHashSca:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlHashSca:
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	$LN1@xmlHashSca

; 885  : 	    if (table->table[i].valid == 0)

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+ecx+20], 0
	jne	SHORT $LN10@xmlHashSca

; 886  : 		continue;

	jmp	SHORT $LN2@xmlHashSca
$LN10@xmlHashSca:

; 887  : 	    iter = &(table->table[i]);

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _iter$[ebp], ecx
$LN5@xmlHashSca:

; 888  : 	    while (iter) {

	cmp	DWORD PTR _iter$[ebp], 0
	je	$LN6@xmlHashSca

; 889  : 		next = iter->next;

	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _next$[ebp], ecx

; 890  :                 nb = table->nbElems;

	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _nb$[ebp], eax

; 891  : 		if ((f != NULL) && (iter->payload != NULL))

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN11@xmlHashSca
	mov	ecx, DWORD PTR _iter$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN11@xmlHashSca

; 892  : 		    f(iter->payload, data, iter->name,

	mov	esi, esp
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _f$[ebp]
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlHashSca:

; 893  : 		      iter->name2, iter->name3);
; 894  :                 if (nb != table->nbElems) {

	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR _nb$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN12@xmlHashSca

; 895  :                     /* table was modified by the callback, be careful */
; 896  :                     if (iter == &(table->table[i])) {

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	add	ecx, DWORD PTR [edx]
	cmp	DWORD PTR _iter$[ebp], ecx
	jne	SHORT $LN14@xmlHashSca

; 897  :                         if (table->table[i].valid == 0)

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+eax+20], 0
	jne	SHORT $LN16@xmlHashSca

; 898  :                             iter = NULL;

	mov	DWORD PTR _iter$[ebp], 0
$LN16@xmlHashSca:

; 899  :                         if (table->table[i].next != next)

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax]
	cmp	eax, DWORD PTR _next$[ebp]
	je	SHORT $LN17@xmlHashSca

; 900  : 			    iter = &(table->table[i]);

	imul	ecx, DWORD PTR _i$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _iter$[ebp], ecx
$LN17@xmlHashSca:

; 901  :                     } else

	jmp	SHORT $LN15@xmlHashSca
$LN14@xmlHashSca:

; 902  : 		        iter = next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _iter$[ebp], eax
$LN15@xmlHashSca:

; 903  :                 } else

	jmp	SHORT $LN13@xmlHashSca
$LN12@xmlHashSca:

; 904  : 		    iter = next;

	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _iter$[ebp], ecx
$LN13@xmlHashSca:

; 905  : 	    }

	jmp	$LN5@xmlHashSca
$LN6@xmlHashSca:

; 906  : 	}

	jmp	$LN2@xmlHashSca
$LN1@xmlHashSca:

; 907  :     }
; 908  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashScanFull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashScan3
_TEXT	SEGMENT
_stubdata$ = -12					; size = 8
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_f$ = 24						; size = 4
_data$ = 28						; size = 4
_xmlHashScan3 PROC					; COMDAT

; 926  : 	     xmlHashScanner f, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 927  :     stubData stubdata;
; 928  :     stubdata.data = data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _stubdata$[ebp+4], eax

; 929  :     stubdata.hashscanner = f;

	mov	ecx, DWORD PTR _f$[ebp]
	mov	DWORD PTR _stubdata$[ebp], ecx

; 930  :     xmlHashScanFull3(table, name, name2, name3, stubHashScannerFull,

	lea	edx, DWORD PTR _stubdata$[ebp]
	push	edx
	push	OFFSET _stubHashScannerFull
	mov	eax, DWORD PTR _name3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashScanFull3
	add	esp, 24					; 00000018H

; 931  :                      &stubdata);
; 932  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@xmlHashSca
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@xmlHashSca:
	DD	1
	DD	$LN4@xmlHashSca
$LN4@xmlHashSca:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN3@xmlHashSca
$LN3@xmlHashSca:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	98					; 00000062H
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_xmlHashScan3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashScan
_TEXT	SEGMENT
_stubdata$ = -12					; size = 8
_table$ = 8						; size = 4
_f$ = 12						; size = 4
_data$ = 16						; size = 4
_xmlHashScan PROC					; COMDAT

; 857  : xmlHashScan(xmlHashTablePtr table, xmlHashScanner f, void *data) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 858  :     stubData stubdata;
; 859  :     stubdata.data = data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _stubdata$[ebp+4], eax

; 860  :     stubdata.hashscanner = f;

	mov	ecx, DWORD PTR _f$[ebp]
	mov	DWORD PTR _stubdata$[ebp], ecx

; 861  :     xmlHashScanFull (table, stubHashScannerFull, &stubdata);

	lea	edx, DWORD PTR _stubdata$[ebp]
	push	edx
	push	OFFSET _stubHashScannerFull
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashScanFull
	add	esp, 12					; 0000000cH

; 862  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@xmlHashSca
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@xmlHashSca:
	DD	1
	DD	$LN4@xmlHashSca
$LN4@xmlHashSca:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN3@xmlHashSca
$LN3@xmlHashSca:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	98					; 00000062H
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_xmlHashScan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashSize
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlHashSize PROC					; COMDAT

; 1032 : xmlHashSize(xmlHashTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 1033 :     if (table == NULL)

	cmp	DWORD PTR _table$[ebp], 0
	jne	SHORT $LN2@xmlHashSiz

; 1034 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlHashSiz
$LN2@xmlHashSiz:

; 1035 :     return(table->nbElems);

	mov	eax, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [eax+8]
$LN1@xmlHashSiz:

; 1036 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashCopy
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_next$ = -12						; size = 4
_iter$ = -8						; size = 4
_i$ = -4						; size = 4
_table$ = 8						; size = 4
_f$ = 12						; size = 4
_xmlHashCopy PROC					; COMDAT

; 990  : xmlHashCopy(xmlHashTablePtr table, xmlHashCopier f) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 991  :     int i;
; 992  :     xmlHashEntryPtr iter;
; 993  :     xmlHashEntryPtr next;
; 994  :     xmlHashTablePtr ret;
; 995  : 
; 996  :     if (table == NULL)

	cmp	DWORD PTR _table$[ebp], 0
	jne	SHORT $LN7@xmlHashCop

; 997  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlHashCop
$LN7@xmlHashCop:

; 998  :     if (f == NULL)

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN8@xmlHashCop

; 999  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlHashCop
$LN8@xmlHashCop:

; 1000 : 
; 1001 :     ret = xmlHashCreate(table->size);

	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 1002 :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN9@xmlHashCop

; 1003 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlHashCop
$LN9@xmlHashCop:

; 1004 : 
; 1005 :     if (table->table) {

	mov	edx, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN10@xmlHashCop

; 1006 : 	for(i = 0; i < table->size; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlHashCop
$LN2@xmlHashCop:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlHashCop:
	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN10@xmlHashCop

; 1007 : 	    if (table->table[i].valid == 0)

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+eax+20], 0
	jne	SHORT $LN11@xmlHashCop

; 1008 : 		continue;

	jmp	SHORT $LN2@xmlHashCop
$LN11@xmlHashCop:

; 1009 : 	    iter = &(table->table[i]);

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _table$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _iter$[ebp], eax
$LN5@xmlHashCop:

; 1010 : 	    while (iter) {

	cmp	DWORD PTR _iter$[ebp], 0
	je	SHORT $LN6@xmlHashCop

; 1011 : 		next = iter->next;

	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _next$[ebp], eax

; 1012 : 		xmlHashAddEntry3(ret, iter->name, iter->name2,

	mov	esi, esp
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _f$[ebp]
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlHashAddEntry3
	add	esp, 20					; 00000014H

; 1013 : 			         iter->name3, f(iter->payload, iter->name));
; 1014 : 		iter = next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _iter$[ebp], eax

; 1015 : 	    }

	jmp	SHORT $LN5@xmlHashCop
$LN6@xmlHashCop:

; 1016 : 	}

	jmp	$LN2@xmlHashCop
$LN10@xmlHashCop:

; 1017 :     }
; 1018 :     ret->nbElems = table->nbElems;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 1019 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlHashCop:

; 1020 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashCopy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashQLookup3
_TEXT	SEGMENT
_entry$ = -8						; size = 4
_key$ = -4						; size = 4
_table$ = 8						; size = 4
_prefix$ = 12						; size = 4
_name$ = 16						; size = 4
_prefix2$ = 20						; size = 4
_name2$ = 24						; size = 4
_prefix3$ = 28						; size = 4
_name3$ = 32						; size = 4
_xmlHashQLookup3 PROC					; COMDAT

; 814  : 		const xmlChar *prefix3, const xmlChar *name3) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 815  :     unsigned long key;
; 816  :     xmlHashEntryPtr entry;
; 817  : 
; 818  :     if (table == NULL)

	cmp	DWORD PTR _table$[ebp], 0
	jne	SHORT $LN5@xmlHashQLo

; 819  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlHashQLo
$LN5@xmlHashQLo:

; 820  :     if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN6@xmlHashQLo

; 821  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlHashQLo
$LN6@xmlHashQLo:

; 822  :     key = xmlHashComputeQKey(table, prefix, name, prefix2,

	mov	eax, DWORD PTR _name3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name2$[ebp]
	push	edx
	mov	eax, DWORD PTR _prefix2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashComputeQKey
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _key$[ebp], eax

; 823  :                              name2, prefix3, name3);
; 824  :     if (table->table[key].valid == 0)

	imul	ecx, DWORD PTR _key$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+ecx+20], 0
	jne	SHORT $LN7@xmlHashQLo

; 825  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlHashQLo
$LN7@xmlHashQLo:

; 826  :     for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {

	imul	ecx, DWORD PTR _key$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _entry$[ebp], ecx
	jmp	SHORT $LN4@xmlHashQLo
$LN2@xmlHashQLo:
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _entry$[ebp], ecx
$LN4@xmlHashQLo:
	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN3@xmlHashQLo

; 827  : 	if ((xmlStrQEqual(prefix, name, entry->name)) &&
; 828  : 	    (xmlStrQEqual(prefix2, name2, entry->name2)) &&

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@xmlHashQLo
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _name2$[ebp]
	push	edx
	mov	eax, DWORD PTR _prefix2$[ebp]
	push	eax
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@xmlHashQLo
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _name3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix3$[ebp]
	push	ecx
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@xmlHashQLo

; 829  : 	    (xmlStrQEqual(prefix3, name3, entry->name3)))
; 830  : 	    return(entry->payload);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+16]
	jmp	SHORT $LN1@xmlHashQLo
$LN8@xmlHashQLo:

; 831  :     }

	jmp	SHORT $LN2@xmlHashQLo
$LN3@xmlHashQLo:

; 832  :     return(NULL);

	xor	eax, eax
$LN1@xmlHashQLo:

; 833  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashQLookup3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashQLookup2
_TEXT	SEGMENT
_table$ = 8						; size = 4
_prefix$ = 12						; size = 4
_name$ = 16						; size = 4
_prefix2$ = 20						; size = 4
_name2$ = 24						; size = 4
_xmlHashQLookup2 PROC					; COMDAT

; 510  : 	        const xmlChar *name2) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 511  :     return(xmlHashQLookup3(table, prefix, name, prefix2, name2, NULL, NULL));

	push	0
	push	0
	mov	eax, DWORD PTR _name2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _prefix$[ebp]
	push	eax
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlHashQLookup3
	add	esp, 28					; 0000001cH

; 512  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashQLookup2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashQLookup
_TEXT	SEGMENT
_table$ = 8						; size = 4
_prefix$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlHashQLookup PROC					; COMDAT

; 491  :                const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 492  :     return(xmlHashQLookup3(table, prefix, name, NULL, NULL, NULL, NULL));

	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	push	edx
	call	_xmlHashQLookup3
	add	esp, 28					; 0000001cH

; 493  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashQLookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashLookup3
_TEXT	SEGMENT
_entry$ = -8						; size = 4
_key$ = -4						; size = 4
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_xmlHashLookup3 PROC					; COMDAT

; 768  : 	       const xmlChar *name2, const xmlChar *name3) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 769  :     unsigned long key;
; 770  :     xmlHashEntryPtr entry;
; 771  : 
; 772  :     if (table == NULL)

	cmp	DWORD PTR _table$[ebp], 0
	jne	SHORT $LN8@xmlHashLoo

; 773  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlHashLoo
$LN8@xmlHashLoo:

; 774  :     if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN9@xmlHashLoo

; 775  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlHashLoo
$LN9@xmlHashLoo:

; 776  :     key = xmlHashComputeKey(table, name, name2, name3);

	mov	eax, DWORD PTR _name3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashComputeKey
	add	esp, 16					; 00000010H
	mov	DWORD PTR _key$[ebp], eax

; 777  :     if (table->table[key].valid == 0)

	imul	ecx, DWORD PTR _key$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+ecx+20], 0
	jne	SHORT $LN10@xmlHashLoo

; 778  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlHashLoo
$LN10@xmlHashLoo:

; 779  :     if (table->dict) {

	mov	ecx, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN11@xmlHashLoo

; 780  : 	for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {

	imul	edx, DWORD PTR _key$[ebp], 24
	mov	eax, DWORD PTR _table$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _entry$[ebp], edx
	jmp	SHORT $LN4@xmlHashLoo
$LN2@xmlHashLoo:
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _entry$[ebp], edx
$LN4@xmlHashLoo:
	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN11@xmlHashLoo

; 781  : 	    if ((entry->name == name) &&
; 782  : 		(entry->name2 == name2) &&

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _name$[ebp]
	jne	SHORT $LN12@xmlHashLoo
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _name2$[ebp]
	jne	SHORT $LN12@xmlHashLoo
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _name3$[ebp]
	jne	SHORT $LN12@xmlHashLoo

; 783  : 		(entry->name3 == name3))
; 784  : 		return(entry->payload);

	mov	eax, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $LN1@xmlHashLoo
$LN12@xmlHashLoo:

; 785  : 	}

	jmp	SHORT $LN2@xmlHashLoo
$LN11@xmlHashLoo:

; 786  :     }
; 787  :     for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {

	imul	ecx, DWORD PTR _key$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _entry$[ebp], ecx
	jmp	SHORT $LN7@xmlHashLoo
$LN5@xmlHashLoo:
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _entry$[ebp], ecx
$LN7@xmlHashLoo:
	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN6@xmlHashLoo

; 788  : 	if ((xmlStrEqual(entry->name, name)) &&
; 789  : 	    (xmlStrEqual(entry->name2, name2)) &&

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlHashLoo
	mov	edx, DWORD PTR _name2$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlHashLoo
	mov	edx, DWORD PTR _name3$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlHashLoo

; 790  : 	    (xmlStrEqual(entry->name3, name3)))
; 791  : 	    return(entry->payload);

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+16]
	jmp	SHORT $LN1@xmlHashLoo
$LN13@xmlHashLoo:

; 792  :     }

	jmp	SHORT $LN5@xmlHashLoo
$LN6@xmlHashLoo:

; 793  :     return(NULL);

	xor	eax, eax
$LN1@xmlHashLoo:

; 794  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashLookup3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashLookup2
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_xmlHashLookup2 PROC					; COMDAT

; 475  : 	      const xmlChar *name2) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 476  :     return(xmlHashLookup3(table, name, name2, NULL));

	push	0
	mov	eax, DWORD PTR _name2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	push	edx
	call	_xmlHashLookup3
	add	esp, 16					; 00000010H

; 477  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashLookup2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashLookup
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlHashLookup PROC					; COMDAT

; 459  : xmlHashLookup(xmlHashTablePtr table, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 460  :     return(xmlHashLookup3(table, name, NULL, NULL));

	push	0
	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlHashLookup3
	add	esp, 16					; 00000010H

; 461  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashLookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashRemoveEntry3
_TEXT	SEGMENT
_prev$ = -12						; size = 4
_entry$ = -8						; size = 4
_key$ = -4						; size = 4
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_f$ = 24						; size = 4
_xmlHashRemoveEntry3 PROC				; COMDAT

; 1090 :     const xmlChar *name2, const xmlChar *name3, xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 1091 :     unsigned long key;
; 1092 :     xmlHashEntryPtr entry;
; 1093 :     xmlHashEntryPtr prev = NULL;

	mov	DWORD PTR _prev$[ebp], 0

; 1094 : 
; 1095 :     if (table == NULL || name == NULL)

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN6@xmlHashRem
	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN5@xmlHashRem
$LN6@xmlHashRem:

; 1096 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashRem
$LN5@xmlHashRem:

; 1097 : 
; 1098 :     key = xmlHashComputeKey(table, name, name2, name3);

	mov	eax, DWORD PTR _name3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashComputeKey
	add	esp, 16					; 00000010H
	mov	DWORD PTR _key$[ebp], eax

; 1099 :     if (table->table[key].valid == 0) {

	imul	ecx, DWORD PTR _key$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+ecx+20], 0
	jne	SHORT $LN7@xmlHashRem

; 1100 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashRem

; 1101 :     } else {

	jmp	$LN1@xmlHashRem
$LN7@xmlHashRem:

; 1102 :         for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {

	imul	ecx, DWORD PTR _key$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _entry$[ebp], ecx
	jmp	SHORT $LN4@xmlHashRem
$LN2@xmlHashRem:
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _entry$[ebp], ecx
$LN4@xmlHashRem:
	cmp	DWORD PTR _entry$[ebp], 0
	je	$LN3@xmlHashRem

; 1103 :             if (xmlStrEqual(entry->name, name) &&
; 1104 :                     xmlStrEqual(entry->name2, name2) &&

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN9@xmlHashRem
	mov	edx, DWORD PTR _name2$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN9@xmlHashRem
	mov	edx, DWORD PTR _name3$[ebp]
	push	edx
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN9@xmlHashRem

; 1105 :                     xmlStrEqual(entry->name3, name3)) {
; 1106 :                 if ((f != NULL) && (entry->payload != NULL))

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN10@xmlHashRem
	mov	edx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN10@xmlHashRem

; 1107 :                     f(entry->payload, entry->name);

	mov	esi, esp
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR _f$[ebp]
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlHashRem:

; 1108 :                 entry->payload = NULL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 1109 : 		if (table->dict == NULL) {

	mov	edx, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN11@xmlHashRem

; 1110 : 		    if(entry->name)

	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN12@xmlHashRem

; 1111 : 			xmlFree(entry->name);

	mov	esi, esp
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlHashRem:

; 1112 : 		    if(entry->name2)

	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN13@xmlHashRem

; 1113 : 			xmlFree(entry->name2);

	mov	esi, esp
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlHashRem:

; 1114 : 		    if(entry->name3)

	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN11@xmlHashRem

; 1115 : 			xmlFree(entry->name3);

	mov	esi, esp
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlHashRem:

; 1116 : 		}
; 1117 :                 if(prev) {

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN15@xmlHashRem

; 1118 :                     prev->next = entry->next;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1119 : 		    xmlFree(entry);

	mov	esi, esp
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1120 : 		} else {

	jmp	SHORT $LN16@xmlHashRem
$LN15@xmlHashRem:

; 1121 : 		    if (entry->next == NULL) {

	mov	ecx, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN17@xmlHashRem

; 1122 : 			entry->valid = 0;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1123 : 		    } else {

	jmp	SHORT $LN16@xmlHashRem
$LN17@xmlHashRem:

; 1124 : 			entry = entry->next;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _entry$[ebp], ecx

; 1125 : 			memcpy(&(table->table[key]), entry, sizeof(xmlHashEntry));

	imul	edx, DWORD PTR _key$[ebp], 24
	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, edx
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], edx

; 1126 : 			xmlFree(entry);

	mov	esi, esp
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlHashRem:

; 1127 : 		    }
; 1128 : 		}
; 1129 :                 table->nbElems--;

	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 1
	mov	eax, DWORD PTR _table$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1130 :                 return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlHashRem
$LN9@xmlHashRem:

; 1131 :             }
; 1132 :             prev = entry;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR _prev$[ebp], ecx

; 1133 :         }

	jmp	$LN2@xmlHashRem
$LN3@xmlHashRem:

; 1134 :         return(-1);

	or	eax, -1
$LN1@xmlHashRem:

; 1135 :     }
; 1136 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashRemoveEntry3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashRemoveEntry2
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_f$ = 20						; size = 4
_xmlHashRemoveEntry2 PROC				; COMDAT

; 1070 : 			const xmlChar *name2, xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 1071 :     return(xmlHashRemoveEntry3(table, name, name2, NULL, f));

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashRemoveEntry3
	add	esp, 20					; 00000014H

; 1072 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashRemoveEntry2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashRemoveEntry
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_f$ = 16						; size = 4
_xmlHashRemoveEntry PROC				; COMDAT

; 1051 : 		       xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 1052 :     return(xmlHashRemoveEntry3(table, name, NULL, NULL, f));

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	push	edx
	call	_xmlHashRemoveEntry3
	add	esp, 20					; 00000014H

; 1053 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashRemoveEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashUpdateEntry3
_TEXT	SEGMENT
_insert$ = -12						; size = 4
_entry$ = -8						; size = 4
_key$ = -4						; size = 4
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_userdata$ = 24						; size = 4
_f$ = 28						; size = 4
_xmlHashUpdateEntry3 PROC				; COMDAT

; 647  : 		   void *userdata, xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 648  :     unsigned long key;
; 649  :     xmlHashEntryPtr entry;
; 650  :     xmlHashEntryPtr insert;
; 651  : 
; 652  :     if ((table == NULL) || name == NULL)

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN9@xmlHashUpd
	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN8@xmlHashUpd
$LN9@xmlHashUpd:

; 653  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashUpd
$LN8@xmlHashUpd:

; 654  : 
; 655  :     /*
; 656  :      * If using a dict internalize if needed
; 657  :      */
; 658  :     if (table->dict) {

	mov	eax, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN10@xmlHashUpd

; 659  :         if (!xmlDictOwns(table->dict, name)) {

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlHashUpd

; 660  : 	    name = xmlDictLookup(table->dict, name, -1);

	push	-1
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name$[ebp], eax

; 661  : 	    if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN11@xmlHashUpd

; 662  : 	        return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashUpd
$LN11@xmlHashUpd:

; 663  : 	}
; 664  :         if ((name2 != NULL) && (!xmlDictOwns(table->dict, name2))) {

	cmp	DWORD PTR _name2$[ebp], 0
	je	SHORT $LN13@xmlHashUpd
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlHashUpd

; 665  : 	    name2 = xmlDictLookup(table->dict, name2, -1);

	push	-1
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name2$[ebp], eax

; 666  : 	    if (name2 == NULL)

	cmp	DWORD PTR _name2$[ebp], 0
	jne	SHORT $LN13@xmlHashUpd

; 667  : 	        return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashUpd
$LN13@xmlHashUpd:

; 668  : 	}
; 669  :         if ((name3 != NULL) && (!xmlDictOwns(table->dict, name3))) {

	cmp	DWORD PTR _name3$[ebp], 0
	je	SHORT $LN10@xmlHashUpd
	mov	ecx, DWORD PTR _name3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlHashUpd

; 670  : 	    name3 = xmlDictLookup(table->dict, name3, -1);

	push	-1
	mov	ecx, DWORD PTR _name3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name3$[ebp], eax

; 671  : 	    if (name3 == NULL)

	cmp	DWORD PTR _name3$[ebp], 0
	jne	SHORT $LN10@xmlHashUpd

; 672  : 	        return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashUpd
$LN10@xmlHashUpd:

; 673  : 	}
; 674  :     }
; 675  : 
; 676  :     /*
; 677  :      * Check for duplicate and insertion location.
; 678  :      */
; 679  :     key = xmlHashComputeKey(table, name, name2, name3);

	mov	ecx, DWORD PTR _name3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name2$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlHashComputeKey
	add	esp, 16					; 00000010H
	mov	DWORD PTR _key$[ebp], eax

; 680  :     if (table->table[key].valid == 0) {

	imul	edx, DWORD PTR _key$[ebp], 24
	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+edx+20], 0
	jne	SHORT $LN17@xmlHashUpd

; 681  : 	insert = NULL;

	mov	DWORD PTR _insert$[ebp], 0

; 682  :     } else {

	jmp	$LN18@xmlHashUpd
$LN17@xmlHashUpd:

; 683  :         if (table ->dict) {

	mov	edx, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$LN19@xmlHashUpd

; 684  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	imul	eax, DWORD PTR _key$[ebp], 24
	mov	ecx, DWORD PTR _table$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _insert$[ebp], eax
	jmp	SHORT $LN4@xmlHashUpd
$LN2@xmlHashUpd:

; 685  : 		 insert = insert->next) {

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _insert$[ebp], eax
$LN4@xmlHashUpd:

; 684  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	mov	ecx, DWORD PTR _insert$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@xmlHashUpd

; 686  : 		if ((insert->name == name) &&
; 687  : 		    (insert->name2 == name2) &&

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _name$[ebp]
	jne	SHORT $LN21@xmlHashUpd
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _name2$[ebp]
	jne	SHORT $LN21@xmlHashUpd
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _name3$[ebp]
	jne	SHORT $LN21@xmlHashUpd

; 688  : 		    (insert->name3 == name3)) {
; 689  : 		    if (f)

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN22@xmlHashUpd

; 690  : 			f(insert->payload, insert->name);

	mov	esi, esp
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _f$[ebp]
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@xmlHashUpd:

; 691  : 		    insert->payload = userdata;

	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR _userdata$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 692  : 		    return(0);

	xor	eax, eax
	jmp	$LN1@xmlHashUpd
$LN21@xmlHashUpd:

; 693  : 		}
; 694  : 	    }

	jmp	SHORT $LN2@xmlHashUpd
$LN3@xmlHashUpd:

; 695  : 	    if ((insert->name == name) &&
; 696  : 		(insert->name2 == name2) &&

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _name$[ebp]
	jne	SHORT $LN23@xmlHashUpd
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _name2$[ebp]
	jne	SHORT $LN23@xmlHashUpd
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _name3$[ebp]
	jne	SHORT $LN23@xmlHashUpd

; 697  : 		(insert->name3 == name3)) {
; 698  : 		if (f)

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN24@xmlHashUpd

; 699  : 		    f(insert->payload, insert->name);

	mov	esi, esp
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _f$[ebp]
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN24@xmlHashUpd:

; 700  : 		insert->payload = userdata;

	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR _userdata$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 701  : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlHashUpd
$LN23@xmlHashUpd:

; 702  : 	    }
; 703  : 	} else {

	jmp	$LN18@xmlHashUpd
$LN19@xmlHashUpd:

; 704  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	imul	edx, DWORD PTR _key$[ebp], 24
	mov	eax, DWORD PTR _table$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _insert$[ebp], edx
	jmp	SHORT $LN7@xmlHashUpd
$LN5@xmlHashUpd:

; 705  : 		 insert = insert->next) {

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _insert$[ebp], edx
$LN7@xmlHashUpd:

; 704  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	mov	eax, DWORD PTR _insert$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@xmlHashUpd

; 706  : 		if ((xmlStrEqual(insert->name, name)) &&
; 707  : 		    (xmlStrEqual(insert->name2, name2)) &&

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlHashUpd
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlHashUpd
	mov	ecx, DWORD PTR _name3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlHashUpd

; 708  : 		    (xmlStrEqual(insert->name3, name3))) {
; 709  : 		    if (f)

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN26@xmlHashUpd

; 710  : 			f(insert->payload, insert->name);

	mov	esi, esp
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _f$[ebp]
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN26@xmlHashUpd:

; 711  : 		    insert->payload = userdata;

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR _userdata$[ebp]
	mov	DWORD PTR [edx+16], eax

; 712  : 		    return(0);

	xor	eax, eax
	jmp	$LN1@xmlHashUpd
$LN25@xmlHashUpd:

; 713  : 		}
; 714  : 	    }

	jmp	$LN5@xmlHashUpd
$LN6@xmlHashUpd:

; 715  : 	    if ((xmlStrEqual(insert->name, name)) &&
; 716  : 		(xmlStrEqual(insert->name2, name2)) &&

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlHashUpd
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlHashUpd
	mov	ecx, DWORD PTR _name3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlHashUpd

; 717  : 		(xmlStrEqual(insert->name3, name3))) {
; 718  : 		if (f)

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN28@xmlHashUpd

; 719  : 		    f(insert->payload, insert->name);

	mov	esi, esp
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _f$[ebp]
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN28@xmlHashUpd:

; 720  : 		insert->payload = userdata;

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR _userdata$[ebp]
	mov	DWORD PTR [edx+16], eax

; 721  : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlHashUpd
$LN18@xmlHashUpd:

; 722  : 	    }
; 723  : 	}
; 724  :     }
; 725  : 
; 726  :     if (insert == NULL) {

	cmp	DWORD PTR _insert$[ebp], 0
	jne	SHORT $LN29@xmlHashUpd

; 727  : 	entry =  &(table->table[key]);

	imul	ecx, DWORD PTR _key$[ebp], 24
	mov	edx, DWORD PTR _table$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _entry$[ebp], ecx

; 728  :     } else {

	jmp	SHORT $LN30@xmlHashUpd
$LN29@xmlHashUpd:

; 729  : 	entry = xmlMalloc(sizeof(xmlHashEntry));

	mov	esi, esp
	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _entry$[ebp], eax

; 730  : 	if (entry == NULL)

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN30@xmlHashUpd

; 731  : 	     return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashUpd
$LN30@xmlHashUpd:

; 732  :     }
; 733  : 
; 734  :     if (table->dict != NULL) {

	mov	eax, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN32@xmlHashUpd

; 735  :         entry->name = (xmlChar *) name;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _name$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 736  :         entry->name2 = (xmlChar *) name2;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _name2$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 737  :         entry->name3 = (xmlChar *) name3;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _name3$[ebp]
	mov	DWORD PTR [edx+12], eax

; 738  :     } else {

	jmp	SHORT $LN33@xmlHashUpd
$LN32@xmlHashUpd:

; 739  : 	entry->name = xmlStrdup(name);

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+4], eax

; 740  : 	entry->name2 = xmlStrdup(name2);

	mov	eax, DWORD PTR _name2$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 741  : 	entry->name3 = xmlStrdup(name3);

	mov	edx, DWORD PTR _name3$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN33@xmlHashUpd:

; 742  :     }
; 743  :     entry->payload = userdata;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _userdata$[ebp]
	mov	DWORD PTR [edx+16], eax

; 744  :     entry->next = NULL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx], 0

; 745  :     entry->valid = 1;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+20], 1

; 746  :     table->nbElems++;

	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _table$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 747  : 
; 748  : 
; 749  :     if (insert != NULL) {

	cmp	DWORD PTR _insert$[ebp], 0
	je	SHORT $LN34@xmlHashUpd

; 750  : 	insert->next = entry;

	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@xmlHashUpd:

; 751  :     }
; 752  :     return(0);

	xor	eax, eax
$LN1@xmlHashUpd:

; 753  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashUpdateEntry3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashAddEntry3
_TEXT	SEGMENT
_insert$ = -16						; size = 4
_entry$ = -12						; size = 4
_len$ = -8						; size = 4
_key$ = -4						; size = 4
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_name3$ = 20						; size = 4
_userdata$ = 24						; size = 4
_xmlHashAddEntry3 PROC					; COMDAT

; 531  : 		 void *userdata) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 532  :     unsigned long key, len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 533  :     xmlHashEntryPtr entry;
; 534  :     xmlHashEntryPtr insert;
; 535  : 
; 536  :     if ((table == NULL) || (name == NULL))

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN9@xmlHashAdd
	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN8@xmlHashAdd
$LN9@xmlHashAdd:

; 537  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashAdd
$LN8@xmlHashAdd:

; 538  : 
; 539  :     /*
; 540  :      * If using a dict internalize if needed
; 541  :      */
; 542  :     if (table->dict) {

	mov	eax, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN10@xmlHashAdd

; 543  :         if (!xmlDictOwns(table->dict, name)) {

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlHashAdd

; 544  : 	    name = xmlDictLookup(table->dict, name, -1);

	push	-1
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name$[ebp], eax

; 545  : 	    if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN11@xmlHashAdd

; 546  : 	        return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashAdd
$LN11@xmlHashAdd:

; 547  : 	}
; 548  :         if ((name2 != NULL) && (!xmlDictOwns(table->dict, name2))) {

	cmp	DWORD PTR _name2$[ebp], 0
	je	SHORT $LN13@xmlHashAdd
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@xmlHashAdd

; 549  : 	    name2 = xmlDictLookup(table->dict, name2, -1);

	push	-1
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name2$[ebp], eax

; 550  : 	    if (name2 == NULL)

	cmp	DWORD PTR _name2$[ebp], 0
	jne	SHORT $LN13@xmlHashAdd

; 551  : 	        return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashAdd
$LN13@xmlHashAdd:

; 552  : 	}
; 553  :         if ((name3 != NULL) && (!xmlDictOwns(table->dict, name3))) {

	cmp	DWORD PTR _name3$[ebp], 0
	je	SHORT $LN10@xmlHashAdd
	mov	ecx, DWORD PTR _name3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlHashAdd

; 554  : 	    name3 = xmlDictLookup(table->dict, name3, -1);

	push	-1
	mov	ecx, DWORD PTR _name3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _name3$[ebp], eax

; 555  : 	    if (name3 == NULL)

	cmp	DWORD PTR _name3$[ebp], 0
	jne	SHORT $LN10@xmlHashAdd

; 556  : 	        return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashAdd
$LN10@xmlHashAdd:

; 557  : 	}
; 558  :     }
; 559  : 
; 560  :     /*
; 561  :      * Check for duplicate and insertion location.
; 562  :      */
; 563  :     key = xmlHashComputeKey(table, name, name2, name3);

	mov	ecx, DWORD PTR _name3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name2$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlHashComputeKey
	add	esp, 16					; 00000010H
	mov	DWORD PTR _key$[ebp], eax

; 564  :     if (table->table[key].valid == 0) {

	imul	edx, DWORD PTR _key$[ebp], 24
	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+edx+20], 0
	jne	SHORT $LN17@xmlHashAdd

; 565  : 	insert = NULL;

	mov	DWORD PTR _insert$[ebp], 0

; 566  :     } else {

	jmp	$LN18@xmlHashAdd
$LN17@xmlHashAdd:

; 567  :         if (table->dict) {

	mov	edx, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$LN19@xmlHashAdd

; 568  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	imul	eax, DWORD PTR _key$[ebp], 24
	mov	ecx, DWORD PTR _table$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _insert$[ebp], eax
	jmp	SHORT $LN4@xmlHashAdd
$LN2@xmlHashAdd:

; 569  : 		 insert = insert->next) {

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _insert$[ebp], eax
$LN4@xmlHashAdd:

; 568  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	mov	ecx, DWORD PTR _insert$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@xmlHashAdd

; 570  : 		if ((insert->name == name) &&
; 571  : 		    (insert->name2 == name2) &&

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _name$[ebp]
	jne	SHORT $LN21@xmlHashAdd
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _name2$[ebp]
	jne	SHORT $LN21@xmlHashAdd
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _name3$[ebp]
	jne	SHORT $LN21@xmlHashAdd

; 572  : 		    (insert->name3 == name3))
; 573  : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashAdd
$LN21@xmlHashAdd:

; 574  : 		len++;

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 575  : 	    }

	jmp	SHORT $LN2@xmlHashAdd
$LN3@xmlHashAdd:

; 576  : 	    if ((insert->name == name) &&
; 577  : 		(insert->name2 == name2) &&

	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _name$[ebp]
	jne	SHORT $LN22@xmlHashAdd
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _name2$[ebp]
	jne	SHORT $LN22@xmlHashAdd
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _name3$[ebp]
	jne	SHORT $LN22@xmlHashAdd

; 578  : 		(insert->name3 == name3))
; 579  : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashAdd
$LN22@xmlHashAdd:

; 580  : 	} else {

	jmp	$LN18@xmlHashAdd
$LN19@xmlHashAdd:

; 581  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	imul	eax, DWORD PTR _key$[ebp], 24
	mov	ecx, DWORD PTR _table$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _insert$[ebp], eax
	jmp	SHORT $LN7@xmlHashAdd
$LN5@xmlHashAdd:

; 582  : 		 insert = insert->next) {

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _insert$[ebp], eax
$LN7@xmlHashAdd:

; 581  : 	    for (insert = &(table->table[key]); insert->next != NULL;

	mov	ecx, DWORD PTR _insert$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN6@xmlHashAdd

; 583  : 		if ((xmlStrEqual(insert->name, name)) &&
; 584  : 		    (xmlStrEqual(insert->name2, name2)) &&

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlHashAdd
	mov	edx, DWORD PTR _name2$[ebp]
	push	edx
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlHashAdd
	mov	edx, DWORD PTR _name3$[ebp]
	push	edx
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@xmlHashAdd

; 585  : 		    (xmlStrEqual(insert->name3, name3)))
; 586  : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashAdd
$LN23@xmlHashAdd:

; 587  : 		len++;

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 588  : 	    }

	jmp	SHORT $LN5@xmlHashAdd
$LN6@xmlHashAdd:

; 589  : 	    if ((xmlStrEqual(insert->name, name)) &&
; 590  : 		(xmlStrEqual(insert->name2, name2)) &&

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlHashAdd
	mov	eax, DWORD PTR _name2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlHashAdd
	mov	eax, DWORD PTR _name3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@xmlHashAdd

; 591  : 		(xmlStrEqual(insert->name3, name3)))
; 592  : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashAdd
$LN18@xmlHashAdd:

; 593  : 	}
; 594  :     }
; 595  : 
; 596  :     if (insert == NULL) {

	cmp	DWORD PTR _insert$[ebp], 0
	jne	SHORT $LN25@xmlHashAdd

; 597  : 	entry = &(table->table[key]);

	imul	eax, DWORD PTR _key$[ebp], 24
	mov	ecx, DWORD PTR _table$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _entry$[ebp], eax

; 598  :     } else {

	jmp	SHORT $LN26@xmlHashAdd
$LN25@xmlHashAdd:

; 599  : 	entry = xmlMalloc(sizeof(xmlHashEntry));

	mov	esi, esp
	push	24					; 00000018H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _entry$[ebp], eax

; 600  : 	if (entry == NULL)

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN26@xmlHashAdd

; 601  : 	     return(-1);

	or	eax, -1
	jmp	$LN1@xmlHashAdd
$LN26@xmlHashAdd:

; 602  :     }
; 603  : 
; 604  :     if (table->dict != NULL) {

	mov	edx, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN28@xmlHashAdd

; 605  :         entry->name = (xmlChar *) name;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _name$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 606  :         entry->name2 = (xmlChar *) name2;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _name2$[ebp]
	mov	DWORD PTR [edx+8], eax

; 607  :         entry->name3 = (xmlChar *) name3;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _name3$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 608  :     } else {

	jmp	SHORT $LN29@xmlHashAdd
$LN28@xmlHashAdd:

; 609  : 	entry->name = xmlStrdup(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 610  : 	entry->name2 = xmlStrdup(name2);

	mov	edx, DWORD PTR _name2$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 611  : 	entry->name3 = xmlStrdup(name3);

	mov	edx, DWORD PTR _name3$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN29@xmlHashAdd:

; 612  :     }
; 613  :     entry->payload = userdata;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _userdata$[ebp]
	mov	DWORD PTR [edx+16], eax

; 614  :     entry->next = NULL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx], 0

; 615  :     entry->valid = 1;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+20], 1

; 616  : 
; 617  : 
; 618  :     if (insert != NULL)

	cmp	DWORD PTR _insert$[ebp], 0
	je	SHORT $LN30@xmlHashAdd

; 619  : 	insert->next = entry;

	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax], ecx
$LN30@xmlHashAdd:

; 620  : 
; 621  :     table->nbElems++;

	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _table$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 622  : 
; 623  :     if (len > MAX_HASH_LEN)

	cmp	DWORD PTR _len$[ebp], 8
	jbe	SHORT $LN31@xmlHashAdd

; 624  : 	xmlHashGrow(table, MAX_HASH_LEN * table->size);

	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlHashGrow
	add	esp, 8
$LN31@xmlHashAdd:

; 625  : 
; 626  :     return(0);

	xor	eax, eax
$LN1@xmlHashAdd:

; 627  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashAddEntry3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashUpdateEntry2
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_userdata$ = 20						; size = 4
_f$ = 24						; size = 4
_xmlHashUpdateEntry2 PROC				; COMDAT

; 445  : 		   xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 446  :     return(xmlHashUpdateEntry3(table, name, name2, NULL, userdata, f));

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _userdata$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _name2$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlHashUpdateEntry3
	add	esp, 24					; 00000018H

; 447  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashUpdateEntry2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashAddEntry2
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_name2$ = 16						; size = 4
_userdata$ = 20						; size = 4
_xmlHashAddEntry2 PROC					; COMDAT

; 405  : 	        const xmlChar *name2, void *userdata) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 406  :     return(xmlHashAddEntry3(table, name, name2, NULL, userdata));

	mov	eax, DWORD PTR _userdata$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashAddEntry3
	add	esp, 20					; 00000014H

; 407  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashAddEntry2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashUpdateEntry
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_userdata$ = 16						; size = 4
_f$ = 20						; size = 4
_xmlHashUpdateEntry PROC				; COMDAT

; 424  : 	           void *userdata, xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 425  :     return(xmlHashUpdateEntry3(table, name, NULL, NULL, userdata, f));

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _userdata$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashUpdateEntry3
	add	esp, 24					; 00000018H

; 426  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashUpdateEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashAddEntry
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_userdata$ = 16						; size = 4
_xmlHashAddEntry PROC					; COMDAT

; 387  : xmlHashAddEntry(xmlHashTablePtr table, const xmlChar *name, void *userdata) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 388  :     return(xmlHashAddEntry3(table, name, NULL, NULL, userdata));

	mov	eax, DWORD PTR _userdata$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _table$[ebp]
	push	edx
	call	_xmlHashAddEntry3
	add	esp, 20					; 00000014H

; 389  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashAddEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashDefaultDeallocator
_TEXT	SEGMENT
_entry$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlHashDefaultDeallocator PROC				; COMDAT

; 371  : xmlHashDefaultDeallocator(void *entry, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 372  :     xmlFree(entry);

	mov	esi, esp
	mov	eax, DWORD PTR _entry$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 373  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlHashDefaultDeallocator ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashFree
_TEXT	SEGMENT
_nbElems$ = -20						; size = 4
_inside_table$ = -16					; size = 4
_next$ = -12						; size = 4
_iter$ = -8						; size = 4
_i$ = -4						; size = 4
_table$ = 8						; size = 4
_f$ = 12						; size = 4
_xmlHashFree PROC					; COMDAT

; 320  : xmlHashFree(xmlHashTablePtr table, xmlHashDeallocator f) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 321  :     int i;
; 322  :     xmlHashEntryPtr iter;
; 323  :     xmlHashEntryPtr next;
; 324  :     int inside_table = 0;

	mov	DWORD PTR _inside_table$[ebp], 0

; 325  :     int nbElems;
; 326  : 
; 327  :     if (table == NULL)

	cmp	DWORD PTR _table$[ebp], 0
	jne	SHORT $LN7@xmlHashFre

; 328  : 	return;

	jmp	$LN1@xmlHashFre
$LN7@xmlHashFre:

; 329  :     if (table->table) {

	mov	eax, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN8@xmlHashFre

; 330  : 	nbElems = table->nbElems;

	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _nbElems$[ebp], edx

; 331  : 	for(i = 0; (i < table->size) && (nbElems > 0); i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlHashFre
$LN2@xmlHashFre:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlHashFre:
	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	$LN3@xmlHashFre
	cmp	DWORD PTR _nbElems$[ebp], 0
	jle	$LN3@xmlHashFre

; 332  : 	    iter = &(table->table[i]);

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _table$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _iter$[ebp], eax

; 333  : 	    if (iter->valid == 0)

	mov	edx, DWORD PTR _iter$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN9@xmlHashFre

; 334  : 		continue;

	jmp	SHORT $LN2@xmlHashFre
$LN9@xmlHashFre:

; 335  : 	    inside_table = 1;

	mov	DWORD PTR _inside_table$[ebp], 1
$LN5@xmlHashFre:

; 336  : 	    while (iter) {

	cmp	DWORD PTR _iter$[ebp], 0
	je	$LN6@xmlHashFre

; 337  : 		next = iter->next;

	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _next$[ebp], ecx

; 338  : 		if ((f != NULL) && (iter->payload != NULL))

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN10@xmlHashFre
	mov	edx, DWORD PTR _iter$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN10@xmlHashFre

; 339  : 		    f(iter->payload, iter->name);

	mov	esi, esp
	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR _f$[ebp]
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlHashFre:

; 340  : 		if (table->dict == NULL) {

	mov	ecx, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN11@xmlHashFre

; 341  : 		    if (iter->name)

	mov	edx, DWORD PTR _iter$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN12@xmlHashFre

; 342  : 			xmlFree(iter->name);

	mov	esi, esp
	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlHashFre:

; 343  : 		    if (iter->name2)

	mov	edx, DWORD PTR _iter$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN13@xmlHashFre

; 344  : 			xmlFree(iter->name2);

	mov	esi, esp
	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlHashFre:

; 345  : 		    if (iter->name3)

	mov	edx, DWORD PTR _iter$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN11@xmlHashFre

; 346  : 			xmlFree(iter->name3);

	mov	esi, esp
	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlHashFre:

; 347  : 		}
; 348  : 		iter->payload = NULL;

	mov	edx, DWORD PTR _iter$[ebp]
	mov	DWORD PTR [edx+16], 0

; 349  : 		if (!inside_table)

	cmp	DWORD PTR _inside_table$[ebp], 0
	jne	SHORT $LN15@xmlHashFre

; 350  : 		    xmlFree(iter);

	mov	esi, esp
	mov	eax, DWORD PTR _iter$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlHashFre:

; 351  : 		nbElems--;

	mov	ecx, DWORD PTR _nbElems$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nbElems$[ebp], ecx

; 352  : 		inside_table = 0;

	mov	DWORD PTR _inside_table$[ebp], 0

; 353  : 		iter = next;

	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _iter$[ebp], edx

; 354  : 	    }

	jmp	$LN5@xmlHashFre
$LN6@xmlHashFre:

; 355  : 	}

	jmp	$LN2@xmlHashFre
$LN3@xmlHashFre:

; 356  : 	xmlFree(table->table);

	mov	esi, esp
	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlHashFre:

; 357  :     }
; 358  :     if (table->dict)

	mov	edx, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN16@xmlHashFre

; 359  :         xmlDictFree(table->dict);

	mov	eax, DWORD PTR _table$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlDictFree
	add	esp, 4
$LN16@xmlHashFre:

; 360  :     xmlFree(table);

	mov	esi, esp
	mov	edx, DWORD PTR _table$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlHashFre:

; 361  : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashCreateDict
_TEXT	SEGMENT
_table$ = -4						; size = 4
_size$ = 8						; size = 4
_dict$ = 12						; size = 4
_xmlHashCreateDict PROC					; COMDAT

; 208  : xmlHashCreateDict(int size, xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 209  :     xmlHashTablePtr table;
; 210  : 
; 211  :     table = xmlHashCreate(size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR _table$[ebp], eax

; 212  :     if (table != NULL) {

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN2@xmlHashCre

; 213  :         table->dict = dict;

	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 214  : 	xmlDictReference(dict);

	mov	eax, DWORD PTR _dict$[ebp]
	push	eax
	call	_xmlDictReference
	add	esp, 4
$LN2@xmlHashCre:

; 215  :     }
; 216  :     return(table);

	mov	eax, DWORD PTR _table$[ebp]

; 217  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashCreateDict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\hash.c
;	COMDAT _xmlHashCreate
_TEXT	SEGMENT
_table$ = -4						; size = 4
_size$ = 8						; size = 4
_xmlHashCreate PROC					; COMDAT

; 174  : xmlHashCreate(int size) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __776982E1_hash@c
	call	@__CheckForDebuggerJustMyCode@4

; 175  :     xmlHashTablePtr table;
; 176  : 
; 177  :     if (size <= 0)

	cmp	DWORD PTR _size$[ebp], 0
	jg	SHORT $LN2@xmlHashCre

; 178  :         size = 256;

	mov	DWORD PTR _size$[ebp], 256		; 00000100H
$LN2@xmlHashCre:

; 179  : 
; 180  :     table = xmlMalloc(sizeof(xmlHashTable));

	mov	esi, esp
	push	16					; 00000010H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _table$[ebp], eax

; 181  :     if (table) {

	cmp	DWORD PTR _table$[ebp], 0
	je	SHORT $LN3@xmlHashCre

; 182  :         table->dict = NULL;

	mov	eax, DWORD PTR _table$[ebp]
	mov	DWORD PTR [eax+12], 0

; 183  :         table->size = size;

	mov	ecx, DWORD PTR _table$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 184  : 	table->nbElems = 0;

	mov	eax, DWORD PTR _table$[ebp]
	mov	DWORD PTR [eax+8], 0

; 185  :         table->table = xmlMalloc(size * sizeof(xmlHashEntry));

	imul	ecx, DWORD PTR _size$[ebp], 24
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _table$[ebp]
	mov	DWORD PTR [edx], eax

; 186  :         if (table->table) {

	mov	eax, DWORD PTR _table$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@xmlHashCre

; 187  : 	    memset(table->table, 0, size * sizeof(xmlHashEntry));

	imul	ecx, DWORD PTR _size$[ebp], 24
	push	ecx
	push	0
	mov	edx, DWORD PTR _table$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 188  : #ifdef HASH_RANDOMIZATION
; 189  :             table->random_seed = __xmlRandom();
; 190  : #endif
; 191  : 	    return(table);

	mov	eax, DWORD PTR _table$[ebp]
	jmp	SHORT $LN1@xmlHashCre
$LN4@xmlHashCre:

; 192  :         }
; 193  :         xmlFree(table);

	mov	esi, esp
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlHashCre:

; 194  :     }
; 195  :     return(NULL);

	xor	eax, eax
$LN1@xmlHashCre:

; 196  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlHashCreate ENDP
_TEXT	ENDS
END
