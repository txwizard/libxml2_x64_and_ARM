; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlschemastypes.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__74485836_xmlschemastypes@c DB 01H
msvcjmc	ENDS
CONST	SEGMENT
_daysInMonth DD	01fH
	DD	01cH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
_daysInMonthLeap DD 01fH
	DD	01dH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
_dayInYearByMonth DD 00H
	DD	01fH
	DD	03bH
	DD	05aH
	DD	078H
	DD	097H
	DD	0b5H
	DD	0d4H
	DD	0f3H
	DD	0111H
	DD	0130H
	DD	014eH
_dayInLeapYearByMonth DD 00H
	DD	01fH
	DD	03cH
	DD	05bH
	DD	079H
	DD	098H
	DD	0b6H
	DD	0d5H
	DD	0f4H
	DD	0112H
	DD	0131H
	DD	014fH
?dayRange@?1??xmlSchemaCompareDurations@@9@9 DD 00H	; `xmlSchemaCompareDurations'::`2'::dayRange
	DD	01cH
	DD	03bH
	DD	059H
	DD	078H
	DD	096H
	DD	0b5H
	DD	0d4H
	DD	0f2H
	DD	0111H
	DD	012fH
	DD	014eH
	DD	00H
	DD	01fH
	DD	03eH
	DD	05cH
	DD	07bH
	DD	099H
	DD	0b8H
	DD	0d7H
	DD	0f5H
	DD	0114H
	DD	0132H
	DD	0151H
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	_snprintf
PUBLIC	_sscanf
PUBLIC	_xmlSchemaInitTypes
PUBLIC	_xmlSchemaCleanupTypes
PUBLIC	_xmlSchemaGetPredefinedType
PUBLIC	_xmlSchemaValidatePredefinedType
PUBLIC	_xmlSchemaValPredefTypeNode
PUBLIC	_xmlSchemaValidateFacet
PUBLIC	_xmlSchemaValidateFacetWhtsp
PUBLIC	_xmlSchemaFreeValue
PUBLIC	_xmlSchemaCompareValues
PUBLIC	_xmlSchemaGetBuiltInListSimpleTypeItemType
PUBLIC	_xmlSchemaValidateListSimpleTypeFacet
PUBLIC	_xmlSchemaGetBuiltInType
PUBLIC	_xmlSchemaIsBuiltInTypeFacet
PUBLIC	_xmlSchemaCollapseString
PUBLIC	_xmlSchemaWhiteSpaceReplace
PUBLIC	_xmlSchemaGetFacetValueAsULong
PUBLIC	_xmlSchemaValidateLengthFacet
PUBLIC	_xmlSchemaValidateLengthFacetWhtsp
PUBLIC	_xmlSchemaValPredefTypeNodeNoNorm
PUBLIC	_xmlSchemaGetCanonValue
PUBLIC	_xmlSchemaGetCanonValueWhtsp
PUBLIC	_xmlSchemaValueAppend
PUBLIC	_xmlSchemaValueGetNext
PUBLIC	_xmlSchemaValueGetAsString
PUBLIC	_xmlSchemaValueGetAsBoolean
PUBLIC	_xmlSchemaNewStringValue
PUBLIC	_xmlSchemaNewNOTATIONValue
PUBLIC	_xmlSchemaNewQNameValue
PUBLIC	_xmlSchemaCompareValuesWhtsp
PUBLIC	_xmlSchemaCopyValue
PUBLIC	_xmlSchemaGetValType
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@ ; `string'
PUBLIC	??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@ ; `string'
PUBLIC	??_C@_0BO@IIFFCFND@allocating?5particle?5component@ ; `string'
PUBLIC	??_C@_07OGOHJKKN@anyType@			; `string'
PUBLIC	??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@ ; `string'
PUBLIC	??_C@_0BO@DGENAAFP@allocating?5wildcard?5component@ ; `string'
PUBLIC	??_C@_0DC@HFHHKPAL@could?5not?5create?5an?5attribute?5w@ ; `string'
PUBLIC	??_C@_0O@DMECCPMH@anySimpleType@		; `string'
PUBLIC	??_C@_06ICGJLFIM@string@			; `string'
PUBLIC	??_C@_07EEKBCPDP@decimal@			; `string'
PUBLIC	??_C@_04JNIHBGGH@date@				; `string'
PUBLIC	??_C@_08JHBOOHBO@dateTime@			; `string'
PUBLIC	??_C@_04CLCEDBPF@time@				; `string'
PUBLIC	??_C@_05DGCLHBFG@gYear@				; `string'
PUBLIC	??_C@_0L@FEFFJNNL@gYearMonth@			; `string'
PUBLIC	??_C@_06KBADAKNH@gMonth@			; `string'
PUBLIC	??_C@_09EILODGOG@gMonthDay@			; `string'
PUBLIC	??_C@_04LBFBAPHN@gDay@				; `string'
PUBLIC	??_C@_08LGBPINEC@duration@			; `string'
PUBLIC	??_C@_05KNFBNCOH@float@				; `string'
PUBLIC	??_C@_06BNJCAIGJ@double@			; `string'
PUBLIC	??_C@_07GOBOHMJA@boolean@			; `string'
PUBLIC	??_C@_06DLDOHKEG@anyURI@			; `string'
PUBLIC	??_C@_09EHHLIAMK@hexBinary@			; `string'
PUBLIC	??_C@_0N@NBAOPEBP@base64Binary@			; `string'
PUBLIC	??_C@_08NCDGCBCC@NOTATION@			; `string'
PUBLIC	??_C@_05LFDDDENB@QName@				; `string'
PUBLIC	??_C@_07LKHFMGFB@integer@			; `string'
PUBLIC	??_C@_0BD@FMNGDL@nonPositiveInteger@		; `string'
PUBLIC	??_C@_0BA@HJODLFEP@negativeInteger@		; `string'
PUBLIC	??_C@_04GOKPGOLB@long@				; `string'
PUBLIC	??_C@_03JBIPMCLC@int@				; `string'
PUBLIC	??_C@_05BFKKPKCG@short@				; `string'
PUBLIC	??_C@_04IHGKJMLH@byte@				; `string'
PUBLIC	??_C@_0BD@IEOLADAC@nonNegativeInteger@		; `string'
PUBLIC	??_C@_0N@PNDKOLAJ@unsignedLong@			; `string'
PUBLIC	??_C@_0M@NPFOHDP@unsignedInt@			; `string'
PUBLIC	??_C@_0O@NAIDFEBN@unsignedShort@		; `string'
PUBLIC	??_C@_0N@BEPPBJAP@unsignedByte@			; `string'
PUBLIC	??_C@_0BA@PNFEGAHG@positiveInteger@		; `string'
PUBLIC	??_C@_0BB@HPFKIGKN@normalizedString@		; `string'
PUBLIC	??_C@_05JMKJMOPH@token@				; `string'
PUBLIC	??_C@_08JGCCIMAA@language@			; `string'
PUBLIC	??_C@_04FABLJDN@Name@				; `string'
PUBLIC	??_C@_07JKBEJDBF@NMTOKEN@			; `string'
PUBLIC	??_C@_06MDLHOHLI@NCName@			; `string'
PUBLIC	??_C@_02OLOABKKD@ID@				; `string'
PUBLIC	??_C@_05HKGPJLPA@IDREF@				; `string'
PUBLIC	??_C@_06GKLBAPIO@ENTITY@			; `string'
PUBLIC	??_C@_08ICGBNEMG@ENTITIES@			; `string'
PUBLIC	??_C@_06CMFBJDBA@IDREFS@			; `string'
PUBLIC	??_C@_08PMNBPOOP@NMTOKENS@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf@				; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf@			; `string'
PUBLIC	??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@ ; `string'
PUBLIC	??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_0BH@DMAOOAAN@allocating?5hexbin?5data@	; `string'
PUBLIC	??_C@_0BH@PBMCLKED@allocating?5base64?5data@	; `string'
PUBLIC	??_C@_01HCONENDN@?$HL@				; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN@				; `string'
PUBLIC	??_C@_03MDAFIFFL@0?40@				; `string'
PUBLIC	??_C@_09LMAOOEAH@?$CFlu?$CFlu?$CFlu@		; `string'
PUBLIC	??_C@_06DFHLHGNP@?$CFlu?$CFlu@			; `string'
PUBLIC	??_C@_03FKNCMABI@?$CFlu@			; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0L@HJALPPEN@?9?$CFlu?$CFlu?$CFlu@		; `string'
PUBLIC	??_C@_07KPEGABEP@?9?$CFlu?$CFlu@		; `string'
PUBLIC	??_C@_04IEOFADKM@?9?$CFlu@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_0BN@KBIIDNPF@P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@ ; `string'
PUBLIC	??_C@_0BO@LOJFMPEL@?9P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@ ; `string'
PUBLIC	??_C@_05IHGIIBEO@?$CF04ld@			; `string'
PUBLIC	??_C@_06PLGGIKKN@?9?9?$CF02u@			; `string'
PUBLIC	??_C@_07GBFLPNDN@?9?9?9?$CF02u@			; `string'
PUBLIC	??_C@_0M@IGNOHAOM@?9?9?$CF02u?9?$CF02u@		; `string'
PUBLIC	??_C@_0M@CBHDPMIH@?9?$CF04ld?9?$CF02u@		; `string'
PUBLIC	??_C@_0L@LHLPFBBC@?$CF04ld?9?$CF02u@		; `string'
PUBLIC	??_C@_0BD@EKHIMNMI@?$CF02u?3?$CF02u?3?$CF02?414gZ@ ; `string'
PUBLIC	??_C@_0BC@CMNGDBIO@?$CF02u?3?$CF02u?3?$CF02?414g@ ; `string'
PUBLIC	??_C@_0BB@EPCAOJB@?$CF04ld?3?$CF02u?3?$CF02uZ@	; `string'
PUBLIC	??_C@_0BA@KCJGDMGM@?$CF04ld?3?$CF02u?3?$CF02u@	; `string'
PUBLIC	??_C@_0CD@NGIOFKDM@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@ ; `string'
PUBLIC	??_C@_0CC@NDEHGMEK@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@ ; `string'
PUBLIC	??_C@_07EBIAOBPB@?$CF01?414e@			; `string'
PUBLIC	??_C@_03BBKEAIF@?$DP?$DP?$DP@			; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@4028000000000000
PUBLIC	__real@4038000000000000
PUBLIC	__real@404e000000000000
PUBLIC	__real@40ac200000000000
PUBLIC	__real@40e89c0000000000
PUBLIC	__real@40f5180000000000
PUBLIC	__real@c0e89c0000000000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrcmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	_xmlUTF8Strlen:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	_xmlRegexpExec:PROC
EXTRN	_xmlValidateNCName:PROC
EXTRN	_xmlValidateQName:PROC
EXTRN	_xmlValidateName:PROC
EXTRN	_xmlValidateNMToken:PROC
EXTRN	_xmlSplitQName2:PROC
EXTRN	_xmlSearchNs:PROC
EXTRN	_xmlHashCreate:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashAddEntry2:PROC
EXTRN	_xmlHashLookup2:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_xmlAddID:PROC
EXTRN	_xmlAddRef:PROC
EXTRN	_xmlValidateNotationUse:PROC
EXTRN	_xmlGetDocEntity:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlCheckLanguageID:PROC
EXTRN	_xmlXPathIsNaN:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlSchemaFreeType:PROC
EXTRN	_xmlSchemaFreeWildcard:PROC
EXTRN	_xmlSchemaNewFacet:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__dtoui3:PROC
EXTRN	__ftol2_sse_excpt:PROC
EXTRN	_floor:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlSchemaTypesInitialized DD 01H DUP (?)
_xmlSchemaTypesBank DD 01H DUP (?)
_xmlSchemaTypeStringDef DD 01H DUP (?)
_xmlSchemaTypeAnyTypeDef DD 01H DUP (?)
_xmlSchemaTypeAnySimpleTypeDef DD 01H DUP (?)
_xmlSchemaTypeDecimalDef DD 01H DUP (?)
_xmlSchemaTypeDatetimeDef DD 01H DUP (?)
_xmlSchemaTypeDateDef DD 01H DUP (?)
_xmlSchemaTypeTimeDef DD 01H DUP (?)
_xmlSchemaTypeGYearDef DD 01H DUP (?)
_xmlSchemaTypeGYearMonthDef DD 01H DUP (?)
_xmlSchemaTypeGDayDef DD 01H DUP (?)
_xmlSchemaTypeGMonthDayDef DD 01H DUP (?)
_xmlSchemaTypeGMonthDef DD 01H DUP (?)
_xmlSchemaTypeDurationDef DD 01H DUP (?)
_xmlSchemaTypeFloatDef DD 01H DUP (?)
_xmlSchemaTypeBooleanDef DD 01H DUP (?)
_xmlSchemaTypeDoubleDef DD 01H DUP (?)
_xmlSchemaTypeHexBinaryDef DD 01H DUP (?)
_xmlSchemaTypeBase64BinaryDef DD 01H DUP (?)
_xmlSchemaTypeAnyURIDef DD 01H DUP (?)
_xmlSchemaTypePositiveIntegerDef DD 01H DUP (?)
_xmlSchemaTypeNonPositiveIntegerDef DD 01H DUP (?)
_xmlSchemaTypeNegativeIntegerDef DD 01H DUP (?)
_xmlSchemaTypeNonNegativeIntegerDef DD 01H DUP (?)
_xmlSchemaTypeIntegerDef DD 01H DUP (?)
_xmlSchemaTypeLongDef DD 01H DUP (?)
_xmlSchemaTypeIntDef DD 01H DUP (?)
_xmlSchemaTypeShortDef DD 01H DUP (?)
_xmlSchemaTypeByteDef DD 01H DUP (?)
_xmlSchemaTypeUnsignedLongDef DD 01H DUP (?)
_xmlSchemaTypeUnsignedIntDef DD 01H DUP (?)
_xmlSchemaTypeUnsignedShortDef DD 01H DUP (?)
_xmlSchemaTypeUnsignedByteDef DD 01H DUP (?)
_xmlSchemaTypeNormStringDef DD 01H DUP (?)
_xmlSchemaTypeTokenDef DD 01H DUP (?)
_xmlSchemaTypeLanguageDef DD 01H DUP (?)
_xmlSchemaTypeNameDef DD 01H DUP (?)
_xmlSchemaTypeQNameDef DD 01H DUP (?)
_xmlSchemaTypeNCNameDef DD 01H DUP (?)
_xmlSchemaTypeIdDef DD 01H DUP (?)
_xmlSchemaTypeIdrefDef DD 01H DUP (?)
_xmlSchemaTypeIdrefsDef DD 01H DUP (?)
_xmlSchemaTypeEntityDef DD 01H DUP (?)
_xmlSchemaTypeEntitiesDef DD 01H DUP (?)
_xmlSchemaTypeNotationDef DD 01H DUP (?)
_xmlSchemaTypeNmtokenDef DD 01H DUP (?)
_xmlSchemaTypeNmtokensDef DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c0e89c0000000000
CONST	SEGMENT
__real@c0e89c0000000000 DQ 0c0e89c0000000000r	; -50400
CONST	ENDS
;	COMDAT __real@40f5180000000000
CONST	SEGMENT
__real@40f5180000000000 DQ 040f5180000000000r	; 86400
CONST	ENDS
;	COMDAT __real@40e89c0000000000
CONST	SEGMENT
__real@40e89c0000000000 DQ 040e89c0000000000r	; 50400
CONST	ENDS
;	COMDAT __real@40ac200000000000
CONST	SEGMENT
__real@40ac200000000000 DQ 040ac200000000000r	; 3600
CONST	ENDS
;	COMDAT __real@404e000000000000
CONST	SEGMENT
__real@404e000000000000 DQ 0404e000000000000r	; 60
CONST	ENDS
;	COMDAT __real@4038000000000000
CONST	SEGMENT
__real@4038000000000000 DQ 04038000000000000r	; 24
CONST	ENDS
;	COMDAT __real@4028000000000000
CONST	SEGMENT
__real@4028000000000000 DQ 04028000000000000r	; 12
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_03BBKEAIF@?$DP?$DP?$DP@
CONST	SEGMENT
??_C@_03BBKEAIF@?$DP?$DP?$DP@ DB '???', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBIAOBPB@?$CF01?414e@
CONST	SEGMENT
??_C@_07EBIAOBPB@?$CF01?414e@ DB '%01.14e', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NDEHGMEK@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@
CONST	SEGMENT
??_C@_0CC@NDEHGMEK@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@ DB '%'
	DB	'04ld:%02u:%02uT%02u:%02u:%02.14g', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NGIOFKDM@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@
CONST	SEGMENT
??_C@_0CD@NGIOFKDM@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@ DB '%'
	DB	'04ld:%02u:%02uT%02u:%02u:%02.14gZ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KCJGDMGM@?$CF04ld?3?$CF02u?3?$CF02u@
CONST	SEGMENT
??_C@_0BA@KCJGDMGM@?$CF04ld?3?$CF02u?3?$CF02u@ DB '%04ld:%02u:%02u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPCAOJB@?$CF04ld?3?$CF02u?3?$CF02uZ@
CONST	SEGMENT
??_C@_0BB@EPCAOJB@?$CF04ld?3?$CF02u?3?$CF02uZ@ DB '%04ld:%02u:%02uZ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CMNGDBIO@?$CF02u?3?$CF02u?3?$CF02?414g@
CONST	SEGMENT
??_C@_0BC@CMNGDBIO@?$CF02u?3?$CF02u?3?$CF02?414g@ DB '%02u:%02u:%02.14g', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EKHIMNMI@?$CF02u?3?$CF02u?3?$CF02?414gZ@
CONST	SEGMENT
??_C@_0BD@EKHIMNMI@?$CF02u?3?$CF02u?3?$CF02?414gZ@ DB '%02u:%02u:%02.14gZ'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LHLPFBBC@?$CF04ld?9?$CF02u@
CONST	SEGMENT
??_C@_0L@LHLPFBBC@?$CF04ld?9?$CF02u@ DB '%04ld-%02u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CBHDPMIH@?9?$CF04ld?9?$CF02u@
CONST	SEGMENT
??_C@_0M@CBHDPMIH@?9?$CF04ld?9?$CF02u@ DB '-%04ld-%02u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IGNOHAOM@?9?9?$CF02u?9?$CF02u@
CONST	SEGMENT
??_C@_0M@IGNOHAOM@?9?9?$CF02u?9?$CF02u@ DB '--%02u-%02u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GBFLPNDN@?9?9?9?$CF02u@
CONST	SEGMENT
??_C@_07GBFLPNDN@?9?9?9?$CF02u@ DB '---%02u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PLGGIKKN@?9?9?$CF02u@
CONST	SEGMENT
??_C@_06PLGGIKKN@?9?9?$CF02u@ DB '--%02u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHGIIBEO@?$CF04ld@
CONST	SEGMENT
??_C@_05IHGIIBEO@?$CF04ld@ DB '%04ld', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LOJFMPEL@?9P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@
CONST	SEGMENT
??_C@_0BO@LOJFMPEL@?9P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@ DB '-'
	DB	'P%luY%luM%luDT%luH%luM%.14gS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KBIIDNPF@P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@
CONST	SEGMENT
??_C@_0BN@KBIIDNPF@P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@ DB 'P'
	DB	'%luY%luM%luDT%luH%luM%.14gS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IEOFADKM@?9?$CFlu@
CONST	SEGMENT
??_C@_04IEOFADKM@?9?$CFlu@ DB '-%lu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KPEGABEP@?9?$CFlu?$CFlu@
CONST	SEGMENT
??_C@_07KPEGABEP@?9?$CFlu?$CFlu@ DB '-%lu%lu', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HJALPPEN@?9?$CFlu?$CFlu?$CFlu@
CONST	SEGMENT
??_C@_0L@HJALPPEN@?9?$CFlu?$CFlu?$CFlu@ DB '-%lu%lu%lu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKNCMABI@?$CFlu@
CONST	SEGMENT
??_C@_03FKNCMABI@?$CFlu@ DB '%lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DFHLHGNP@?$CFlu?$CFlu@
CONST	SEGMENT
??_C@_06DFHLHGNP@?$CFlu?$CFlu@ DB '%lu%lu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LMAOOEAH@?$CFlu?$CFlu?$CFlu@
CONST	SEGMENT
??_C@_09LMAOOEAH@?$CFlu?$CFlu?$CFlu@ DB '%lu%lu%lu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDAFIFFL@0?40@
CONST	SEGMENT
??_C@_03MDAFIFFL@0?40@ DB '0.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PBMCLKED@allocating?5base64?5data@
CONST	SEGMENT
??_C@_0BH@PBMCLKED@allocating?5base64?5data@ DB 'allocating base64 data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DMAOOAAN@allocating?5hexbin?5data@
CONST	SEGMENT
??_C@_0BH@DMAOOAAN@allocating?5hexbin?5data@ DB 'allocating hexbin data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ DB 'Unimplem'
	DB	'ented block at %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
CONST	SEGMENT
??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@ DB 'c:\users\dag'
	DB	'\documents\_clients\codeproject authors group\windows on arm\'
	DB	'libxml2\libxml2-2.9.9\xmlschemastypes.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf@ DB '%lf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMNBPOOP@NMTOKENS@
CONST	SEGMENT
??_C@_08PMNBPOOP@NMTOKENS@ DB 'NMTOKENS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CMFBJDBA@IDREFS@
CONST	SEGMENT
??_C@_06CMFBJDBA@IDREFS@ DB 'IDREFS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ICGBNEMG@ENTITIES@
CONST	SEGMENT
??_C@_08ICGBNEMG@ENTITIES@ DB 'ENTITIES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKLBAPIO@ENTITY@
CONST	SEGMENT
??_C@_06GKLBAPIO@ENTITY@ DB 'ENTITY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKGPJLPA@IDREF@
CONST	SEGMENT
??_C@_05HKGPJLPA@IDREF@ DB 'IDREF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OLOABKKD@ID@
CONST	SEGMENT
??_C@_02OLOABKKD@ID@ DB 'ID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MDLHOHLI@NCName@
CONST	SEGMENT
??_C@_06MDLHOHLI@NCName@ DB 'NCName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JKBEJDBF@NMTOKEN@
CONST	SEGMENT
??_C@_07JKBEJDBF@NMTOKEN@ DB 'NMTOKEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FABLJDN@Name@
CONST	SEGMENT
??_C@_04FABLJDN@Name@ DB 'Name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08JGCCIMAA@language@
CONST	SEGMENT
??_C@_08JGCCIMAA@language@ DB 'language', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JMKJMOPH@token@
CONST	SEGMENT
??_C@_05JMKJMOPH@token@ DB 'token', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HPFKIGKN@normalizedString@
CONST	SEGMENT
??_C@_0BB@HPFKIGKN@normalizedString@ DB 'normalizedString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PNFEGAHG@positiveInteger@
CONST	SEGMENT
??_C@_0BA@PNFEGAHG@positiveInteger@ DB 'positiveInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BEPPBJAP@unsignedByte@
CONST	SEGMENT
??_C@_0N@BEPPBJAP@unsignedByte@ DB 'unsignedByte', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NAIDFEBN@unsignedShort@
CONST	SEGMENT
??_C@_0O@NAIDFEBN@unsignedShort@ DB 'unsignedShort', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NPFOHDP@unsignedInt@
CONST	SEGMENT
??_C@_0M@NPFOHDP@unsignedInt@ DB 'unsignedInt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PNDKOLAJ@unsignedLong@
CONST	SEGMENT
??_C@_0N@PNDKOLAJ@unsignedLong@ DB 'unsignedLong', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IEOLADAC@nonNegativeInteger@
CONST	SEGMENT
??_C@_0BD@IEOLADAC@nonNegativeInteger@ DB 'nonNegativeInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IHGKJMLH@byte@
CONST	SEGMENT
??_C@_04IHGKJMLH@byte@ DB 'byte', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BFKKPKCG@short@
CONST	SEGMENT
??_C@_05BFKKPKCG@short@ DB 'short', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBIPMCLC@int@
CONST	SEGMENT
??_C@_03JBIPMCLC@int@ DB 'int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOKPGOLB@long@
CONST	SEGMENT
??_C@_04GOKPGOLB@long@ DB 'long', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HJODLFEP@negativeInteger@
CONST	SEGMENT
??_C@_0BA@HJODLFEP@negativeInteger@ DB 'negativeInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FMNGDL@nonPositiveInteger@
CONST	SEGMENT
??_C@_0BD@FMNGDL@nonPositiveInteger@ DB 'nonPositiveInteger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LKHFMGFB@integer@
CONST	SEGMENT
??_C@_07LKHFMGFB@integer@ DB 'integer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LFDDDENB@QName@
CONST	SEGMENT
??_C@_05LFDDDENB@QName@ DB 'QName', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCDGCBCC@NOTATION@
CONST	SEGMENT
??_C@_08NCDGCBCC@NOTATION@ DB 'NOTATION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NBAOPEBP@base64Binary@
CONST	SEGMENT
??_C@_0N@NBAOPEBP@base64Binary@ DB 'base64Binary', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EHHLIAMK@hexBinary@
CONST	SEGMENT
??_C@_09EHHLIAMK@hexBinary@ DB 'hexBinary', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLDOHKEG@anyURI@
CONST	SEGMENT
??_C@_06DLDOHKEG@anyURI@ DB 'anyURI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOBOHMJA@boolean@
CONST	SEGMENT
??_C@_07GOBOHMJA@boolean@ DB 'boolean', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNJCAIGJ@double@
CONST	SEGMENT
??_C@_06BNJCAIGJ@double@ DB 'double', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KNFBNCOH@float@
CONST	SEGMENT
??_C@_05KNFBNCOH@float@ DB 'float', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGBPINEC@duration@
CONST	SEGMENT
??_C@_08LGBPINEC@duration@ DB 'duration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBFBAPHN@gDay@
CONST	SEGMENT
??_C@_04LBFBAPHN@gDay@ DB 'gDay', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EILODGOG@gMonthDay@
CONST	SEGMENT
??_C@_09EILODGOG@gMonthDay@ DB 'gMonthDay', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KBADAKNH@gMonth@
CONST	SEGMENT
??_C@_06KBADAKNH@gMonth@ DB 'gMonth', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FEFFJNNL@gYearMonth@
CONST	SEGMENT
??_C@_0L@FEFFJNNL@gYearMonth@ DB 'gYearMonth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DGCLHBFG@gYear@
CONST	SEGMENT
??_C@_05DGCLHBFG@gYear@ DB 'gYear', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLCEDBPF@time@
CONST	SEGMENT
??_C@_04CLCEDBPF@time@ DB 'time', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08JHBOOHBO@dateTime@
CONST	SEGMENT
??_C@_08JHBOOHBO@dateTime@ DB 'dateTime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JNIHBGGH@date@
CONST	SEGMENT
??_C@_04JNIHBGGH@date@ DB 'date', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEKBCPDP@decimal@
CONST	SEGMENT
??_C@_07EEKBCPDP@decimal@ DB 'decimal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string@
CONST	SEGMENT
??_C@_06ICGJLFIM@string@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMECCPMH@anySimpleType@
CONST	SEGMENT
??_C@_0O@DMECCPMH@anySimpleType@ DB 'anySimpleType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HFHHKPAL@could?5not?5create?5an?5attribute?5w@
CONST	SEGMENT
??_C@_0DC@HFHHKPAL@could?5not?5create?5an?5attribute?5w@ DB 'could not cr'
	DB	'eate an attribute wildcard on anyType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DGENAAFP@allocating?5wildcard?5component@
CONST	SEGMENT
??_C@_0BO@DGENAAFP@allocating?5wildcard?5component@ DB 'allocating wildca'
	DB	'rd component', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@
CONST	SEGMENT
??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@ DB 'allocating mod'
	DB	'el group component', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07OGOHJKKN@anyType@
CONST	SEGMENT
??_C@_07OGOHJKKN@anyType@ DB 'anyType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IIFFCFND@allocating?5particle?5component@
CONST	SEGMENT
??_C@_0BO@IIFFCFND@allocating?5particle?5component@ DB 'allocating partic'
	DB	'le component', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
CONST	SEGMENT
??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@ DB 'http://www'
	DB	'.w3.org/2001/XMLSchema', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
CONST	SEGMENT
??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@ DB 'could not ini'
	DB	'tialize basic types', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateFacetInternal
_TEXT	SEGMENT
tv195 = -28						; size = 4
tv83 = -24						; size = 4
tv77 = -20						; size = 4
tv66 = -16						; size = 4
_len$1 = -12						; size = 4
_stringType$ = -8					; size = 4
_ret$ = -4						; size = 4
_facet$ = 8						; size = 4
_fws$ = 12						; size = 4
_valType$ = 16						; size = 4
_value$ = 20						; size = 4
_val$ = 24						; size = 4
_ws$ = 28						; size = 4
_xmlSchemaValidateFacetInternal PROC			; COMDAT

; 5318 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5319 :     int ret;
; 5320 :     int stringType;
; 5321 : 
; 5322 :     if (facet == NULL)

	cmp	DWORD PTR _facet$[ebp], 0
	jne	SHORT $LN6@xmlSchemaV

; 5323 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN6@xmlSchemaV:

; 5324 : 
; 5325 :     switch (facet->type) {

	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR tv66[ebp]
	sub	edx, 1000				; 000003e8H
	mov	DWORD PTR tv66[ebp], edx
	cmp	DWORD PTR tv66[ebp], 11			; 0000000bH
	ja	$LN74@xmlSchemaV
	mov	eax, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN84@xmlSchemaV[eax*4]
$LN7@xmlSchemaV:

; 5326 : 	case XML_SCHEMA_FACET_PATTERN:
; 5327 : 	    /*
; 5328 : 	    * NOTE that for patterns, the @value needs to be the normalized
; 5329 : 	    * value, *not* the lexical initial value or the canonical value.
; 5330 : 	    */
; 5331 : 	    if (value == NULL)

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN8@xmlSchemaV

; 5332 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN8@xmlSchemaV:

; 5333 : 	    /*
; 5334 : 	    * If string-derived type, regexp must be tested on the value space of
; 5335 : 	    * the datatype.
; 5336 : 	    * See https://www.w3.org/TR/xmlschema-2/#rf-pattern
; 5337 : 	    */
; 5338 : 	    stringType = val && ((val->type >= XML_SCHEMAS_STRING && val->type <= XML_SCHEMAS_NORMSTRING)

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN77@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx], 1
	jl	SHORT $LN76@xmlSchemaV
	mov	edx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [edx], 2
	jle	SHORT $LN78@xmlSchemaV
$LN76@xmlSchemaV:
	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax], 16			; 00000010H
	jl	SHORT $LN77@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx], 22			; 00000016H
	jg	SHORT $LN77@xmlSchemaV
$LN78@xmlSchemaV:
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN80@xmlSchemaV
$LN77@xmlSchemaV:
	mov	DWORD PTR tv77[ebp], 0
$LN80@xmlSchemaV:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _stringType$[ebp], edx

; 5339 : 			      || (val->type >= XML_SCHEMAS_TOKEN && val->type <= XML_SCHEMAS_NCNAME));
; 5340 : 	    ret = xmlRegexpExec(facet->regexp,

	cmp	DWORD PTR _stringType$[ebp], 0
	je	SHORT $LN81@xmlSchemaV
	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN81@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN82@xmlSchemaV
$LN81@xmlSchemaV:
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv83[ebp], eax
$LN82@xmlSchemaV:
	mov	ecx, DWORD PTR tv83[ebp]
	push	ecx
	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_xmlRegexpExec
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 5341 : 	                        (stringType && val->value.str) ? val->value.str : value);
; 5342 : 	    if (ret == 1)

	cmp	DWORD PTR _ret$[ebp], 1
	jne	SHORT $LN9@xmlSchemaV

; 5343 : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaV
$LN9@xmlSchemaV:

; 5344 : 	    if (ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN10@xmlSchemaV

; 5345 : 		return(XML_SCHEMAV_CVC_PATTERN_VALID);

	mov	eax, 1839				; 0000072fH
	jmp	$LN1@xmlSchemaV
$LN10@xmlSchemaV:

; 5346 : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlSchemaV
$LN11@xmlSchemaV:

; 5347 : 	case XML_SCHEMA_FACET_MAXEXCLUSIVE:
; 5348 : 	    ret = xmlSchemaCompareValues(val, facet->val);

	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlSchemaCompareValues
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 5349 : 	    if (ret == -2)

	cmp	DWORD PTR _ret$[ebp], -2		; fffffffeH
	jne	SHORT $LN12@xmlSchemaV

; 5350 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN12@xmlSchemaV:

; 5351 : 	    if (ret == -1)

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN13@xmlSchemaV

; 5352 : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaV
$LN13@xmlSchemaV:

; 5353 : 	    return(XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID);

	mov	eax, 1836				; 0000072cH
	jmp	$LN1@xmlSchemaV
$LN14@xmlSchemaV:

; 5354 : 	case XML_SCHEMA_FACET_MAXINCLUSIVE:
; 5355 : 	    ret = xmlSchemaCompareValues(val, facet->val);

	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlSchemaCompareValues
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 5356 : 	    if (ret == -2)

	cmp	DWORD PTR _ret$[ebp], -2		; fffffffeH
	jne	SHORT $LN15@xmlSchemaV

; 5357 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN15@xmlSchemaV:

; 5358 : 	    if ((ret == -1) || (ret == 0))

	cmp	DWORD PTR _ret$[ebp], -1
	je	SHORT $LN17@xmlSchemaV
	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN16@xmlSchemaV
$LN17@xmlSchemaV:

; 5359 : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaV
$LN16@xmlSchemaV:

; 5360 : 	    return(XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID);

	mov	eax, 1834				; 0000072aH
	jmp	$LN1@xmlSchemaV
$LN18@xmlSchemaV:

; 5361 : 	case XML_SCHEMA_FACET_MINEXCLUSIVE:
; 5362 : 	    ret = xmlSchemaCompareValues(val, facet->val);

	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlSchemaCompareValues
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 5363 : 	    if (ret == -2)

	cmp	DWORD PTR _ret$[ebp], -2		; fffffffeH
	jne	SHORT $LN19@xmlSchemaV

; 5364 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN19@xmlSchemaV:

; 5365 : 	    if (ret == 1)

	cmp	DWORD PTR _ret$[ebp], 1
	jne	SHORT $LN20@xmlSchemaV

; 5366 : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaV
$LN20@xmlSchemaV:

; 5367 : 	    return(XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID);

	mov	eax, 1835				; 0000072bH
	jmp	$LN1@xmlSchemaV
$LN21@xmlSchemaV:

; 5368 : 	case XML_SCHEMA_FACET_MININCLUSIVE:
; 5369 : 	    ret = xmlSchemaCompareValues(val, facet->val);

	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlSchemaCompareValues
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 5370 : 	    if (ret == -2)

	cmp	DWORD PTR _ret$[ebp], -2		; fffffffeH
	jne	SHORT $LN22@xmlSchemaV

; 5371 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN22@xmlSchemaV:

; 5372 : 	    if ((ret == 1) || (ret == 0))

	cmp	DWORD PTR _ret$[ebp], 1
	je	SHORT $LN24@xmlSchemaV
	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN23@xmlSchemaV
$LN24@xmlSchemaV:

; 5373 : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaV
$LN23@xmlSchemaV:

; 5374 : 	    return(XML_SCHEMAV_CVC_MININCLUSIVE_VALID);

	mov	eax, 1833				; 00000729H
	jmp	$LN1@xmlSchemaV
$LN25@xmlSchemaV:

; 5375 : 	case XML_SCHEMA_FACET_WHITESPACE:
; 5376 : 	    /* TODO whitespaces */
; 5377 : 	    /*
; 5378 : 	    * NOTE: Whitespace should be handled to normalize
; 5379 : 	    * the value to be validated against a the facets;
; 5380 : 	    * not to normalize the value in-between.
; 5381 : 	    */
; 5382 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaV
$LN26@xmlSchemaV:

; 5383 : 	case  XML_SCHEMA_FACET_ENUMERATION:
; 5384 : 	    if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) {

	cmp	DWORD PTR _ws$[ebp], 0
	jne	SHORT $LN27@xmlSchemaV

; 5385 : 		/*
; 5386 : 		* This is to ensure API compatibility with the old
; 5387 : 		* xmlSchemaValidateFacet().
; 5388 : 		* TODO: Get rid of this case.
; 5389 : 		*/
; 5390 : 		if ((facet->value != NULL) &&

	mov	ecx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN29@xmlSchemaV
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@xmlSchemaV

; 5391 : 		    (xmlStrEqual(facet->value, value)))
; 5392 : 		    return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaV
$LN29@xmlSchemaV:

; 5393 : 	    } else {

	jmp	SHORT $LN28@xmlSchemaV
$LN27@xmlSchemaV:

; 5394 : 		ret = xmlSchemaCompareValuesWhtspExt(facet->val->type,

	mov	edx, DWORD PTR _ws$[ebp]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _valType$[ebp]
	push	edx
	mov	eax, DWORD PTR _fws$[ebp]
	push	eax
	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlSchemaCompareValuesWhtspExt
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ret$[ebp], eax

; 5395 : 		    facet->val, facet->value, fws, valType, val,
; 5396 : 		    value, ws);
; 5397 : 		if (ret == -2)

	cmp	DWORD PTR _ret$[ebp], -2		; fffffffeH
	jne	SHORT $LN30@xmlSchemaV

; 5398 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN30@xmlSchemaV:

; 5399 : 		if (ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN28@xmlSchemaV

; 5400 : 		    return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaV
$LN28@xmlSchemaV:

; 5401 : 	    }
; 5402 : 	    return(XML_SCHEMAV_CVC_ENUMERATION_VALID);

	mov	eax, 1840				; 00000730H
	jmp	$LN1@xmlSchemaV
$LN32@xmlSchemaV:

; 5403 : 	case XML_SCHEMA_FACET_LENGTH:
; 5404 : 	    /*
; 5405 : 	    * SPEC (1.3) "if {primitive type definition} is QName or NOTATION,
; 5406 : 	    * then any {value} is facet-valid."
; 5407 : 	    */
; 5408 : 	    if ((valType == XML_SCHEMAS_QNAME) ||

	cmp	DWORD PTR _valType$[ebp], 21		; 00000015H
	je	SHORT $LN34@xmlSchemaV
	cmp	DWORD PTR _valType$[ebp], 28		; 0000001cH
	jne	SHORT $LN35@xmlSchemaV
$LN34@xmlSchemaV:

; 5409 : 		(valType == XML_SCHEMAS_NOTATION))
; 5410 : 		return (0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaV
$LN35@xmlSchemaV:

; 5411 :             /* Falls through. */
; 5412 : 	case XML_SCHEMA_FACET_MAXLENGTH:
; 5413 : 	case XML_SCHEMA_FACET_MINLENGTH: {
; 5414 : 	    unsigned int len = 0;

	mov	DWORD PTR _len$1[ebp], 0

; 5415 : 
; 5416 : 	    if ((valType == XML_SCHEMAS_QNAME) ||

	cmp	DWORD PTR _valType$[ebp], 21		; 00000015H
	je	SHORT $LN37@xmlSchemaV
	cmp	DWORD PTR _valType$[ebp], 28		; 0000001cH
	jne	SHORT $LN36@xmlSchemaV
$LN37@xmlSchemaV:

; 5417 : 		(valType == XML_SCHEMAS_NOTATION))
; 5418 : 		return (0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaV
$LN36@xmlSchemaV:

; 5419 : 	    /*
; 5420 : 	    * TODO: length, maxLength and minLength must be of type
; 5421 : 	    * nonNegativeInteger only. Check if decimal is used somehow.
; 5422 : 	    */
; 5423 : 	    if ((facet->val == NULL) ||
; 5424 : 		((facet->val->type != XML_SCHEMAS_DECIMAL) &&
; 5425 : 		 (facet->val->type != XML_SCHEMAS_NNINTEGER)) ||

	mov	edx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN39@xmlSchemaV
	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN40@xmlSchemaV
	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR [edx+32]
	cmp	DWORD PTR [eax], 33			; 00000021H
	jne	SHORT $LN39@xmlSchemaV
$LN40@xmlSchemaV:
	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 1
	and	eax, 127				; 0000007fH
	je	SHORT $LN38@xmlSchemaV
$LN39@xmlSchemaV:

; 5426 : 		(facet->val->value.decimal.frac != 0)) {
; 5427 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN38@xmlSchemaV:

; 5428 : 	    }
; 5429 : 	    if ((val != NULL) && (val->type == XML_SCHEMAS_HEXBINARY))

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN41@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx], 43			; 0000002bH
	jne	SHORT $LN41@xmlSchemaV

; 5430 : 		len = val->value.hex.total;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _len$1[ebp], eax
	jmp	$LN42@xmlSchemaV
$LN41@xmlSchemaV:

; 5431 : 	    else if ((val != NULL) && (val->type == XML_SCHEMAS_BASE64BINARY))

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN43@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx], 44			; 0000002cH
	jne	SHORT $LN43@xmlSchemaV

; 5432 : 		len = val->value.base64.total;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _len$1[ebp], eax
	jmp	$LN42@xmlSchemaV
$LN43@xmlSchemaV:

; 5433 : 	    else {
; 5434 : 		switch (valType) {

	mov	ecx, DWORD PTR _valType$[ebp]
	mov	DWORD PTR tv195[ebp], ecx
	mov	edx, DWORD PTR tv195[ebp]
	sub	edx, 1
	mov	DWORD PTR tv195[ebp], edx
	cmp	DWORD PTR tv195[ebp], 28		; 0000001cH
	ja	$LN55@xmlSchemaV
	mov	eax, DWORD PTR tv195[ebp]
	movzx	ecx, BYTE PTR $LN83@xmlSchemaV[eax]
	jmp	DWORD PTR $LN85@xmlSchemaV[ecx*4]
$LN45@xmlSchemaV:

; 5435 : 		    case XML_SCHEMAS_STRING:
; 5436 : 		    case XML_SCHEMAS_NORMSTRING:
; 5437 : 			if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) {

	cmp	DWORD PTR _ws$[ebp], 0
	jne	SHORT $LN46@xmlSchemaV

; 5438 : 			    /*
; 5439 : 			    * This is to ensure API compatibility with the old
; 5440 : 			    * xmlSchemaValidateFacet(). Anyway, this was and
; 5441 : 			    * is not the correct handling.
; 5442 : 			    * TODO: Get rid of this case somehow.
; 5443 : 			    */
; 5444 : 			    if (valType == XML_SCHEMAS_STRING)

	cmp	DWORD PTR _valType$[ebp], 1
	jne	SHORT $LN48@xmlSchemaV

; 5445 : 				len = xmlUTF8Strlen(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlUTF8Strlen
	add	esp, 4
	mov	DWORD PTR _len$1[ebp], eax
	jmp	SHORT $LN49@xmlSchemaV
$LN48@xmlSchemaV:

; 5446 : 			    else
; 5447 : 				len = xmlSchemaNormLen(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlSchemaNormLen
	add	esp, 4
	mov	DWORD PTR _len$1[ebp], eax
$LN49@xmlSchemaV:

; 5448 : 			} else if (value != NULL) {

	jmp	SHORT $LN47@xmlSchemaV
$LN46@xmlSchemaV:
	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN47@xmlSchemaV

; 5449 : 			    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	DWORD PTR _ws$[ebp], 3
	jne	SHORT $LN51@xmlSchemaV

; 5450 : 				len = xmlSchemaNormLen(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlSchemaNormLen
	add	esp, 4
	mov	DWORD PTR _len$1[ebp], eax
	jmp	SHORT $LN47@xmlSchemaV
$LN51@xmlSchemaV:

; 5451 : 			    else
; 5452 : 				/*
; 5453 : 				* Should be OK for "preserve" as well.
; 5454 : 				*/
; 5455 : 				len = xmlUTF8Strlen(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlUTF8Strlen
	add	esp, 4
	mov	DWORD PTR _len$1[ebp], eax
$LN47@xmlSchemaV:

; 5456 : 			}
; 5457 : 			break;

	jmp	SHORT $LN42@xmlSchemaV
$LN53@xmlSchemaV:

; 5458 : 		    case XML_SCHEMAS_IDREF:
; 5459 : 		    case XML_SCHEMAS_TOKEN:
; 5460 : 		    case XML_SCHEMAS_LANGUAGE:
; 5461 : 		    case XML_SCHEMAS_NMTOKEN:
; 5462 : 		    case XML_SCHEMAS_NAME:
; 5463 : 		    case XML_SCHEMAS_NCNAME:
; 5464 : 		    case XML_SCHEMAS_ID:
; 5465 : 		    case XML_SCHEMAS_ANYURI:
; 5466 : 			if (value != NULL)

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN54@xmlSchemaV

; 5467 : 			    len = xmlSchemaNormLen(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlSchemaNormLen
	add	esp, 4
	mov	DWORD PTR _len$1[ebp], eax
$LN54@xmlSchemaV:

; 5468 : 			break;

	jmp	SHORT $LN42@xmlSchemaV
$LN55@xmlSchemaV:

; 5469 : 		    default:
; 5470 : 		        TODO

	mov	esi, esp
	push	5470					; 0000155eH
	push	OFFSET ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN42@xmlSchemaV:

; 5471 : 		}
; 5472 : 	    }
; 5473 : 	    if (facet->type == XML_SCHEMA_FACET_LENGTH) {

	mov	eax, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [eax], 1009			; 000003f1H
	jne	SHORT $LN56@xmlSchemaV

; 5474 : 		if (len != facet->val->value.decimal.lo)

	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _len$1[ebp]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN58@xmlSchemaV

; 5475 : 		    return(XML_SCHEMAV_CVC_LENGTH_VALID);

	mov	eax, 1830				; 00000726H
	jmp	$LN1@xmlSchemaV
$LN58@xmlSchemaV:

; 5476 : 	    } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) {

	jmp	SHORT $LN57@xmlSchemaV
$LN56@xmlSchemaV:
	mov	ecx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [ecx], 1011			; 000003f3H
	jne	SHORT $LN59@xmlSchemaV

; 5477 : 		if (len < facet->val->value.decimal.lo)

	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _len$1[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN61@xmlSchemaV

; 5478 : 		    return(XML_SCHEMAV_CVC_MINLENGTH_VALID);

	mov	eax, 1831				; 00000727H
	jmp	$LN1@xmlSchemaV
$LN61@xmlSchemaV:

; 5479 : 	    } else {

	jmp	SHORT $LN57@xmlSchemaV
$LN59@xmlSchemaV:

; 5480 : 		if (len > facet->val->value.decimal.lo)

	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _len$1[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jbe	SHORT $LN57@xmlSchemaV

; 5481 : 		    return(XML_SCHEMAV_CVC_MAXLENGTH_VALID);

	mov	eax, 1832				; 00000728H
	jmp	$LN1@xmlSchemaV
$LN57@xmlSchemaV:

; 5482 : 	    }
; 5483 : 	    break;

	jmp	$LN2@xmlSchemaV
$LN63@xmlSchemaV:

; 5484 : 	}
; 5485 : 	case XML_SCHEMA_FACET_TOTALDIGITS:
; 5486 : 	case XML_SCHEMA_FACET_FRACTIONDIGITS:
; 5487 : 
; 5488 : 	    if ((facet->val == NULL) ||
; 5489 : 		((facet->val->type != XML_SCHEMAS_PINTEGER) &&
; 5490 : 		 (facet->val->type != XML_SCHEMAS_NNINTEGER)) ||

	mov	edx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN65@xmlSchemaV
	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	DWORD PTR [ecx], 34			; 00000022H
	je	SHORT $LN66@xmlSchemaV
	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR [edx+32]
	cmp	DWORD PTR [eax], 33			; 00000021H
	jne	SHORT $LN65@xmlSchemaV
$LN66@xmlSchemaV:
	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 1
	and	eax, 127				; 0000007fH
	je	SHORT $LN64@xmlSchemaV
$LN65@xmlSchemaV:

; 5491 : 		(facet->val->value.decimal.frac != 0)) {
; 5492 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN64@xmlSchemaV:

; 5493 : 	    }
; 5494 : 	    if ((val == NULL) ||

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN68@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN67@xmlSchemaV
	mov	edx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [edx], 30			; 0000001eH
	je	SHORT $LN67@xmlSchemaV
	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax], 31			; 0000001fH
	je	SHORT $LN67@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx], 32			; 00000020H
	je	SHORT $LN67@xmlSchemaV
	mov	edx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [edx], 33			; 00000021H
	je	SHORT $LN67@xmlSchemaV
	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax], 34			; 00000022H
	je	SHORT $LN67@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx], 35			; 00000023H
	je	SHORT $LN67@xmlSchemaV
	mov	edx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [edx], 36			; 00000024H
	je	SHORT $LN67@xmlSchemaV
	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax], 37			; 00000025H
	je	SHORT $LN67@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx], 38			; 00000026H
	je	SHORT $LN67@xmlSchemaV
	mov	edx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [edx], 39			; 00000027H
	je	SHORT $LN67@xmlSchemaV
	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax], 40			; 00000028H
	je	SHORT $LN67@xmlSchemaV
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx], 41			; 00000029H
	je	SHORT $LN67@xmlSchemaV
	mov	edx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [edx], 42			; 0000002aH
	je	SHORT $LN67@xmlSchemaV
$LN68@xmlSchemaV:

; 5495 : 		((val->type != XML_SCHEMAS_DECIMAL) &&
; 5496 : 		 (val->type != XML_SCHEMAS_INTEGER) &&
; 5497 : 		 (val->type != XML_SCHEMAS_NPINTEGER) &&
; 5498 : 		 (val->type != XML_SCHEMAS_NINTEGER) &&
; 5499 : 		 (val->type != XML_SCHEMAS_NNINTEGER) &&
; 5500 : 		 (val->type != XML_SCHEMAS_PINTEGER) &&
; 5501 : 		 (val->type != XML_SCHEMAS_INT) &&
; 5502 : 		 (val->type != XML_SCHEMAS_UINT) &&
; 5503 : 		 (val->type != XML_SCHEMAS_LONG) &&
; 5504 : 		 (val->type != XML_SCHEMAS_ULONG) &&
; 5505 : 		 (val->type != XML_SCHEMAS_SHORT) &&
; 5506 : 		 (val->type != XML_SCHEMAS_USHORT) &&
; 5507 : 		 (val->type != XML_SCHEMAS_BYTE) &&
; 5508 : 		 (val->type != XML_SCHEMAS_UBYTE))) {
; 5509 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN67@xmlSchemaV:

; 5510 : 	    }
; 5511 : 	    if (facet->type == XML_SCHEMA_FACET_TOTALDIGITS) {

	mov	eax, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [eax], 1004			; 000003ecH
	jne	SHORT $LN69@xmlSchemaV

; 5512 : 	        if (val->value.decimal.total > facet->val->value.decimal.lo)

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	shr	edx, 8
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	edx, DWORD PTR [ecx+8]
	jbe	SHORT $LN71@xmlSchemaV

; 5513 : 	            return(XML_SCHEMAV_CVC_TOTALDIGITS_VALID);

	mov	eax, 1837				; 0000072dH
	jmp	SHORT $LN1@xmlSchemaV
$LN71@xmlSchemaV:

; 5514 : 
; 5515 : 	    } else if (facet->type == XML_SCHEMA_FACET_FRACTIONDIGITS) {

	jmp	SHORT $LN70@xmlSchemaV
$LN69@xmlSchemaV:
	mov	edx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [edx], 1005			; 000003edH
	jne	SHORT $LN70@xmlSchemaV

; 5516 : 	        if (val->value.decimal.frac > facet->val->value.decimal.lo)

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shr	ecx, 1
	and	ecx, 127				; 0000007fH
	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR [edx+32]
	cmp	ecx, DWORD PTR [eax+8]
	jbe	SHORT $LN70@xmlSchemaV

; 5517 : 		    return(XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID);

	mov	eax, 1838				; 0000072eH
	jmp	SHORT $LN1@xmlSchemaV
$LN70@xmlSchemaV:

; 5518 : 	    }
; 5519 : 	    break;

	jmp	SHORT $LN2@xmlSchemaV
$LN74@xmlSchemaV:

; 5520 : 	default:
; 5521 : 	    TODO

	mov	esi, esp
	push	5521					; 00001591H
	push	OFFSET ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@xmlSchemaV:

; 5522 :     }
; 5523 :     return(0);

	xor	eax, eax
$LN1@xmlSchemaV:

; 5524 : 
; 5525 : }

	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN84@xmlSchemaV:
	DD	$LN21@xmlSchemaV
	DD	$LN18@xmlSchemaV
	DD	$LN14@xmlSchemaV
	DD	$LN11@xmlSchemaV
	DD	$LN63@xmlSchemaV
	DD	$LN63@xmlSchemaV
	DD	$LN7@xmlSchemaV
	DD	$LN26@xmlSchemaV
	DD	$LN25@xmlSchemaV
	DD	$LN32@xmlSchemaV
	DD	$LN35@xmlSchemaV
	DD	$LN35@xmlSchemaV
$LN85@xmlSchemaV:
	DD	$LN45@xmlSchemaV
	DD	$LN53@xmlSchemaV
	DD	$LN55@xmlSchemaV
$LN83@xmlSchemaV:
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
	DB	1
	DB	2
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
_xmlSchemaValidateFacetInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateLengthFacetInternal
_TEXT	SEGMENT
tv93 = -8						; size = 4
_len$ = -4						; size = 4
_facet$ = 8						; size = 4
_valType$ = 12						; size = 4
_value$ = 16						; size = 4
_val$ = 20						; size = 4
_length$ = 24						; size = 4
_ws$ = 28						; size = 4
_xmlSchemaValidateLengthFacetInternal PROC		; COMDAT

; 5149 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5150 :     unsigned int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 5151 : 
; 5152 :     if ((length == NULL) || (facet == NULL))

	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN5@xmlSchemaV
	cmp	DWORD PTR _facet$[ebp], 0
	jne	SHORT $LN4@xmlSchemaV
$LN5@xmlSchemaV:

; 5153 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN4@xmlSchemaV:

; 5154 :     *length = 0;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], 0

; 5155 :     if ((facet->type != XML_SCHEMA_FACET_LENGTH) &&
; 5156 : 	(facet->type != XML_SCHEMA_FACET_MAXLENGTH) &&

	mov	ecx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [ecx], 1009			; 000003f1H
	je	SHORT $LN6@xmlSchemaV
	mov	edx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [edx], 1010			; 000003f2H
	je	SHORT $LN6@xmlSchemaV
	mov	eax, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [eax], 1011			; 000003f3H
	je	SHORT $LN6@xmlSchemaV

; 5157 : 	(facet->type != XML_SCHEMA_FACET_MINLENGTH))
; 5158 : 	return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN6@xmlSchemaV:

; 5159 : 
; 5160 :     /*
; 5161 :     * TODO: length, maxLength and minLength must be of type
; 5162 :     * nonNegativeInteger only. Check if decimal is used somehow.
; 5163 :     */
; 5164 :     if ((facet->val == NULL) ||
; 5165 : 	((facet->val->type != XML_SCHEMAS_DECIMAL) &&
; 5166 : 	 (facet->val->type != XML_SCHEMAS_NNINTEGER)) ||

	mov	ecx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN8@xmlSchemaV
	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR [edx+32]
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN9@xmlSchemaV
	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx], 33			; 00000021H
	jne	SHORT $LN8@xmlSchemaV
$LN9@xmlSchemaV:
	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+24]
	shr	edx, 1
	and	edx, 127				; 0000007fH
	je	SHORT $LN7@xmlSchemaV
$LN8@xmlSchemaV:

; 5167 : 	(facet->val->value.decimal.frac != 0)) {
; 5168 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN7@xmlSchemaV:

; 5169 :     }
; 5170 :     if ((val != NULL) && (val->type == XML_SCHEMAS_HEXBINARY))

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN10@xmlSchemaV
	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax], 43			; 0000002bH
	jne	SHORT $LN10@xmlSchemaV

; 5171 : 	len = val->value.hex.total;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _len$[ebp], edx
	jmp	$LN11@xmlSchemaV
$LN10@xmlSchemaV:

; 5172 :     else if ((val != NULL) && (val->type == XML_SCHEMAS_BASE64BINARY))

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN12@xmlSchemaV
	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax], 44			; 0000002cH
	jne	SHORT $LN12@xmlSchemaV

; 5173 : 	len = val->value.base64.total;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _len$[ebp], edx
	jmp	$LN11@xmlSchemaV
$LN12@xmlSchemaV:

; 5174 :     else {
; 5175 : 	switch (valType) {

	mov	eax, DWORD PTR _valType$[ebp]
	mov	DWORD PTR tv93[ebp], eax
	mov	ecx, DWORD PTR tv93[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv93[ebp], ecx
	cmp	DWORD PTR tv93[ebp], 28			; 0000001cH
	ja	$LN25@xmlSchemaV
	mov	edx, DWORD PTR tv93[ebp]
	movzx	eax, BYTE PTR $LN34@xmlSchemaV[edx]
	jmp	DWORD PTR $LN35@xmlSchemaV[eax*4]
$LN14@xmlSchemaV:

; 5176 : 	    case XML_SCHEMAS_STRING:
; 5177 : 	    case XML_SCHEMAS_NORMSTRING:
; 5178 : 		if (ws == XML_SCHEMA_WHITESPACE_UNKNOWN) {

	cmp	DWORD PTR _ws$[ebp], 0
	jne	SHORT $LN15@xmlSchemaV

; 5179 : 		    /*
; 5180 : 		    * This is to ensure API compatibility with the old
; 5181 : 		    * xmlSchemaValidateLengthFacet(). Anyway, this was and
; 5182 : 		    * is not the correct handling.
; 5183 : 		    * TODO: Get rid of this case somehow.
; 5184 : 		    */
; 5185 : 		    if (valType == XML_SCHEMAS_STRING)

	cmp	DWORD PTR _valType$[ebp], 1
	jne	SHORT $LN17@xmlSchemaV

; 5186 : 			len = xmlUTF8Strlen(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlUTF8Strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN18@xmlSchemaV
$LN17@xmlSchemaV:

; 5187 : 		    else
; 5188 : 			len = xmlSchemaNormLen(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlSchemaNormLen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN18@xmlSchemaV:

; 5189 : 		} else if (value != NULL) {

	jmp	SHORT $LN16@xmlSchemaV
$LN15@xmlSchemaV:
	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN16@xmlSchemaV

; 5190 : 		    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	DWORD PTR _ws$[ebp], 3
	jne	SHORT $LN20@xmlSchemaV

; 5191 : 			len = xmlSchemaNormLen(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlSchemaNormLen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN16@xmlSchemaV
$LN20@xmlSchemaV:

; 5192 : 		    else
; 5193 : 		    /*
; 5194 : 		    * Should be OK for "preserve" as well.
; 5195 : 		    */
; 5196 : 		    len = xmlUTF8Strlen(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlUTF8Strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN16@xmlSchemaV:

; 5197 : 		}
; 5198 : 		break;

	jmp	SHORT $LN11@xmlSchemaV
$LN22@xmlSchemaV:

; 5199 : 	    case XML_SCHEMAS_IDREF:
; 5200 : 	    case XML_SCHEMAS_TOKEN:
; 5201 : 	    case XML_SCHEMAS_LANGUAGE:
; 5202 : 	    case XML_SCHEMAS_NMTOKEN:
; 5203 : 	    case XML_SCHEMAS_NAME:
; 5204 : 	    case XML_SCHEMAS_NCNAME:
; 5205 : 	    case XML_SCHEMAS_ID:
; 5206 : 		/*
; 5207 : 		* FIXME: What exactly to do with anyURI?
; 5208 : 		*/
; 5209 : 	    case XML_SCHEMAS_ANYURI:
; 5210 : 		if (value != NULL)

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN23@xmlSchemaV

; 5211 : 		    len = xmlSchemaNormLen(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlSchemaNormLen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN23@xmlSchemaV:

; 5212 : 		break;

	jmp	SHORT $LN11@xmlSchemaV
$LN24@xmlSchemaV:

; 5213 : 	    case XML_SCHEMAS_QNAME:
; 5214 : 	    case XML_SCHEMAS_NOTATION:
; 5215 : 		/*
; 5216 : 		* For QName and NOTATION, those facets are
; 5217 : 		* deprecated and should be ignored.
; 5218 : 		*/
; 5219 : 		return (0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaV
$LN25@xmlSchemaV:

; 5220 : 	    default:
; 5221 : 		TODO

	mov	esi, esp
	push	5221					; 00001465H
	push	OFFSET ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlSchemaV:

; 5222 : 	}
; 5223 :     }
; 5224 :     *length = (unsigned long) len;

	mov	edx, DWORD PTR _length$[ebp]
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx], eax

; 5225 :     /*
; 5226 :     * TODO: Return the whole expected value, i.e. "lo", "mi" and "hi".
; 5227 :     */
; 5228 :     if (facet->type == XML_SCHEMA_FACET_LENGTH) {

	mov	ecx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [ecx], 1009			; 000003f1H
	jne	SHORT $LN26@xmlSchemaV

; 5229 : 	if (len != facet->val->value.decimal.lo)

	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN28@xmlSchemaV

; 5230 : 	    return(XML_SCHEMAV_CVC_LENGTH_VALID);

	mov	eax, 1830				; 00000726H
	jmp	SHORT $LN1@xmlSchemaV
$LN28@xmlSchemaV:

; 5231 :     } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) {

	jmp	SHORT $LN27@xmlSchemaV
$LN26@xmlSchemaV:
	mov	edx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [edx], 1011			; 000003f3H
	jne	SHORT $LN29@xmlSchemaV

; 5232 : 	if (len < facet->val->value.decimal.lo)

	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _len$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN31@xmlSchemaV

; 5233 : 	    return(XML_SCHEMAV_CVC_MINLENGTH_VALID);

	mov	eax, 1831				; 00000727H
	jmp	SHORT $LN1@xmlSchemaV
$LN31@xmlSchemaV:

; 5234 :     } else {

	jmp	SHORT $LN27@xmlSchemaV
$LN29@xmlSchemaV:

; 5235 : 	if (len > facet->val->value.decimal.lo)

	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _len$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jbe	SHORT $LN27@xmlSchemaV

; 5236 : 	    return(XML_SCHEMAV_CVC_MAXLENGTH_VALID);

	mov	eax, 1832				; 00000728H
	jmp	SHORT $LN1@xmlSchemaV
$LN27@xmlSchemaV:

; 5237 :     }
; 5238 : 
; 5239 :     return (0);

	xor	eax, eax
$LN1@xmlSchemaV:

; 5240 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN35@xmlSchemaV:
	DD	$LN14@xmlSchemaV
	DD	$LN22@xmlSchemaV
	DD	$LN24@xmlSchemaV
	DD	$LN25@xmlSchemaV
$LN34@xmlSchemaV:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	3
	DB	1
	DB	2
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
_xmlSchemaValidateLengthFacetInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNormLen
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_utf$ = -4						; size = 4
_value$ = 8						; size = 4
_xmlSchemaNormLen PROC					; COMDAT

; 5019 : xmlSchemaNormLen(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5020 :     const xmlChar *utf;
; 5021 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 5022 : 
; 5023 :     if (value == NULL)

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN8@xmlSchemaN

; 5024 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaN
$LN8@xmlSchemaN:

; 5025 :     utf = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _utf$[ebp], eax
$LN2@xmlSchemaN:

; 5026 :     while (IS_BLANK_CH(*utf)) utf++;

	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN9@xmlSchemaN
	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN10@xmlSchemaN
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN9@xmlSchemaN
$LN10@xmlSchemaN:
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN4@xmlSchemaN
$LN9@xmlSchemaN:
	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, 1
	mov	DWORD PTR _utf$[ebp], eax
	jmp	SHORT $LN2@xmlSchemaN
$LN4@xmlSchemaN:

; 5027 :     while (*utf != 0) {

	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN5@xmlSchemaN

; 5028 : 	if (utf[0] & 0x80) {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 128				; 00000080H
	je	$LN11@xmlSchemaN

; 5029 : 	    if ((utf[1] & 0xc0) != 0x80)

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN13@xmlSchemaN

; 5030 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaN
$LN13@xmlSchemaN:

; 5031 : 	    if ((utf[0] & 0xe0) == 0xe0) {

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 224				; 000000e0H
	cmp	ecx, 224				; 000000e0H
	jne	$LN14@xmlSchemaN

; 5032 : 		if ((utf[2] & 0xc0) != 0x80)

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 128				; 00000080H
	je	SHORT $LN16@xmlSchemaN

; 5033 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaN
$LN16@xmlSchemaN:

; 5034 : 		if ((utf[0] & 0xf0) == 0xf0) {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 240				; 000000f0H
	cmp	edx, 240				; 000000f0H
	jne	SHORT $LN17@xmlSchemaN

; 5035 : 		    if ((utf[0] & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 248				; 000000f8H
	cmp	eax, 240				; 000000f0H
	jne	SHORT $LN20@xmlSchemaN
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 128				; 00000080H
	je	SHORT $LN19@xmlSchemaN
$LN20@xmlSchemaN:

; 5036 : 			return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaN
$LN19@xmlSchemaN:

; 5037 : 		    utf += 4;

	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, 4
	mov	DWORD PTR _utf$[ebp], edx

; 5038 : 		} else {

	jmp	SHORT $LN18@xmlSchemaN
$LN17@xmlSchemaN:

; 5039 : 		    utf += 3;

	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, 3
	mov	DWORD PTR _utf$[ebp], eax
$LN18@xmlSchemaN:

; 5040 : 		}
; 5041 : 	    } else {

	jmp	SHORT $LN15@xmlSchemaN
$LN14@xmlSchemaN:

; 5042 : 		utf += 2;

	mov	ecx, DWORD PTR _utf$[ebp]
	add	ecx, 2
	mov	DWORD PTR _utf$[ebp], ecx
$LN15@xmlSchemaN:

; 5043 : 	    }

	jmp	SHORT $LN12@xmlSchemaN
$LN11@xmlSchemaN:

; 5044 : 	} else if (IS_BLANK_CH(*utf)) {

	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN6@xmlSchemaN
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN24@xmlSchemaN
	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN6@xmlSchemaN
$LN24@xmlSchemaN:
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN21@xmlSchemaN
$LN6@xmlSchemaN:

; 5045 : 	    while (IS_BLANK_CH(*utf)) utf++;

	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN25@xmlSchemaN
	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN26@xmlSchemaN
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN25@xmlSchemaN
$LN26@xmlSchemaN:
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN7@xmlSchemaN
$LN25@xmlSchemaN:
	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, 1
	mov	DWORD PTR _utf$[ebp], eax
	jmp	SHORT $LN6@xmlSchemaN
$LN7@xmlSchemaN:

; 5046 : 	    if (*utf == 0)

	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN27@xmlSchemaN

; 5047 : 		break;

	jmp	SHORT $LN5@xmlSchemaN
$LN27@xmlSchemaN:

; 5048 : 	} else {

	jmp	SHORT $LN12@xmlSchemaN
$LN21@xmlSchemaN:

; 5049 : 	    utf++;

	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, 1
	mov	DWORD PTR _utf$[ebp], eax
$LN12@xmlSchemaN:

; 5050 : 	}
; 5051 : 	ret++;

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ret$[ebp], ecx

; 5052 :     }

	jmp	$LN4@xmlSchemaN
$LN5@xmlSchemaN:

; 5053 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSchemaN:

; 5054 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaNormLen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareValuesWhtspExt
_TEXT	SEGMENT
_xtype$ = 8						; size = 4
_x$ = 12						; size = 4
_xvalue$ = 16						; size = 4
_xws$ = 20						; size = 4
_ytype$ = 24						; size = 4
_y$ = 28						; size = 4
_yvalue$ = 32						; size = 4
_yws$ = 36						; size = 4
_xmlSchemaCompareValuesWhtspExt PROC			; COMDAT

; 5005 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5006 :     return(xmlSchemaCompareValuesInternal(xtype, x, xvalue, xws, ytype, y,

	mov	eax, DWORD PTR _yws$[ebp]
	push	eax
	mov	ecx, DWORD PTR _yvalue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _ytype$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xws$[ebp]
	push	ecx
	mov	edx, DWORD PTR _xvalue$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xtype$[ebp]
	push	ecx
	call	_xmlSchemaCompareValuesInternal
	add	esp, 32					; 00000020H

; 5007 : 	yvalue, yws));
; 5008 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaCompareValuesWhtspExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareValuesInternal
_TEXT	SEGMENT
tv64 = -20						; size = 4
_ret$1 = -16						; size = 4
_ret$2 = -12						; size = 4
_yv$3 = -8						; size = 4
_xv$4 = -4						; size = 4
_xtype$ = 8						; size = 4
_x$ = 12						; size = 4
_xvalue$ = 16						; size = 4
_xws$ = 20						; size = 4
_ytype$ = 24						; size = 4
_y$ = 28						; size = 4
_yvalue$ = 32						; size = 4
_yws$ = 36						; size = 4
_xmlSchemaCompareValuesInternal PROC			; COMDAT

; 4699 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 4700 :     switch (xtype) {

	mov	eax, DWORD PTR _xtype$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 46			; 0000002eH
	ja	$LN2@xmlSchemaC
	mov	ecx, DWORD PTR tv64[ebp]
	movzx	edx, BYTE PTR $LN89@xmlSchemaC[ecx]
	jmp	DWORD PTR $LN90@xmlSchemaC[edx*4]
$LN4@xmlSchemaC:

; 4701 : 	case XML_SCHEMAS_UNKNOWN:
; 4702 : 	case XML_SCHEMAS_ANYTYPE:
; 4703 : 	    return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN5@xmlSchemaC:

; 4704 :         case XML_SCHEMAS_INTEGER:
; 4705 :         case XML_SCHEMAS_NPINTEGER:
; 4706 :         case XML_SCHEMAS_NINTEGER:
; 4707 :         case XML_SCHEMAS_NNINTEGER:
; 4708 :         case XML_SCHEMAS_PINTEGER:
; 4709 :         case XML_SCHEMAS_INT:
; 4710 :         case XML_SCHEMAS_UINT:
; 4711 :         case XML_SCHEMAS_LONG:
; 4712 :         case XML_SCHEMAS_ULONG:
; 4713 :         case XML_SCHEMAS_SHORT:
; 4714 :         case XML_SCHEMAS_USHORT:
; 4715 :         case XML_SCHEMAS_BYTE:
; 4716 :         case XML_SCHEMAS_UBYTE:
; 4717 : 	case XML_SCHEMAS_DECIMAL:
; 4718 : 	    if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN7@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN6@xmlSchemaC
$LN7@xmlSchemaC:

; 4719 : 		return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN6@xmlSchemaC:

; 4720 : 	    if (ytype == xtype)

	mov	eax, DWORD PTR _ytype$[ebp]
	cmp	eax, DWORD PTR _xtype$[ebp]
	jne	SHORT $LN8@xmlSchemaC

; 4721 : 		return(xmlSchemaCompareDecimals(x, y));

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_xmlSchemaCompareDecimals
	add	esp, 8
	jmp	$LN1@xmlSchemaC
$LN8@xmlSchemaC:

; 4722 : 	    if ((ytype == XML_SCHEMAS_DECIMAL) ||
; 4723 : 		(ytype == XML_SCHEMAS_INTEGER) ||
; 4724 : 		(ytype == XML_SCHEMAS_NPINTEGER) ||
; 4725 : 		(ytype == XML_SCHEMAS_NINTEGER) ||
; 4726 : 		(ytype == XML_SCHEMAS_NNINTEGER) ||
; 4727 : 		(ytype == XML_SCHEMAS_PINTEGER) ||
; 4728 : 		(ytype == XML_SCHEMAS_INT) ||
; 4729 : 		(ytype == XML_SCHEMAS_UINT) ||
; 4730 : 		(ytype == XML_SCHEMAS_LONG) ||
; 4731 : 		(ytype == XML_SCHEMAS_ULONG) ||
; 4732 : 		(ytype == XML_SCHEMAS_SHORT) ||
; 4733 : 		(ytype == XML_SCHEMAS_USHORT) ||
; 4734 : 		(ytype == XML_SCHEMAS_BYTE) ||

	cmp	DWORD PTR _ytype$[ebp], 3
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 30		; 0000001eH
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 31		; 0000001fH
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 32		; 00000020H
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 33		; 00000021H
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 34		; 00000022H
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 35		; 00000023H
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 36		; 00000024H
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 37		; 00000025H
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 38		; 00000026H
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 39		; 00000027H
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 40		; 00000028H
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 41		; 00000029H
	je	SHORT $LN10@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 42		; 0000002aH
	jne	SHORT $LN9@xmlSchemaC
$LN10@xmlSchemaC:

; 4735 : 		(ytype == XML_SCHEMAS_UBYTE))
; 4736 : 		return(xmlSchemaCompareDecimals(x, y));

	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_xmlSchemaCompareDecimals
	add	esp, 8
	jmp	$LN1@xmlSchemaC
$LN9@xmlSchemaC:

; 4737 : 	    return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN11@xmlSchemaC:

; 4738 :         case XML_SCHEMAS_DURATION:
; 4739 : 	    if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN13@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN12@xmlSchemaC
$LN13@xmlSchemaC:

; 4740 : 		return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN12@xmlSchemaC:

; 4741 : 	    if (ytype == XML_SCHEMAS_DURATION)

	cmp	DWORD PTR _ytype$[ebp], 12		; 0000000cH
	jne	SHORT $LN14@xmlSchemaC

; 4742 :                 return(xmlSchemaCompareDurations(x, y));

	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_xmlSchemaCompareDurations
	add	esp, 8
	jmp	$LN1@xmlSchemaC
$LN14@xmlSchemaC:

; 4743 :             return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN15@xmlSchemaC:

; 4744 :         case XML_SCHEMAS_TIME:
; 4745 :         case XML_SCHEMAS_GDAY:
; 4746 :         case XML_SCHEMAS_GMONTH:
; 4747 :         case XML_SCHEMAS_GMONTHDAY:
; 4748 :         case XML_SCHEMAS_GYEAR:
; 4749 :         case XML_SCHEMAS_GYEARMONTH:
; 4750 :         case XML_SCHEMAS_DATE:
; 4751 :         case XML_SCHEMAS_DATETIME:
; 4752 : 	    if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN17@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN16@xmlSchemaC
$LN17@xmlSchemaC:

; 4753 : 		return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN16@xmlSchemaC:

; 4754 :             if ((ytype == XML_SCHEMAS_DATETIME)  ||
; 4755 :                 (ytype == XML_SCHEMAS_TIME)      ||
; 4756 :                 (ytype == XML_SCHEMAS_GDAY)      ||
; 4757 :                 (ytype == XML_SCHEMAS_GMONTH)    ||
; 4758 :                 (ytype == XML_SCHEMAS_GMONTHDAY) ||
; 4759 :                 (ytype == XML_SCHEMAS_GYEAR)     ||
; 4760 :                 (ytype == XML_SCHEMAS_DATE)      ||

	cmp	DWORD PTR _ytype$[ebp], 11		; 0000000bH
	je	SHORT $LN19@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 4
	je	SHORT $LN19@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 5
	je	SHORT $LN19@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 6
	je	SHORT $LN19@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 7
	je	SHORT $LN19@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 8
	je	SHORT $LN19@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 10		; 0000000aH
	je	SHORT $LN19@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 9
	jne	SHORT $LN18@xmlSchemaC
$LN19@xmlSchemaC:

; 4761 :                 (ytype == XML_SCHEMAS_GYEARMONTH))
; 4762 :                 return (xmlSchemaCompareDates(x, y));

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_xmlSchemaCompareDates
	add	esp, 8
	jmp	$LN1@xmlSchemaC
$LN18@xmlSchemaC:

; 4763 :             return (-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN20@xmlSchemaC:

; 4764 : 	/*
; 4765 : 	* Note that we will support comparison of string types against
; 4766 : 	* anySimpleType as well.
; 4767 : 	*/
; 4768 : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 4769 : 	case XML_SCHEMAS_STRING:
; 4770 :         case XML_SCHEMAS_NORMSTRING:
; 4771 :         case XML_SCHEMAS_TOKEN:
; 4772 :         case XML_SCHEMAS_LANGUAGE:
; 4773 :         case XML_SCHEMAS_NMTOKEN:
; 4774 :         case XML_SCHEMAS_NAME:
; 4775 :         case XML_SCHEMAS_NCNAME:
; 4776 :         case XML_SCHEMAS_ID:
; 4777 :         case XML_SCHEMAS_IDREF:
; 4778 :         case XML_SCHEMAS_ENTITY:
; 4779 :         case XML_SCHEMAS_ANYURI:
; 4780 : 	{
; 4781 : 	    const xmlChar *xv, *yv;
; 4782 : 
; 4783 : 	    if (x == NULL)

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN21@xmlSchemaC

; 4784 : 		xv = xvalue;

	mov	eax, DWORD PTR _xvalue$[ebp]
	mov	DWORD PTR _xv$4[ebp], eax
	jmp	SHORT $LN22@xmlSchemaC
$LN21@xmlSchemaC:

; 4785 : 	    else
; 4786 : 		xv = x->value.str;

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _xv$4[ebp], edx
$LN22@xmlSchemaC:

; 4787 : 	    if (y == NULL)

	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN23@xmlSchemaC

; 4788 : 		yv = yvalue;

	mov	eax, DWORD PTR _yvalue$[ebp]
	mov	DWORD PTR _yv$3[ebp], eax
	jmp	SHORT $LN24@xmlSchemaC
$LN23@xmlSchemaC:

; 4789 : 	    else
; 4790 : 		yv = y->value.str;

	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _yv$3[ebp], edx
$LN24@xmlSchemaC:

; 4791 : 	    /*
; 4792 : 	    * TODO: Compare those against QName.
; 4793 : 	    */
; 4794 : 	    if (ytype == XML_SCHEMAS_QNAME) {

	cmp	DWORD PTR _ytype$[ebp], 21		; 00000015H
	jne	SHORT $LN25@xmlSchemaC

; 4795 : 		TODO

	mov	esi, esp
	push	4795					; 000012bbH
	push	OFFSET ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4796 : 		if (y == NULL)

	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN26@xmlSchemaC

; 4797 : 		    return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN26@xmlSchemaC:

; 4798 : 		return (-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN25@xmlSchemaC:

; 4799 : 	    }
; 4800 :             if ((ytype == XML_SCHEMAS_ANYSIMPLETYPE) ||
; 4801 : 		(ytype == XML_SCHEMAS_STRING) ||
; 4802 : 		(ytype == XML_SCHEMAS_NORMSTRING) ||
; 4803 :                 (ytype == XML_SCHEMAS_TOKEN) ||
; 4804 :                 (ytype == XML_SCHEMAS_LANGUAGE) ||
; 4805 :                 (ytype == XML_SCHEMAS_NMTOKEN) ||
; 4806 :                 (ytype == XML_SCHEMAS_NAME) ||
; 4807 :                 (ytype == XML_SCHEMAS_NCNAME) ||
; 4808 :                 (ytype == XML_SCHEMAS_ID) ||
; 4809 :                 (ytype == XML_SCHEMAS_IDREF) ||
; 4810 :                 (ytype == XML_SCHEMAS_ENTITY) ||

	cmp	DWORD PTR _ytype$[ebp], 46		; 0000002eH
	je	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 1
	je	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 2
	je	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 16		; 00000010H
	je	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 17		; 00000011H
	je	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 18		; 00000012H
	je	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 20		; 00000014H
	je	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 22		; 00000016H
	je	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 23		; 00000017H
	je	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 24		; 00000018H
	je	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 26		; 0000001aH
	je	SHORT $LN28@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 29		; 0000001dH
	jne	$LN27@xmlSchemaC
$LN28@xmlSchemaC:

; 4811 :                 (ytype == XML_SCHEMAS_ANYURI)) {
; 4812 : 
; 4813 : 		if (xws == XML_SCHEMA_WHITESPACE_PRESERVE) {

	cmp	DWORD PTR _xws$[ebp], 1
	jne	SHORT $LN29@xmlSchemaC

; 4814 : 
; 4815 : 		    if (yws == XML_SCHEMA_WHITESPACE_PRESERVE) {

	cmp	DWORD PTR _yws$[ebp], 1
	jne	SHORT $LN31@xmlSchemaC

; 4816 : 			/* TODO: What about x < y or x > y. */
; 4817 : 			if (xmlStrEqual(xv, yv))

	mov	edx, DWORD PTR _yv$3[ebp]
	push	edx
	mov	eax, DWORD PTR _xv$4[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@xmlSchemaC

; 4818 : 			    return (0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN34@xmlSchemaC
$LN33@xmlSchemaC:

; 4819 : 			else
; 4820 : 			    return (2);

	mov	eax, 2
	jmp	$LN1@xmlSchemaC
$LN34@xmlSchemaC:

; 4821 : 		    } else if (yws == XML_SCHEMA_WHITESPACE_REPLACE)

	jmp	SHORT $LN32@xmlSchemaC
$LN31@xmlSchemaC:
	cmp	DWORD PTR _yws$[ebp], 2
	jne	SHORT $LN35@xmlSchemaC

; 4822 : 			return (xmlSchemaComparePreserveReplaceStrings(xv, yv, 0));

	push	0
	mov	ecx, DWORD PTR _yv$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _xv$4[ebp]
	push	edx
	call	_xmlSchemaComparePreserveReplaceStrings
	add	esp, 12					; 0000000cH
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN32@xmlSchemaC
$LN35@xmlSchemaC:

; 4823 : 		    else if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	DWORD PTR _yws$[ebp], 3
	jne	SHORT $LN32@xmlSchemaC

; 4824 : 			return (xmlSchemaComparePreserveCollapseStrings(xv, yv, 0));

	push	0
	mov	eax, DWORD PTR _yv$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _xv$4[ebp]
	push	ecx
	call	_xmlSchemaComparePreserveCollapseStrings
	add	esp, 12					; 0000000cH
	jmp	$LN1@xmlSchemaC
$LN32@xmlSchemaC:

; 4825 : 
; 4826 : 		} else if (xws == XML_SCHEMA_WHITESPACE_REPLACE) {

	jmp	$LN27@xmlSchemaC
$LN29@xmlSchemaC:
	cmp	DWORD PTR _xws$[ebp], 2
	jne	SHORT $LN38@xmlSchemaC

; 4827 : 
; 4828 : 		    if (yws == XML_SCHEMA_WHITESPACE_PRESERVE)

	cmp	DWORD PTR _yws$[ebp], 1
	jne	SHORT $LN40@xmlSchemaC

; 4829 : 			return (xmlSchemaComparePreserveReplaceStrings(yv, xv, 1));

	push	1
	mov	edx, DWORD PTR _xv$4[ebp]
	push	edx
	mov	eax, DWORD PTR _yv$3[ebp]
	push	eax
	call	_xmlSchemaComparePreserveReplaceStrings
	add	esp, 12					; 0000000cH
	jmp	$LN1@xmlSchemaC
$LN40@xmlSchemaC:

; 4830 : 		    if (yws == XML_SCHEMA_WHITESPACE_REPLACE)

	cmp	DWORD PTR _yws$[ebp], 2
	jne	SHORT $LN41@xmlSchemaC

; 4831 : 			return (xmlSchemaCompareReplacedStrings(xv, yv));

	mov	ecx, DWORD PTR _yv$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _xv$4[ebp]
	push	edx
	call	_xmlSchemaCompareReplacedStrings
	add	esp, 8
	jmp	$LN1@xmlSchemaC
$LN41@xmlSchemaC:

; 4832 : 		    if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	DWORD PTR _yws$[ebp], 3
	jne	SHORT $LN42@xmlSchemaC

; 4833 : 			return (xmlSchemaCompareReplaceCollapseStrings(xv, yv, 0));

	push	0
	mov	eax, DWORD PTR _yv$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _xv$4[ebp]
	push	ecx
	call	_xmlSchemaCompareReplaceCollapseStrings
	add	esp, 12					; 0000000cH
	jmp	$LN1@xmlSchemaC
$LN42@xmlSchemaC:

; 4834 : 
; 4835 : 		} else if (xws == XML_SCHEMA_WHITESPACE_COLLAPSE) {

	jmp	SHORT $LN27@xmlSchemaC
$LN38@xmlSchemaC:
	cmp	DWORD PTR _xws$[ebp], 3
	jne	SHORT $LN43@xmlSchemaC

; 4836 : 
; 4837 : 		    if (yws == XML_SCHEMA_WHITESPACE_PRESERVE)

	cmp	DWORD PTR _yws$[ebp], 1
	jne	SHORT $LN45@xmlSchemaC

; 4838 : 			return (xmlSchemaComparePreserveCollapseStrings(yv, xv, 1));

	push	1
	mov	edx, DWORD PTR _xv$4[ebp]
	push	edx
	mov	eax, DWORD PTR _yv$3[ebp]
	push	eax
	call	_xmlSchemaComparePreserveCollapseStrings
	add	esp, 12					; 0000000cH
	jmp	$LN1@xmlSchemaC
$LN45@xmlSchemaC:

; 4839 : 		    if (yws == XML_SCHEMA_WHITESPACE_REPLACE)

	cmp	DWORD PTR _yws$[ebp], 2
	jne	SHORT $LN46@xmlSchemaC

; 4840 : 			return (xmlSchemaCompareReplaceCollapseStrings(yv, xv, 1));

	push	1
	mov	ecx, DWORD PTR _xv$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _yv$3[ebp]
	push	edx
	call	_xmlSchemaCompareReplaceCollapseStrings
	add	esp, 12					; 0000000cH
	jmp	$LN1@xmlSchemaC
$LN46@xmlSchemaC:

; 4841 : 		    if (yws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	DWORD PTR _yws$[ebp], 3
	jne	SHORT $LN47@xmlSchemaC

; 4842 : 			return (xmlSchemaCompareNormStrings(xv, yv));

	mov	eax, DWORD PTR _yv$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _xv$4[ebp]
	push	ecx
	call	_xmlSchemaCompareNormStrings
	add	esp, 8
	jmp	$LN1@xmlSchemaC
$LN47@xmlSchemaC:

; 4843 : 		} else

	jmp	SHORT $LN27@xmlSchemaC
$LN43@xmlSchemaC:

; 4844 : 		    return (-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN27@xmlSchemaC:

; 4845 : 
; 4846 : 	    }
; 4847 :             return (-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN48@xmlSchemaC:

; 4848 : 	}
; 4849 :         case XML_SCHEMAS_QNAME:
; 4850 : 	case XML_SCHEMAS_NOTATION:
; 4851 : 	    if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN50@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN49@xmlSchemaC
$LN50@xmlSchemaC:

; 4852 : 		return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN49@xmlSchemaC:

; 4853 :             if ((ytype == XML_SCHEMAS_QNAME) ||

	cmp	DWORD PTR _ytype$[ebp], 21		; 00000015H
	je	SHORT $LN52@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 28		; 0000001cH
	jne	SHORT $LN51@xmlSchemaC
$LN52@xmlSchemaC:

; 4854 : 		(ytype == XML_SCHEMAS_NOTATION)) {
; 4855 : 		if ((xmlStrEqual(x->value.qname.name, y->value.qname.name)) &&

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN53@xmlSchemaC
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN53@xmlSchemaC

; 4856 : 		    (xmlStrEqual(x->value.qname.uri, y->value.qname.uri)))
; 4857 : 		    return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaC
$LN53@xmlSchemaC:

; 4858 : 		return(2);

	mov	eax, 2
	jmp	$LN1@xmlSchemaC
$LN51@xmlSchemaC:

; 4859 : 	    }
; 4860 : 	    return (-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN54@xmlSchemaC:

; 4861 :         case XML_SCHEMAS_FLOAT:
; 4862 :         case XML_SCHEMAS_DOUBLE:
; 4863 : 	    if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN56@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN55@xmlSchemaC
$LN56@xmlSchemaC:

; 4864 : 		return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN55@xmlSchemaC:

; 4865 :             if ((ytype == XML_SCHEMAS_FLOAT) ||

	cmp	DWORD PTR _ytype$[ebp], 13		; 0000000dH
	je	SHORT $LN58@xmlSchemaC
	cmp	DWORD PTR _ytype$[ebp], 14		; 0000000eH
	jne	SHORT $LN57@xmlSchemaC
$LN58@xmlSchemaC:

; 4866 :                 (ytype == XML_SCHEMAS_DOUBLE))
; 4867 :                 return (xmlSchemaCompareFloats(x, y));

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_xmlSchemaCompareFloats
	add	esp, 8
	jmp	$LN1@xmlSchemaC
$LN57@xmlSchemaC:

; 4868 :             return (-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN59@xmlSchemaC:

; 4869 :         case XML_SCHEMAS_BOOLEAN:
; 4870 : 	    if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN61@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN60@xmlSchemaC
$LN61@xmlSchemaC:

; 4871 : 		return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN60@xmlSchemaC:

; 4872 :             if (ytype == XML_SCHEMAS_BOOLEAN) {

	cmp	DWORD PTR _ytype$[ebp], 15		; 0000000fH
	jne	SHORT $LN62@xmlSchemaC

; 4873 : 		if (x->value.b == y->value.b)

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN63@xmlSchemaC

; 4874 : 		    return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaC
$LN63@xmlSchemaC:

; 4875 : 		if (x->value.b == 0)

	mov	eax, DWORD PTR _x$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN64@xmlSchemaC

; 4876 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
$LN64@xmlSchemaC:

; 4877 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN62@xmlSchemaC:

; 4878 : 	    }
; 4879 : 	    return (-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN65@xmlSchemaC:

; 4880 :         case XML_SCHEMAS_HEXBINARY:
; 4881 : 	    if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN67@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN66@xmlSchemaC
$LN67@xmlSchemaC:

; 4882 : 		return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN66@xmlSchemaC:

; 4883 :             if (ytype == XML_SCHEMAS_HEXBINARY) {

	cmp	DWORD PTR _ytype$[ebp], 43		; 0000002bH
	jne	SHORT $LN68@xmlSchemaC

; 4884 : 	        if (x->value.hex.total == y->value.hex.total) {

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+12]
	jne	SHORT $LN69@xmlSchemaC

; 4885 : 		    int ret = xmlStrcmp(x->value.hex.str, y->value.hex.str);

	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	mov	DWORD PTR _ret$2[ebp], eax

; 4886 : 		    if (ret > 0)

	cmp	DWORD PTR _ret$2[ebp], 0
	jle	SHORT $LN71@xmlSchemaC

; 4887 : 			return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN72@xmlSchemaC
$LN71@xmlSchemaC:

; 4888 : 		    else if (ret == 0)

	cmp	DWORD PTR _ret$2[ebp], 0
	jne	SHORT $LN72@xmlSchemaC

; 4889 : 			return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaC
$LN72@xmlSchemaC:

; 4890 : 		}

	jmp	SHORT $LN70@xmlSchemaC
$LN69@xmlSchemaC:

; 4891 : 		else if (x->value.hex.total > y->value.hex.total)

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+12]
	jbe	SHORT $LN70@xmlSchemaC

; 4892 : 		    return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN70@xmlSchemaC:

; 4893 : 
; 4894 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
$LN68@xmlSchemaC:

; 4895 :             }
; 4896 :             return (-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN75@xmlSchemaC:

; 4897 :         case XML_SCHEMAS_BASE64BINARY:
; 4898 : 	    if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN77@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN76@xmlSchemaC
$LN77@xmlSchemaC:

; 4899 : 		return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN76@xmlSchemaC:

; 4900 :             if (ytype == XML_SCHEMAS_BASE64BINARY) {

	cmp	DWORD PTR _ytype$[ebp], 44		; 0000002cH
	jne	SHORT $LN78@xmlSchemaC

; 4901 :                 if (x->value.base64.total == y->value.base64.total) {

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+12]
	jne	SHORT $LN79@xmlSchemaC

; 4902 :                     int ret = xmlStrcmp(x->value.base64.str,

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	mov	DWORD PTR _ret$1[ebp], eax

; 4903 : 		                        y->value.base64.str);
; 4904 :                     if (ret > 0)

	cmp	DWORD PTR _ret$1[ebp], 0
	jle	SHORT $LN81@xmlSchemaC

; 4905 :                         return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN82@xmlSchemaC
$LN81@xmlSchemaC:

; 4906 :                     else if (ret == 0)

	cmp	DWORD PTR _ret$1[ebp], 0
	jne	SHORT $LN83@xmlSchemaC

; 4907 :                         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN82@xmlSchemaC
$LN83@xmlSchemaC:

; 4908 : 		    else
; 4909 : 		        return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
$LN82@xmlSchemaC:

; 4910 :                 }

	jmp	SHORT $LN78@xmlSchemaC
$LN79@xmlSchemaC:

; 4911 :                 else if (x->value.base64.total > y->value.base64.total)

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jbe	SHORT $LN85@xmlSchemaC

; 4912 :                     return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN78@xmlSchemaC
$LN85@xmlSchemaC:

; 4913 :                 else
; 4914 :                     return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
$LN78@xmlSchemaC:

; 4915 :             }
; 4916 :             return (-2);

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@xmlSchemaC
$LN87@xmlSchemaC:

; 4917 :         case XML_SCHEMAS_IDREFS:
; 4918 :         case XML_SCHEMAS_ENTITIES:
; 4919 :         case XML_SCHEMAS_NMTOKENS:
; 4920 : 	    TODO

	mov	esi, esp
	push	4920					; 00001338H
	push	OFFSET ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@xmlSchemaC:

; 4921 : 	    break;
; 4922 :     }
; 4923 :     return -2;

	mov	eax, -2					; fffffffeH
$LN1@xmlSchemaC:

; 4924 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN90@xmlSchemaC:
	DD	$LN4@xmlSchemaC
	DD	$LN20@xmlSchemaC
	DD	$LN5@xmlSchemaC
	DD	$LN15@xmlSchemaC
	DD	$LN11@xmlSchemaC
	DD	$LN54@xmlSchemaC
	DD	$LN59@xmlSchemaC
	DD	$LN87@xmlSchemaC
	DD	$LN48@xmlSchemaC
	DD	$LN65@xmlSchemaC
	DD	$LN75@xmlSchemaC
$LN89@xmlSchemaC:
	DB	0
	DB	1
	DB	1
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	4
	DB	5
	DB	5
	DB	6
	DB	1
	DB	1
	DB	1
	DB	7
	DB	1
	DB	8
	DB	1
	DB	1
	DB	1
	DB	7
	DB	1
	DB	7
	DB	8
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	9
	DB	10					; 0000000aH
	DB	0
	DB	1
_xmlSchemaCompareValuesInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareFloats
_TEXT	SEGMENT
_d2$ = -16						; size = 8
_d1$ = -8						; size = 8
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareFloats PROC				; COMDAT

; 4614 : xmlSchemaCompareFloats(xmlSchemaValPtr x, xmlSchemaValPtr y) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 4615 :     double d1, d2;
; 4616 : 
; 4617 :     if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN2@xmlSchemaC
$LN3@xmlSchemaC:

; 4618 : 	return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN2@xmlSchemaC:

; 4619 : 
; 4620 :     /*
; 4621 :      * Cast everything to doubles.
; 4622 :      */
; 4623 :     if (x->type == XML_SCHEMAS_DOUBLE)

	mov	eax, DWORD PTR _x$[ebp]
	cmp	DWORD PTR [eax], 14			; 0000000eH
	jne	SHORT $LN4@xmlSchemaC

; 4624 : 	d1 = x->value.d;

	mov	ecx, DWORD PTR _x$[ebp]
	movsd	xmm0, QWORD PTR [ecx+8]
	movsd	QWORD PTR _d1$[ebp], xmm0
	jmp	SHORT $LN7@xmlSchemaC
$LN4@xmlSchemaC:

; 4625 :     else if (x->type == XML_SCHEMAS_FLOAT)

	mov	edx, DWORD PTR _x$[ebp]
	cmp	DWORD PTR [edx], 13			; 0000000dH
	jne	SHORT $LN6@xmlSchemaC

; 4626 : 	d1 = x->value.f;

	mov	eax, DWORD PTR _x$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+8]
	movsd	QWORD PTR _d1$[ebp], xmm0
	jmp	SHORT $LN7@xmlSchemaC
$LN6@xmlSchemaC:

; 4627 :     else
; 4628 : 	return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN7@xmlSchemaC:

; 4629 : 
; 4630 :     if (y->type == XML_SCHEMAS_DOUBLE)

	mov	ecx, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [ecx], 14			; 0000000eH
	jne	SHORT $LN8@xmlSchemaC

; 4631 : 	d2 = y->value.d;

	mov	edx, DWORD PTR _y$[ebp]
	movsd	xmm0, QWORD PTR [edx+8]
	movsd	QWORD PTR _d2$[ebp], xmm0
	jmp	SHORT $LN11@xmlSchemaC
$LN8@xmlSchemaC:

; 4632 :     else if (y->type == XML_SCHEMAS_FLOAT)

	mov	eax, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [eax], 13			; 0000000dH
	jne	SHORT $LN10@xmlSchemaC

; 4633 : 	d2 = y->value.f;

	mov	ecx, DWORD PTR _y$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+8]
	movsd	QWORD PTR _d2$[ebp], xmm0
	jmp	SHORT $LN11@xmlSchemaC
$LN10@xmlSchemaC:

; 4634 :     else
; 4635 : 	return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN11@xmlSchemaC:

; 4636 : 
; 4637 :     /*
; 4638 :      * Check for special cases.
; 4639 :      */
; 4640 :     if (xmlXPathIsNaN(d1)) {

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d1$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlSchemaC

; 4641 : 	if (xmlXPathIsNaN(d2))

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d2$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlSchemaC

; 4642 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaC
$LN13@xmlSchemaC:

; 4643 : 	return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN12@xmlSchemaC:

; 4644 :     }
; 4645 :     if (xmlXPathIsNaN(d2))

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d2$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_xmlXPathIsNaN
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@xmlSchemaC

; 4646 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
$LN14@xmlSchemaC:

; 4647 :     if (d1 == xmlXPathPINF) {

	movsd	xmm0, QWORD PTR _d1$[ebp]
	ucomisd	xmm0, QWORD PTR _xmlXPathPINF
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@xmlSchemaC

; 4648 : 	if (d2 == xmlXPathPINF)

	movsd	xmm0, QWORD PTR _d2$[ebp]
	ucomisd	xmm0, QWORD PTR _xmlXPathPINF
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN16@xmlSchemaC

; 4649 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaC
$LN16@xmlSchemaC:

; 4650 :         return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN15@xmlSchemaC:

; 4651 :     }
; 4652 :     if (d2 == xmlXPathPINF)

	movsd	xmm0, QWORD PTR _d2$[ebp]
	ucomisd	xmm0, QWORD PTR _xmlXPathPINF
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN17@xmlSchemaC

; 4653 :         return(-1);

	mov	eax, -1
	jmp	$LN1@xmlSchemaC
$LN17@xmlSchemaC:

; 4654 :     if (d1 == xmlXPathNINF) {

	movsd	xmm0, QWORD PTR _d1$[ebp]
	ucomisd	xmm0, QWORD PTR _xmlXPathNINF
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@xmlSchemaC

; 4655 : 	if (d2 == xmlXPathNINF)

	movsd	xmm0, QWORD PTR _d2$[ebp]
	ucomisd	xmm0, QWORD PTR _xmlXPathNINF
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@xmlSchemaC

; 4656 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaC
$LN19@xmlSchemaC:

; 4657 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
$LN18@xmlSchemaC:

; 4658 :     }
; 4659 :     if (d2 == xmlXPathNINF)

	movsd	xmm0, QWORD PTR _d2$[ebp]
	ucomisd	xmm0, QWORD PTR _xmlXPathNINF
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@xmlSchemaC

; 4660 :         return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
$LN20@xmlSchemaC:

; 4661 : 
; 4662 :     /*
; 4663 :      * basic tests, the last one we should have equality, but
; 4664 :      * portability is more important than speed and handling
; 4665 :      * NaN or Inf in a portable way is always a challenge, so ...
; 4666 :      */
; 4667 :     if (d1 < d2)

	movsd	xmm0, QWORD PTR _d2$[ebp]
	comisd	xmm0, QWORD PTR _d1$[ebp]
	jbe	SHORT $LN21@xmlSchemaC

; 4668 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
$LN21@xmlSchemaC:

; 4669 :     if (d1 > d2)

	movsd	xmm0, QWORD PTR _d1$[ebp]
	comisd	xmm0, QWORD PTR _d2$[ebp]
	jbe	SHORT $LN22@xmlSchemaC

; 4670 : 	return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
$LN22@xmlSchemaC:

; 4671 :     if (d1 == d2)

	movsd	xmm0, QWORD PTR _d1$[ebp]
	ucomisd	xmm0, QWORD PTR _d2$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@xmlSchemaC

; 4672 : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaC
$LN23@xmlSchemaC:

; 4673 :     return(2);

	mov	eax, 2
$LN1@xmlSchemaC:

; 4674 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCompareFloats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareNormStrings
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareNormStrings PROC			; COMDAT

; 4569 : 			    const xmlChar *y) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlSchemaC:

; 4570 :     int tmp;
; 4571 : 
; 4572 :     while (IS_BLANK_CH(*x)) x++;

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN16@xmlSchemaC
	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN17@xmlSchemaC
	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN16@xmlSchemaC
$LN17@xmlSchemaC:
	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN4@xmlSchemaC
$LN16@xmlSchemaC:
	mov	edx, DWORD PTR _x$[ebp]
	add	edx, 1
	mov	DWORD PTR _x$[ebp], edx
	jmp	SHORT $LN2@xmlSchemaC
$LN4@xmlSchemaC:

; 4573 :     while (IS_BLANK_CH(*y)) y++;

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN18@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN19@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN18@xmlSchemaC
$LN19@xmlSchemaC:
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN6@xmlSchemaC
$LN18@xmlSchemaC:
	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
	jmp	SHORT $LN4@xmlSchemaC
$LN6@xmlSchemaC:

; 4574 :     while ((*x != 0) && (*y != 0)) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN7@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN7@xmlSchemaC

; 4575 : 	if (IS_BLANK_CH(*x)) {

	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN22@xmlSchemaC
	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN23@xmlSchemaC
	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN22@xmlSchemaC
$LN23@xmlSchemaC:
	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	$LN20@xmlSchemaC
$LN22@xmlSchemaC:

; 4576 : 	    if (!IS_BLANK_CH(*y)) {

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN8@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN25@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN8@xmlSchemaC
$LN25@xmlSchemaC:
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN8@xmlSchemaC

; 4577 : 		tmp = *x - *y;

	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	sub	eax, edx
	mov	DWORD PTR _tmp$[ebp], eax

; 4578 : 		return(tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	$LN1@xmlSchemaC
$LN8@xmlSchemaC:

; 4579 : 	    }
; 4580 : 	    while (IS_BLANK_CH(*x)) x++;

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN26@xmlSchemaC
	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN27@xmlSchemaC
	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN26@xmlSchemaC
$LN27@xmlSchemaC:
	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN10@xmlSchemaC
$LN26@xmlSchemaC:
	mov	edx, DWORD PTR _x$[ebp]
	add	edx, 1
	mov	DWORD PTR _x$[ebp], edx
	jmp	SHORT $LN8@xmlSchemaC
$LN10@xmlSchemaC:

; 4581 : 	    while (IS_BLANK_CH(*y)) y++;

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN28@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN29@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN28@xmlSchemaC
$LN29@xmlSchemaC:
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN11@xmlSchemaC
$LN28@xmlSchemaC:
	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
	jmp	SHORT $LN10@xmlSchemaC
$LN11@xmlSchemaC:

; 4582 : 	} else {

	jmp	SHORT $LN21@xmlSchemaC
$LN20@xmlSchemaC:

; 4583 : 	    tmp = *x++ - *y++;

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	ecx, eax
	mov	DWORD PTR _tmp$[ebp], ecx
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, 1
	mov	DWORD PTR _y$[ebp], ecx
	mov	edx, DWORD PTR _x$[ebp]
	add	edx, 1
	mov	DWORD PTR _x$[ebp], edx

; 4584 : 	    if (tmp < 0)

	cmp	DWORD PTR _tmp$[ebp], 0
	jge	SHORT $LN30@xmlSchemaC

; 4585 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
$LN30@xmlSchemaC:

; 4586 : 	    if (tmp > 0)

	cmp	DWORD PTR _tmp$[ebp], 0
	jle	SHORT $LN21@xmlSchemaC

; 4587 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN21@xmlSchemaC:

; 4588 : 	}
; 4589 :     }

	jmp	$LN6@xmlSchemaC
$LN7@xmlSchemaC:

; 4590 :     if (*x != 0) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN32@xmlSchemaC
$LN12@xmlSchemaC:

; 4591 : 	while (IS_BLANK_CH(*x)) x++;

	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN33@xmlSchemaC
	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN34@xmlSchemaC
	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN33@xmlSchemaC
$LN34@xmlSchemaC:
	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN13@xmlSchemaC
$LN33@xmlSchemaC:
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx
	jmp	SHORT $LN12@xmlSchemaC
$LN13@xmlSchemaC:

; 4592 : 	if (*x != 0)

	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN32@xmlSchemaC

; 4593 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
$LN32@xmlSchemaC:

; 4594 :     }
; 4595 :     if (*y != 0) {

	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN36@xmlSchemaC
$LN14@xmlSchemaC:

; 4596 : 	while (IS_BLANK_CH(*y)) y++;

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN37@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN38@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN37@xmlSchemaC
$LN38@xmlSchemaC:
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN15@xmlSchemaC
$LN37@xmlSchemaC:
	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
	jmp	SHORT $LN14@xmlSchemaC
$LN15@xmlSchemaC:

; 4597 : 	if (*y != 0)

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN36@xmlSchemaC

; 4598 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
$LN36@xmlSchemaC:

; 4599 :     }
; 4600 :     return(0);

	xor	eax, eax
$LN1@xmlSchemaC:

; 4601 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCompareNormStrings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareReplacedStrings
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareReplacedStrings PROC			; COMDAT

; 4523 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlSchemaC:

; 4524 :     int tmp;
; 4525 : 
; 4526 :     while ((*x != 0) && (*y != 0)) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@xmlSchemaC

; 4527 : 	if IS_WSP_BLANK_CH(*y) {

	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN6@xmlSchemaC
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN7@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN6@xmlSchemaC
$LN7@xmlSchemaC:
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN4@xmlSchemaC
$LN6@xmlSchemaC:

; 4528 : 	    if (! IS_WSP_BLANK_CH(*x)) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN8@xmlSchemaC
	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN9@xmlSchemaC
	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN8@xmlSchemaC
$LN9@xmlSchemaC:
	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN8@xmlSchemaC

; 4529 : 		if ((*x - 0x20) < 0)

	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	eax, 32					; 00000020H
	jns	SHORT $LN10@xmlSchemaC

; 4530 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN8@xmlSchemaC
$LN10@xmlSchemaC:

; 4531 : 		else
; 4532 : 		    return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN8@xmlSchemaC:

; 4533 : 	    }
; 4534 : 	} else {

	jmp	SHORT $LN5@xmlSchemaC
$LN4@xmlSchemaC:

; 4535 : 	    if IS_WSP_BLANK_CH(*x) {

	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN13@xmlSchemaC
	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN14@xmlSchemaC
	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN13@xmlSchemaC
$LN14@xmlSchemaC:
	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN12@xmlSchemaC
$LN13@xmlSchemaC:

; 4536 : 		if ((0x20 - *y) < 0)

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, 32					; 00000020H
	sub	edx, ecx
	jns	SHORT $LN15@xmlSchemaC

; 4537 : 		    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN12@xmlSchemaC
$LN15@xmlSchemaC:

; 4538 : 		else
; 4539 : 		    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
$LN12@xmlSchemaC:

; 4540 : 	    }
; 4541 : 	    tmp = *x - *y;

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	ecx, eax
	mov	DWORD PTR _tmp$[ebp], ecx

; 4542 : 	    if (tmp < 0)

	jns	SHORT $LN17@xmlSchemaC

; 4543 : 		return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
$LN17@xmlSchemaC:

; 4544 : 	    if (tmp > 0)

	cmp	DWORD PTR _tmp$[ebp], 0
	jle	SHORT $LN5@xmlSchemaC

; 4545 : 		return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
$LN5@xmlSchemaC:

; 4546 : 	}
; 4547 : 	x++;

	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx

; 4548 : 	y++;

	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx

; 4549 :     }

	jmp	$LN2@xmlSchemaC
$LN3@xmlSchemaC:

; 4550 :     if (*x != 0)

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN19@xmlSchemaC

; 4551 :         return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
$LN19@xmlSchemaC:

; 4552 :     if (*y != 0)

	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN20@xmlSchemaC

; 4553 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
$LN20@xmlSchemaC:

; 4554 :     return(0);

	xor	eax, eax
$LN1@xmlSchemaC:

; 4555 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCompareReplacedStrings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareReplaceCollapseStrings
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_invert$ = 16						; size = 4
_xmlSchemaCompareReplaceCollapseStrings PROC		; COMDAT

; 4429 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlSchemaC:

; 4430 :     int tmp;
; 4431 : 
; 4432 :     /*
; 4433 :     * Skip leading blank chars of the collapsed string.
; 4434 :     */
; 4435 :     while IS_WSP_BLANK_CH(*y)

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN10@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN11@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN10@xmlSchemaC
$LN11@xmlSchemaC:
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN4@xmlSchemaC
$LN10@xmlSchemaC:

; 4436 : 	y++;

	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
	jmp	SHORT $LN2@xmlSchemaC
$LN4@xmlSchemaC:

; 4437 : 
; 4438 :     while ((*x != 0) && (*y != 0)) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN5@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN5@xmlSchemaC

; 4439 : 	if IS_WSP_BLANK_CH(*y) {

	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN14@xmlSchemaC
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN15@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN14@xmlSchemaC
$LN15@xmlSchemaC:
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	$LN12@xmlSchemaC
$LN14@xmlSchemaC:

; 4440 : 	    if (! IS_WSP_BLANK_CH(*x)) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN16@xmlSchemaC
	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN17@xmlSchemaC
	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN16@xmlSchemaC
$LN17@xmlSchemaC:
	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN16@xmlSchemaC

; 4441 : 		/*
; 4442 : 		* The yv character would have been replaced to 0x20.
; 4443 : 		*/
; 4444 : 		if ((*x - 0x20) < 0) {

	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	eax, 32					; 00000020H
	jns	SHORT $LN18@xmlSchemaC

; 4445 : 		    if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN20@xmlSchemaC

; 4446 : 			return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN21@xmlSchemaC
$LN20@xmlSchemaC:

; 4447 : 		    else
; 4448 : 			return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
$LN21@xmlSchemaC:

; 4449 : 		} else {

	jmp	SHORT $LN16@xmlSchemaC
$LN18@xmlSchemaC:

; 4450 : 		    if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN22@xmlSchemaC

; 4451 : 			return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN16@xmlSchemaC
$LN22@xmlSchemaC:

; 4452 : 		    else
; 4453 : 			return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN16@xmlSchemaC:

; 4454 : 		}
; 4455 : 	    }
; 4456 : 	    x++;

	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx

; 4457 : 	    y++;

	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
$LN6@xmlSchemaC:

; 4458 : 	    /*
; 4459 : 	    * Skip contiguous blank chars of the collapsed string.
; 4460 : 	    */
; 4461 : 	    while IS_WSP_BLANK_CH(*y)

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN24@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN25@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN24@xmlSchemaC
$LN25@xmlSchemaC:
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN7@xmlSchemaC
$LN24@xmlSchemaC:

; 4462 : 		y++;

	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
	jmp	SHORT $LN6@xmlSchemaC
$LN7@xmlSchemaC:

; 4463 : 	} else {

	jmp	$LN13@xmlSchemaC
$LN12@xmlSchemaC:

; 4464 : 	    if IS_WSP_BLANK_CH(*x) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN27@xmlSchemaC
	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN28@xmlSchemaC
	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN27@xmlSchemaC
$LN28@xmlSchemaC:
	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN26@xmlSchemaC
$LN27@xmlSchemaC:

; 4465 : 		/*
; 4466 : 		* The xv character would have been replaced to 0x20.
; 4467 : 		*/
; 4468 : 		if ((0x20 - *y) < 0) {

	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, 32					; 00000020H
	sub	ecx, eax
	jns	SHORT $LN29@xmlSchemaC

; 4469 : 		    if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN31@xmlSchemaC

; 4470 : 			return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN32@xmlSchemaC
$LN31@xmlSchemaC:

; 4471 : 		    else
; 4472 : 			return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
$LN32@xmlSchemaC:

; 4473 : 		} else {

	jmp	SHORT $LN26@xmlSchemaC
$LN29@xmlSchemaC:

; 4474 : 		    if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN33@xmlSchemaC

; 4475 : 			return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN26@xmlSchemaC
$LN33@xmlSchemaC:

; 4476 : 		    else
; 4477 : 			return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN26@xmlSchemaC:

; 4478 : 		}
; 4479 : 	    }
; 4480 : 	    tmp = *x++ - *y++;

	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	sub	eax, edx
	mov	DWORD PTR _tmp$[ebp], eax
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx

; 4481 : 	    if (tmp < 0)

	cmp	DWORD PTR _tmp$[ebp], 0
	jge	SHORT $LN35@xmlSchemaC

; 4482 : 		return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
$LN35@xmlSchemaC:

; 4483 : 	    if (tmp > 0)

	cmp	DWORD PTR _tmp$[ebp], 0
	jle	SHORT $LN13@xmlSchemaC

; 4484 : 		return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN13@xmlSchemaC:

; 4485 : 	}
; 4486 :     }

	jmp	$LN4@xmlSchemaC
$LN5@xmlSchemaC:

; 4487 :     if (*x != 0) {

	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN37@xmlSchemaC

; 4488 : 	 if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN38@xmlSchemaC

; 4489 : 	     return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN37@xmlSchemaC
$LN38@xmlSchemaC:

; 4490 : 	 else
; 4491 : 	     return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
$LN37@xmlSchemaC:

; 4492 :     }
; 4493 :     if (*y != 0) {

	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN40@xmlSchemaC
$LN8@xmlSchemaC:

; 4494 : 	/*
; 4495 : 	* Skip trailing blank chars of the collapsed string.
; 4496 : 	*/
; 4497 : 	while IS_WSP_BLANK_CH(*y)

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN41@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN42@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN41@xmlSchemaC
$LN42@xmlSchemaC:
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN9@xmlSchemaC
$LN41@xmlSchemaC:

; 4498 : 	    y++;

	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
	jmp	SHORT $LN8@xmlSchemaC
$LN9@xmlSchemaC:

; 4499 : 	if (*y != 0) {

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN40@xmlSchemaC

; 4500 : 	    if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN44@xmlSchemaC

; 4501 : 		return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN40@xmlSchemaC
$LN44@xmlSchemaC:

; 4502 : 	    else
; 4503 : 		return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
$LN40@xmlSchemaC:

; 4504 : 	}
; 4505 :     }
; 4506 :     return(0);

	xor	eax, eax
$LN1@xmlSchemaC:

; 4507 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCompareReplaceCollapseStrings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaComparePreserveCollapseStrings
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_invert$ = 16						; size = 4
_xmlSchemaComparePreserveCollapseStrings PROC		; COMDAT

; 4340 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlSchemaC:

; 4341 :     int tmp;
; 4342 : 
; 4343 :     /*
; 4344 :     * Skip leading blank chars of the collapsed string.
; 4345 :     */
; 4346 :     while IS_WSP_BLANK_CH(*y)

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN10@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN11@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN10@xmlSchemaC
$LN11@xmlSchemaC:
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN4@xmlSchemaC
$LN10@xmlSchemaC:

; 4347 : 	y++;

	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
	jmp	SHORT $LN2@xmlSchemaC
$LN4@xmlSchemaC:

; 4348 : 
; 4349 :     while ((*x != 0) && (*y != 0)) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN5@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN5@xmlSchemaC

; 4350 : 	if IS_WSP_BLANK_CH(*y) {

	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN14@xmlSchemaC
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN15@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN14@xmlSchemaC
$LN15@xmlSchemaC:
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	$LN12@xmlSchemaC
$LN14@xmlSchemaC:

; 4351 : 	    if (! IS_WSP_SPACE_CH(*x)) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN16@xmlSchemaC

; 4352 : 		/*
; 4353 : 		* The yv character would have been replaced to 0x20.
; 4354 : 		*/
; 4355 : 		if ((*x - 0x20) < 0) {

	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	eax, 32					; 00000020H
	jns	SHORT $LN17@xmlSchemaC

; 4356 : 		    if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN19@xmlSchemaC

; 4357 : 			return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN20@xmlSchemaC
$LN19@xmlSchemaC:

; 4358 : 		    else
; 4359 : 			return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
$LN20@xmlSchemaC:

; 4360 : 		} else {

	jmp	SHORT $LN16@xmlSchemaC
$LN17@xmlSchemaC:

; 4361 : 		    if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN21@xmlSchemaC

; 4362 : 			return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN16@xmlSchemaC
$LN21@xmlSchemaC:

; 4363 : 		    else
; 4364 : 			return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN16@xmlSchemaC:

; 4365 : 		}
; 4366 : 	    }
; 4367 : 	    x++;

	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx

; 4368 : 	    y++;

	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
$LN6@xmlSchemaC:

; 4369 : 	    /*
; 4370 : 	    * Skip contiguous blank chars of the collapsed string.
; 4371 : 	    */
; 4372 : 	    while IS_WSP_BLANK_CH(*y)

	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN23@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN24@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN23@xmlSchemaC
$LN24@xmlSchemaC:
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN7@xmlSchemaC
$LN23@xmlSchemaC:

; 4373 : 		y++;

	mov	edx, DWORD PTR _y$[ebp]
	add	edx, 1
	mov	DWORD PTR _y$[ebp], edx
	jmp	SHORT $LN6@xmlSchemaC
$LN7@xmlSchemaC:

; 4374 : 	} else {

	jmp	SHORT $LN13@xmlSchemaC
$LN12@xmlSchemaC:

; 4375 : 	    tmp = *x++ - *y++;

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	ecx, eax
	mov	DWORD PTR _tmp$[ebp], ecx
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, 1
	mov	DWORD PTR _y$[ebp], ecx
	mov	edx, DWORD PTR _x$[ebp]
	add	edx, 1
	mov	DWORD PTR _x$[ebp], edx

; 4376 : 	    if (tmp < 0) {

	cmp	DWORD PTR _tmp$[ebp], 0
	jge	SHORT $LN25@xmlSchemaC

; 4377 : 		if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN26@xmlSchemaC

; 4378 : 		    return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN25@xmlSchemaC
$LN26@xmlSchemaC:

; 4379 : 		else
; 4380 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
$LN25@xmlSchemaC:

; 4381 : 	    }
; 4382 : 	    if (tmp > 0) {

	cmp	DWORD PTR _tmp$[ebp], 0
	jle	SHORT $LN13@xmlSchemaC

; 4383 : 		if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN29@xmlSchemaC

; 4384 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN13@xmlSchemaC
$LN29@xmlSchemaC:

; 4385 : 		else
; 4386 : 		    return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN13@xmlSchemaC:

; 4387 : 	    }
; 4388 : 	}
; 4389 :     }

	jmp	$LN4@xmlSchemaC
$LN5@xmlSchemaC:

; 4390 :     if (*x != 0) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN31@xmlSchemaC

; 4391 : 	 if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN32@xmlSchemaC

; 4392 : 	     return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN31@xmlSchemaC
$LN32@xmlSchemaC:

; 4393 : 	 else
; 4394 : 	     return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
$LN31@xmlSchemaC:

; 4395 :     }
; 4396 :     if (*y != 0) {

	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN34@xmlSchemaC
$LN8@xmlSchemaC:

; 4397 : 	/*
; 4398 : 	* Skip trailing blank chars of the collapsed string.
; 4399 : 	*/
; 4400 : 	while IS_WSP_BLANK_CH(*y)

	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN35@xmlSchemaC
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN36@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN35@xmlSchemaC
$LN36@xmlSchemaC:
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN9@xmlSchemaC
$LN35@xmlSchemaC:

; 4401 : 	    y++;

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
	jmp	SHORT $LN8@xmlSchemaC
$LN9@xmlSchemaC:

; 4402 : 	if (*y != 0) {

	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN34@xmlSchemaC

; 4403 : 	    if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN38@xmlSchemaC

; 4404 : 		return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN34@xmlSchemaC
$LN38@xmlSchemaC:

; 4405 : 	    else
; 4406 : 		return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
$LN34@xmlSchemaC:

; 4407 : 	}
; 4408 :     }
; 4409 :     return(0);

	xor	eax, eax
$LN1@xmlSchemaC:

; 4410 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaComparePreserveCollapseStrings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaComparePreserveReplaceStrings
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_invert$ = 16						; size = 4
_xmlSchemaComparePreserveReplaceStrings PROC		; COMDAT

; 4272 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlSchemaC:

; 4273 :     int tmp;
; 4274 : 
; 4275 :     while ((*x != 0) && (*y != 0)) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@xmlSchemaC

; 4276 : 	if (IS_WSP_REPLACE_CH(*y)) {

	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	je	SHORT $LN6@xmlSchemaC
	mov	eax, DWORD PTR _y$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN6@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN4@xmlSchemaC
$LN6@xmlSchemaC:

; 4277 : 	    if (! IS_WSP_SPACE_CH(*x)) {

	mov	ecx, DWORD PTR _x$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN7@xmlSchemaC

; 4278 : 		if ((*x - 0x20) < 0) {

	mov	eax, DWORD PTR _x$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 32					; 00000020H
	jns	SHORT $LN8@xmlSchemaC

; 4279 : 		    if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN10@xmlSchemaC

; 4280 : 			return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN11@xmlSchemaC
$LN10@xmlSchemaC:

; 4281 : 		    else
; 4282 : 			return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
$LN11@xmlSchemaC:

; 4283 : 		} else {

	jmp	SHORT $LN7@xmlSchemaC
$LN8@xmlSchemaC:

; 4284 : 		    if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN12@xmlSchemaC

; 4285 : 			return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN7@xmlSchemaC
$LN12@xmlSchemaC:

; 4286 : 		    else
; 4287 : 			return(1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN7@xmlSchemaC:

; 4288 : 		}
; 4289 : 	    }
; 4290 : 	} else {

	jmp	SHORT $LN5@xmlSchemaC
$LN4@xmlSchemaC:

; 4291 : 	    tmp = *x - *y;

	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	sub	eax, edx
	mov	DWORD PTR _tmp$[ebp], eax

; 4292 : 	    if (tmp < 0) {

	jns	SHORT $LN14@xmlSchemaC

; 4293 : 		if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN15@xmlSchemaC

; 4294 : 		    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN14@xmlSchemaC
$LN15@xmlSchemaC:

; 4295 : 		else
; 4296 : 		    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
$LN14@xmlSchemaC:

; 4297 : 	    }
; 4298 : 	    if (tmp > 0) {

	cmp	DWORD PTR _tmp$[ebp], 0
	jle	SHORT $LN5@xmlSchemaC

; 4299 : 		if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN18@xmlSchemaC

; 4300 : 		    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN5@xmlSchemaC
$LN18@xmlSchemaC:

; 4301 : 		else
; 4302 : 		    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
$LN5@xmlSchemaC:

; 4303 : 	    }
; 4304 : 	}
; 4305 : 	x++;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 4306 : 	y++;

	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, 1
	mov	DWORD PTR _y$[ebp], ecx

; 4307 :     }

	jmp	$LN2@xmlSchemaC
$LN3@xmlSchemaC:

; 4308 :     if (*x != 0) {

	mov	edx, DWORD PTR _x$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN20@xmlSchemaC

; 4309 : 	if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN21@xmlSchemaC

; 4310 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN20@xmlSchemaC
$LN21@xmlSchemaC:

; 4311 : 	else
; 4312 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
$LN20@xmlSchemaC:

; 4313 :     }
; 4314 :     if (*y != 0) {

	mov	ecx, DWORD PTR _y$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN23@xmlSchemaC

; 4315 : 	if (invert)

	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN24@xmlSchemaC

; 4316 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN23@xmlSchemaC
$LN24@xmlSchemaC:

; 4317 : 	else
; 4318 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
$LN23@xmlSchemaC:

; 4319 :     }
; 4320 :     return(0);

	xor	eax, eax
$LN1@xmlSchemaC:

; 4321 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaComparePreserveReplaceStrings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareDates
_TEXT	SEGMENT
tv410 = -120						; size = 4
tv406 = -116						; size = 4
tv727 = -112						; size = 4
tv716 = -108						; size = 4
tv677 = -104						; size = 4
tv666 = -100						; size = 4
tv641 = -96						; size = 4
tv630 = -92						; size = 4
tv589 = -88						; size = 4
tv578 = -84						; size = 4
tv553 = -80						; size = 4
tv542 = -76						; size = 4
_sec$1 = -72						; size = 8
_ret$2 = -64						; size = 4
_ret$3 = -60						; size = 4
_sec$4 = -56						; size = 8
_ret$5 = -48						; size = 4
_sec$6 = -44						; size = 8
_q2d$ = -36						; size = 4
_q1d$ = -32						; size = 4
_p2d$ = -28						; size = 4
_p1d$ = -24						; size = 4
_q2$ = -20						; size = 4
_q1$ = -16						; size = 4
_p2$ = -12						; size = 4
_p1$ = -8						; size = 4
_and_mask$ = -4						; size = 1
_xor_mask$ = -3						; size = 1
_ymask$ = -2						; size = 1
_xmask$ = -1						; size = 1
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareDates PROC				; COMDAT

; 4009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	edi
	lea	edi, DWORD PTR [ebp-120]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 4010 :     unsigned char xmask, ymask, xor_mask, and_mask;
; 4011 :     xmlSchemaValPtr p1, p2, q1, q2;
; 4012 :     long p1d, p2d, q1d, q2d;
; 4013 : 
; 4014 :     if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN7@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN6@xmlSchemaC
$LN7@xmlSchemaC:

; 4015 :         return -2;

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN6@xmlSchemaC:

; 4016 : 
; 4017 :     if (x->value.date.tz_flag) {

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 1
	je	$LN8@xmlSchemaC

; 4018 : 
; 4019 :         if (!y->value.date.tz_flag) {

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 1
	jne	$LN14@xmlSchemaC

; 4020 :             p1 = xmlSchemaDateNormalize(x, 0);

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_xmlSchemaDateNormalize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _p1$[ebp], eax

; 4021 :             p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;

	mov	edx, DWORD PTR _p1$[ebp]
	push	edx
	call	__xmlSchemaDateCastYMToDays
	add	esp, 4
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _p1d$[ebp], eax

; 4022 :             /* normalize y + 14:00 */
; 4023 :             q1 = xmlSchemaDateNormalize(y, (14 * SECS_PER_HOUR));

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@40e89c0000000000
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	call	_xmlSchemaDateNormalize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _q1$[ebp], eax

; 4024 : 
; 4025 :             q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;

	mov	ecx, DWORD PTR _q1$[ebp]
	push	ecx
	call	__xmlSchemaDateCastYMToDays
	add	esp, 4
	mov	edx, DWORD PTR _q1$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	add	eax, ecx
	mov	DWORD PTR _q1d$[ebp], eax

; 4026 :             if (p1d < q1d) {

	mov	edx, DWORD PTR _p1d$[ebp]
	cmp	edx, DWORD PTR _q1d$[ebp]
	jge	SHORT $LN11@xmlSchemaC

; 4027 : 		xmlSchemaFreeValue(p1);

	mov	eax, DWORD PTR _p1$[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4028 : 		xmlSchemaFreeValue(q1);

	mov	ecx, DWORD PTR _q1$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4029 :                 return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	$LN14@xmlSchemaC
$LN11@xmlSchemaC:

; 4030 : 	    } else if (p1d == q1d) {

	mov	edx, DWORD PTR _p1d$[ebp]
	cmp	edx, DWORD PTR _q1d$[ebp]
	jne	$LN13@xmlSchemaC

; 4031 :                 double sec;
; 4032 : 
; 4033 :                 sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);

	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	imul	edx, ecx, 3600
	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	imul	eax, ecx, 60
	add	edx, eax
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	imul	ecx, eax, 60
	add	edx, ecx
	mov	DWORD PTR tv542[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv542[ebp]
	mov	edx, DWORD PTR tv542[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mov	eax, DWORD PTR _p1$[ebp]
	addsd	xmm0, QWORD PTR [eax+16]
	mov	ecx, DWORD PTR _q1$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 9
	and	edx, 31					; 0000001fH
	imul	eax, edx, 3600
	mov	ecx, DWORD PTR _q1$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 14					; 0000000eH
	and	edx, 63					; 0000003fH
	imul	ecx, edx, 60
	add	eax, ecx
	mov	edx, DWORD PTR _q1$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shl	ecx, 19					; 00000013H
	sar	ecx, 20					; 00000014H
	imul	edx, ecx, 60
	add	eax, edx
	mov	DWORD PTR tv553[ebp], eax
	cvtsi2sd xmm1, DWORD PTR tv553[ebp]
	mov	eax, DWORD PTR tv553[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR _q1$[ebp]
	addsd	xmm1, QWORD PTR [ecx+16]
	subsd	xmm0, xmm1
	movsd	QWORD PTR _sec$6[ebp], xmm0

; 4034 :                 if (sec < 0.0) {

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _sec$6[ebp]
	jbe	SHORT $LN15@xmlSchemaC

; 4035 : 		    xmlSchemaFreeValue(p1);

	mov	edx, DWORD PTR _p1$[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4036 : 		    xmlSchemaFreeValue(q1);

	mov	eax, DWORD PTR _q1$[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4037 :                     return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaC

; 4038 : 		} else {

	jmp	$LN22@xmlSchemaC
$LN15@xmlSchemaC:

; 4039 : 		    int ret = 0;

	mov	DWORD PTR _ret$5[ebp], 0

; 4040 :                     /* normalize y - 14:00 */
; 4041 :                     q2 = xmlSchemaDateNormalize(y, -(14 * SECS_PER_HOUR));

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@c0e89c0000000000
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	call	_xmlSchemaDateNormalize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _q2$[ebp], eax

; 4042 :                     q2d = _xmlSchemaDateCastYMToDays(q2) + q2->value.date.day;

	mov	edx, DWORD PTR _q2$[ebp]
	push	edx
	call	__xmlSchemaDateCastYMToDays
	add	esp, 4
	mov	ecx, DWORD PTR _q2$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _q2d$[ebp], eax

; 4043 :                     if (p1d > q2d)

	mov	eax, DWORD PTR _p1d$[ebp]
	cmp	eax, DWORD PTR _q2d$[ebp]
	jle	SHORT $LN17@xmlSchemaC

; 4044 :                         ret = 1;

	mov	DWORD PTR _ret$5[ebp], 1
	jmp	$LN21@xmlSchemaC
$LN17@xmlSchemaC:

; 4045 :                     else if (p1d == q2d) {

	mov	ecx, DWORD PTR _p1d$[ebp]
	cmp	ecx, DWORD PTR _q2d$[ebp]
	jne	$LN21@xmlSchemaC

; 4046 :                         sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q2);

	mov	edx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 9
	and	eax, 31					; 0000001fH
	imul	ecx, eax, 3600
	mov	edx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	imul	edx, eax, 60
	add	ecx, edx
	mov	eax, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [eax+24]
	shl	edx, 19					; 00000013H
	sar	edx, 20					; 00000014H
	imul	eax, edx, 60
	add	ecx, eax
	mov	DWORD PTR tv578[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv578[ebp]
	mov	ecx, DWORD PTR tv578[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _p1$[ebp]
	addsd	xmm0, QWORD PTR [edx+16]
	mov	eax, DWORD PTR _q2$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	imul	edx, ecx, 3600
	mov	eax, DWORD PTR _q2$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	imul	eax, ecx, 60
	add	edx, eax
	mov	ecx, DWORD PTR _q2$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	imul	ecx, eax, 60
	add	edx, ecx
	mov	DWORD PTR tv589[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv589[ebp]
	mov	edx, DWORD PTR tv589[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mov	eax, DWORD PTR _q2$[ebp]
	addsd	xmm1, QWORD PTR [eax+16]
	subsd	xmm0, xmm1
	movsd	QWORD PTR _sec$6[ebp], xmm0

; 4047 :                         if (sec > 0.0)

	movsd	xmm0, QWORD PTR _sec$6[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN20@xmlSchemaC

; 4048 :                             ret = 1;

	mov	DWORD PTR _ret$5[ebp], 1
	jmp	SHORT $LN21@xmlSchemaC
$LN20@xmlSchemaC:

; 4049 :                         else
; 4050 :                             ret = 2; /* indeterminate */

	mov	DWORD PTR _ret$5[ebp], 2
$LN21@xmlSchemaC:

; 4051 :                     }
; 4052 : 		    xmlSchemaFreeValue(p1);

	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4053 : 		    xmlSchemaFreeValue(q1);

	mov	edx, DWORD PTR _q1$[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4054 : 		    xmlSchemaFreeValue(q2);

	mov	eax, DWORD PTR _q2$[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4055 : 		    if (ret != 0)

	cmp	DWORD PTR _ret$5[ebp], 0
	je	SHORT $LN22@xmlSchemaC

; 4056 : 		        return(ret);

	mov	eax, DWORD PTR _ret$5[ebp]
	jmp	$LN1@xmlSchemaC
$LN22@xmlSchemaC:

; 4057 :                 }
; 4058 :             } else {

	jmp	SHORT $LN14@xmlSchemaC
$LN13@xmlSchemaC:

; 4059 : 		xmlSchemaFreeValue(p1);

	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4060 : 		xmlSchemaFreeValue(q1);

	mov	edx, DWORD PTR _q1$[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN14@xmlSchemaC:

; 4061 : 	    }
; 4062 :         }

	jmp	$LN27@xmlSchemaC
$LN8@xmlSchemaC:

; 4063 :     } else if (y->value.date.tz_flag) {

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 1
	je	$LN27@xmlSchemaC

; 4064 :         q1 = xmlSchemaDateNormalize(y, 0);

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	call	_xmlSchemaDateNormalize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _q1$[ebp], eax

; 4065 :         q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;

	mov	eax, DWORD PTR _q1$[ebp]
	push	eax
	call	__xmlSchemaDateCastYMToDays
	add	esp, 4
	mov	ecx, DWORD PTR _q1$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _q1d$[ebp], eax

; 4066 : 
; 4067 :         /* normalize x - 14:00 */
; 4068 :         p1 = xmlSchemaDateNormalize(x, -(14 * SECS_PER_HOUR));

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@c0e89c0000000000
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_xmlSchemaDateNormalize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _p1$[ebp], eax

; 4069 :         p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;

	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	call	__xmlSchemaDateCastYMToDays
	add	esp, 4
	mov	edx, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	add	eax, ecx
	mov	DWORD PTR _p1d$[ebp], eax

; 4070 : 
; 4071 :         if (p1d < q1d) {

	mov	edx, DWORD PTR _p1d$[ebp]
	cmp	edx, DWORD PTR _q1d$[ebp]
	jge	SHORT $LN24@xmlSchemaC

; 4072 : 	    xmlSchemaFreeValue(p1);

	mov	eax, DWORD PTR _p1$[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4073 : 	    xmlSchemaFreeValue(q1);

	mov	ecx, DWORD PTR _q1$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4074 :             return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	$LN27@xmlSchemaC
$LN24@xmlSchemaC:

; 4075 : 	} else if (p1d == q1d) {

	mov	edx, DWORD PTR _p1d$[ebp]
	cmp	edx, DWORD PTR _q1d$[ebp]
	jne	$LN26@xmlSchemaC

; 4076 :             double sec;
; 4077 : 
; 4078 :             sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);

	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	imul	edx, ecx, 3600
	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	imul	eax, ecx, 60
	add	edx, eax
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	imul	ecx, eax, 60
	add	edx, ecx
	mov	DWORD PTR tv630[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv630[ebp]
	mov	edx, DWORD PTR tv630[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mov	eax, DWORD PTR _p1$[ebp]
	addsd	xmm0, QWORD PTR [eax+16]
	mov	ecx, DWORD PTR _q1$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 9
	and	edx, 31					; 0000001fH
	imul	eax, edx, 3600
	mov	ecx, DWORD PTR _q1$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 14					; 0000000eH
	and	edx, 63					; 0000003fH
	imul	ecx, edx, 60
	add	eax, ecx
	mov	edx, DWORD PTR _q1$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shl	ecx, 19					; 00000013H
	sar	ecx, 20					; 00000014H
	imul	edx, ecx, 60
	add	eax, edx
	mov	DWORD PTR tv641[ebp], eax
	cvtsi2sd xmm1, DWORD PTR tv641[ebp]
	mov	eax, DWORD PTR tv641[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR _q1$[ebp]
	addsd	xmm1, QWORD PTR [ecx+16]
	subsd	xmm0, xmm1
	movsd	QWORD PTR _sec$4[ebp], xmm0

; 4079 :             if (sec < 0.0) {

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _sec$4[ebp]
	jbe	SHORT $LN28@xmlSchemaC

; 4080 : 		xmlSchemaFreeValue(p1);

	mov	edx, DWORD PTR _p1$[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4081 : 		xmlSchemaFreeValue(q1);

	mov	eax, DWORD PTR _q1$[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4082 :                 return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaC

; 4083 : 	    } else {

	jmp	$LN35@xmlSchemaC
$LN28@xmlSchemaC:

; 4084 : 	        int ret = 0;

	mov	DWORD PTR _ret$3[ebp], 0

; 4085 :                 /* normalize x + 14:00 */
; 4086 :                 p2 = xmlSchemaDateNormalize(x, (14 * SECS_PER_HOUR));

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@40e89c0000000000
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_xmlSchemaDateNormalize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _p2$[ebp], eax

; 4087 :                 p2d = _xmlSchemaDateCastYMToDays(p2) + p2->value.date.day;

	mov	edx, DWORD PTR _p2$[ebp]
	push	edx
	call	__xmlSchemaDateCastYMToDays
	add	esp, 4
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _p2d$[ebp], eax

; 4088 : 
; 4089 :                 if (p2d > q1d) {

	mov	eax, DWORD PTR _p2d$[ebp]
	cmp	eax, DWORD PTR _q1d$[ebp]
	jle	SHORT $LN30@xmlSchemaC

; 4090 :                     ret = 1;

	mov	DWORD PTR _ret$3[ebp], 1
	jmp	$LN34@xmlSchemaC
$LN30@xmlSchemaC:

; 4091 : 		} else if (p2d == q1d) {

	mov	ecx, DWORD PTR _p2d$[ebp]
	cmp	ecx, DWORD PTR _q1d$[ebp]
	jne	$LN34@xmlSchemaC

; 4092 :                     sec = TIME_TO_NUMBER(p2) - TIME_TO_NUMBER(q1);

	mov	edx, DWORD PTR _p2$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 9
	and	eax, 31					; 0000001fH
	imul	ecx, eax, 3600
	mov	edx, DWORD PTR _p2$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	imul	edx, eax, 60
	add	ecx, edx
	mov	eax, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR [eax+24]
	shl	edx, 19					; 00000013H
	sar	edx, 20					; 00000014H
	imul	eax, edx, 60
	add	ecx, eax
	mov	DWORD PTR tv666[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv666[ebp]
	mov	ecx, DWORD PTR tv666[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _p2$[ebp]
	addsd	xmm0, QWORD PTR [edx+16]
	mov	eax, DWORD PTR _q1$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	imul	edx, ecx, 3600
	mov	eax, DWORD PTR _q1$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	imul	eax, ecx, 60
	add	edx, eax
	mov	ecx, DWORD PTR _q1$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	imul	ecx, eax, 60
	add	edx, ecx
	mov	DWORD PTR tv677[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv677[ebp]
	mov	edx, DWORD PTR tv677[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mov	eax, DWORD PTR _q1$[ebp]
	addsd	xmm1, QWORD PTR [eax+16]
	subsd	xmm0, xmm1
	movsd	QWORD PTR _sec$4[ebp], xmm0

; 4093 :                     if (sec > 0.0)

	movsd	xmm0, QWORD PTR _sec$4[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN33@xmlSchemaC

; 4094 :                         ret = 1;

	mov	DWORD PTR _ret$3[ebp], 1
	jmp	SHORT $LN34@xmlSchemaC
$LN33@xmlSchemaC:

; 4095 :                     else
; 4096 :                         ret = 2; /* indeterminate */

	mov	DWORD PTR _ret$3[ebp], 2
$LN34@xmlSchemaC:

; 4097 :                 }
; 4098 : 		xmlSchemaFreeValue(p1);

	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4099 : 		xmlSchemaFreeValue(q1);

	mov	edx, DWORD PTR _q1$[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4100 : 		xmlSchemaFreeValue(p2);

	mov	eax, DWORD PTR _p2$[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4101 : 		if (ret != 0)

	cmp	DWORD PTR _ret$3[ebp], 0
	je	SHORT $LN35@xmlSchemaC

; 4102 : 		    return(ret);

	mov	eax, DWORD PTR _ret$3[ebp]
	jmp	$LN1@xmlSchemaC
$LN35@xmlSchemaC:

; 4103 :             }
; 4104 : 	} else {

	jmp	SHORT $LN27@xmlSchemaC
$LN26@xmlSchemaC:

; 4105 : 	    xmlSchemaFreeValue(p1);

	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4106 : 	    xmlSchemaFreeValue(q1);

	mov	edx, DWORD PTR _q1$[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN27@xmlSchemaC:

; 4107 :         }
; 4108 :     }
; 4109 : 
; 4110 :     /*
; 4111 :      * if the same type then calculate the difference
; 4112 :      */
; 4113 :     if (x->type == y->type) {

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	$LN36@xmlSchemaC

; 4114 :         int ret = 0;

	mov	DWORD PTR _ret$2[ebp], 0

; 4115 :         q1 = xmlSchemaDateNormalize(y, 0);

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	call	_xmlSchemaDateNormalize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _q1$[ebp], eax

; 4116 :         q1d = _xmlSchemaDateCastYMToDays(q1) + q1->value.date.day;

	mov	ecx, DWORD PTR _q1$[ebp]
	push	ecx
	call	__xmlSchemaDateCastYMToDays
	add	esp, 4
	mov	edx, DWORD PTR _q1$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	add	eax, ecx
	mov	DWORD PTR _q1d$[ebp], eax

; 4117 : 
; 4118 :         p1 = xmlSchemaDateNormalize(x, 0);

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_xmlSchemaDateNormalize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _p1$[ebp], eax

; 4119 :         p1d = _xmlSchemaDateCastYMToDays(p1) + p1->value.date.day;

	mov	eax, DWORD PTR _p1$[ebp]
	push	eax
	call	__xmlSchemaDateCastYMToDays
	add	esp, 4
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _p1d$[ebp], eax

; 4120 : 
; 4121 :         if (p1d < q1d) {

	mov	eax, DWORD PTR _p1d$[ebp]
	cmp	eax, DWORD PTR _q1d$[ebp]
	jge	SHORT $LN37@xmlSchemaC

; 4122 :             ret = -1;

	mov	DWORD PTR _ret$2[ebp], -1
	jmp	$LN43@xmlSchemaC
$LN37@xmlSchemaC:

; 4123 : 	} else if (p1d > q1d) {

	mov	ecx, DWORD PTR _p1d$[ebp]
	cmp	ecx, DWORD PTR _q1d$[ebp]
	jle	SHORT $LN39@xmlSchemaC

; 4124 :             ret = 1;

	mov	DWORD PTR _ret$2[ebp], 1

; 4125 : 	} else {

	jmp	$LN43@xmlSchemaC
$LN39@xmlSchemaC:

; 4126 :             double sec;
; 4127 : 
; 4128 :             sec = TIME_TO_NUMBER(p1) - TIME_TO_NUMBER(q1);

	mov	edx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 9
	and	eax, 31					; 0000001fH
	imul	ecx, eax, 3600
	mov	edx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	imul	edx, eax, 60
	add	ecx, edx
	mov	eax, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [eax+24]
	shl	edx, 19					; 00000013H
	sar	edx, 20					; 00000014H
	imul	eax, edx, 60
	add	ecx, eax
	mov	DWORD PTR tv716[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv716[ebp]
	mov	ecx, DWORD PTR tv716[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _p1$[ebp]
	addsd	xmm0, QWORD PTR [edx+16]
	mov	eax, DWORD PTR _q1$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	imul	edx, ecx, 3600
	mov	eax, DWORD PTR _q1$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	imul	eax, ecx, 60
	add	edx, eax
	mov	ecx, DWORD PTR _q1$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	imul	ecx, eax, 60
	add	edx, ecx
	mov	DWORD PTR tv727[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv727[ebp]
	mov	edx, DWORD PTR tv727[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mov	eax, DWORD PTR _q1$[ebp]
	addsd	xmm1, QWORD PTR [eax+16]
	subsd	xmm0, xmm1
	movsd	QWORD PTR _sec$1[ebp], xmm0

; 4129 :             if (sec < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _sec$1[ebp]
	jbe	SHORT $LN41@xmlSchemaC

; 4130 :                 ret = -1;

	mov	DWORD PTR _ret$2[ebp], -1
	jmp	SHORT $LN43@xmlSchemaC
$LN41@xmlSchemaC:

; 4131 :             else if (sec > 0.0)

	movsd	xmm0, QWORD PTR _sec$1[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN43@xmlSchemaC

; 4132 :                 ret = 1;

	mov	DWORD PTR _ret$2[ebp], 1
$LN43@xmlSchemaC:

; 4133 : 
; 4134 :         }
; 4135 : 	xmlSchemaFreeValue(p1);

	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4136 : 	xmlSchemaFreeValue(q1);

	mov	edx, DWORD PTR _q1$[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 4137 :         return(ret);

	mov	eax, DWORD PTR _ret$2[ebp]
	jmp	$LN1@xmlSchemaC
$LN36@xmlSchemaC:

; 4138 :     }
; 4139 : 
; 4140 :     switch (x->type) {

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv406[ebp], ecx
	mov	edx, DWORD PTR tv406[ebp]
	sub	edx, 4
	mov	DWORD PTR tv406[ebp], edx
	cmp	DWORD PTR tv406[ebp], 7
	ja	SHORT $LN52@xmlSchemaC
	mov	eax, DWORD PTR tv406[ebp]
	jmp	DWORD PTR $LN95@xmlSchemaC[eax*4]
$LN44@xmlSchemaC:

; 4141 :         case XML_SCHEMAS_DATETIME:
; 4142 :             xmask = 0xf;

	mov	BYTE PTR _xmask$[ebp], 15		; 0000000fH

; 4143 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN45@xmlSchemaC:

; 4144 :         case XML_SCHEMAS_DATE:
; 4145 :             xmask = 0x7;

	mov	BYTE PTR _xmask$[ebp], 7

; 4146 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN46@xmlSchemaC:

; 4147 :         case XML_SCHEMAS_GYEAR:
; 4148 :             xmask = 0x1;

	mov	BYTE PTR _xmask$[ebp], 1

; 4149 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN47@xmlSchemaC:

; 4150 :         case XML_SCHEMAS_GMONTH:
; 4151 :             xmask = 0x2;

	mov	BYTE PTR _xmask$[ebp], 2

; 4152 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN48@xmlSchemaC:

; 4153 :         case XML_SCHEMAS_GDAY:
; 4154 :             xmask = 0x3;

	mov	BYTE PTR _xmask$[ebp], 3

; 4155 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN49@xmlSchemaC:

; 4156 :         case XML_SCHEMAS_GYEARMONTH:
; 4157 :             xmask = 0x3;

	mov	BYTE PTR _xmask$[ebp], 3

; 4158 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN50@xmlSchemaC:

; 4159 :         case XML_SCHEMAS_GMONTHDAY:
; 4160 :             xmask = 0x6;

	mov	BYTE PTR _xmask$[ebp], 6

; 4161 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN51@xmlSchemaC:

; 4162 :         case XML_SCHEMAS_TIME:
; 4163 :             xmask = 0x8;

	mov	BYTE PTR _xmask$[ebp], 8

; 4164 :             break;

	jmp	SHORT $LN2@xmlSchemaC
$LN52@xmlSchemaC:

; 4165 :         default:
; 4166 :             xmask = 0;

	mov	BYTE PTR _xmask$[ebp], 0
$LN2@xmlSchemaC:

; 4167 :             break;
; 4168 :     }
; 4169 : 
; 4170 :     switch (y->type) {

	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv410[ebp], edx
	mov	eax, DWORD PTR tv410[ebp]
	sub	eax, 4
	mov	DWORD PTR tv410[ebp], eax
	cmp	DWORD PTR tv410[ebp], 7
	ja	SHORT $LN61@xmlSchemaC
	mov	ecx, DWORD PTR tv410[ebp]
	jmp	DWORD PTR $LN96@xmlSchemaC[ecx*4]
$LN53@xmlSchemaC:

; 4171 :         case XML_SCHEMAS_DATETIME:
; 4172 :             ymask = 0xf;

	mov	BYTE PTR _ymask$[ebp], 15		; 0000000fH

; 4173 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN54@xmlSchemaC:

; 4174 :         case XML_SCHEMAS_DATE:
; 4175 :             ymask = 0x7;

	mov	BYTE PTR _ymask$[ebp], 7

; 4176 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN55@xmlSchemaC:

; 4177 :         case XML_SCHEMAS_GYEAR:
; 4178 :             ymask = 0x1;

	mov	BYTE PTR _ymask$[ebp], 1

; 4179 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN56@xmlSchemaC:

; 4180 :         case XML_SCHEMAS_GMONTH:
; 4181 :             ymask = 0x2;

	mov	BYTE PTR _ymask$[ebp], 2

; 4182 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN57@xmlSchemaC:

; 4183 :         case XML_SCHEMAS_GDAY:
; 4184 :             ymask = 0x3;

	mov	BYTE PTR _ymask$[ebp], 3

; 4185 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN58@xmlSchemaC:

; 4186 :         case XML_SCHEMAS_GYEARMONTH:
; 4187 :             ymask = 0x3;

	mov	BYTE PTR _ymask$[ebp], 3

; 4188 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN59@xmlSchemaC:

; 4189 :         case XML_SCHEMAS_GMONTHDAY:
; 4190 :             ymask = 0x6;

	mov	BYTE PTR _ymask$[ebp], 6

; 4191 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN60@xmlSchemaC:

; 4192 :         case XML_SCHEMAS_TIME:
; 4193 :             ymask = 0x8;

	mov	BYTE PTR _ymask$[ebp], 8

; 4194 :             break;

	jmp	SHORT $LN4@xmlSchemaC
$LN61@xmlSchemaC:

; 4195 :         default:
; 4196 :             ymask = 0;

	mov	BYTE PTR _ymask$[ebp], 0
$LN4@xmlSchemaC:

; 4197 :             break;
; 4198 :     }
; 4199 : 
; 4200 :     xor_mask = xmask ^ ymask;           /* mark type differences */

	movzx	edx, BYTE PTR _xmask$[ebp]
	movzx	eax, BYTE PTR _ymask$[ebp]
	xor	edx, eax
	mov	BYTE PTR _xor_mask$[ebp], dl

; 4201 :     and_mask = xmask & ymask;           /* mark field specification */

	movzx	ecx, BYTE PTR _xmask$[ebp]
	movzx	edx, BYTE PTR _ymask$[ebp]
	and	ecx, edx
	mov	BYTE PTR _and_mask$[ebp], cl

; 4202 : 
; 4203 :     /* year */
; 4204 :     if (xor_mask & 1)

	movzx	eax, BYTE PTR _xor_mask$[ebp]
	and	eax, 1
	je	SHORT $LN62@xmlSchemaC

; 4205 :         return 2; /* indeterminate */

	mov	eax, 2
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN67@xmlSchemaC
$LN62@xmlSchemaC:

; 4206 :     else if (and_mask & 1) {

	movzx	ecx, BYTE PTR _and_mask$[ebp]
	and	ecx, 1
	je	SHORT $LN67@xmlSchemaC

; 4207 :         if (x->value.date.year < y->value.date.year)

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN65@xmlSchemaC

; 4208 :             return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN67@xmlSchemaC
$LN65@xmlSchemaC:

; 4209 :         else if (x->value.date.year > y->value.date.year)

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	cmp	ecx, DWORD PTR [eax+8]
	jle	SHORT $LN67@xmlSchemaC

; 4210 :             return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN67@xmlSchemaC:

; 4211 :     }
; 4212 : 
; 4213 :     /* month */
; 4214 :     if (xor_mask & 2)

	movzx	edx, BYTE PTR _xor_mask$[ebp]
	and	edx, 2
	je	SHORT $LN68@xmlSchemaC

; 4215 :         return 2; /* indeterminate */

	mov	eax, 2
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN73@xmlSchemaC
$LN68@xmlSchemaC:

; 4216 :     else if (and_mask & 2) {

	movzx	eax, BYTE PTR _and_mask$[ebp]
	and	eax, 2
	je	SHORT $LN73@xmlSchemaC

; 4217 :         if (x->value.date.mon < y->value.date.mon)

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 15					; 0000000fH
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 15					; 0000000fH
	cmp	edx, ecx
	jae	SHORT $LN71@xmlSchemaC

; 4218 :             return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN73@xmlSchemaC
$LN71@xmlSchemaC:

; 4219 :         else if (x->value.date.mon > y->value.date.mon)

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 15					; 0000000fH
	cmp	eax, edx
	jbe	SHORT $LN73@xmlSchemaC

; 4220 :             return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN73@xmlSchemaC:

; 4221 :     }
; 4222 : 
; 4223 :     /* day */
; 4224 :     if (xor_mask & 4)

	movzx	eax, BYTE PTR _xor_mask$[ebp]
	and	eax, 4
	je	SHORT $LN74@xmlSchemaC

; 4225 :         return 2; /* indeterminate */

	mov	eax, 2
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN79@xmlSchemaC
$LN74@xmlSchemaC:

; 4226 :     else if (and_mask & 4) {

	movzx	ecx, BYTE PTR _and_mask$[ebp]
	and	ecx, 4
	je	SHORT $LN79@xmlSchemaC

; 4227 :         if (x->value.date.day < y->value.date.day)

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	cmp	eax, edx
	jae	SHORT $LN77@xmlSchemaC

; 4228 :             return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN79@xmlSchemaC
$LN77@xmlSchemaC:

; 4229 :         else if (x->value.date.day > y->value.date.day)

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	cmp	ecx, eax
	jbe	SHORT $LN79@xmlSchemaC

; 4230 :             return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN79@xmlSchemaC:

; 4231 :     }
; 4232 : 
; 4233 :     /* time */
; 4234 :     if (xor_mask & 8)

	movzx	ecx, BYTE PTR _xor_mask$[ebp]
	and	ecx, 8
	je	SHORT $LN80@xmlSchemaC

; 4235 :         return 2; /* indeterminate */

	mov	eax, 2
	jmp	$LN1@xmlSchemaC
	jmp	$LN93@xmlSchemaC
$LN80@xmlSchemaC:

; 4236 :     else if (and_mask & 8) {

	movzx	edx, BYTE PTR _and_mask$[ebp]
	and	edx, 8
	je	$LN93@xmlSchemaC

; 4237 :         if (x->value.date.hour < y->value.date.hour)

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 9
	and	eax, 31					; 0000001fH
	cmp	ecx, eax
	jae	SHORT $LN83@xmlSchemaC

; 4238 :             return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	$LN93@xmlSchemaC
$LN83@xmlSchemaC:

; 4239 :         else if (x->value.date.hour > y->value.date.hour)

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 9
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	cmp	edx, ecx
	jbe	SHORT $LN85@xmlSchemaC

; 4240 :             return 1;

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN93@xmlSchemaC
$LN85@xmlSchemaC:

; 4241 :         else if (x->value.date.min < y->value.date.min)

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 14					; 0000000eH
	and	edx, 63					; 0000003fH
	cmp	eax, edx
	jae	SHORT $LN87@xmlSchemaC

; 4242 :             return -1;

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN93@xmlSchemaC
$LN87@xmlSchemaC:

; 4243 :         else if (x->value.date.min > y->value.date.min)

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	cmp	ecx, eax
	jbe	SHORT $LN89@xmlSchemaC

; 4244 :             return 1;

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN93@xmlSchemaC
$LN89@xmlSchemaC:

; 4245 :         else if (x->value.date.sec < y->value.date.sec)

	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	movsd	xmm0, QWORD PTR [ecx+16]
	comisd	xmm0, QWORD PTR [edx+16]
	jbe	SHORT $LN91@xmlSchemaC

; 4246 :             return -1;

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN93@xmlSchemaC
$LN91@xmlSchemaC:

; 4247 :         else if (x->value.date.sec > y->value.date.sec)

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	movsd	xmm0, QWORD PTR [eax+16]
	comisd	xmm0, QWORD PTR [ecx+16]
	jbe	SHORT $LN93@xmlSchemaC

; 4248 :             return 1;

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaC
$LN93@xmlSchemaC:

; 4249 :     }
; 4250 : 
; 4251 :     return 0;

	xor	eax, eax
$LN1@xmlSchemaC:

; 4252 : }

	pop	edi
	add	esp, 120				; 00000078H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN95@xmlSchemaC:
	DD	$LN51@xmlSchemaC
	DD	$LN48@xmlSchemaC
	DD	$LN47@xmlSchemaC
	DD	$LN50@xmlSchemaC
	DD	$LN46@xmlSchemaC
	DD	$LN49@xmlSchemaC
	DD	$LN45@xmlSchemaC
	DD	$LN44@xmlSchemaC
$LN96@xmlSchemaC:
	DD	$LN60@xmlSchemaC
	DD	$LN57@xmlSchemaC
	DD	$LN56@xmlSchemaC
	DD	$LN59@xmlSchemaC
	DD	$LN55@xmlSchemaC
	DD	$LN58@xmlSchemaC
	DD	$LN54@xmlSchemaC
	DD	$LN53@xmlSchemaC
_xmlSchemaCompareDates ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaDateCastYMToDays
_TEXT	SEGMENT
tv162 = -16						; size = 4
tv130 = -12						; size = 4
_mon$ = -8						; size = 4
_ret$ = -4						; size = 4
_dt$ = 8						; size = 4
__xmlSchemaDateCastYMToDays PROC			; COMDAT

; 3962 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 3963 :     long ret;
; 3964 :     int mon;
; 3965 : 
; 3966 :     mon = dt->value.date.mon;

	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _mon$[ebp], ecx

; 3967 :     if (mon <= 0) mon = 1; /* normalization */

	jg	SHORT $LN2@xmlSchemaD
	mov	DWORD PTR _mon$[ebp], 1
$LN2@xmlSchemaD:

; 3968 : 
; 3969 :     if (dt->value.date.year <= 0)

	mov	edx, DWORD PTR _dt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jg	$LN3@xmlSchemaD

; 3970 :         ret = (dt->value.date.year * 365) +

	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN12@xmlSchemaD
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN12@xmlSchemaD:
	test	ecx, ecx
	jne	SHORT $LN6@xmlSchemaD
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN7@xmlSchemaD
$LN6@xmlSchemaD:
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN7@xmlSchemaD
	mov	edx, DWORD PTR _mon$[ebp]
	mov	eax, DWORD PTR _dayInYearByMonth[edx*4-4]
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $LN8@xmlSchemaD
$LN7@xmlSchemaD:
	mov	ecx, DWORD PTR _mon$[ebp]
	mov	edx, DWORD PTR _dayInLeapYearByMonth[ecx*4-4]
	mov	DWORD PTR tv130[ebp], edx
$LN8@xmlSchemaD:
	mov	eax, DWORD PTR _dt$[ebp]
	imul	ecx, DWORD PTR [eax+8], 365
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	cdq
	and	edx, 3
	add	eax, edx
	mov	esi, eax
	sar	esi, 2
	mov	eax, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [eax+8]
	add	eax, 1
	cdq
	mov	edi, 100				; 00000064H
	idiv	edi
	sub	esi, eax
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	cdq
	mov	edi, 400				; 00000190H
	idiv	edi
	add	esi, eax
	add	ecx, DWORD PTR tv130[ebp]
	add	esi, ecx
	mov	DWORD PTR _ret$[ebp], esi
	jmp	$LN4@xmlSchemaD
$LN3@xmlSchemaD:

; 3971 :               (((dt->value.date.year+1)/4)-((dt->value.date.year+1)/100)+
; 3972 :                ((dt->value.date.year+1)/400)) +
; 3973 :               DAY_IN_YEAR(0, mon, dt->value.date.year);
; 3974 :     else
; 3975 :         ret = ((dt->value.date.year-1) * 365) +

	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN13@xmlSchemaD
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN13@xmlSchemaD:
	test	ecx, ecx
	jne	SHORT $LN9@xmlSchemaD
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN10@xmlSchemaD
$LN9@xmlSchemaD:
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN10@xmlSchemaD
	mov	edx, DWORD PTR _mon$[ebp]
	mov	eax, DWORD PTR _dayInYearByMonth[edx*4-4]
	mov	DWORD PTR tv162[ebp], eax
	jmp	SHORT $LN11@xmlSchemaD
$LN10@xmlSchemaD:
	mov	ecx, DWORD PTR _mon$[ebp]
	mov	edx, DWORD PTR _dayInLeapYearByMonth[ecx*4-4]
	mov	DWORD PTR tv162[ebp], edx
$LN11@xmlSchemaD:
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	imul	ecx, ecx, 365
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	cdq
	and	edx, 3
	add	eax, edx
	mov	esi, eax
	sar	esi, 2
	mov	eax, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, 1
	cdq
	mov	edi, 100				; 00000064H
	idiv	edi
	sub	esi, eax
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	cdq
	mov	edi, 400				; 00000190H
	idiv	edi
	add	esi, eax
	add	ecx, DWORD PTR tv162[ebp]
	add	esi, ecx
	mov	DWORD PTR _ret$[ebp], esi
$LN4@xmlSchemaD:

; 3976 :               (((dt->value.date.year-1)/4)-((dt->value.date.year-1)/100)+
; 3977 :                ((dt->value.date.year-1)/400)) +
; 3978 :               DAY_IN_YEAR(0, mon, dt->value.date.year);
; 3979 : 
; 3980 :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 3981 : }

	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__xmlSchemaDateCastYMToDays ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaDateNormalize
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_dur$ = -4						; size = 4
_dt$ = 8						; size = 4
_offset$ = 12						; size = 8
_xmlSchemaDateNormalize PROC				; COMDAT

; 3922 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 3923 :     xmlSchemaValPtr dur, ret;
; 3924 : 
; 3925 :     if (dt == NULL)

	cmp	DWORD PTR _dt$[ebp], 0
	jne	SHORT $LN2@xmlSchemaD

; 3926 :         return NULL;

	xor	eax, eax
	jmp	$LN1@xmlSchemaD
$LN2@xmlSchemaD:

; 3927 : 
; 3928 :     if (((dt->type != XML_SCHEMAS_TIME) &&
; 3929 :          (dt->type != XML_SCHEMAS_DATETIME) &&
; 3930 : 	 (dt->type != XML_SCHEMAS_DATE)) || (dt->value.date.tzo == 0))

	mov	eax, DWORD PTR _dt$[ebp]
	cmp	DWORD PTR [eax], 4
	je	SHORT $LN5@xmlSchemaD
	mov	ecx, DWORD PTR _dt$[ebp]
	cmp	DWORD PTR [ecx], 11			; 0000000bH
	je	SHORT $LN5@xmlSchemaD
	mov	edx, DWORD PTR _dt$[ebp]
	cmp	DWORD PTR [edx], 10			; 0000000aH
	jne	SHORT $LN4@xmlSchemaD
$LN5@xmlSchemaD:
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shl	ecx, 19					; 00000013H
	sar	ecx, 20					; 00000014H
	test	ecx, ecx
	jne	SHORT $LN3@xmlSchemaD
$LN4@xmlSchemaD:

; 3931 :         return xmlSchemaDupVal(dt);

	mov	edx, DWORD PTR _dt$[ebp]
	push	edx
	call	_xmlSchemaDupVal
	add	esp, 4
	jmp	SHORT $LN1@xmlSchemaD
$LN3@xmlSchemaD:

; 3932 : 
; 3933 :     dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION);

	push	12					; 0000000cH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _dur$[ebp], eax

; 3934 :     if (dur == NULL)

	cmp	DWORD PTR _dur$[ebp], 0
	jne	SHORT $LN6@xmlSchemaD

; 3935 :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaD
$LN6@xmlSchemaD:

; 3936 : 
; 3937 :     dur->value.date.sec -= offset;

	mov	eax, DWORD PTR _dur$[ebp]
	movsd	xmm0, QWORD PTR [eax+16]
	subsd	xmm0, QWORD PTR _offset$[ebp]
	mov	ecx, DWORD PTR _dur$[ebp]
	movsd	QWORD PTR [ecx+16], xmm0

; 3938 : 
; 3939 :     ret = _xmlSchemaDateAdd(dt, dur);

	mov	edx, DWORD PTR _dur$[ebp]
	push	edx
	mov	eax, DWORD PTR _dt$[ebp]
	push	eax
	call	__xmlSchemaDateAdd
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 3940 :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN7@xmlSchemaD

; 3941 :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaD
$LN7@xmlSchemaD:

; 3942 : 
; 3943 :     xmlSchemaFreeValue(dur);

	mov	ecx, DWORD PTR _dur$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 3944 : 
; 3945 :     /* ret->value.date.tzo = 0; */
; 3946 :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSchemaD:

; 3947 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaDateNormalize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaDateAdd
_TEXT	SEGMENT
tv897 = -260						; size = 8
tv890 = -252						; size = 8
tv881 = -244						; size = 8
tv942 = -236						; size = 8
tv874 = -228						; size = 8
tv448 = -220						; size = 4
tv427 = -216						; size = 4
tv398 = -212						; size = 4
tv803 = -208						; size = 8
tv796 = -200						; size = 8
tv792 = -192						; size = 8
tv940 = -184						; size = 8
tv785 = -176						; size = 8
tv333 = -168						; size = 4
tv312 = -164						; size = 4
tv718 = -160						; size = 8
tv710 = -152						; size = 8
tv938 = -144						; size = 8
tv703 = -136						; size = 8
tv692 = -128						; size = 8
tv684 = -120						; size = 8
tv936 = -112						; size = 8
tv677 = -104						; size = 8
tv670 = -96						; size = 8
tv663 = -88						; size = 8
tv648 = -80						; size = 8
tv615 = -72						; size = 8
tv606 = -64						; size = 8
tv934 = -56						; size = 8
tv599 = -48						; size = 8
_tyr$1 = -40						; size = 4
_tmon$2 = -36						; size = 4
_u$ = -32						; size = 4
_d$ = -28						; size = 4
_r$ = -24						; size = 4
_temp$ = -20						; size = 4
_tempdays$ = -16					; size = 4
_carry$ = -12						; size = 4
_tmp$ = -8						; size = 4
_ret$ = -4						; size = 4
_dt$ = 8						; size = 4
_dur$ = 12						; size = 4
__xmlSchemaDateAdd PROC					; COMDAT

; 3769 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 3770 :     xmlSchemaValPtr ret, tmp;
; 3771 :     long carry, tempdays, temp;
; 3772 :     xmlSchemaValDatePtr r, d;
; 3773 :     xmlSchemaValDurationPtr u;
; 3774 : 
; 3775 :     if ((dt == NULL) || (dur == NULL))

	cmp	DWORD PTR _dt$[ebp], 0
	je	SHORT $LN5@xmlSchemaD
	cmp	DWORD PTR _dur$[ebp], 0
	jne	SHORT $LN4@xmlSchemaD
$LN5@xmlSchemaD:

; 3776 :         return NULL;

	xor	eax, eax
	jmp	$LN1@xmlSchemaD
$LN4@xmlSchemaD:

; 3777 : 
; 3778 :     ret = xmlSchemaNewValue(dt->type);

	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 3779 :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN6@xmlSchemaD

; 3780 :         return NULL;

	xor	eax, eax
	jmp	$LN1@xmlSchemaD
$LN6@xmlSchemaD:

; 3781 : 
; 3782 :     /* make a copy so we don't alter the original value */
; 3783 :     tmp = xmlSchemaDupVal(dt);

	mov	edx, DWORD PTR _dt$[ebp]
	push	edx
	call	_xmlSchemaDupVal
	add	esp, 4
	mov	DWORD PTR _tmp$[ebp], eax

; 3784 :     if (tmp == NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN7@xmlSchemaD

; 3785 :         xmlSchemaFreeValue(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 3786 :         return NULL;

	xor	eax, eax
	jmp	$LN1@xmlSchemaD
$LN7@xmlSchemaD:

; 3787 :     }
; 3788 : 
; 3789 :     r = &(ret->value.date);

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, 8
	mov	DWORD PTR _r$[ebp], ecx

; 3790 :     d = &(tmp->value.date);

	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 8
	mov	DWORD PTR _d$[ebp], edx

; 3791 :     u = &(dur->value.dur);

	mov	eax, DWORD PTR _dur$[ebp]
	add	eax, 8
	mov	DWORD PTR _u$[ebp], eax

; 3792 : 
; 3793 :     /* normalization */
; 3794 :     if (d->mon == 0)

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 15					; 0000000fH
	jne	SHORT $LN8@xmlSchemaD

; 3795 :         d->mon = 1;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -16				; fffffff0H
	or	ecx, 1
	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN8@xmlSchemaD:

; 3796 : 
; 3797 :     /* normalize for time zone offset */
; 3798 :     u->sec -= (d->tzo * 60);

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	shl	ecx, 19					; 00000013H
	sar	ecx, 20					; 00000014H
	imul	edx, ecx, 60
	cvtsi2sd xmm0, edx
	mov	eax, DWORD PTR _u$[ebp]
	movsd	xmm1, QWORD PTR [eax+8]
	subsd	xmm1, xmm0
	mov	ecx, DWORD PTR _u$[ebp]
	movsd	QWORD PTR [ecx+8], xmm1

; 3799 :     d->tzo = 0;

	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [edx+16]
	and	eax, -8191				; ffffe001H
	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 3800 : 
; 3801 :     /* normalization */
; 3802 :     if (d->day == 0)

	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	jne	SHORT $LN9@xmlSchemaD

; 3803 :         d->day = 1;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -497				; fffffe0fH
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN9@xmlSchemaD:

; 3804 : 
; 3805 :     /* month */
; 3806 :     carry  = d->mon + u->mon;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 15					; 0000000fH
	mov	eax, DWORD PTR _u$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _carry$[ebp], edx

; 3807 :     r->mon = (unsigned int) MODULO_RANGE(carry, 1, 13);

	mov	ecx, DWORD PTR _carry$[ebp]
	sub	ecx, 1
	cvtsi2sd xmm0, ecx
	mov	edx, DWORD PTR _carry$[ebp]
	sub	edx, 1
	cvtsi2sd xmm1, edx
	divsd	xmm1, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR tv599[ebp], xmm1
	fld	QWORD PTR tv599[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	movsd	QWORD PTR tv934[ebp], xmm0
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv606[ebp]
	movsd	xmm0, QWORD PTR tv606[ebp]
	mulsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	xmm1, QWORD PTR tv934[ebp]
	subsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3ff0000000000000
	movaps	xmm0, xmm1
	call	__dtoui3
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -16				; fffffff0H
	or	edx, eax
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3808 :     carry  = (long) FQUOTIENT_RANGE(carry, 1, 13);

	mov	ecx, DWORD PTR _carry$[ebp]
	sub	ecx, 1
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR tv615[ebp], xmm0
	fld	QWORD PTR tv615[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse_excpt
	mov	DWORD PTR _carry$[ebp], eax

; 3809 : 
; 3810 :     /* year (may be modified later) */
; 3811 :     r->year = d->year + carry;

	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _carry$[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx], eax

; 3812 :     if (r->year == 0) {

	mov	edx, DWORD PTR _r$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN12@xmlSchemaD

; 3813 :         if (d->year > 0)

	mov	eax, DWORD PTR _d$[ebp]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN11@xmlSchemaD

; 3814 :             r->year--;

	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN12@xmlSchemaD
$LN11@xmlSchemaD:

; 3815 :         else
; 3816 :             r->year++;

	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax], edx
$LN12@xmlSchemaD:

; 3817 :     }
; 3818 : 
; 3819 :     /* time zone */
; 3820 :     r->tzo     = d->tzo;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	shl	edx, 19					; 00000013H
	sar	edx, 20					; 00000014H
	and	edx, 4095				; 00000fffH
	shl	edx, 1
	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -8191				; ffffe001H
	or	ecx, edx
	mov	edx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 3821 :     r->tz_flag = d->tz_flag;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 1
	and	ecx, 1
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+16]
	and	eax, -2					; fffffffeH
	or	eax, ecx
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 3822 : 
; 3823 :     /* seconds */
; 3824 :     r->sec = d->sec + u->sec;

	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR _u$[ebp]
	movsd	xmm0, QWORD PTR [edx+8]
	addsd	xmm0, QWORD PTR [eax+8]
	mov	ecx, DWORD PTR _r$[ebp]
	movsd	QWORD PTR [ecx+8], xmm0

; 3825 :     carry  = (long) FQUOTIENT((long)r->sec, 60);

	mov	edx, DWORD PTR _r$[ebp]
	cvttsd2si eax, QWORD PTR [edx+8]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR tv648[ebp], xmm0
	fld	QWORD PTR tv648[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse_excpt
	mov	DWORD PTR _carry$[ebp], eax

; 3826 :     if (r->sec != 0.0) {

	mov	ecx, DWORD PTR _r$[ebp]
	movsd	xmm0, QWORD PTR [ecx+8]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@xmlSchemaD

; 3827 :         r->sec = MODULO(r->sec, 60.0);

	mov	edx, DWORD PTR _r$[ebp]
	movsd	xmm0, QWORD PTR [edx+8]
	divsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR tv663[ebp], xmm0
	fld	QWORD PTR tv663[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv670[ebp]
	movsd	xmm0, QWORD PTR tv670[ebp]
	mulsd	xmm0, QWORD PTR __real@404e000000000000
	mov	eax, DWORD PTR _r$[ebp]
	movsd	xmm1, QWORD PTR [eax+8]
	subsd	xmm1, xmm0
	mov	ecx, DWORD PTR _r$[ebp]
	movsd	QWORD PTR [ecx+8], xmm1
$LN13@xmlSchemaD:

; 3828 :     }
; 3829 : 
; 3830 :     /* minute */
; 3831 :     carry += d->min;

	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 14					; 0000000eH
	and	eax, 63					; 0000003fH
	add	eax, DWORD PTR _carry$[ebp]
	mov	DWORD PTR _carry$[ebp], eax

; 3832 :     r->min = (unsigned int) MODULO(carry, 60);

	cvtsi2sd xmm0, DWORD PTR _carry$[ebp]
	cvtsi2sd xmm1, DWORD PTR _carry$[ebp]
	divsd	xmm1, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR tv677[ebp], xmm1
	fld	QWORD PTR tv677[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	movsd	QWORD PTR tv936[ebp], xmm0
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv684[ebp]
	movsd	xmm0, QWORD PTR tv684[ebp]
	mulsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	xmm1, QWORD PTR tv936[ebp]
	subsd	xmm1, xmm0
	movaps	xmm0, xmm1
	call	__dtoui3
	and	eax, 63					; 0000003fH
	shl	eax, 14					; 0000000eH
	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -1032193				; fff03fffH
	or	edx, eax
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3833 :     carry  = (long) FQUOTIENT(carry, 60);

	cvtsi2sd xmm0, DWORD PTR _carry$[ebp]
	divsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR tv692[ebp], xmm0
	fld	QWORD PTR tv692[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse_excpt
	mov	DWORD PTR _carry$[ebp], eax

; 3834 : 
; 3835 :     /* hours */
; 3836 :     carry  += d->hour;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 9
	and	edx, 31					; 0000001fH
	add	edx, DWORD PTR _carry$[ebp]
	mov	DWORD PTR _carry$[ebp], edx

; 3837 :     r->hour = (unsigned int) MODULO(carry, 24);

	cvtsi2sd xmm0, DWORD PTR _carry$[ebp]
	cvtsi2sd xmm1, DWORD PTR _carry$[ebp]
	divsd	xmm1, QWORD PTR __real@4038000000000000
	movsd	QWORD PTR tv703[ebp], xmm1
	fld	QWORD PTR tv703[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	movsd	QWORD PTR tv938[ebp], xmm0
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv710[ebp]
	movsd	xmm0, QWORD PTR tv710[ebp]
	mulsd	xmm0, QWORD PTR __real@4038000000000000
	movsd	xmm1, QWORD PTR tv938[ebp]
	subsd	xmm1, xmm0
	movaps	xmm0, xmm1
	call	__dtoui3
	and	eax, 31					; 0000001fH
	shl	eax, 9
	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -15873				; ffffc1ffH
	or	edx, eax
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3838 :     carry   = (long)FQUOTIENT(carry, 24);

	cvtsi2sd xmm0, DWORD PTR _carry$[ebp]
	divsd	xmm0, QWORD PTR __real@4038000000000000
	movsd	QWORD PTR tv718[ebp], xmm0
	fld	QWORD PTR tv718[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse_excpt
	mov	DWORD PTR _carry$[ebp], eax

; 3839 : 
; 3840 :     /*
; 3841 :      * days
; 3842 :      * Note we use tempdays because the temporary values may need more
; 3843 :      * than 5 bits
; 3844 :      */
; 3845 :     if ((VALID_YEAR(r->year)) && (VALID_MONTH(r->mon)) &&

	mov	ecx, DWORD PTR _r$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$LN14@xmlSchemaD
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 15					; 0000000fH
	cmp	eax, 1
	jb	$LN14@xmlSchemaD
	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 15					; 0000000fH
	cmp	edx, 12					; 0000000cH
	ja	$LN14@xmlSchemaD
	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN52@xmlSchemaD
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN52@xmlSchemaD:
	test	ecx, ecx
	jne	SHORT $LN37@xmlSchemaD
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN38@xmlSchemaD
$LN37@xmlSchemaD:
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN38@xmlSchemaD
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _daysInMonth[eax*4-4]
	mov	DWORD PTR tv312[ebp], ecx
	jmp	SHORT $LN39@xmlSchemaD
$LN38@xmlSchemaD:
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _daysInMonthLeap[eax*4-4]
	mov	DWORD PTR tv312[ebp], ecx
$LN39@xmlSchemaD:
	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	cmp	eax, DWORD PTR tv312[ebp]
	jbe	SHORT $LN14@xmlSchemaD

; 3846 :                   (d->day > MAX_DAYINMONTH(r->year, r->mon)))
; 3847 :         tempdays = MAX_DAYINMONTH(r->year, r->mon);

	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, -2147483645			; 80000003H
	jns	SHORT $LN53@xmlSchemaD
	dec	edx
	or	edx, -4					; fffffffcH
	inc	edx
$LN53@xmlSchemaD:
	test	edx, edx
	jne	SHORT $LN40@xmlSchemaD
	mov	eax, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN41@xmlSchemaD
$LN40@xmlSchemaD:
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN41@xmlSchemaD
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _daysInMonth[eax*4-4]
	mov	DWORD PTR tv333[ebp], ecx
	jmp	SHORT $LN42@xmlSchemaD
$LN41@xmlSchemaD:
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _daysInMonthLeap[eax*4-4]
	mov	DWORD PTR tv333[ebp], ecx
$LN42@xmlSchemaD:
	mov	edx, DWORD PTR tv333[ebp]
	mov	DWORD PTR _tempdays$[ebp], edx
	jmp	SHORT $LN17@xmlSchemaD
$LN14@xmlSchemaD:

; 3848 :     else if (d->day < 1)

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 4
	and	ecx, 31					; 0000001fH
	cmp	ecx, 1
	jae	SHORT $LN16@xmlSchemaD

; 3849 :         tempdays = 1;

	mov	DWORD PTR _tempdays$[ebp], 1
	jmp	SHORT $LN17@xmlSchemaD
$LN16@xmlSchemaD:

; 3850 :     else
; 3851 :         tempdays = d->day;

	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _tempdays$[ebp], eax
$LN17@xmlSchemaD:

; 3852 : 
; 3853 :     tempdays += u->day + carry;

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _carry$[ebp]
	add	edx, DWORD PTR _tempdays$[ebp]
	mov	DWORD PTR _tempdays$[ebp], edx
$LN2@xmlSchemaD:

; 3854 : 
; 3855 :     while (1) {

	mov	eax, 1
	test	eax, eax
	je	$LN3@xmlSchemaD

; 3856 :         if (tempdays < 1) {

	cmp	DWORD PTR _tempdays$[ebp], 1
	jge	$LN18@xmlSchemaD

; 3857 :             long tmon = (long) MODULO_RANGE((int)r->mon-1, 1, 13);

	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 15					; 0000000fH
	sub	edx, 2
	cvtsi2sd xmm0, edx
	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 15					; 0000000fH
	sub	ecx, 2
	cvtsi2sd xmm1, ecx
	divsd	xmm1, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR tv785[ebp], xmm1
	fld	QWORD PTR tv785[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	movsd	QWORD PTR tv940[ebp], xmm0
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv792[ebp]
	movsd	xmm0, QWORD PTR tv792[ebp]
	mulsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	xmm1, QWORD PTR tv940[ebp]
	subsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3ff0000000000000
	cvttsd2si edx, xmm1
	mov	DWORD PTR _tmon$2[ebp], edx

; 3858 :             long tyr  = r->year + (long)FQUOTIENT_RANGE((int)r->mon-1, 1, 13);

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 15					; 0000000fH
	sub	ecx, 2
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR tv796[ebp], xmm0
	fld	QWORD PTR tv796[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv803[ebp]
	movsd	xmm0, QWORD PTR tv803[ebp]
	cvttsd2si edx, xmm0
	mov	eax, DWORD PTR _r$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _tyr$1[ebp], edx

; 3859 :             if (tyr == 0)

	jne	SHORT $LN20@xmlSchemaD

; 3860 :                 tyr--;

	mov	ecx, DWORD PTR _tyr$1[ebp]
	sub	ecx, 1
	mov	DWORD PTR _tyr$1[ebp], ecx
$LN20@xmlSchemaD:

; 3861 : 	    /*
; 3862 : 	     * Coverity detected an overrun in daysInMonth
; 3863 : 	     * of size 12 at position 12 with index variable "((r)->mon - 1)"
; 3864 : 	     */
; 3865 : 	    if (tmon < 1)

	cmp	DWORD PTR _tmon$2[ebp], 1
	jge	SHORT $LN21@xmlSchemaD

; 3866 : 	        tmon = 1;

	mov	DWORD PTR _tmon$2[ebp], 1
$LN21@xmlSchemaD:

; 3867 : 	    if (tmon > 12)

	cmp	DWORD PTR _tmon$2[ebp], 12		; 0000000cH
	jle	SHORT $LN22@xmlSchemaD

; 3868 : 	        tmon = 12;

	mov	DWORD PTR _tmon$2[ebp], 12		; 0000000cH
$LN22@xmlSchemaD:

; 3869 :             tempdays += MAX_DAYINMONTH(tyr, tmon);

	mov	edx, DWORD PTR _tyr$1[ebp]
	and	edx, -2147483645			; 80000003H
	jns	SHORT $LN54@xmlSchemaD
	dec	edx
	or	edx, -4					; fffffffcH
	inc	edx
$LN54@xmlSchemaD:
	test	edx, edx
	jne	SHORT $LN43@xmlSchemaD
	mov	eax, DWORD PTR _tyr$1[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN44@xmlSchemaD
$LN43@xmlSchemaD:
	mov	eax, DWORD PTR _tyr$1[ebp]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN44@xmlSchemaD
	mov	edx, DWORD PTR _tmon$2[ebp]
	mov	eax, DWORD PTR _daysInMonth[edx*4-4]
	mov	DWORD PTR tv398[ebp], eax
	jmp	SHORT $LN45@xmlSchemaD
$LN44@xmlSchemaD:
	mov	ecx, DWORD PTR _tmon$2[ebp]
	mov	edx, DWORD PTR _daysInMonthLeap[ecx*4-4]
	mov	DWORD PTR tv398[ebp], edx
$LN45@xmlSchemaD:
	mov	eax, DWORD PTR _tempdays$[ebp]
	add	eax, DWORD PTR tv398[ebp]
	mov	DWORD PTR _tempdays$[ebp], eax

; 3870 :             carry = -1;

	mov	DWORD PTR _carry$[ebp], -1
	jmp	$LN24@xmlSchemaD
$LN18@xmlSchemaD:

; 3871 :         } else if (VALID_YEAR(r->year) && VALID_MONTH(r->mon) &&

	mov	ecx, DWORD PTR _r$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$LN23@xmlSchemaD
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 15					; 0000000fH
	cmp	eax, 1
	jb	$LN23@xmlSchemaD
	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 15					; 0000000fH
	cmp	edx, 12					; 0000000cH
	ja	$LN23@xmlSchemaD
	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN55@xmlSchemaD
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN55@xmlSchemaD:
	test	ecx, ecx
	jne	SHORT $LN46@xmlSchemaD
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN47@xmlSchemaD
$LN46@xmlSchemaD:
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN47@xmlSchemaD
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _daysInMonth[eax*4-4]
	mov	DWORD PTR tv427[ebp], ecx
	jmp	SHORT $LN48@xmlSchemaD
$LN47@xmlSchemaD:
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _daysInMonthLeap[eax*4-4]
	mov	DWORD PTR tv427[ebp], ecx
$LN48@xmlSchemaD:
	mov	edx, DWORD PTR _tempdays$[ebp]
	cmp	edx, DWORD PTR tv427[ebp]
	jle	SHORT $LN23@xmlSchemaD

; 3872 :                    tempdays > (long) MAX_DAYINMONTH(r->year, r->mon)) {
; 3873 :             tempdays = tempdays - MAX_DAYINMONTH(r->year, r->mon);

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN56@xmlSchemaD
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN56@xmlSchemaD:
	test	ecx, ecx
	jne	SHORT $LN49@xmlSchemaD
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN50@xmlSchemaD
$LN49@xmlSchemaD:
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN50@xmlSchemaD
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _daysInMonth[eax*4-4]
	mov	DWORD PTR tv448[ebp], ecx
	jmp	SHORT $LN51@xmlSchemaD
$LN50@xmlSchemaD:
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _daysInMonthLeap[eax*4-4]
	mov	DWORD PTR tv448[ebp], ecx
$LN51@xmlSchemaD:
	mov	edx, DWORD PTR _tempdays$[ebp]
	sub	edx, DWORD PTR tv448[ebp]
	mov	DWORD PTR _tempdays$[ebp], edx

; 3874 :             carry = 1;

	mov	DWORD PTR _carry$[ebp], 1

; 3875 :         } else

	jmp	SHORT $LN24@xmlSchemaD
$LN23@xmlSchemaD:

; 3876 :             break;

	jmp	$LN3@xmlSchemaD
$LN24@xmlSchemaD:

; 3877 : 
; 3878 :         temp = r->mon + carry;

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 15					; 0000000fH
	add	ecx, DWORD PTR _carry$[ebp]
	mov	DWORD PTR _temp$[ebp], ecx

; 3879 :         r->mon = (unsigned int) MODULO_RANGE(temp, 1, 13);

	mov	edx, DWORD PTR _temp$[ebp]
	sub	edx, 1
	cvtsi2sd xmm0, edx
	mov	eax, DWORD PTR _temp$[ebp]
	sub	eax, 1
	cvtsi2sd xmm1, eax
	divsd	xmm1, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR tv874[ebp], xmm1
	fld	QWORD PTR tv874[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	movsd	QWORD PTR tv942[ebp], xmm0
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv881[ebp]
	movsd	xmm0, QWORD PTR tv881[ebp]
	mulsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	xmm1, QWORD PTR tv942[ebp]
	subsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3ff0000000000000
	movaps	xmm0, xmm1
	call	__dtoui3
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -16				; fffffff0H
	or	edx, eax
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3880 :         r->year = r->year + (unsigned int) FQUOTIENT_RANGE(temp, 1, 13);

	mov	ecx, DWORD PTR _temp$[ebp]
	sub	ecx, 1
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR tv890[ebp], xmm0
	fld	QWORD PTR tv890[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv897[ebp]
	movsd	xmm0, QWORD PTR tv897[ebp]
	call	__dtoui3
	mov	edx, DWORD PTR _r$[ebp]
	add	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx], eax

; 3881 :         if (r->year == 0) {

	mov	edx, DWORD PTR _r$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN27@xmlSchemaD

; 3882 :             if (temp < 1)

	cmp	DWORD PTR _temp$[ebp], 1
	jge	SHORT $LN26@xmlSchemaD

; 3883 :                 r->year--;

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN27@xmlSchemaD
$LN26@xmlSchemaD:

; 3884 :             else
; 3885 :                 r->year++;

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx], ecx
$LN27@xmlSchemaD:

; 3886 : 	}
; 3887 :     }

	jmp	$LN2@xmlSchemaD
$LN3@xmlSchemaD:

; 3888 : 
; 3889 :     r->day = tempdays;

	mov	eax, DWORD PTR _tempdays$[ebp]
	and	eax, 31					; 0000001fH
	shl	eax, 4
	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -497				; fffffe0fH
	or	edx, eax
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3890 : 
; 3891 :     /*
; 3892 :      * adjust the date/time type to the date values
; 3893 :      */
; 3894 :     if (ret->type != XML_SCHEMAS_DATETIME) {

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [ecx], 11			; 0000000bH
	je	$LN35@xmlSchemaD

; 3895 :         if ((r->hour) || (r->min) || (r->sec))

	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 9
	and	eax, 31					; 0000001fH
	jne	SHORT $LN31@xmlSchemaD
	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 14					; 0000000eH
	and	edx, 63					; 0000003fH
	jne	SHORT $LN31@xmlSchemaD
	mov	eax, DWORD PTR _r$[ebp]
	movsd	xmm0, QWORD PTR [eax+8]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN29@xmlSchemaD
$LN31@xmlSchemaD:

; 3896 :             ret->type = XML_SCHEMAS_DATETIME;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], 11			; 0000000bH
	jmp	SHORT $LN35@xmlSchemaD
$LN29@xmlSchemaD:

; 3897 :         else if (ret->type != XML_SCHEMAS_DATE) {

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx], 10			; 0000000aH
	je	SHORT $LN35@xmlSchemaD

; 3898 :             if ((r->mon != 1) && (r->day != 1))

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 1
	je	SHORT $LN33@xmlSchemaD
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	cmp	eax, 1
	je	SHORT $LN33@xmlSchemaD

; 3899 :                 ret->type = XML_SCHEMAS_DATE;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], 10			; 0000000aH
	jmp	SHORT $LN35@xmlSchemaD
$LN33@xmlSchemaD:

; 3900 :             else if ((ret->type != XML_SCHEMAS_GYEARMONTH) && (r->mon != 1))

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx], 9
	je	SHORT $LN35@xmlSchemaD
	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 1
	je	SHORT $LN35@xmlSchemaD

; 3901 :                 ret->type = XML_SCHEMAS_GYEARMONTH;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx], 9
$LN35@xmlSchemaD:

; 3902 :         }
; 3903 :     }
; 3904 : 
; 3905 :     xmlSchemaFreeValue(tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 3906 : 
; 3907 :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSchemaD:

; 3908 : }

	pop	edi
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__xmlSchemaDateAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaDupVal
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_v$ = 8							; size = 4
_xmlSchemaDupVal PROC					; COMDAT

; 3670 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 3671 :     xmlSchemaValPtr ret = xmlSchemaNewValue(v->type);

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 3672 :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlSchemaD

; 3673 :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaD
$LN2@xmlSchemaD:

; 3674 : 
; 3675 :     memcpy(ret, v, sizeof(xmlSchemaVal));

	mov	ecx, 8
	mov	esi, DWORD PTR _v$[ebp]
	mov	edi, DWORD PTR _ret$[ebp]
	rep movsd

; 3676 :     ret->next = NULL;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+4], 0

; 3677 :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSchemaD:

; 3678 : }

	pop	edi
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaDupVal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareDurations
_TEXT	SEGMENT
_maxday$ = -44						; size = 4
_minday$ = -40						; size = 4
_myear$ = -36						; size = 4
_xday$ = -32						; size = 4
_xmon$ = -28						; size = 4
_invert$ = -24						; size = 4
_sec$ = -20						; size = 8
_day$ = -12						; size = 4
_mon$ = -8						; size = 4
_carry$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareDurations PROC				; COMDAT

; 3573 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 3574 :     long carry, mon, day;
; 3575 :     double sec;
; 3576 :     int invert = 1;

	mov	DWORD PTR _invert$[ebp], 1

; 3577 :     long xmon, xday, myear, minday, maxday;
; 3578 :     static const long dayRange [2][12] = {
; 3579 :         { 0, 28, 59, 89, 120, 150, 181, 212, 242, 273, 303, 334, },
; 3580 :         { 0, 31, 62, 92, 123, 153, 184, 215, 245, 276, 306, 337} };
; 3581 : 
; 3582 :     if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN2@xmlSchemaC
$LN3@xmlSchemaC:

; 3583 :         return -2;

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaC
$LN2@xmlSchemaC:

; 3584 : 
; 3585 :     /* months */
; 3586 :     mon = x->value.dur.mon - y->value.dur.mon;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _mon$[ebp], edx

; 3587 : 
; 3588 :     /* seconds */
; 3589 :     sec = x->value.dur.sec - y->value.dur.sec;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	movsd	xmm0, QWORD PTR [eax+16]
	subsd	xmm0, QWORD PTR [ecx+16]
	movsd	QWORD PTR _sec$[ebp], xmm0

; 3590 :     carry = (long)(sec / SECS_PER_DAY);

	movsd	xmm0, QWORD PTR _sec$[ebp]
	divsd	xmm0, QWORD PTR __real@40f5180000000000
	cvttsd2si edx, xmm0
	mov	DWORD PTR _carry$[ebp], edx

; 3591 :     sec -= ((double)carry) * SECS_PER_DAY;

	cvtsi2sd xmm0, DWORD PTR _carry$[ebp]
	mulsd	xmm0, QWORD PTR __real@40f5180000000000
	movsd	xmm1, QWORD PTR _sec$[ebp]
	subsd	xmm1, xmm0
	movsd	QWORD PTR _sec$[ebp], xmm1

; 3592 : 
; 3593 :     /* days */
; 3594 :     day = x->value.dur.day - y->value.dur.day + carry;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _carry$[ebp]
	mov	DWORD PTR _day$[ebp], edx

; 3595 : 
; 3596 :     /* easy test */
; 3597 :     if (mon == 0) {

	cmp	DWORD PTR _mon$[ebp], 0
	jne	SHORT $LN12@xmlSchemaC

; 3598 :         if (day == 0)

	cmp	DWORD PTR _day$[ebp], 0
	jne	SHORT $LN5@xmlSchemaC

; 3599 :             if (sec == 0.0)

	movsd	xmm0, QWORD PTR _sec$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@xmlSchemaC

; 3600 :                 return 0;

	xor	eax, eax
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN10@xmlSchemaC
$LN7@xmlSchemaC:

; 3601 :             else if (sec < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _sec$[ebp]
	jbe	SHORT $LN9@xmlSchemaC

; 3602 :                 return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN10@xmlSchemaC
$LN9@xmlSchemaC:

; 3603 :             else
; 3604 :                 return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN10@xmlSchemaC:
	jmp	SHORT $LN12@xmlSchemaC
$LN5@xmlSchemaC:

; 3605 :         else if (day < 0)

	cmp	DWORD PTR _day$[ebp], 0
	jge	SHORT $LN11@xmlSchemaC

; 3606 :             return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN12@xmlSchemaC
$LN11@xmlSchemaC:

; 3607 :         else
; 3608 :             return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN12@xmlSchemaC:

; 3609 :     }
; 3610 : 
; 3611 :     if (mon > 0) {

	cmp	DWORD PTR _mon$[ebp], 0
	jle	SHORT $LN13@xmlSchemaC

; 3612 :         if ((day >= 0) && (sec >= 0.0))

	cmp	DWORD PTR _day$[ebp], 0
	jl	SHORT $LN15@xmlSchemaC
	movsd	xmm0, QWORD PTR _sec$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN15@xmlSchemaC

; 3613 :             return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN16@xmlSchemaC
$LN15@xmlSchemaC:

; 3614 :         else {
; 3615 :             xmon = mon;

	mov	eax, DWORD PTR _mon$[ebp]
	mov	DWORD PTR _xmon$[ebp], eax

; 3616 :             xday = -day;

	mov	ecx, DWORD PTR _day$[ebp]
	neg	ecx
	mov	DWORD PTR _xday$[ebp], ecx
$LN16@xmlSchemaC:

; 3617 :         }

	jmp	SHORT $LN18@xmlSchemaC
$LN13@xmlSchemaC:

; 3618 :     } else if ((day <= 0) && (sec <= 0.0)) {

	cmp	DWORD PTR _day$[ebp], 0
	jg	SHORT $LN17@xmlSchemaC
	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _sec$[ebp]
	jb	SHORT $LN17@xmlSchemaC

; 3619 :         return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaC

; 3620 :     } else {

	jmp	SHORT $LN18@xmlSchemaC
$LN17@xmlSchemaC:

; 3621 : 	invert = -1;

	mov	DWORD PTR _invert$[ebp], -1

; 3622 :         xmon = -mon;

	mov	edx, DWORD PTR _mon$[ebp]
	neg	edx
	mov	DWORD PTR _xmon$[ebp], edx

; 3623 :         xday = day;

	mov	eax, DWORD PTR _day$[ebp]
	mov	DWORD PTR _xday$[ebp], eax
$LN18@xmlSchemaC:

; 3624 :     }
; 3625 : 
; 3626 :     myear = xmon / 12;

	mov	eax, DWORD PTR _xmon$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR _myear$[ebp], eax

; 3627 :     if (myear == 0) {

	cmp	DWORD PTR _myear$[ebp], 0
	jne	SHORT $LN19@xmlSchemaC

; 3628 : 	minday = 0;

	mov	DWORD PTR _minday$[ebp], 0

; 3629 : 	maxday = 0;

	mov	DWORD PTR _maxday$[ebp], 0

; 3630 :     } else {

	jmp	SHORT $LN20@xmlSchemaC
$LN19@xmlSchemaC:

; 3631 : 	maxday = 366 * ((myear + 3) / 4) +

	mov	eax, DWORD PTR _myear$[ebp]
	add	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	imul	edx, eax, 366
	mov	eax, DWORD PTR _myear$[ebp]
	sub	eax, 1
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN25@xmlSchemaC
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN25@xmlSchemaC:
	imul	ecx, eax, 365
	add	edx, ecx
	mov	DWORD PTR _maxday$[ebp], edx

; 3632 : 	         365 * ((myear - 1) % 4);
; 3633 : 	minday = maxday - 1;

	mov	edx, DWORD PTR _maxday$[ebp]
	sub	edx, 1
	mov	DWORD PTR _minday$[ebp], edx
$LN20@xmlSchemaC:

; 3634 :     }
; 3635 : 
; 3636 :     xmon = xmon % 12;

	mov	eax, DWORD PTR _xmon$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR _xmon$[ebp], edx

; 3637 :     minday += dayRange[0][xmon];

	mov	edx, 48					; 00000030H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _xmon$[ebp]
	mov	edx, DWORD PTR _minday$[ebp]
	add	edx, DWORD PTR ?dayRange@?1??xmlSchemaCompareDurations@@9@9[eax+ecx*4]
	mov	DWORD PTR _minday$[ebp], edx

; 3638 :     maxday += dayRange[1][xmon];

	mov	eax, 48					; 00000030H
	shl	eax, 0
	mov	ecx, DWORD PTR _xmon$[ebp]
	mov	edx, DWORD PTR _maxday$[ebp]
	add	edx, DWORD PTR ?dayRange@?1??xmlSchemaCompareDurations@@9@9[eax+ecx*4]
	mov	DWORD PTR _maxday$[ebp], edx

; 3639 : 
; 3640 :     if ((maxday == minday) && (maxday == xday))

	mov	eax, DWORD PTR _maxday$[ebp]
	cmp	eax, DWORD PTR _minday$[ebp]
	jne	SHORT $LN21@xmlSchemaC
	mov	ecx, DWORD PTR _maxday$[ebp]
	cmp	ecx, DWORD PTR _xday$[ebp]
	jne	SHORT $LN21@xmlSchemaC

; 3641 : 	return(0); /* can this really happen ? */

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaC
$LN21@xmlSchemaC:

; 3642 :     if (maxday < xday)

	mov	edx, DWORD PTR _maxday$[ebp]
	cmp	edx, DWORD PTR _xday$[ebp]
	jge	SHORT $LN22@xmlSchemaC

; 3643 :         return(-invert);

	mov	eax, DWORD PTR _invert$[ebp]
	neg	eax
	jmp	SHORT $LN1@xmlSchemaC
$LN22@xmlSchemaC:

; 3644 :     if (minday > xday)

	mov	eax, DWORD PTR _minday$[ebp]
	cmp	eax, DWORD PTR _xday$[ebp]
	jle	SHORT $LN23@xmlSchemaC

; 3645 :         return(invert);

	mov	eax, DWORD PTR _invert$[ebp]
	jmp	SHORT $LN1@xmlSchemaC
$LN23@xmlSchemaC:

; 3646 : 
; 3647 :     /* indeterminate */
; 3648 :     return 2;

	mov	eax, 2
$LN1@xmlSchemaC:

; 3649 : }

	pop	edi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCompareDurations ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareDecimals
_TEXT	SEGMENT
_rem2$1 = -40						; size = 4
_rem1$2 = -36						; size = 4
_lo$ = -32						; size = 4
_mi$ = -28						; size = 4
_hi$ = -24						; size = 4
_dlen$ = -20						; size = 4
_integy$ = -16						; size = 4
_integx$ = -12						; size = 4
_order$ = -8						; size = 4
_swp$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareDecimals PROC				; COMDAT

; 3425 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 3426 :     xmlSchemaValPtr swp;
; 3427 :     int order = 1, integx, integy, dlen;

	mov	DWORD PTR _order$[ebp], 1

; 3428 :     unsigned long hi, mi, lo;
; 3429 : 
; 3430 :     /*
; 3431 :      * First test: If x is -ve and not zero
; 3432 :      */
; 3433 :     if ((x->value.decimal.sign) &&

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 1
	je	SHORT $LN6@xmlSchemaC
	mov	edx, DWORD PTR _x$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN8@xmlSchemaC
	mov	eax, DWORD PTR _x$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN8@xmlSchemaC
	mov	ecx, DWORD PTR _x$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN6@xmlSchemaC
$LN8@xmlSchemaC:

; 3434 : 	((x->value.decimal.lo != 0) ||
; 3435 : 	 (x->value.decimal.mi != 0) ||
; 3436 : 	 (x->value.decimal.hi != 0))) {
; 3437 : 	/*
; 3438 : 	 * Then if y is -ve and not zero reverse the compare
; 3439 : 	 */
; 3440 : 	if ((y->value.decimal.sign) &&

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 1
	je	SHORT $LN9@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN11@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN11@xmlSchemaC
	mov	eax, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN9@xmlSchemaC
$LN11@xmlSchemaC:

; 3441 : 	    ((y->value.decimal.lo != 0) ||
; 3442 : 	     (y->value.decimal.mi != 0) ||
; 3443 : 	     (y->value.decimal.hi != 0)))
; 3444 : 	    order = -1;

	mov	DWORD PTR _order$[ebp], -1
	jmp	SHORT $LN10@xmlSchemaC
$LN9@xmlSchemaC:

; 3445 : 	/*
; 3446 : 	 * Otherwise (y >= 0) we have the answer
; 3447 : 	 */
; 3448 : 	else
; 3449 : 	    return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaC
$LN10@xmlSchemaC:

; 3450 :     /*
; 3451 :      * If x is not -ve and y is -ve we have the answer
; 3452 :      */
; 3453 :     } else if ((y->value.decimal.sign) &&

	jmp	SHORT $LN7@xmlSchemaC
$LN6@xmlSchemaC:
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, 1
	je	SHORT $LN7@xmlSchemaC
	mov	eax, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN13@xmlSchemaC
	mov	ecx, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN13@xmlSchemaC
	mov	edx, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN7@xmlSchemaC
$LN13@xmlSchemaC:

; 3454 : 	       ((y->value.decimal.lo != 0) ||
; 3455 : 		(y->value.decimal.mi != 0) ||
; 3456 : 		(y->value.decimal.hi != 0))) {
; 3457 :         return (1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaC
$LN7@xmlSchemaC:

; 3458 :     }
; 3459 :     /*
; 3460 :      * If it's not simply determined by a difference in sign,
; 3461 :      * then we need to compare the actual values of the two nums.
; 3462 :      * To do this, we start by looking at the integral parts.
; 3463 :      * If the number of integral digits differ, then we have our
; 3464 :      * answer.
; 3465 :      */
; 3466 :     integx = x->value.decimal.total - x->value.decimal.frac;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 1
	and	eax, 127				; 0000007fH
	sub	ecx, eax
	mov	DWORD PTR _integx$[ebp], ecx

; 3467 :     integy = y->value.decimal.total - y->value.decimal.frac;

	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	shr	edx, 8
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shr	ecx, 1
	and	ecx, 127				; 0000007fH
	sub	edx, ecx
	mov	DWORD PTR _integy$[ebp], edx

; 3468 :     /*
; 3469 :     * NOTE: We changed the "total" for values like "0.1"
; 3470 :     *   (or "-0.1" or ".1") to be 1, which was 2 previously.
; 3471 :     *   Therefore the special case, when such values are
; 3472 :     *   compared with 0, needs to be handled separately;
; 3473 :     *   otherwise a zero would be recognized incorrectly as
; 3474 :     *   greater than those values. This has the nice side effect
; 3475 :     *   that we gain an overall optimized comparison with zeroes.
; 3476 :     * Note that a "0" has a "total" of 1 already.
; 3477 :     */
; 3478 :     if (integx == 1) {

	cmp	DWORD PTR _integx$[ebp], 1
	jne	SHORT $LN14@xmlSchemaC

; 3479 : 	if (x->value.decimal.lo == 0) {

	mov	edx, DWORD PTR _x$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN14@xmlSchemaC

; 3480 : 	    if (integy != 1)

	cmp	DWORD PTR _integy$[ebp], 1
	je	SHORT $LN16@xmlSchemaC

; 3481 : 		return -order;

	mov	eax, DWORD PTR _order$[ebp]
	neg	eax
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN14@xmlSchemaC
$LN16@xmlSchemaC:

; 3482 : 	    else if (y->value.decimal.lo != 0)

	mov	eax, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN18@xmlSchemaC

; 3483 : 		return -order;

	mov	eax, DWORD PTR _order$[ebp]
	neg	eax
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN14@xmlSchemaC
$LN18@xmlSchemaC:

; 3484 : 	    else
; 3485 : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaC
$LN14@xmlSchemaC:

; 3486 : 	}
; 3487 :     }
; 3488 :     if (integy == 1) {

	cmp	DWORD PTR _integy$[ebp], 1
	jne	SHORT $LN20@xmlSchemaC

; 3489 : 	if (y->value.decimal.lo == 0) {

	mov	ecx, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN20@xmlSchemaC

; 3490 : 	    if (integx != 1)

	cmp	DWORD PTR _integx$[ebp], 1
	je	SHORT $LN22@xmlSchemaC

; 3491 : 		return order;

	mov	eax, DWORD PTR _order$[ebp]
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN20@xmlSchemaC
$LN22@xmlSchemaC:

; 3492 : 	    else if (x->value.decimal.lo != 0)

	mov	edx, DWORD PTR _x$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN24@xmlSchemaC

; 3493 : 		return order;

	mov	eax, DWORD PTR _order$[ebp]
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN20@xmlSchemaC
$LN24@xmlSchemaC:

; 3494 : 	    else
; 3495 : 		return(0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaC
$LN20@xmlSchemaC:

; 3496 : 	}
; 3497 :     }
; 3498 : 
; 3499 :     if (integx > integy)

	mov	eax, DWORD PTR _integx$[ebp]
	cmp	eax, DWORD PTR _integy$[ebp]
	jle	SHORT $LN26@xmlSchemaC

; 3500 : 	return order;

	mov	eax, DWORD PTR _order$[ebp]
	jmp	$LN1@xmlSchemaC
	jmp	SHORT $LN27@xmlSchemaC
$LN26@xmlSchemaC:

; 3501 :     else if (integy > integx)

	mov	ecx, DWORD PTR _integy$[ebp]
	cmp	ecx, DWORD PTR _integx$[ebp]
	jle	SHORT $LN27@xmlSchemaC

; 3502 : 	return -order;

	mov	eax, DWORD PTR _order$[ebp]
	neg	eax
	jmp	$LN1@xmlSchemaC
$LN27@xmlSchemaC:

; 3503 : 
; 3504 :     /*
; 3505 :      * If the number of integral digits is the same for both numbers,
; 3506 :      * then things get a little more complicated.  We need to "normalize"
; 3507 :      * the numbers in order to properly compare them.  To do this, we
; 3508 :      * look at the total length of each number (length => number of
; 3509 :      * significant digits), and divide the "shorter" by 10 (decreasing
; 3510 :      * the length) until they are of equal length.
; 3511 :      */
; 3512 :     dlen = x->value.decimal.total - y->value.decimal.total;

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	shr	edx, 8
	and	edx, 255				; 000000ffH
	sub	eax, edx
	mov	DWORD PTR _dlen$[ebp], eax

; 3513 :     if (dlen < 0) {	/* y has more digits than x */

	jns	SHORT $LN29@xmlSchemaC

; 3514 : 	swp = x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _swp$[ebp], eax

; 3515 : 	hi = y->value.decimal.hi;

	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _hi$[ebp], edx

; 3516 : 	mi = y->value.decimal.mi;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _mi$[ebp], ecx

; 3517 : 	lo = y->value.decimal.lo;

	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _lo$[ebp], eax

; 3518 : 	dlen = -dlen;

	mov	ecx, DWORD PTR _dlen$[ebp]
	neg	ecx
	mov	DWORD PTR _dlen$[ebp], ecx

; 3519 : 	order = -order;

	mov	edx, DWORD PTR _order$[ebp]
	neg	edx
	mov	DWORD PTR _order$[ebp], edx

; 3520 :     } else {		/* x has more digits than y */

	jmp	SHORT $LN2@xmlSchemaC
$LN29@xmlSchemaC:

; 3521 : 	swp = y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _swp$[ebp], eax

; 3522 : 	hi = x->value.decimal.hi;

	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _hi$[ebp], edx

; 3523 : 	mi = x->value.decimal.mi;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _mi$[ebp], ecx

; 3524 : 	lo = x->value.decimal.lo;

	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _lo$[ebp], eax
$LN2@xmlSchemaC:

; 3525 :     }
; 3526 :     while (dlen > 8) {	/* in effect, right shift by 10**8 */

	cmp	DWORD PTR _dlen$[ebp], 8
	jle	SHORT $LN4@xmlSchemaC

; 3527 : 	lo = mi;

	mov	ecx, DWORD PTR _mi$[ebp]
	mov	DWORD PTR _lo$[ebp], ecx

; 3528 : 	mi = hi;

	mov	edx, DWORD PTR _hi$[ebp]
	mov	DWORD PTR _mi$[ebp], edx

; 3529 : 	hi = 0;

	mov	DWORD PTR _hi$[ebp], 0

; 3530 : 	dlen -= 8;

	mov	eax, DWORD PTR _dlen$[ebp]
	sub	eax, 8
	mov	DWORD PTR _dlen$[ebp], eax

; 3531 :     }

	jmp	SHORT $LN2@xmlSchemaC
$LN4@xmlSchemaC:

; 3532 :     while (dlen > 0) {

	cmp	DWORD PTR _dlen$[ebp], 0
	jle	SHORT $LN5@xmlSchemaC

; 3533 : 	unsigned long rem1, rem2;
; 3534 : 	rem1 = (hi % 10) * 100000000L;

	mov	eax, DWORD PTR _hi$[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	imul	edx, edx, 100000000
	mov	DWORD PTR _rem1$2[ebp], edx

; 3535 : 	hi = hi / 10;

	mov	eax, DWORD PTR _hi$[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	DWORD PTR _hi$[ebp], eax

; 3536 : 	rem2 = (mi % 10) * 100000000L;

	mov	eax, DWORD PTR _mi$[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	imul	edx, edx, 100000000
	mov	DWORD PTR _rem2$1[ebp], edx

; 3537 : 	mi = (mi + rem1) / 10;

	mov	eax, DWORD PTR _mi$[ebp]
	add	eax, DWORD PTR _rem1$2[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	DWORD PTR _mi$[ebp], eax

; 3538 : 	lo = (lo + rem2) / 10;

	mov	eax, DWORD PTR _lo$[ebp]
	add	eax, DWORD PTR _rem2$1[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	DWORD PTR _lo$[ebp], eax

; 3539 : 	dlen--;

	mov	edx, DWORD PTR _dlen$[ebp]
	sub	edx, 1
	mov	DWORD PTR _dlen$[ebp], edx

; 3540 :     }

	jmp	SHORT $LN4@xmlSchemaC
$LN5@xmlSchemaC:

; 3541 :     if (hi > swp->value.decimal.hi) {

	mov	eax, DWORD PTR _swp$[ebp]
	mov	ecx, DWORD PTR _hi$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jbe	SHORT $LN31@xmlSchemaC

; 3542 : 	return order;

	mov	eax, DWORD PTR _order$[ebp]
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN32@xmlSchemaC
$LN31@xmlSchemaC:

; 3543 :     } else if (hi == swp->value.decimal.hi) {

	mov	edx, DWORD PTR _swp$[ebp]
	mov	eax, DWORD PTR _hi$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jne	SHORT $LN32@xmlSchemaC

; 3544 : 	if (mi > swp->value.decimal.mi) {

	mov	ecx, DWORD PTR _swp$[ebp]
	mov	edx, DWORD PTR _mi$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jbe	SHORT $LN34@xmlSchemaC

; 3545 : 	    return order;

	mov	eax, DWORD PTR _order$[ebp]
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN32@xmlSchemaC
$LN34@xmlSchemaC:

; 3546 : 	} else if (mi == swp->value.decimal.mi) {

	mov	eax, DWORD PTR _swp$[ebp]
	mov	ecx, DWORD PTR _mi$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jne	SHORT $LN32@xmlSchemaC

; 3547 : 	    if (lo > swp->value.decimal.lo) {

	mov	edx, DWORD PTR _swp$[ebp]
	mov	eax, DWORD PTR _lo$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jbe	SHORT $LN37@xmlSchemaC

; 3548 : 		return order;

	mov	eax, DWORD PTR _order$[ebp]
	jmp	SHORT $LN1@xmlSchemaC
	jmp	SHORT $LN32@xmlSchemaC
$LN37@xmlSchemaC:

; 3549 : 	    } else if (lo == swp->value.decimal.lo) {

	mov	ecx, DWORD PTR _swp$[ebp]
	mov	edx, DWORD PTR _lo$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN32@xmlSchemaC

; 3550 : 		if (x->value.decimal.total == y->value.decimal.total) {

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	cmp	ecx, eax
	jne	SHORT $LN40@xmlSchemaC

; 3551 : 		    return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaC

; 3552 : 		} else {

	jmp	SHORT $LN32@xmlSchemaC
$LN40@xmlSchemaC:

; 3553 : 		    return order;

	mov	eax, DWORD PTR _order$[ebp]
	jmp	SHORT $LN1@xmlSchemaC
$LN32@xmlSchemaC:

; 3554 : 		}
; 3555 : 	    }
; 3556 : 	}
; 3557 :     }
; 3558 :     return -order;

	mov	eax, DWORD PTR _order$[ebp]
	neg	eax
$LN1@xmlSchemaC:

; 3559 : }

	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCompareDecimals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValAtomicType
_TEXT	SEGMENT
tv1056 = -496						; size = 4
tv1055 = -492						; size = 4
tv526 = -488						; size = 4
tv525 = -484						; size = 4
tv520 = -480						; size = 4
tv519 = -476						; size = 4
tv514 = -472						; size = 4
tv513 = -468						; size = 4
tv508 = -464						; size = 4
tv507 = -460						; size = 4
tv499 = -456						; size = 4
tv498 = -452						; size = 4
tv493 = -448						; size = 4
tv492 = -444						; size = 4
tv487 = -440						; size = 4
tv486 = -436						; size = 4
tv84 = -432						; size = 4
_hi$1 = -424						; size = 4
_mi$2 = -412						; size = 4
_lo$3 = -400						; size = 4
_cur$4 = -388						; size = 4
_sign$5 = -380						; size = 4
_hi$6 = -372						; size = 4
_mi$7 = -360						; size = 4
_lo$8 = -348						; size = 4
_cur$9 = -336						; size = 4
_sign$10 = -328						; size = 4
_hi$11 = -320						; size = 4
_mi$12 = -308						; size = 4
_lo$13 = -296						; size = 4
_cur$14 = -284						; size = 4
_decc$15 = -276						; size = 4
_decc$16 = -272						; size = 4
_decc$17 = -268						; size = 4
_decc$18 = -264						; size = 4
_pad$19 = -260						; size = 4
_i$20 = -256						; size = 4
_total$21 = -252					; size = 4
_base$22 = -248						; size = 4
_cur$23 = -244						; size = 4
_i$24 = -240						; size = 4
_total$25 = -236					; size = 4
_base$26 = -232						; size = 4
_start$27 = -228					; size = 4
_cur$28 = -224						; size = 4
_cur$29 = -220						; size = 4
_tmpval$30 = -216					; size = 4
_uri$31 = -212						; size = 4
_ns$32 = -208						; size = 4
_prefix$33 = -200					; size = 4
_local$34 = -192					; size = 4
_uri$35 = -188						; size = 4
_attr$36 = -184						; size = 4
_attr$37 = -180						; size = 4
_ent$38 = -176						; size = 4
_strip$39 = -172					; size = 4
_attr$40 = -168						; size = 4
_strip$41 = -164					; size = 4
_attr$42 = -160						; size = 4
_strip$43 = -156					; size = 4
_res$44 = -152						; size = 4
_attr$45 = -148						; size = 4
_ns$46 = -144						; size = 4
_prefix$47 = -136					; size = 4
_local$48 = -128					; size = 4
_uri$49 = -124						; size = 4
_end$50 = -120						; size = 4
_start$51 = -116					; size = 4
_cur$52 = -112						; size = 4
_cur$53 = -108						; size = 4
_digits_after$54 = -104					; size = 4
_digits_before$55 = -100				; size = 4
_neg$56 = -96						; size = 4
_cur$57 = -92						; size = 4
_cptr$58 = -84						; size = 4
_cval$59 = -72						; size = 25
_hasLeadingZeroes$60 = -40				; size = 4
_integ$61 = -36						; size = 4
_neg$62 = -32						; size = 4
_len$63 = -28						; size = 4
_cur$64 = -24						; size = 4
_cur$65 = -20						; size = 4
_cur$66 = -16						; size = 4
_ret$ = -12						; size = 4
_norm$ = -8						; size = 4
_v$ = -4						; size = 4
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_val$ = 16						; size = 4
_node$ = 20						; size = 4
_flags$ = 24						; size = 4
_ws$ = 28						; size = 4
_normOnTheFly$ = 32					; size = 4
_applyNorm$ = 36					; size = 4
_createStringValue$ = 40				; size = 4
_xmlSchemaValAtomicType PROC				; COMDAT

; 2147 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 496				; 000001f0H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-496]
	mov	ecx, 124				; 0000007cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 2148 :     xmlSchemaValPtr v;
; 2149 :     xmlChar *norm = NULL;

	mov	DWORD PTR _norm$[ebp], 0

; 2150 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2151 : 
; 2152 :     if (xmlSchemaTypesInitialized == 0)

	cmp	DWORD PTR _xmlSchemaTypesInitialized, 0
	jne	SHORT $LN74@xmlSchemaV

; 2153 :         xmlSchemaInitTypes();

	call	_xmlSchemaInitTypes
$LN74@xmlSchemaV:

; 2154 :     if (type == NULL)

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN75@xmlSchemaV

; 2155 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN75@xmlSchemaV:

; 2156 : 
; 2157 :     /*
; 2158 :      * validating a non existant text node is similar to validating
; 2159 :      * an empty one.
; 2160 :      */
; 2161 :     if (value == NULL)

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN76@xmlSchemaV

; 2162 :         value = BAD_CAST "";

	mov	DWORD PTR _value$[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN76@xmlSchemaV:

; 2163 : 
; 2164 :     if (val != NULL)

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN77@xmlSchemaV

; 2165 :         *val = NULL;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], 0
$LN77@xmlSchemaV:

; 2166 :     if ((flags == 0) && (value != NULL)) {

	cmp	DWORD PTR _flags$[ebp], 0
	jne	SHORT $LN82@xmlSchemaV
	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN82@xmlSchemaV

; 2167 : 
; 2168 :         if ((type->builtInType != XML_SCHEMAS_STRING) &&
; 2169 : 	  (type->builtInType != XML_SCHEMAS_ANYTYPE) &&

	mov	ecx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [ecx+88], 1
	je	SHORT $LN82@xmlSchemaV
	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [edx+88], 45			; 0000002dH
	je	SHORT $LN82@xmlSchemaV
	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+88], 46			; 0000002eH
	je	SHORT $LN82@xmlSchemaV

; 2170 : 	  (type->builtInType != XML_SCHEMAS_ANYSIMPLETYPE)) {
; 2171 : 	    if (type->builtInType == XML_SCHEMAS_NORMSTRING)

	mov	ecx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [ecx+88], 2
	jne	SHORT $LN80@xmlSchemaV

; 2172 : 		norm = xmlSchemaWhiteSpaceReplace(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlSchemaWhiteSpaceReplace
	add	esp, 4
	mov	DWORD PTR _norm$[ebp], eax
	jmp	SHORT $LN81@xmlSchemaV
$LN80@xmlSchemaV:

; 2173 :             else
; 2174 : 		norm = xmlSchemaCollapseString(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	DWORD PTR _norm$[ebp], eax
$LN81@xmlSchemaV:

; 2175 :             if (norm != NULL)

	cmp	DWORD PTR _norm$[ebp], 0
	je	SHORT $LN82@xmlSchemaV

; 2176 :                 value = norm;

	mov	ecx, DWORD PTR _norm$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN82@xmlSchemaV:

; 2177 :         }
; 2178 :     }
; 2179 : 
; 2180 :     switch (type->builtInType) {

	mov	edx, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR tv84[ebp], eax
	cmp	DWORD PTR tv84[ebp], 46			; 0000002eH
	ja	$done$543
	mov	ecx, DWORD PTR tv84[ebp]
	movzx	edx, BYTE PTR $LN519@xmlSchemaV[ecx]
	jmp	DWORD PTR $LN542@xmlSchemaV[edx*4]
$LN83@xmlSchemaV:

; 2181 :         case XML_SCHEMAS_UNKNOWN:
; 2182 :             goto error;

	jmp	$error$544
$LN84@xmlSchemaV:

; 2183 : 	case XML_SCHEMAS_ANYTYPE:
; 2184 : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 2185 : 	    if ((createStringValue) && (val != NULL)) {

	cmp	DWORD PTR _createStringValue$[ebp], 0
	je	SHORT $LN87@xmlSchemaV
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN87@xmlSchemaV

; 2186 : 		v = xmlSchemaNewValue(XML_SCHEMAS_ANYSIMPLETYPE);

	push	46					; 0000002eH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2187 : 		if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN86@xmlSchemaV

; 2188 : 		    v->value.str = xmlStrdup(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2189 : 		    *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax

; 2190 : 		} else {

	jmp	SHORT $LN87@xmlSchemaV
$LN86@xmlSchemaV:

; 2191 : 		    goto error;

	jmp	$error$544
$LN87@xmlSchemaV:

; 2192 : 		}
; 2193 : 	    }
; 2194 : 	    goto return0;

	jmp	$return0$545
$LN88@xmlSchemaV:

; 2195 :         case XML_SCHEMAS_STRING:
; 2196 : 	    if (! normOnTheFly) {

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	jne	$LN7@xmlSchemaV

; 2197 : 		const xmlChar *cur = value;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$66[ebp], ecx

; 2198 : 
; 2199 : 		if (ws == XML_SCHEMA_WHITESPACE_REPLACE) {

	cmp	DWORD PTR _ws$[ebp], 2
	jne	SHORT $LN90@xmlSchemaV
$LN4@xmlSchemaV:

; 2200 : 		    while (*cur != 0) {

	mov	edx, DWORD PTR _cur$66[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN5@xmlSchemaV

; 2201 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {

	mov	ecx, DWORD PTR _cur$66[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN94@xmlSchemaV
	mov	eax, DWORD PTR _cur$66[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN94@xmlSchemaV
	mov	edx, DWORD PTR _cur$66[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jne	SHORT $LN92@xmlSchemaV
$LN94@xmlSchemaV:

; 2202 : 			    goto return1;

	jmp	$return1$546

; 2203 : 			} else {

	jmp	SHORT $LN93@xmlSchemaV
$LN92@xmlSchemaV:

; 2204 : 			    cur++;

	mov	ecx, DWORD PTR _cur$66[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$66[ebp], ecx
$LN93@xmlSchemaV:

; 2205 : 			}
; 2206 : 		    }

	jmp	SHORT $LN4@xmlSchemaV
$LN5@xmlSchemaV:

; 2207 : 		} else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE) {

	jmp	SHORT $LN7@xmlSchemaV
$LN90@xmlSchemaV:
	cmp	DWORD PTR _ws$[ebp], 3
	jne	SHORT $LN7@xmlSchemaV
$LN6@xmlSchemaV:

; 2208 : 		    while (*cur != 0) {

	mov	edx, DWORD PTR _cur$66[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN7@xmlSchemaV

; 2209 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {

	mov	ecx, DWORD PTR _cur$66[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN98@xmlSchemaV
	mov	eax, DWORD PTR _cur$66[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN98@xmlSchemaV
	mov	edx, DWORD PTR _cur$66[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jne	SHORT $LN96@xmlSchemaV
$LN98@xmlSchemaV:

; 2210 : 			    goto return1;

	jmp	$return1$546
	jmp	SHORT $LN100@xmlSchemaV
$LN96@xmlSchemaV:

; 2211 : 			} else if IS_WSP_SPACE_CH(*cur) {

	mov	ecx, DWORD PTR _cur$66[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN99@xmlSchemaV

; 2212 : 			    cur++;

	mov	eax, DWORD PTR _cur$66[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$66[ebp], eax

; 2213 : 			    if IS_WSP_SPACE_CH(*cur)

	mov	ecx, DWORD PTR _cur$66[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN101@xmlSchemaV

; 2214 : 				goto return1;

	jmp	$return1$546
$LN101@xmlSchemaV:

; 2215 : 			} else {

	jmp	SHORT $LN100@xmlSchemaV
$LN99@xmlSchemaV:

; 2216 : 			    cur++;

	mov	eax, DWORD PTR _cur$66[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$66[ebp], eax
$LN100@xmlSchemaV:

; 2217 : 			}
; 2218 : 		    }

	jmp	SHORT $LN6@xmlSchemaV
$LN7@xmlSchemaV:

; 2219 : 		}
; 2220 : 	    }
; 2221 : 	    if (createStringValue && (val != NULL)) {

	cmp	DWORD PTR _createStringValue$[ebp], 0
	je	SHORT $LN109@xmlSchemaV
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN109@xmlSchemaV

; 2222 : 		if (applyNorm) {

	cmp	DWORD PTR _applyNorm$[ebp], 0
	je	SHORT $LN107@xmlSchemaV

; 2223 : 		    if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	DWORD PTR _ws$[ebp], 3
	jne	SHORT $LN104@xmlSchemaV

; 2224 : 			norm = xmlSchemaCollapseString(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	DWORD PTR _norm$[ebp], eax
	jmp	SHORT $LN106@xmlSchemaV
$LN104@xmlSchemaV:

; 2225 : 		    else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)

	cmp	DWORD PTR _ws$[ebp], 2
	jne	SHORT $LN106@xmlSchemaV

; 2226 : 			norm = xmlSchemaWhiteSpaceReplace(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlSchemaWhiteSpaceReplace
	add	esp, 4
	mov	DWORD PTR _norm$[ebp], eax
$LN106@xmlSchemaV:

; 2227 : 		    if (norm != NULL)

	cmp	DWORD PTR _norm$[ebp], 0
	je	SHORT $LN107@xmlSchemaV

; 2228 : 			value = norm;

	mov	eax, DWORD PTR _norm$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN107@xmlSchemaV:

; 2229 : 		}
; 2230 : 		v = xmlSchemaNewValue(XML_SCHEMAS_STRING);

	push	1
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2231 : 		if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN108@xmlSchemaV

; 2232 : 		    v->value.str = xmlStrdup(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+8], eax

; 2233 : 		    *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax], ecx

; 2234 : 		} else {

	jmp	SHORT $LN109@xmlSchemaV
$LN108@xmlSchemaV:

; 2235 : 		    goto error;

	jmp	$error$544
$LN109@xmlSchemaV:

; 2236 : 		}
; 2237 : 	    }
; 2238 :             goto return0;

	jmp	$return0$545
$LN110@xmlSchemaV:

; 2239 :         case XML_SCHEMAS_NORMSTRING:{
; 2240 : 		if (normOnTheFly) {

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN111@xmlSchemaV

; 2241 : 		    if (applyNorm) {

	cmp	DWORD PTR _applyNorm$[ebp], 0
	je	SHORT $LN116@xmlSchemaV

; 2242 : 			if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	DWORD PTR _ws$[ebp], 3
	jne	SHORT $LN114@xmlSchemaV

; 2243 : 			    norm = xmlSchemaCollapseString(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	DWORD PTR _norm$[ebp], eax
	jmp	SHORT $LN115@xmlSchemaV
$LN114@xmlSchemaV:

; 2244 : 			else
; 2245 : 			    norm = xmlSchemaWhiteSpaceReplace(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlSchemaWhiteSpaceReplace
	add	esp, 4
	mov	DWORD PTR _norm$[ebp], eax
$LN115@xmlSchemaV:

; 2246 : 			if (norm != NULL)

	cmp	DWORD PTR _norm$[ebp], 0
	je	SHORT $LN116@xmlSchemaV

; 2247 : 			    value = norm;

	mov	ecx, DWORD PTR _norm$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN116@xmlSchemaV:

; 2248 : 		    }
; 2249 : 		} else {

	jmp	SHORT $LN9@xmlSchemaV
$LN111@xmlSchemaV:

; 2250 : 		    const xmlChar *cur = value;

	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$65[ebp], edx
$LN8@xmlSchemaV:

; 2251 : 		    while (*cur != 0) {

	mov	eax, DWORD PTR _cur$65[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN9@xmlSchemaV

; 2252 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {

	mov	edx, DWORD PTR _cur$65[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN119@xmlSchemaV
	mov	ecx, DWORD PTR _cur$65[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN119@xmlSchemaV
	mov	eax, DWORD PTR _cur$65[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jne	SHORT $LN117@xmlSchemaV
$LN119@xmlSchemaV:

; 2253 : 			    goto return1;

	jmp	$return1$546

; 2254 : 			} else {

	jmp	SHORT $LN118@xmlSchemaV
$LN117@xmlSchemaV:

; 2255 : 			    cur++;

	mov	edx, DWORD PTR _cur$65[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$65[ebp], edx
$LN118@xmlSchemaV:

; 2256 : 			}
; 2257 : 		    }

	jmp	SHORT $LN8@xmlSchemaV
$LN9@xmlSchemaV:

; 2258 : 		}
; 2259 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN122@xmlSchemaV

; 2260 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NORMSTRING);

	push	2
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2261 :                     if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN121@xmlSchemaV

; 2262 :                         v->value.str = xmlStrdup(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2263 :                         *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax

; 2264 :                     } else {

	jmp	SHORT $LN122@xmlSchemaV
$LN121@xmlSchemaV:

; 2265 :                         goto error;

	jmp	$error$544
$LN122@xmlSchemaV:

; 2266 :                     }
; 2267 :                 }
; 2268 :                 goto return0;

	jmp	$return0$545
$LN123@xmlSchemaV:

; 2269 :             }
; 2270 :         case XML_SCHEMAS_DECIMAL:{
; 2271 :                 const xmlChar *cur = value;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$64[ebp], ecx

; 2272 :                 unsigned int len, neg, integ, hasLeadingZeroes;
; 2273 : 		xmlChar cval[25];
; 2274 : 		xmlChar *cptr = cval;

	lea	edx, DWORD PTR _cval$59[ebp]
	mov	DWORD PTR _cptr$58[ebp], edx

; 2275 : 
; 2276 :                 if ((cur == NULL) || (*cur == 0))

	cmp	DWORD PTR _cur$64[ebp], 0
	je	SHORT $LN125@xmlSchemaV
	mov	eax, DWORD PTR _cur$64[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN124@xmlSchemaV
$LN125@xmlSchemaV:

; 2277 :                     goto return1;

	jmp	$return1$546
$LN124@xmlSchemaV:

; 2278 : 
; 2279 : 		/*
; 2280 : 		* xs:decimal has a whitespace-facet value of 'collapse'.
; 2281 : 		*/
; 2282 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN11@xmlSchemaV
$LN10@xmlSchemaV:

; 2283 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	edx, DWORD PTR _cur$64[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN127@xmlSchemaV
	mov	ecx, DWORD PTR _cur$64[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN128@xmlSchemaV
	mov	eax, DWORD PTR _cur$64[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN127@xmlSchemaV
$LN128@xmlSchemaV:
	mov	edx, DWORD PTR _cur$64[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN11@xmlSchemaV
$LN127@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$64[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$64[ebp], ecx
	jmp	SHORT $LN10@xmlSchemaV
$LN11@xmlSchemaV:

; 2284 : 
; 2285 : 		/*
; 2286 : 		* First we handle an optional sign.
; 2287 : 		*/
; 2288 : 		neg = 0;

	mov	DWORD PTR _neg$62[ebp], 0

; 2289 :                 if (*cur == '-') {

	mov	edx, DWORD PTR _cur$64[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN129@xmlSchemaV

; 2290 : 		    neg = 1;

	mov	DWORD PTR _neg$62[ebp], 1

; 2291 :                     cur++;

	mov	ecx, DWORD PTR _cur$64[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$64[ebp], ecx
	jmp	SHORT $LN131@xmlSchemaV
$LN129@xmlSchemaV:

; 2292 : 		} else if (*cur == '+')

	mov	edx, DWORD PTR _cur$64[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN131@xmlSchemaV

; 2293 :                     cur++;

	mov	ecx, DWORD PTR _cur$64[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$64[ebp], ecx
$LN131@xmlSchemaV:

; 2294 : 		/*
; 2295 : 		* Disallow: "", "-", "- "
; 2296 : 		*/
; 2297 : 		if (*cur == 0)

	mov	edx, DWORD PTR _cur$64[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN132@xmlSchemaV

; 2298 : 		    goto return1;

	jmp	$return1$546
$LN132@xmlSchemaV:

; 2299 : 		/*
; 2300 : 		 * Next we "pre-parse" the number, in preparation for calling
; 2301 : 		 * the common routine xmlSchemaParseUInt.  We get rid of any
; 2302 : 		 * leading zeroes (because we have reserved only 25 chars),
; 2303 : 		 * and note the position of a decimal point.
; 2304 : 		 */
; 2305 : 		len = 0;

	mov	DWORD PTR _len$63[ebp], 0

; 2306 : 		integ = ~0u;

	mov	DWORD PTR _integ$61[ebp], -1

; 2307 : 		hasLeadingZeroes = 0;

	mov	DWORD PTR _hasLeadingZeroes$60[ebp], 0
$LN12@xmlSchemaV:

; 2308 : 		/*
; 2309 : 		* Skip leading zeroes.
; 2310 : 		*/
; 2311 : 		while (*cur == '0') {

	mov	ecx, DWORD PTR _cur$64[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jne	SHORT $LN13@xmlSchemaV

; 2312 : 		    cur++;

	mov	eax, DWORD PTR _cur$64[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$64[ebp], eax

; 2313 : 		    hasLeadingZeroes = 1;

	mov	DWORD PTR _hasLeadingZeroes$60[ebp], 1

; 2314 : 		}

	jmp	SHORT $LN12@xmlSchemaV
$LN13@xmlSchemaV:

; 2315 : 		if (*cur != 0) {

	mov	ecx, DWORD PTR _cur$64[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN15@xmlSchemaV
$LN16@xmlSchemaV:

; 2316 : 		    do {
; 2317 : 			if ((*cur >= '0') && (*cur <= '9')) {

	mov	eax, DWORD PTR _cur$64[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN134@xmlSchemaV
	mov	edx, DWORD PTR _cur$64[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN134@xmlSchemaV

; 2318 : 			    *cptr++ = *cur++;

	mov	ecx, DWORD PTR _cptr$58[ebp]
	mov	edx, DWORD PTR _cur$64[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _cptr$58[ebp]
	add	ecx, 1
	mov	DWORD PTR _cptr$58[ebp], ecx
	mov	edx, DWORD PTR _cur$64[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$64[ebp], edx

; 2319 : 			    len++;

	mov	eax, DWORD PTR _len$63[ebp]
	add	eax, 1
	mov	DWORD PTR _len$63[ebp], eax
	jmp	SHORT $LN137@xmlSchemaV
$LN134@xmlSchemaV:

; 2320 : 			} else if (*cur == '.') {

	mov	ecx, DWORD PTR _cur$64[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN136@xmlSchemaV

; 2321 : 			    cur++;

	mov	eax, DWORD PTR _cur$64[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$64[ebp], eax

; 2322 : 			    integ = len;

	mov	ecx, DWORD PTR _len$63[ebp]
	mov	DWORD PTR _integ$61[ebp], ecx
$LN19@xmlSchemaV:

; 2323 : 			    do {
; 2324 : 				if ((*cur >= '0') && (*cur <= '9')) {

	mov	edx, DWORD PTR _cur$64[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN138@xmlSchemaV
	mov	ecx, DWORD PTR _cur$64[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN138@xmlSchemaV

; 2325 : 				    *cptr++ = *cur++;

	mov	eax, DWORD PTR _cptr$58[ebp]
	mov	ecx, DWORD PTR _cur$64[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _cptr$58[ebp]
	add	eax, 1
	mov	DWORD PTR _cptr$58[ebp], eax
	mov	ecx, DWORD PTR _cur$64[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$64[ebp], ecx

; 2326 : 				    len++;

	mov	edx, DWORD PTR _len$63[ebp]
	add	edx, 1
	mov	DWORD PTR _len$63[ebp], edx

; 2327 : 				} else

	jmp	SHORT $LN139@xmlSchemaV
$LN138@xmlSchemaV:

; 2328 : 				    break;

	jmp	SHORT $LN18@xmlSchemaV
$LN139@xmlSchemaV:

; 2329 : 			    } while (len < 24);

	cmp	DWORD PTR _len$63[ebp], 24		; 00000018H
	jb	SHORT $LN19@xmlSchemaV
$LN18@xmlSchemaV:

; 2330 : 			    /*
; 2331 : 			    * Disallow "." but allow "00."
; 2332 : 			    */
; 2333 : 			    if ((len == 0) && (!hasLeadingZeroes))

	cmp	DWORD PTR _len$63[ebp], 0
	jne	SHORT $LN140@xmlSchemaV
	cmp	DWORD PTR _hasLeadingZeroes$60[ebp], 0
	jne	SHORT $LN140@xmlSchemaV

; 2334 : 				goto return1;

	jmp	$return1$546
$LN140@xmlSchemaV:

; 2335 : 			    break;

	jmp	SHORT $LN15@xmlSchemaV

; 2336 : 			} else

	jmp	SHORT $LN137@xmlSchemaV
$LN136@xmlSchemaV:

; 2337 : 			    break;

	jmp	SHORT $LN15@xmlSchemaV
$LN137@xmlSchemaV:

; 2338 : 		    } while (len < 24);

	cmp	DWORD PTR _len$63[ebp], 24		; 00000018H
	jb	$LN16@xmlSchemaV
$LN15@xmlSchemaV:

; 2339 : 		}
; 2340 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN21@xmlSchemaV
$LN20@xmlSchemaV:

; 2341 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	eax, DWORD PTR _cur$64[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN142@xmlSchemaV
	mov	edx, DWORD PTR _cur$64[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN143@xmlSchemaV
	mov	ecx, DWORD PTR _cur$64[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN142@xmlSchemaV
$LN143@xmlSchemaV:
	mov	eax, DWORD PTR _cur$64[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN21@xmlSchemaV
$LN142@xmlSchemaV:
	mov	edx, DWORD PTR _cur$64[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$64[ebp], edx
	jmp	SHORT $LN20@xmlSchemaV
$LN21@xmlSchemaV:

; 2342 : 		if (*cur != 0)

	mov	eax, DWORD PTR _cur$64[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN144@xmlSchemaV

; 2343 : 		    goto return1; /* error if any extraneous chars */

	jmp	$return1$546
$LN144@xmlSchemaV:

; 2344 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$LN146@xmlSchemaV

; 2345 :                     v = xmlSchemaNewValue(XML_SCHEMAS_DECIMAL);

	push	3
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2346 :                     if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	$LN146@xmlSchemaV

; 2347 : 			/*
; 2348 : 			* Now evaluate the significant digits of the number
; 2349 : 			*/
; 2350 : 			if (len != 0) {

	cmp	DWORD PTR _len$63[ebp], 0
	je	SHORT $LN149@xmlSchemaV

; 2351 : 
; 2352 : 			    if (integ != ~0u) {

	cmp	DWORD PTR _integ$61[ebp], -1
	je	SHORT $LN23@xmlSchemaV
$LN22@xmlSchemaV:

; 2353 : 				/*
; 2354 : 				* Get rid of trailing zeroes in the
; 2355 : 				* fractional part.
; 2356 : 				*/
; 2357 : 				while ((len != integ) && (*(cptr-1) == '0')) {

	mov	edx, DWORD PTR _len$63[ebp]
	cmp	edx, DWORD PTR _integ$61[ebp]
	je	SHORT $LN23@xmlSchemaV
	mov	eax, DWORD PTR _cptr$58[ebp]
	movzx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN23@xmlSchemaV

; 2358 : 				    cptr--;

	mov	edx, DWORD PTR _cptr$58[ebp]
	sub	edx, 1
	mov	DWORD PTR _cptr$58[ebp], edx

; 2359 : 				    len--;

	mov	eax, DWORD PTR _len$63[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$63[ebp], eax

; 2360 : 				}

	jmp	SHORT $LN22@xmlSchemaV
$LN23@xmlSchemaV:

; 2361 : 			    }
; 2362 : 			    /*
; 2363 : 			    * Terminate the (preparsed) string.
; 2364 : 			    */
; 2365 : 			    if (len != 0) {

	cmp	DWORD PTR _len$63[ebp], 0
	je	SHORT $LN149@xmlSchemaV

; 2366 : 				*cptr = 0;

	mov	ecx, DWORD PTR _cptr$58[ebp]
	mov	BYTE PTR [ecx], 0

; 2367 : 				cptr = cval;

	lea	edx, DWORD PTR _cval$59[ebp]
	mov	DWORD PTR _cptr$58[ebp], edx

; 2368 : 
; 2369 : 				xmlSchemaParseUInt((const xmlChar **)&cptr,

	mov	eax, DWORD PTR _v$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _v$[ebp]
	add	edx, 8
	push	edx
	lea	eax, DWORD PTR _cptr$58[ebp]
	push	eax
	call	_xmlSchemaParseUInt
	add	esp, 16					; 00000010H
$LN149@xmlSchemaV:

; 2370 : 				    &v->value.decimal.lo,
; 2371 : 				    &v->value.decimal.mi,
; 2372 : 				    &v->value.decimal.hi);
; 2373 : 			    }
; 2374 : 			}
; 2375 : 			/*
; 2376 : 			* Set the total digits to 1 if a zero value.
; 2377 : 			*/
; 2378 :                         v->value.decimal.sign = neg;

	mov	ecx, DWORD PTR _neg$62[ebp]
	and	ecx, 1
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, -2					; fffffffeH
	or	eax, ecx
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 2379 : 			if (len == 0) {

	cmp	DWORD PTR _len$63[ebp], 0
	jne	SHORT $LN150@xmlSchemaV

; 2380 : 			    /* Speedup for zero values. */
; 2381 : 			    v->value.decimal.total = 1;

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, -65281				; ffff00ffH
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 2382 : 			} else {

	jmp	SHORT $LN153@xmlSchemaV
$LN150@xmlSchemaV:

; 2383 : 			    v->value.decimal.total = len;

	mov	edx, DWORD PTR _len$63[ebp]
	and	edx, 255				; 000000ffH
	shl	edx, 8
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, -65281				; ffff00ffH
	or	ecx, edx
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 2384 : 			    if (integ == ~0u)

	cmp	DWORD PTR _integ$61[ebp], -1
	jne	SHORT $LN152@xmlSchemaV

; 2385 : 				v->value.decimal.frac = 0;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, -255				; ffffff01H
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+24], ecx
	jmp	SHORT $LN153@xmlSchemaV
$LN152@xmlSchemaV:

; 2386 : 			    else
; 2387 : 				v->value.decimal.frac = len - integ;

	mov	eax, DWORD PTR _len$63[ebp]
	sub	eax, DWORD PTR _integ$61[ebp]
	and	eax, 127				; 0000007fH
	shl	eax, 1
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, -255				; ffffff01H
	or	edx, eax
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+24], edx
$LN153@xmlSchemaV:

; 2388 : 			}
; 2389 :                         *val = v;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx], edx
$LN146@xmlSchemaV:

; 2390 :                     }
; 2391 :                 }
; 2392 :                 goto return0;

	jmp	$return0$545
$LN154@xmlSchemaV:

; 2393 :             }
; 2394 :         case XML_SCHEMAS_TIME:
; 2395 :         case XML_SCHEMAS_GDAY:
; 2396 :         case XML_SCHEMAS_GMONTH:
; 2397 :         case XML_SCHEMAS_GMONTHDAY:
; 2398 :         case XML_SCHEMAS_GYEAR:
; 2399 :         case XML_SCHEMAS_GYEARMONTH:
; 2400 :         case XML_SCHEMAS_DATE:
; 2401 :         case XML_SCHEMAS_DATETIME:
; 2402 :             ret = xmlSchemaValidateDates(type->builtInType, value, val,

	mov	eax, DWORD PTR _normOnTheFly$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	call	_xmlSchemaValidateDates
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 2403 : 		normOnTheFly);
; 2404 :             break;

	jmp	$done$543
$LN155@xmlSchemaV:

; 2405 :         case XML_SCHEMAS_DURATION:
; 2406 :             ret = xmlSchemaValidateDuration(type, value, val,

	mov	edx, DWORD PTR _normOnTheFly$[ebp]
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	call	_xmlSchemaValidateDuration
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 2407 : 		normOnTheFly);
; 2408 :             break;

	jmp	$done$543
$LN156@xmlSchemaV:

; 2409 :         case XML_SCHEMAS_FLOAT:
; 2410 :         case XML_SCHEMAS_DOUBLE: {
; 2411 :                 const xmlChar *cur = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$57[ebp], eax

; 2412 :                 int neg = 0;

	mov	DWORD PTR _neg$56[ebp], 0

; 2413 :                 int digits_before = 0;

	mov	DWORD PTR _digits_before$55[ebp], 0

; 2414 :                 int digits_after = 0;

	mov	DWORD PTR _digits_after$54[ebp], 0

; 2415 : 
; 2416 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN25@xmlSchemaV
$LN24@xmlSchemaV:

; 2417 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN158@xmlSchemaV
	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN159@xmlSchemaV
	mov	edx, DWORD PTR _cur$57[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN158@xmlSchemaV
$LN159@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN25@xmlSchemaV
$LN158@xmlSchemaV:
	mov	eax, DWORD PTR _cur$57[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$57[ebp], eax
	jmp	SHORT $LN24@xmlSchemaV
$LN25@xmlSchemaV:

; 2418 : 
; 2419 :                 if ((cur[0] == 'N') && (cur[1] == 'a') && (cur[2] == 'N')) {

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 78					; 0000004eH
	jne	$LN160@xmlSchemaV
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 97					; 00000061H
	jne	$LN160@xmlSchemaV
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 78					; 0000004eH
	jne	$LN160@xmlSchemaV

; 2420 :                     cur += 3;

	mov	edx, DWORD PTR _cur$57[ebp]
	add	edx, 3
	mov	DWORD PTR _cur$57[ebp], edx

; 2421 :                     if (*cur != 0)

	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN161@xmlSchemaV

; 2422 :                         goto return1;

	jmp	$return1$546
$LN161@xmlSchemaV:

; 2423 :                     if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$LN162@xmlSchemaV

; 2424 :                         if (type == xmlSchemaTypeFloatDef) {

	mov	edx, DWORD PTR _type$[ebp]
	cmp	edx, DWORD PTR _xmlSchemaTypeFloatDef
	jne	SHORT $LN163@xmlSchemaV

; 2425 :                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);

	push	13					; 0000000dH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2426 :                             if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN165@xmlSchemaV

; 2427 :                                 v->value.f = (float) xmlXPathNAN;

	cvtsd2ss xmm0, QWORD PTR _xmlXPathNAN
	mov	eax, DWORD PTR _v$[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 2428 :                             } else {

	jmp	SHORT $LN166@xmlSchemaV
$LN165@xmlSchemaV:

; 2429 :                                 xmlSchemaFreeValue(v);

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 2430 :                                 goto error;

	jmp	$error$544
$LN166@xmlSchemaV:

; 2431 :                             }
; 2432 :                         } else {

	jmp	SHORT $LN168@xmlSchemaV
$LN163@xmlSchemaV:

; 2433 :                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);

	push	14					; 0000000eH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2434 :                             if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN167@xmlSchemaV

; 2435 :                                 v->value.d = xmlXPathNAN;

	mov	edx, DWORD PTR _v$[ebp]
	movsd	xmm0, QWORD PTR _xmlXPathNAN
	movsd	QWORD PTR [edx+8], xmm0

; 2436 :                             } else {

	jmp	SHORT $LN168@xmlSchemaV
$LN167@xmlSchemaV:

; 2437 :                                 xmlSchemaFreeValue(v);

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 2438 :                                 goto error;

	jmp	$error$544
$LN168@xmlSchemaV:

; 2439 :                             }
; 2440 :                         }
; 2441 :                         *val = v;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx], edx
$LN162@xmlSchemaV:

; 2442 :                     }
; 2443 :                     goto return0;

	jmp	$return0$545
$LN160@xmlSchemaV:

; 2444 :                 }
; 2445 :                 if (*cur == '-') {

	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN169@xmlSchemaV

; 2446 :                     neg = 1;

	mov	DWORD PTR _neg$56[ebp], 1

; 2447 :                     cur++;

	mov	edx, DWORD PTR _cur$57[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$57[ebp], edx
$LN169@xmlSchemaV:

; 2448 :                 }
; 2449 :                 if ((cur[0] == 'I') && (cur[1] == 'N') && (cur[2] == 'F')) {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$57[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 73					; 00000049H
	jne	$LN170@xmlSchemaV
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$57[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 78					; 0000004eH
	jne	$LN170@xmlSchemaV
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _cur$57[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 70					; 00000046H
	jne	$LN170@xmlSchemaV

; 2450 :                     cur += 3;

	mov	ecx, DWORD PTR _cur$57[ebp]
	add	ecx, 3
	mov	DWORD PTR _cur$57[ebp], ecx

; 2451 :                     if (*cur != 0)

	mov	edx, DWORD PTR _cur$57[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN171@xmlSchemaV

; 2452 :                         goto return1;

	jmp	$return1$546
$LN171@xmlSchemaV:

; 2453 :                     if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$LN172@xmlSchemaV

; 2454 :                         if (type == xmlSchemaTypeFloatDef) {

	mov	ecx, DWORD PTR _type$[ebp]
	cmp	ecx, DWORD PTR _xmlSchemaTypeFloatDef
	jne	SHORT $LN173@xmlSchemaV

; 2455 :                             v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);

	push	13					; 0000000dH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2456 :                             if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN175@xmlSchemaV

; 2457 :                                 if (neg)

	cmp	DWORD PTR _neg$56[ebp], 0
	je	SHORT $LN177@xmlSchemaV

; 2458 :                                     v->value.f = (float) xmlXPathNINF;

	cvtsd2ss xmm0, QWORD PTR _xmlXPathNINF
	mov	edx, DWORD PTR _v$[ebp]
	movss	DWORD PTR [edx+8], xmm0
	jmp	SHORT $LN178@xmlSchemaV
$LN177@xmlSchemaV:

; 2459 :                                 else
; 2460 :                                     v->value.f = (float) xmlXPathPINF;

	cvtsd2ss xmm0, QWORD PTR _xmlXPathPINF
	mov	eax, DWORD PTR _v$[ebp]
	movss	DWORD PTR [eax+8], xmm0
$LN178@xmlSchemaV:

; 2461 :                             } else {

	jmp	SHORT $LN176@xmlSchemaV
$LN175@xmlSchemaV:

; 2462 :                                 xmlSchemaFreeValue(v);

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 2463 :                                 goto error;

	jmp	$error$544
$LN176@xmlSchemaV:

; 2464 :                             }
; 2465 :                         } else {

	jmp	SHORT $LN180@xmlSchemaV
$LN173@xmlSchemaV:

; 2466 :                             v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);

	push	14					; 0000000eH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2467 :                             if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN179@xmlSchemaV

; 2468 :                                 if (neg)

	cmp	DWORD PTR _neg$56[ebp], 0
	je	SHORT $LN181@xmlSchemaV

; 2469 :                                     v->value.d = xmlXPathNINF;

	mov	edx, DWORD PTR _v$[ebp]
	movsd	xmm0, QWORD PTR _xmlXPathNINF
	movsd	QWORD PTR [edx+8], xmm0
	jmp	SHORT $LN182@xmlSchemaV
$LN181@xmlSchemaV:

; 2470 :                                 else
; 2471 :                                     v->value.d = xmlXPathPINF;

	mov	eax, DWORD PTR _v$[ebp]
	movsd	xmm0, QWORD PTR _xmlXPathPINF
	movsd	QWORD PTR [eax+8], xmm0
$LN182@xmlSchemaV:

; 2472 :                             } else {

	jmp	SHORT $LN180@xmlSchemaV
$LN179@xmlSchemaV:

; 2473 :                                 xmlSchemaFreeValue(v);

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 2474 :                                 goto error;

	jmp	$error$544
$LN180@xmlSchemaV:

; 2475 :                             }
; 2476 :                         }
; 2477 :                         *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax
$LN172@xmlSchemaV:

; 2478 :                     }
; 2479 :                     goto return0;

	jmp	$return0$545
$LN170@xmlSchemaV:

; 2480 :                 }
; 2481 :                 if ((neg == 0) && (*cur == '+'))

	cmp	DWORD PTR _neg$56[ebp], 0
	jne	SHORT $LN183@xmlSchemaV
	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN183@xmlSchemaV

; 2482 :                     cur++;

	mov	eax, DWORD PTR _cur$57[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$57[ebp], eax
$LN183@xmlSchemaV:

; 2483 :                 if ((cur[0] == 0) || (cur[0] == '+') || (cur[0] == '-'))

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN185@xmlSchemaV
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 43					; 0000002bH
	je	SHORT $LN185@xmlSchemaV
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$57[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN184@xmlSchemaV
$LN185@xmlSchemaV:

; 2484 :                     goto return1;

	jmp	$return1$546
$LN184@xmlSchemaV:

; 2485 :                 while ((*cur >= '0') && (*cur <= '9')) {

	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN27@xmlSchemaV
	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN27@xmlSchemaV

; 2486 :                     cur++;

	mov	edx, DWORD PTR _cur$57[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$57[ebp], edx

; 2487 :                     digits_before++;

	mov	eax, DWORD PTR _digits_before$55[ebp]
	add	eax, 1
	mov	DWORD PTR _digits_before$55[ebp], eax

; 2488 :                 }

	jmp	SHORT $LN184@xmlSchemaV
$LN27@xmlSchemaV:

; 2489 :                 if (*cur == '.') {

	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN29@xmlSchemaV

; 2490 :                     cur++;

	mov	eax, DWORD PTR _cur$57[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$57[ebp], eax
$LN28@xmlSchemaV:

; 2491 :                     while ((*cur >= '0') && (*cur <= '9')) {

	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN29@xmlSchemaV
	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN29@xmlSchemaV

; 2492 :                         cur++;

	mov	edx, DWORD PTR _cur$57[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$57[ebp], edx

; 2493 :                         digits_after++;

	mov	eax, DWORD PTR _digits_after$54[ebp]
	add	eax, 1
	mov	DWORD PTR _digits_after$54[ebp], eax

; 2494 :                     }

	jmp	SHORT $LN28@xmlSchemaV
$LN29@xmlSchemaV:

; 2495 :                 }
; 2496 :                 if ((digits_before == 0) && (digits_after == 0))

	cmp	DWORD PTR _digits_before$55[ebp], 0
	jne	SHORT $LN187@xmlSchemaV
	cmp	DWORD PTR _digits_after$54[ebp], 0
	jne	SHORT $LN187@xmlSchemaV

; 2497 :                     goto return1;

	jmp	$return1$546
$LN187@xmlSchemaV:

; 2498 :                 if ((*cur == 'e') || (*cur == 'E')) {

	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 101				; 00000065H
	je	SHORT $LN189@xmlSchemaV
	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 69					; 00000045H
	jne	SHORT $LN31@xmlSchemaV
$LN189@xmlSchemaV:

; 2499 :                     cur++;

	mov	edx, DWORD PTR _cur$57[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$57[ebp], edx

; 2500 :                     if ((*cur == '-') || (*cur == '+'))

	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN191@xmlSchemaV
	mov	edx, DWORD PTR _cur$57[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN190@xmlSchemaV
$LN191@xmlSchemaV:

; 2501 :                         cur++;

	mov	ecx, DWORD PTR _cur$57[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$57[ebp], ecx
$LN190@xmlSchemaV:

; 2502 :                     while ((*cur >= '0') && (*cur <= '9'))

	mov	edx, DWORD PTR _cur$57[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN31@xmlSchemaV
	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN31@xmlSchemaV

; 2503 :                         cur++;

	mov	eax, DWORD PTR _cur$57[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$57[ebp], eax
	jmp	SHORT $LN190@xmlSchemaV
$LN31@xmlSchemaV:

; 2504 :                 }
; 2505 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN33@xmlSchemaV
$LN32@xmlSchemaV:

; 2506 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN193@xmlSchemaV
	mov	eax, DWORD PTR _cur$57[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN194@xmlSchemaV
	mov	edx, DWORD PTR _cur$57[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN193@xmlSchemaV
$LN194@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN33@xmlSchemaV
$LN193@xmlSchemaV:
	mov	eax, DWORD PTR _cur$57[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$57[ebp], eax
	jmp	SHORT $LN32@xmlSchemaV
$LN33@xmlSchemaV:

; 2507 : 
; 2508 :                 if (*cur != 0)

	mov	ecx, DWORD PTR _cur$57[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN195@xmlSchemaV

; 2509 :                     goto return1;

	jmp	$return1$546
$LN195@xmlSchemaV:

; 2510 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$LN204@xmlSchemaV

; 2511 :                     if (type == xmlSchemaTypeFloatDef) {

	mov	eax, DWORD PTR _type$[ebp]
	cmp	eax, DWORD PTR _xmlSchemaTypeFloatDef
	jne	SHORT $LN197@xmlSchemaV

; 2512 :                         v = xmlSchemaNewValue(XML_SCHEMAS_FLOAT);

	push	13					; 0000000dH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2513 :                         if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN199@xmlSchemaV

; 2514 : 			    /*
; 2515 : 			    * TODO: sscanf seems not to give the correct
; 2516 : 			    * value for extremely high/low values.
; 2517 : 			    * E.g. "1E-149" results in zero.
; 2518 : 			    */
; 2519 :                             if (sscanf((const char *) value, "%f",
; 2520 :                                  &(v->value.f)) == 1) {

	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 8
	push	ecx
	push	OFFSET ??_C@_02NJPGOMH@?$CFf@
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN201@xmlSchemaV

; 2521 :                                 *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax], ecx

; 2522 :                             } else {

	jmp	SHORT $LN202@xmlSchemaV
$LN201@xmlSchemaV:

; 2523 :                                 xmlSchemaFreeValue(v);

	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 2524 :                                 goto return1;

	jmp	$return1$546
$LN202@xmlSchemaV:

; 2525 :                             }
; 2526 :                         } else {

	jmp	SHORT $LN200@xmlSchemaV
$LN199@xmlSchemaV:

; 2527 :                             goto error;

	jmp	$error$544
$LN200@xmlSchemaV:

; 2528 :                         }
; 2529 :                     } else {

	jmp	SHORT $LN204@xmlSchemaV
$LN197@xmlSchemaV:

; 2530 :                         v = xmlSchemaNewValue(XML_SCHEMAS_DOUBLE);

	push	14					; 0000000eH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2531 :                         if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN203@xmlSchemaV

; 2532 : 			    /*
; 2533 : 			    * TODO: sscanf seems not to give the correct
; 2534 : 			    * value for extremely high/low values.
; 2535 : 			    */
; 2536 :                             if (sscanf((const char *) value, "%lf",
; 2537 :                                  &(v->value.d)) == 1) {

	mov	eax, DWORD PTR _v$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_03DLDNIBIK@?$CFlf@
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN205@xmlSchemaV

; 2538 :                                 *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax

; 2539 :                             } else {

	jmp	SHORT $LN206@xmlSchemaV
$LN205@xmlSchemaV:

; 2540 :                                 xmlSchemaFreeValue(v);

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 2541 :                                 goto return1;

	jmp	$return1$546
$LN206@xmlSchemaV:

; 2542 :                             }
; 2543 :                         } else {

	jmp	SHORT $LN204@xmlSchemaV
$LN203@xmlSchemaV:

; 2544 :                             goto error;

	jmp	$error$544
$LN204@xmlSchemaV:

; 2545 :                         }
; 2546 :                     }
; 2547 :                 }
; 2548 :                 goto return0;

	jmp	$return0$545
$LN207@xmlSchemaV:

; 2549 :             }
; 2550 :         case XML_SCHEMAS_BOOLEAN:{
; 2551 :                 const xmlChar *cur = value;

	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$53[ebp], edx

; 2552 : 
; 2553 : 		if (normOnTheFly) {

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	$LN208@xmlSchemaV
$LN34@xmlSchemaV:

; 2554 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN210@xmlSchemaV
	mov	edx, DWORD PTR _cur$53[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN211@xmlSchemaV
	mov	ecx, DWORD PTR _cur$53[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN210@xmlSchemaV
$LN211@xmlSchemaV:
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN35@xmlSchemaV
$LN210@xmlSchemaV:
	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx
	jmp	SHORT $LN34@xmlSchemaV
$LN35@xmlSchemaV:

; 2555 : 		    if (*cur == '0') {

	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN212@xmlSchemaV

; 2556 : 			ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2557 : 			cur++;

	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx
	jmp	$LN221@xmlSchemaV
$LN212@xmlSchemaV:

; 2558 : 		    } else if (*cur == '1') {

	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 49					; 00000031H
	jne	SHORT $LN214@xmlSchemaV

; 2559 : 			ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 2560 : 			cur++;

	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx
	jmp	$LN221@xmlSchemaV
$LN214@xmlSchemaV:

; 2561 : 		    } else if (*cur == 't') {

	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 116				; 00000074H
	jne	$LN216@xmlSchemaV

; 2562 : 			cur++;

	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx

; 2563 : 			if ((*cur++ == 'r') && (*cur++ == 'u') &&

	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv486[ebp], ecx
	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx
	cmp	DWORD PTR tv486[ebp], 114		; 00000072H
	jne	SHORT $LN503@xmlSchemaV
	mov	DWORD PTR tv487[ebp], 1
	jmp	SHORT $LN504@xmlSchemaV
$LN503@xmlSchemaV:
	mov	DWORD PTR tv487[ebp], 0
$LN504@xmlSchemaV:
	cmp	DWORD PTR tv487[ebp], 0
	je	$LN218@xmlSchemaV
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv492[ebp], ecx
	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx
	cmp	DWORD PTR tv492[ebp], 117		; 00000075H
	jne	SHORT $LN505@xmlSchemaV
	mov	DWORD PTR tv493[ebp], 1
	jmp	SHORT $LN506@xmlSchemaV
$LN505@xmlSchemaV:
	mov	DWORD PTR tv493[ebp], 0
$LN506@xmlSchemaV:
	cmp	DWORD PTR tv493[ebp], 0
	je	SHORT $LN218@xmlSchemaV
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv498[ebp], ecx
	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx
	cmp	DWORD PTR tv498[ebp], 101		; 00000065H
	jne	SHORT $LN507@xmlSchemaV
	mov	DWORD PTR tv499[ebp], 1
	jmp	SHORT $LN508@xmlSchemaV
$LN507@xmlSchemaV:
	mov	DWORD PTR tv499[ebp], 0
$LN508@xmlSchemaV:
	cmp	DWORD PTR tv499[ebp], 0
	je	SHORT $LN218@xmlSchemaV

; 2564 : 			    (*cur++ == 'e')) {
; 2565 : 			    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1

; 2566 : 			} else

	jmp	SHORT $LN219@xmlSchemaV
$LN218@xmlSchemaV:

; 2567 : 			    goto return1;

	jmp	$return1$546
$LN219@xmlSchemaV:

; 2568 : 		    } else if (*cur == 'f') {

	jmp	$LN221@xmlSchemaV
$LN216@xmlSchemaV:
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 102				; 00000066H
	jne	$LN220@xmlSchemaV

; 2569 : 			cur++;

	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx

; 2570 : 			if ((*cur++ == 'a') && (*cur++ == 'l') &&
; 2571 : 			    (*cur++ == 's') && (*cur++ == 'e')) {

	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv507[ebp], ecx
	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx
	cmp	DWORD PTR tv507[ebp], 97		; 00000061H
	jne	SHORT $LN509@xmlSchemaV
	mov	DWORD PTR tv508[ebp], 1
	jmp	SHORT $LN510@xmlSchemaV
$LN509@xmlSchemaV:
	mov	DWORD PTR tv508[ebp], 0
$LN510@xmlSchemaV:
	cmp	DWORD PTR tv508[ebp], 0
	je	$LN222@xmlSchemaV
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv513[ebp], ecx
	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx
	cmp	DWORD PTR tv513[ebp], 108		; 0000006cH
	jne	SHORT $LN511@xmlSchemaV
	mov	DWORD PTR tv514[ebp], 1
	jmp	SHORT $LN512@xmlSchemaV
$LN511@xmlSchemaV:
	mov	DWORD PTR tv514[ebp], 0
$LN512@xmlSchemaV:
	cmp	DWORD PTR tv514[ebp], 0
	je	$LN222@xmlSchemaV
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv519[ebp], ecx
	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx
	cmp	DWORD PTR tv519[ebp], 115		; 00000073H
	jne	SHORT $LN513@xmlSchemaV
	mov	DWORD PTR tv520[ebp], 1
	jmp	SHORT $LN514@xmlSchemaV
$LN513@xmlSchemaV:
	mov	DWORD PTR tv520[ebp], 0
$LN514@xmlSchemaV:
	cmp	DWORD PTR tv520[ebp], 0
	je	SHORT $LN222@xmlSchemaV
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv525[ebp], ecx
	mov	edx, DWORD PTR _cur$53[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$53[ebp], edx
	cmp	DWORD PTR tv525[ebp], 101		; 00000065H
	jne	SHORT $LN515@xmlSchemaV
	mov	DWORD PTR tv526[ebp], 1
	jmp	SHORT $LN516@xmlSchemaV
$LN515@xmlSchemaV:
	mov	DWORD PTR tv526[ebp], 0
$LN516@xmlSchemaV:
	cmp	DWORD PTR tv526[ebp], 0
	je	SHORT $LN222@xmlSchemaV

; 2572 : 			    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2573 : 			} else

	jmp	SHORT $LN223@xmlSchemaV
$LN222@xmlSchemaV:

; 2574 : 			    goto return1;

	jmp	$return1$546
$LN223@xmlSchemaV:

; 2575 : 		    } else

	jmp	SHORT $LN221@xmlSchemaV
$LN220@xmlSchemaV:

; 2576 : 			goto return1;

	jmp	$return1$546
$LN221@xmlSchemaV:

; 2577 : 		    if (*cur != 0) {

	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN227@xmlSchemaV
$LN36@xmlSchemaV:

; 2578 : 			while IS_WSP_BLANK_CH(*cur) cur++;

	mov	edx, DWORD PTR _cur$53[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN225@xmlSchemaV
	mov	ecx, DWORD PTR _cur$53[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN226@xmlSchemaV
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN225@xmlSchemaV
$LN226@xmlSchemaV:
	mov	edx, DWORD PTR _cur$53[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN37@xmlSchemaV
$LN225@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$53[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$53[ebp], ecx
	jmp	SHORT $LN36@xmlSchemaV
$LN37@xmlSchemaV:

; 2579 : 			if (*cur != 0)

	mov	edx, DWORD PTR _cur$53[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN227@xmlSchemaV

; 2580 : 			    goto return1;

	jmp	$return1$546
$LN227@xmlSchemaV:

; 2581 : 		    }
; 2582 : 		} else {

	jmp	$LN235@xmlSchemaV
$LN208@xmlSchemaV:

; 2583 : 		    if ((cur[0] == '0') && (cur[1] == 0))

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN228@xmlSchemaV
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN228@xmlSchemaV

; 2584 : 			ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	$LN235@xmlSchemaV
$LN228@xmlSchemaV:

; 2585 : 		    else if ((cur[0] == '1') && (cur[1] == 0))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$53[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 49					; 00000031H
	jne	SHORT $LN230@xmlSchemaV
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$53[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN230@xmlSchemaV

; 2586 : 			ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	$LN235@xmlSchemaV
$LN230@xmlSchemaV:

; 2587 : 		    else if ((cur[0] == 't') && (cur[1] == 'r')
; 2588 : 			&& (cur[2] == 'u') && (cur[3] == 'e')
; 2589 : 			&& (cur[4] == 0))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$53[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 116				; 00000074H
	jne	SHORT $LN232@xmlSchemaV
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$53[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 114				; 00000072H
	jne	SHORT $LN232@xmlSchemaV
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _cur$53[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 117				; 00000075H
	jne	SHORT $LN232@xmlSchemaV
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 101				; 00000065H
	jne	SHORT $LN232@xmlSchemaV
	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN232@xmlSchemaV

; 2590 : 			ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	$LN235@xmlSchemaV
$LN232@xmlSchemaV:

; 2591 : 		    else if ((cur[0] == 'f') && (cur[1] == 'a')
; 2592 : 			&& (cur[2] == 'l') && (cur[3] == 's')
; 2593 : 			&& (cur[4] == 'e') && (cur[5] == 0))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$53[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 102				; 00000066H
	jne	SHORT $LN234@xmlSchemaV
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$53[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 97					; 00000061H
	jne	SHORT $LN234@xmlSchemaV
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _cur$53[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 108				; 0000006cH
	jne	SHORT $LN234@xmlSchemaV
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _cur$53[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 115				; 00000073H
	jne	SHORT $LN234@xmlSchemaV
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _cur$53[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 101				; 00000065H
	jne	SHORT $LN234@xmlSchemaV
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _cur$53[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN234@xmlSchemaV

; 2594 : 			ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN235@xmlSchemaV
$LN234@xmlSchemaV:

; 2595 : 		    else
; 2596 : 			goto return1;

	jmp	$return1$546
$LN235@xmlSchemaV:

; 2597 : 		}
; 2598 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN238@xmlSchemaV

; 2599 :                     v = xmlSchemaNewValue(XML_SCHEMAS_BOOLEAN);

	push	15					; 0000000fH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2600 :                     if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN237@xmlSchemaV

; 2601 :                         v->value.b = ret;

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+8], eax

; 2602 :                         *val = v;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx], edx

; 2603 :                     } else {

	jmp	SHORT $LN238@xmlSchemaV
$LN237@xmlSchemaV:

; 2604 :                         goto error;

	jmp	$error$544
$LN238@xmlSchemaV:

; 2605 :                     }
; 2606 :                 }
; 2607 :                 goto return0;

	jmp	$return0$545
$LN239@xmlSchemaV:

; 2608 :             }
; 2609 :         case XML_SCHEMAS_TOKEN:{
; 2610 :                 const xmlChar *cur = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$52[ebp], eax

; 2611 : 
; 2612 : 		if (! normOnTheFly) {

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	jne	SHORT $LN39@xmlSchemaV
$LN38@xmlSchemaV:

; 2613 : 		    while (*cur != 0) {

	mov	ecx, DWORD PTR _cur$52[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN39@xmlSchemaV

; 2614 : 			if ((*cur == 0xd) || (*cur == 0xa) || (*cur == 0x9)) {

	mov	eax, DWORD PTR _cur$52[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN243@xmlSchemaV
	mov	edx, DWORD PTR _cur$52[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN243@xmlSchemaV
	mov	ecx, DWORD PTR _cur$52[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN241@xmlSchemaV
$LN243@xmlSchemaV:

; 2615 : 			    goto return1;

	jmp	$return1$546
	jmp	SHORT $LN245@xmlSchemaV
$LN241@xmlSchemaV:

; 2616 : 			} else if (*cur == ' ') {

	mov	eax, DWORD PTR _cur$52[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN244@xmlSchemaV

; 2617 : 			    cur++;

	mov	edx, DWORD PTR _cur$52[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$52[ebp], edx

; 2618 : 			    if (*cur == 0)

	mov	eax, DWORD PTR _cur$52[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN246@xmlSchemaV

; 2619 : 				goto return1;

	jmp	$return1$546
$LN246@xmlSchemaV:

; 2620 : 			    if (*cur == ' ')

	mov	edx, DWORD PTR _cur$52[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN247@xmlSchemaV

; 2621 : 				goto return1;

	jmp	$return1$546
$LN247@xmlSchemaV:

; 2622 : 			} else {

	jmp	SHORT $LN245@xmlSchemaV
$LN244@xmlSchemaV:

; 2623 : 			    cur++;

	mov	ecx, DWORD PTR _cur$52[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$52[ebp], ecx
$LN245@xmlSchemaV:

; 2624 : 			}
; 2625 : 		    }

	jmp	SHORT $LN38@xmlSchemaV
$LN39@xmlSchemaV:

; 2626 : 		}
; 2627 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN250@xmlSchemaV

; 2628 :                     v = xmlSchemaNewValue(XML_SCHEMAS_TOKEN);

	push	16					; 00000010H
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2629 :                     if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN249@xmlSchemaV

; 2630 :                         v->value.str = xmlStrdup(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2631 :                         *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax

; 2632 :                     } else {

	jmp	SHORT $LN250@xmlSchemaV
$LN249@xmlSchemaV:

; 2633 :                         goto error;

	jmp	$error$544
$LN250@xmlSchemaV:

; 2634 :                     }
; 2635 :                 }
; 2636 :                 goto return0;

	jmp	$return0$545
$LN251@xmlSchemaV:

; 2637 :             }
; 2638 :         case XML_SCHEMAS_LANGUAGE:
; 2639 : 	    if (normOnTheFly) {

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN253@xmlSchemaV

; 2640 : 		norm = xmlSchemaCollapseString(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	DWORD PTR _norm$[ebp], eax

; 2641 : 		if (norm != NULL)

	cmp	DWORD PTR _norm$[ebp], 0
	je	SHORT $LN253@xmlSchemaV

; 2642 : 		    value = norm;

	mov	edx, DWORD PTR _norm$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN253@xmlSchemaV:

; 2643 : 	    }
; 2644 :             if (xmlCheckLanguageID(value) == 1) {

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlCheckLanguageID
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN254@xmlSchemaV

; 2645 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN257@xmlSchemaV

; 2646 :                     v = xmlSchemaNewValue(XML_SCHEMAS_LANGUAGE);

	push	17					; 00000011H
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2647 :                     if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN256@xmlSchemaV

; 2648 :                         v->value.str = xmlStrdup(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+8], eax

; 2649 :                         *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax], ecx

; 2650 :                     } else {

	jmp	SHORT $LN257@xmlSchemaV
$LN256@xmlSchemaV:

; 2651 :                         goto error;

	jmp	$error$544
$LN257@xmlSchemaV:

; 2652 :                     }
; 2653 :                 }
; 2654 :                 goto return0;

	jmp	$return0$545
$LN254@xmlSchemaV:

; 2655 :             }
; 2656 :             goto return1;

	jmp	$return1$546
$LN258@xmlSchemaV:

; 2657 :         case XML_SCHEMAS_NMTOKEN:
; 2658 :             if (xmlValidateNMToken(value, 1) == 0) {

	push	1
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlValidateNMToken
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN259@xmlSchemaV

; 2659 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN262@xmlSchemaV

; 2660 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NMTOKEN);

	push	18					; 00000012H
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2661 :                     if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN261@xmlSchemaV

; 2662 :                         v->value.str = xmlStrdup(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2663 :                         *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax

; 2664 :                     } else {

	jmp	SHORT $LN262@xmlSchemaV
$LN261@xmlSchemaV:

; 2665 :                         goto error;

	jmp	$error$544
$LN262@xmlSchemaV:

; 2666 :                     }
; 2667 :                 }
; 2668 :                 goto return0;

	jmp	$return0$545
$LN259@xmlSchemaV:

; 2669 :             }
; 2670 :             goto return1;

	jmp	$return1$546
$LN263@xmlSchemaV:

; 2671 :         case XML_SCHEMAS_NMTOKENS:
; 2672 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeNmtokenDef,

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmlSchemaTypeNmtokenDef
	push	ecx
	call	_xmlSchemaValAtomicListNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 2673 :                                              value, val, node);
; 2674 :             if (ret > 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jle	SHORT $LN264@xmlSchemaV

; 2675 :                 ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN265@xmlSchemaV
$LN264@xmlSchemaV:

; 2676 :             else
; 2677 :                 ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN265@xmlSchemaV:

; 2678 :             goto done;

	jmp	$done$543
$LN266@xmlSchemaV:

; 2679 :         case XML_SCHEMAS_NAME:
; 2680 :             ret = xmlValidateName(value, 1);

	push	1
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlValidateName
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2681 :             if ((ret == 0) && (val != NULL) && (value != NULL)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN269@xmlSchemaV
	cmp	DWORD PTR _val$[ebp], 0
	je	$LN269@xmlSchemaV
	cmp	DWORD PTR _value$[ebp], 0
	je	$LN269@xmlSchemaV

; 2682 : 		v = xmlSchemaNewValue(XML_SCHEMAS_NAME);

	push	20					; 00000014H
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2683 : 		if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	$LN268@xmlSchemaV

; 2684 : 		     const xmlChar *start = value, *end;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _start$51[ebp], eax
$LN40@xmlSchemaV:

; 2685 : 		     while (IS_BLANK_CH(*start)) start++;

	mov	ecx, DWORD PTR _start$51[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN270@xmlSchemaV
	mov	eax, DWORD PTR _start$51[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN271@xmlSchemaV
	mov	edx, DWORD PTR _start$51[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN270@xmlSchemaV
$LN271@xmlSchemaV:
	mov	ecx, DWORD PTR _start$51[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN41@xmlSchemaV
$LN270@xmlSchemaV:
	mov	eax, DWORD PTR _start$51[ebp]
	add	eax, 1
	mov	DWORD PTR _start$51[ebp], eax
	jmp	SHORT $LN40@xmlSchemaV
$LN41@xmlSchemaV:

; 2686 : 		     end = start;

	mov	ecx, DWORD PTR _start$51[ebp]
	mov	DWORD PTR _end$50[ebp], ecx
$LN42@xmlSchemaV:

; 2687 : 		     while ((*end != 0) && (!IS_BLANK_CH(*end))) end++;

	mov	edx, DWORD PTR _end$50[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN43@xmlSchemaV
	mov	ecx, DWORD PTR _end$50[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN43@xmlSchemaV
	mov	eax, DWORD PTR _end$50[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN272@xmlSchemaV
	mov	edx, DWORD PTR _end$50[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN43@xmlSchemaV
$LN272@xmlSchemaV:
	mov	ecx, DWORD PTR _end$50[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN43@xmlSchemaV
	mov	eax, DWORD PTR _end$50[ebp]
	add	eax, 1
	mov	DWORD PTR _end$50[ebp], eax
	jmp	SHORT $LN42@xmlSchemaV
$LN43@xmlSchemaV:

; 2688 : 		     v->value.str = xmlStrndup(start, end - start);

	mov	ecx, DWORD PTR _end$50[ebp]
	sub	ecx, DWORD PTR _start$51[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$51[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2689 : 		    *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax

; 2690 : 		} else {

	jmp	SHORT $LN269@xmlSchemaV
$LN268@xmlSchemaV:

; 2691 : 		    goto error;

	jmp	$error$544
$LN269@xmlSchemaV:

; 2692 : 		}
; 2693 :             }
; 2694 :             goto done;

	jmp	$done$543
$LN273@xmlSchemaV:

; 2695 :         case XML_SCHEMAS_QNAME:{
; 2696 :                 const xmlChar *uri = NULL;

	mov	DWORD PTR _uri$49[ebp], 0

; 2697 :                 xmlChar *local = NULL;

	mov	DWORD PTR _local$48[ebp], 0

; 2698 : 
; 2699 :                 ret = xmlValidateQName(value, 1);

	push	1
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlValidateQName
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2700 : 		if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN274@xmlSchemaV

; 2701 : 		    goto done;

	jmp	$done$543
$LN274@xmlSchemaV:

; 2702 :                 if (node != NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	je	$LN279@xmlSchemaV

; 2703 :                     xmlChar *prefix;
; 2704 : 		    xmlNsPtr ns;
; 2705 : 
; 2706 :                     local = xmlSplitQName2(value, &prefix);

	lea	edx, DWORD PTR _prefix$47[ebp]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlSplitQName2
	add	esp, 8
	mov	DWORD PTR _local$48[ebp], eax

; 2707 : 		    ns = xmlSearchNs(node->doc, node, prefix);

	mov	ecx, DWORD PTR _prefix$47[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ns$46[ebp], eax

; 2708 : 		    if ((ns == NULL) && (prefix != NULL)) {

	cmp	DWORD PTR _ns$46[ebp], 0
	jne	SHORT $LN276@xmlSchemaV
	cmp	DWORD PTR _prefix$47[ebp], 0
	je	SHORT $LN276@xmlSchemaV

; 2709 : 			xmlFree(prefix);

	mov	esi, esp
	mov	edx, DWORD PTR _prefix$47[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2710 : 			if (local != NULL)

	cmp	DWORD PTR _local$48[ebp], 0
	je	SHORT $LN277@xmlSchemaV

; 2711 : 			    xmlFree(local);

	mov	esi, esp
	mov	eax, DWORD PTR _local$48[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN277@xmlSchemaV:

; 2712 : 			goto return1;

	jmp	$return1$546
$LN276@xmlSchemaV:

; 2713 : 		    }
; 2714 : 		    if (ns != NULL)

	cmp	DWORD PTR _ns$46[ebp], 0
	je	SHORT $LN278@xmlSchemaV

; 2715 : 			uri = ns->href;

	mov	ecx, DWORD PTR _ns$46[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _uri$49[ebp], edx
$LN278@xmlSchemaV:

; 2716 :                     if (prefix != NULL)

	cmp	DWORD PTR _prefix$47[ebp], 0
	je	SHORT $LN279@xmlSchemaV

; 2717 :                         xmlFree(prefix);

	mov	esi, esp
	mov	eax, DWORD PTR _prefix$47[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN279@xmlSchemaV:

; 2718 :                 }
; 2719 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN280@xmlSchemaV

; 2720 :                     v = xmlSchemaNewValue(XML_SCHEMAS_QNAME);

	push	21					; 00000015H
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2721 :                     if (v == NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	jne	SHORT $LN282@xmlSchemaV

; 2722 : 			if (local != NULL)

	cmp	DWORD PTR _local$48[ebp], 0
	je	SHORT $LN283@xmlSchemaV

; 2723 : 			    xmlFree(local);

	mov	esi, esp
	mov	ecx, DWORD PTR _local$48[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN283@xmlSchemaV:

; 2724 : 			goto error;

	jmp	$error$544
$LN282@xmlSchemaV:

; 2725 : 		    }
; 2726 : 		    if (local != NULL)

	cmp	DWORD PTR _local$48[ebp], 0
	je	SHORT $LN284@xmlSchemaV

; 2727 : 			v->value.qname.name = local;

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _local$48[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN285@xmlSchemaV
$LN284@xmlSchemaV:

; 2728 : 		    else
; 2729 : 			v->value.qname.name = xmlStrdup(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN285@xmlSchemaV:

; 2730 : 		    if (uri != NULL)

	cmp	DWORD PTR _uri$49[ebp], 0
	je	SHORT $LN286@xmlSchemaV

; 2731 : 			v->value.qname.uri = xmlStrdup(uri);

	mov	eax, DWORD PTR _uri$49[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN286@xmlSchemaV:

; 2732 : 		    *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax

; 2733 :                 } else

	jmp	SHORT $LN287@xmlSchemaV
$LN280@xmlSchemaV:

; 2734 : 		    if (local != NULL)

	cmp	DWORD PTR _local$48[ebp], 0
	je	SHORT $LN287@xmlSchemaV

; 2735 : 			xmlFree(local);

	mov	esi, esp
	mov	ecx, DWORD PTR _local$48[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN287@xmlSchemaV:

; 2736 :                 goto done;

	jmp	$done$543
$LN288@xmlSchemaV:

; 2737 :             }
; 2738 :         case XML_SCHEMAS_NCNAME:
; 2739 :             ret = xmlValidateNCName(value, 1);

	push	1
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlValidateNCName
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2740 :             if ((ret == 0) && (val != NULL)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN291@xmlSchemaV
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN291@xmlSchemaV

; 2741 :                 v = xmlSchemaNewValue(XML_SCHEMAS_NCNAME);

	push	22					; 00000016H
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2742 :                 if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN290@xmlSchemaV

; 2743 :                     v->value.str = xmlStrdup(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2744 :                     *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax

; 2745 :                 } else {

	jmp	SHORT $LN291@xmlSchemaV
$LN290@xmlSchemaV:

; 2746 :                     goto error;

	jmp	$error$544
$LN291@xmlSchemaV:

; 2747 :                 }
; 2748 :             }
; 2749 :             goto done;

	jmp	$done$543
$LN292@xmlSchemaV:

; 2750 :         case XML_SCHEMAS_ID:
; 2751 :             ret = xmlValidateNCName(value, 1);

	push	1
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlValidateNCName
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2752 :             if ((ret == 0) && (val != NULL)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN295@xmlSchemaV
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN295@xmlSchemaV

; 2753 :                 v = xmlSchemaNewValue(XML_SCHEMAS_ID);

	push	23					; 00000017H
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2754 :                 if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN294@xmlSchemaV

; 2755 :                     v->value.str = xmlStrdup(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2756 :                     *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax

; 2757 :                 } else {

	jmp	SHORT $LN295@xmlSchemaV
$LN294@xmlSchemaV:

; 2758 :                     goto error;

	jmp	$error$544
$LN295@xmlSchemaV:

; 2759 :                 }
; 2760 :             }
; 2761 :             if ((ret == 0) && (node != NULL) &&

	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN301@xmlSchemaV
	cmp	DWORD PTR _node$[ebp], 0
	je	$LN301@xmlSchemaV
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 2
	jne	$LN301@xmlSchemaV

; 2762 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2763 :                 xmlAttrPtr attr = (xmlAttrPtr) node;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _attr$45[ebp], edx

; 2764 : 
; 2765 :                 /*
; 2766 :                  * NOTE: the IDness might have already be declared in the DTD
; 2767 :                  */
; 2768 :                 if (attr->atype != XML_ATTRIBUTE_ID) {

	mov	eax, DWORD PTR _attr$45[ebp]
	cmp	DWORD PTR [eax+40], 2
	je	$LN301@xmlSchemaV

; 2769 :                     xmlIDPtr res;
; 2770 :                     xmlChar *strip;
; 2771 : 
; 2772 :                     strip = xmlSchemaStrip(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlSchemaStrip
	add	esp, 4
	mov	DWORD PTR _strip$43[ebp], eax

; 2773 :                     if (strip != NULL) {

	cmp	DWORD PTR _strip$43[ebp], 0
	je	SHORT $LN298@xmlSchemaV

; 2774 :                         res = xmlAddID(NULL, node->doc, strip, attr);

	mov	edx, DWORD PTR _attr$45[ebp]
	push	edx
	mov	eax, DWORD PTR _strip$43[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	push	0
	call	_xmlAddID
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$44[ebp], eax

; 2775 :                         xmlFree(strip);

	mov	esi, esp
	mov	eax, DWORD PTR _strip$43[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2776 :                     } else

	jmp	SHORT $LN299@xmlSchemaV
$LN298@xmlSchemaV:

; 2777 :                         res = xmlAddID(NULL, node->doc, value, attr);

	mov	ecx, DWORD PTR _attr$45[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	push	0
	call	_xmlAddID
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$44[ebp], eax
$LN299@xmlSchemaV:

; 2778 :                     if (res == NULL) {

	cmp	DWORD PTR _res$44[ebp], 0
	jne	SHORT $LN300@xmlSchemaV

; 2779 :                         ret = 2;

	mov	DWORD PTR _ret$[ebp], 2

; 2780 :                     } else {

	jmp	SHORT $LN301@xmlSchemaV
$LN300@xmlSchemaV:

; 2781 :                         attr->atype = XML_ATTRIBUTE_ID;

	mov	edx, DWORD PTR _attr$45[ebp]
	mov	DWORD PTR [edx+40], 2
$LN301@xmlSchemaV:

; 2782 :                     }
; 2783 :                 }
; 2784 :             }
; 2785 :             goto done;

	jmp	$done$543
$LN302@xmlSchemaV:

; 2786 :         case XML_SCHEMAS_IDREF:
; 2787 :             ret = xmlValidateNCName(value, 1);

	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlValidateNCName
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2788 :             if ((ret == 0) && (val != NULL)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN303@xmlSchemaV
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN303@xmlSchemaV

; 2789 : 		v = xmlSchemaNewValue(XML_SCHEMAS_IDREF);

	push	24					; 00000018H
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2790 : 		if (v == NULL)

	cmp	DWORD PTR _v$[ebp], 0
	jne	SHORT $LN304@xmlSchemaV

; 2791 : 		    goto error;

	jmp	$error$544
$LN304@xmlSchemaV:

; 2792 : 		v->value.str = xmlStrdup(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+8], eax

; 2793 : 		*val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax], ecx
$LN303@xmlSchemaV:

; 2794 :             }
; 2795 :             if ((ret == 0) && (node != NULL) &&

	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN305@xmlSchemaV
	cmp	DWORD PTR _node$[ebp], 0
	je	$LN305@xmlSchemaV
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 2
	jne	$LN305@xmlSchemaV

; 2796 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2797 :                 xmlAttrPtr attr = (xmlAttrPtr) node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _attr$42[ebp], eax

; 2798 :                 xmlChar *strip;
; 2799 : 
; 2800 :                 strip = xmlSchemaStrip(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlSchemaStrip
	add	esp, 4
	mov	DWORD PTR _strip$41[ebp], eax

; 2801 :                 if (strip != NULL) {

	cmp	DWORD PTR _strip$41[ebp], 0
	je	SHORT $LN306@xmlSchemaV

; 2802 :                     xmlAddRef(NULL, node->doc, strip, attr);

	mov	edx, DWORD PTR _attr$42[ebp]
	push	edx
	mov	eax, DWORD PTR _strip$41[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	push	0
	call	_xmlAddRef
	add	esp, 16					; 00000010H

; 2803 :                     xmlFree(strip);

	mov	esi, esp
	mov	eax, DWORD PTR _strip$41[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2804 :                 } else

	jmp	SHORT $LN307@xmlSchemaV
$LN306@xmlSchemaV:

; 2805 :                     xmlAddRef(NULL, node->doc, value, attr);

	mov	ecx, DWORD PTR _attr$42[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	push	0
	call	_xmlAddRef
	add	esp, 16					; 00000010H
$LN307@xmlSchemaV:

; 2806 :                 attr->atype = XML_ATTRIBUTE_IDREF;

	mov	edx, DWORD PTR _attr$42[ebp]
	mov	DWORD PTR [edx+40], 3
$LN305@xmlSchemaV:

; 2807 :             }
; 2808 :             goto done;

	jmp	$done$543
$LN308@xmlSchemaV:

; 2809 :         case XML_SCHEMAS_IDREFS:
; 2810 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeIdrefDef,

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _xmlSchemaTypeIdrefDef
	push	eax
	call	_xmlSchemaValAtomicListNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 2811 :                                              value, val, node);
; 2812 :             if (ret < 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN309@xmlSchemaV

; 2813 :                 ret = 2;

	mov	DWORD PTR _ret$[ebp], 2
	jmp	SHORT $LN310@xmlSchemaV
$LN309@xmlSchemaV:

; 2814 :             else
; 2815 :                 ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN310@xmlSchemaV:

; 2816 :             if ((ret == 0) && (node != NULL) &&

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN311@xmlSchemaV
	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN311@xmlSchemaV
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 2
	jne	SHORT $LN311@xmlSchemaV

; 2817 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2818 :                 xmlAttrPtr attr = (xmlAttrPtr) node;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _attr$40[ebp], edx

; 2819 : 
; 2820 :                 attr->atype = XML_ATTRIBUTE_IDREFS;

	mov	eax, DWORD PTR _attr$40[ebp]
	mov	DWORD PTR [eax+40], 4
$LN311@xmlSchemaV:

; 2821 :             }
; 2822 :             goto done;

	jmp	$done$543
$LN312@xmlSchemaV:

; 2823 :         case XML_SCHEMAS_ENTITY:{
; 2824 :                 xmlChar *strip;
; 2825 : 
; 2826 :                 ret = xmlValidateNCName(value, 1);

	push	1
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlValidateNCName
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2827 :                 if ((node == NULL) || (node->doc == NULL))

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN314@xmlSchemaV
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN313@xmlSchemaV
$LN314@xmlSchemaV:

; 2828 :                     ret = 3;

	mov	DWORD PTR _ret$[ebp], 3
$LN313@xmlSchemaV:

; 2829 :                 if (ret == 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN318@xmlSchemaV

; 2830 :                     xmlEntityPtr ent;
; 2831 : 
; 2832 :                     strip = xmlSchemaStrip(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlSchemaStrip
	add	esp, 4
	mov	DWORD PTR _strip$39[ebp], eax

; 2833 :                     if (strip != NULL) {

	cmp	DWORD PTR _strip$39[ebp], 0
	je	SHORT $LN316@xmlSchemaV

; 2834 :                         ent = xmlGetDocEntity(node->doc, strip);

	mov	ecx, DWORD PTR _strip$39[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_xmlGetDocEntity
	add	esp, 8
	mov	DWORD PTR _ent$38[ebp], eax

; 2835 :                         xmlFree(strip);

	mov	esi, esp
	mov	ecx, DWORD PTR _strip$39[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2836 :                     } else {

	jmp	SHORT $LN317@xmlSchemaV
$LN316@xmlSchemaV:

; 2837 :                         ent = xmlGetDocEntity(node->doc, value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_xmlGetDocEntity
	add	esp, 8
	mov	DWORD PTR _ent$38[ebp], eax
$LN317@xmlSchemaV:

; 2838 :                     }
; 2839 :                     if ((ent == NULL) ||

	cmp	DWORD PTR _ent$38[ebp], 0
	je	SHORT $LN319@xmlSchemaV
	mov	edx, DWORD PTR _ent$38[ebp]
	cmp	DWORD PTR [edx+48], 3
	je	SHORT $LN318@xmlSchemaV
$LN319@xmlSchemaV:

; 2840 :                         (ent->etype !=
; 2841 :                          XML_EXTERNAL_GENERAL_UNPARSED_ENTITY))
; 2842 :                         ret = 4;

	mov	DWORD PTR _ret$[ebp], 4
$LN318@xmlSchemaV:

; 2843 :                 }
; 2844 :                 if ((ret == 0) && (val != NULL)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN320@xmlSchemaV
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN320@xmlSchemaV

; 2845 :                     TODO;

	mov	esi, esp
	push	2845					; 00000b1dH
	push	OFFSET ??_C@_0HB@FHPILMCP@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN320@xmlSchemaV:

; 2846 :                 }
; 2847 :                 if ((ret == 0) && (node != NULL) &&

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN321@xmlSchemaV
	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN321@xmlSchemaV
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 2
	jne	SHORT $LN321@xmlSchemaV

; 2848 :                     (node->type == XML_ATTRIBUTE_NODE)) {
; 2849 :                     xmlAttrPtr attr = (xmlAttrPtr) node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _attr$37[ebp], eax

; 2850 : 
; 2851 :                     attr->atype = XML_ATTRIBUTE_ENTITY;

	mov	ecx, DWORD PTR _attr$37[ebp]
	mov	DWORD PTR [ecx+40], 5
$LN321@xmlSchemaV:

; 2852 :                 }
; 2853 :                 goto done;

	jmp	$done$543
$LN322@xmlSchemaV:

; 2854 :             }
; 2855 :         case XML_SCHEMAS_ENTITIES:
; 2856 :             if ((node == NULL) || (node->doc == NULL))

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN324@xmlSchemaV
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN323@xmlSchemaV
$LN324@xmlSchemaV:

; 2857 :                 goto return3;

	jmp	$return3$547
$LN323@xmlSchemaV:

; 2858 :             ret = xmlSchemaValAtomicListNode(xmlSchemaTypeEntityDef,

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _xmlSchemaTypeEntityDef
	push	eax
	call	_xmlSchemaValAtomicListNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 2859 :                                              value, val, node);
; 2860 :             if (ret <= 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jg	SHORT $LN325@xmlSchemaV

; 2861 :                 ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN326@xmlSchemaV
$LN325@xmlSchemaV:

; 2862 :             else
; 2863 :                 ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN326@xmlSchemaV:

; 2864 :             if ((ret == 0) && (node != NULL) &&

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN327@xmlSchemaV
	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN327@xmlSchemaV
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 2
	jne	SHORT $LN327@xmlSchemaV

; 2865 :                 (node->type == XML_ATTRIBUTE_NODE)) {
; 2866 :                 xmlAttrPtr attr = (xmlAttrPtr) node;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _attr$36[ebp], edx

; 2867 : 
; 2868 :                 attr->atype = XML_ATTRIBUTE_ENTITIES;

	mov	eax, DWORD PTR _attr$36[ebp]
	mov	DWORD PTR [eax+40], 6
$LN327@xmlSchemaV:

; 2869 :             }
; 2870 :             goto done;

	jmp	$done$543
$LN328@xmlSchemaV:

; 2871 :         case XML_SCHEMAS_NOTATION:{
; 2872 :                 xmlChar *uri = NULL;

	mov	DWORD PTR _uri$35[ebp], 0

; 2873 :                 xmlChar *local = NULL;

	mov	DWORD PTR _local$34[ebp], 0

; 2874 : 
; 2875 :                 ret = xmlValidateQName(value, 1);

	push	1
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlValidateQName
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2876 :                 if ((ret == 0) && (node != NULL)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN336@xmlSchemaV
	cmp	DWORD PTR _node$[ebp], 0
	je	$LN336@xmlSchemaV

; 2877 :                     xmlChar *prefix;
; 2878 : 
; 2879 :                     local = xmlSplitQName2(value, &prefix);

	lea	edx, DWORD PTR _prefix$33[ebp]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlSplitQName2
	add	esp, 8
	mov	DWORD PTR _local$34[ebp], eax

; 2880 :                     if (prefix != NULL) {

	cmp	DWORD PTR _prefix$33[ebp], 0
	je	SHORT $LN333@xmlSchemaV

; 2881 :                         xmlNsPtr ns;
; 2882 : 
; 2883 :                         ns = xmlSearchNs(node->doc, node, prefix);

	mov	ecx, DWORD PTR _prefix$33[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_xmlSearchNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ns$32[ebp], eax

; 2884 :                         if (ns == NULL)

	cmp	DWORD PTR _ns$32[ebp], 0
	jne	SHORT $LN331@xmlSchemaV

; 2885 :                             ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN333@xmlSchemaV
$LN331@xmlSchemaV:

; 2886 :                         else if (val != NULL)

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN333@xmlSchemaV

; 2887 :                             uri = xmlStrdup(ns->href);

	mov	edx, DWORD PTR _ns$32[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _uri$35[ebp], eax
$LN333@xmlSchemaV:

; 2888 :                     }
; 2889 :                     if ((local != NULL) && ((val == NULL) || (ret != 0)))

	cmp	DWORD PTR _local$34[ebp], 0
	je	SHORT $LN334@xmlSchemaV
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN335@xmlSchemaV
	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN334@xmlSchemaV
$LN335@xmlSchemaV:

; 2890 :                         xmlFree(local);

	mov	esi, esp
	mov	ecx, DWORD PTR _local$34[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN334@xmlSchemaV:

; 2891 :                     if (prefix != NULL)

	cmp	DWORD PTR _prefix$33[ebp], 0
	je	SHORT $LN336@xmlSchemaV

; 2892 :                         xmlFree(prefix);

	mov	esi, esp
	mov	edx, DWORD PTR _prefix$33[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN336@xmlSchemaV:

; 2893 :                 }
; 2894 :                 if ((node == NULL) || (node->doc == NULL))

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN338@xmlSchemaV
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN337@xmlSchemaV
$LN338@xmlSchemaV:

; 2895 :                     ret = 3;

	mov	DWORD PTR _ret$[ebp], 3
$LN337@xmlSchemaV:

; 2896 :                 if (ret == 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN341@xmlSchemaV

; 2897 :                     ret = xmlValidateNotationUse(NULL, node->doc, value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	push	0
	call	_xmlValidateNotationUse
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 2898 :                     if (ret == 1)

	cmp	DWORD PTR _ret$[ebp], 1
	jne	SHORT $LN340@xmlSchemaV

; 2899 :                         ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
	jmp	SHORT $LN341@xmlSchemaV
$LN340@xmlSchemaV:

; 2900 :                     else
; 2901 :                         ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN341@xmlSchemaV:

; 2902 :                 }
; 2903 :                 if ((ret == 0) && (val != NULL)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN344@xmlSchemaV
	cmp	DWORD PTR _val$[ebp], 0
	je	$LN344@xmlSchemaV

; 2904 :                     v = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);

	push	28					; 0000001cH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2905 :                     if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN343@xmlSchemaV

; 2906 :                         if (local != NULL)

	cmp	DWORD PTR _local$34[ebp], 0
	je	SHORT $LN345@xmlSchemaV

; 2907 :                             v->value.qname.name = local;

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _local$34[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN346@xmlSchemaV
$LN345@xmlSchemaV:

; 2908 :                         else
; 2909 :                             v->value.qname.name = xmlStrdup(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN346@xmlSchemaV:

; 2910 :                         if (uri != NULL)

	cmp	DWORD PTR _uri$35[ebp], 0
	je	SHORT $LN347@xmlSchemaV

; 2911 :                             v->value.qname.uri = uri;

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _uri$35[ebp]
	mov	DWORD PTR [edx+12], eax
$LN347@xmlSchemaV:

; 2912 : 
; 2913 :                         *val = v;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx], edx

; 2914 :                     } else {

	jmp	SHORT $LN344@xmlSchemaV
$LN343@xmlSchemaV:

; 2915 :                         if (local != NULL)

	cmp	DWORD PTR _local$34[ebp], 0
	je	SHORT $LN348@xmlSchemaV

; 2916 :                             xmlFree(local);

	mov	esi, esp
	mov	eax, DWORD PTR _local$34[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN348@xmlSchemaV:

; 2917 :                         if (uri != NULL)

	cmp	DWORD PTR _uri$35[ebp], 0
	je	SHORT $LN349@xmlSchemaV

; 2918 :                             xmlFree(uri);

	mov	esi, esp
	mov	ecx, DWORD PTR _uri$35[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN349@xmlSchemaV:

; 2919 :                         goto error;

	jmp	$error$544
$LN344@xmlSchemaV:

; 2920 :                     }
; 2921 :                 }
; 2922 :                 goto done;

	jmp	$done$543
$LN350@xmlSchemaV:

; 2923 :             }
; 2924 :         case XML_SCHEMAS_ANYURI:{
; 2925 :                 if (*value != 0) {

	mov	edx, DWORD PTR _value$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN351@xmlSchemaV

; 2926 : 		    xmlURIPtr uri;
; 2927 : 		    xmlChar *tmpval, *cur;
; 2928 : 		    if (normOnTheFly) {

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN353@xmlSchemaV

; 2929 : 			norm = xmlSchemaCollapseString(value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	DWORD PTR _norm$[ebp], eax

; 2930 : 			if (norm != NULL)

	cmp	DWORD PTR _norm$[ebp], 0
	je	SHORT $LN353@xmlSchemaV

; 2931 : 			    value = norm;

	mov	edx, DWORD PTR _norm$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN353@xmlSchemaV:

; 2932 : 		    }
; 2933 : 		    tmpval = xmlStrdup(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _tmpval$30[ebp], eax

; 2934 : 		    for (cur = tmpval; *cur; ++cur) {

	mov	ecx, DWORD PTR _tmpval$30[ebp]
	mov	DWORD PTR _cur$29[ebp], ecx
	jmp	SHORT $LN46@xmlSchemaV
$LN44@xmlSchemaV:
	mov	edx, DWORD PTR _cur$29[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$29[ebp], edx
$LN46@xmlSchemaV:
	mov	eax, DWORD PTR _cur$29[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN45@xmlSchemaV

; 2935 : 			if (*cur < 32 || *cur >= 127 || *cur == ' ' ||
; 2936 : 			    *cur == '<' || *cur == '>' || *cur == '"' ||
; 2937 : 			    *cur == '{' || *cur == '}' || *cur == '|' ||
; 2938 : 			    *cur == '\\' || *cur == '^' || *cur == '`' ||

	mov	edx, DWORD PTR _cur$29[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jl	$LN355@xmlSchemaV
	mov	ecx, DWORD PTR _cur$29[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 127				; 0000007fH
	jge	$LN355@xmlSchemaV
	mov	eax, DWORD PTR _cur$29[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	$LN355@xmlSchemaV
	mov	edx, DWORD PTR _cur$29[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN355@xmlSchemaV
	mov	ecx, DWORD PTR _cur$29[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	je	SHORT $LN355@xmlSchemaV
	mov	eax, DWORD PTR _cur$29[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN355@xmlSchemaV
	mov	edx, DWORD PTR _cur$29[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN355@xmlSchemaV
	mov	ecx, DWORD PTR _cur$29[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 125				; 0000007dH
	je	SHORT $LN355@xmlSchemaV
	mov	eax, DWORD PTR _cur$29[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 124				; 0000007cH
	je	SHORT $LN355@xmlSchemaV
	mov	edx, DWORD PTR _cur$29[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN355@xmlSchemaV
	mov	ecx, DWORD PTR _cur$29[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 94					; 0000005eH
	je	SHORT $LN355@xmlSchemaV
	mov	eax, DWORD PTR _cur$29[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 96					; 00000060H
	je	SHORT $LN355@xmlSchemaV
	mov	edx, DWORD PTR _cur$29[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN354@xmlSchemaV
$LN355@xmlSchemaV:

; 2939 : 			    *cur == '\'')
; 2940 : 			    *cur = '_';

	mov	ecx, DWORD PTR _cur$29[ebp]
	mov	BYTE PTR [ecx], 95			; 0000005fH
$LN354@xmlSchemaV:

; 2941 : 		    }

	jmp	$LN44@xmlSchemaV
$LN45@xmlSchemaV:

; 2942 :                     uri = xmlParseURI((const char *) tmpval);

	mov	edx, DWORD PTR _tmpval$30[ebp]
	push	edx
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$31[ebp], eax

; 2943 : 		    xmlFree(tmpval);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpval$30[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2944 :                     if (uri == NULL)

	cmp	DWORD PTR _uri$31[ebp], 0
	jne	SHORT $LN356@xmlSchemaV

; 2945 :                         goto return1;

	jmp	$return1$546
$LN356@xmlSchemaV:

; 2946 :                     xmlFreeURI(uri);

	mov	ecx, DWORD PTR _uri$31[ebp]
	push	ecx
	call	_xmlFreeURI
	add	esp, 4
$LN351@xmlSchemaV:

; 2947 :                 }
; 2948 : 
; 2949 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN357@xmlSchemaV

; 2950 :                     v = xmlSchemaNewValue(XML_SCHEMAS_ANYURI);

	push	29					; 0000001dH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2951 :                     if (v == NULL)

	cmp	DWORD PTR _v$[ebp], 0
	jne	SHORT $LN358@xmlSchemaV

; 2952 :                         goto error;

	jmp	$error$544
$LN358@xmlSchemaV:

; 2953 :                     v->value.str = xmlStrdup(value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2954 :                     *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax
$LN357@xmlSchemaV:

; 2955 :                 }
; 2956 :                 goto return0;

	jmp	$return0$545
$LN359@xmlSchemaV:

; 2957 :             }
; 2958 :         case XML_SCHEMAS_HEXBINARY:{
; 2959 :                 const xmlChar *cur = value, *start;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$28[ebp], ecx

; 2960 :                 xmlChar *base;
; 2961 :                 int total, i = 0;

	mov	DWORD PTR _i$24[ebp], 0

; 2962 : 
; 2963 :                 if (cur == NULL)

	cmp	DWORD PTR _cur$28[ebp], 0
	jne	SHORT $LN360@xmlSchemaV

; 2964 :                     goto return1;

	jmp	$return1$546
$LN360@xmlSchemaV:

; 2965 : 
; 2966 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN48@xmlSchemaV
$LN47@xmlSchemaV:

; 2967 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	edx, DWORD PTR _cur$28[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN362@xmlSchemaV
	mov	ecx, DWORD PTR _cur$28[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN363@xmlSchemaV
	mov	eax, DWORD PTR _cur$28[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN362@xmlSchemaV
$LN363@xmlSchemaV:
	mov	edx, DWORD PTR _cur$28[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN48@xmlSchemaV
$LN362@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$28[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$28[ebp], ecx
	jmp	SHORT $LN47@xmlSchemaV
$LN48@xmlSchemaV:

; 2968 : 
; 2969 : 		start = cur;

	mov	edx, DWORD PTR _cur$28[ebp]
	mov	DWORD PTR _start$27[ebp], edx
$LN49@xmlSchemaV:

; 2970 :                 while (((*cur >= '0') && (*cur <= '9')) ||
; 2971 :                        ((*cur >= 'A') && (*cur <= 'F')) ||

	mov	eax, DWORD PTR _cur$28[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN365@xmlSchemaV
	mov	edx, DWORD PTR _cur$28[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN364@xmlSchemaV
$LN365@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$28[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN366@xmlSchemaV
	mov	eax, DWORD PTR _cur$28[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 70					; 00000046H
	jle	SHORT $LN364@xmlSchemaV
$LN366@xmlSchemaV:
	mov	edx, DWORD PTR _cur$28[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN50@xmlSchemaV
	mov	ecx, DWORD PTR _cur$28[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 102				; 00000066H
	jg	SHORT $LN50@xmlSchemaV
$LN364@xmlSchemaV:

; 2972 :                        ((*cur >= 'a') && (*cur <= 'f'))) {
; 2973 :                     i++;

	mov	eax, DWORD PTR _i$24[ebp]
	add	eax, 1
	mov	DWORD PTR _i$24[ebp], eax

; 2974 :                     cur++;

	mov	ecx, DWORD PTR _cur$28[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$28[ebp], ecx

; 2975 :                 }

	jmp	SHORT $LN49@xmlSchemaV
$LN50@xmlSchemaV:

; 2976 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN52@xmlSchemaV
$LN51@xmlSchemaV:

; 2977 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	edx, DWORD PTR _cur$28[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN368@xmlSchemaV
	mov	ecx, DWORD PTR _cur$28[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN369@xmlSchemaV
	mov	eax, DWORD PTR _cur$28[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN368@xmlSchemaV
$LN369@xmlSchemaV:
	mov	edx, DWORD PTR _cur$28[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN52@xmlSchemaV
$LN368@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$28[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$28[ebp], ecx
	jmp	SHORT $LN51@xmlSchemaV
$LN52@xmlSchemaV:

; 2978 : 
; 2979 :                 if (*cur != 0)

	mov	edx, DWORD PTR _cur$28[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN370@xmlSchemaV

; 2980 :                     goto return1;

	jmp	$return1$546
$LN370@xmlSchemaV:

; 2981 :                 if ((i % 2) != 0)

	mov	ecx, DWORD PTR _i$24[ebp]
	and	ecx, -2147483647			; 80000001H
	jns	SHORT $LN538@xmlSchemaV
	dec	ecx
	or	ecx, -2					; fffffffeH
	inc	ecx
$LN538@xmlSchemaV:
	test	ecx, ecx
	je	SHORT $LN371@xmlSchemaV

; 2982 :                     goto return1;

	jmp	$return1$546
$LN371@xmlSchemaV:

; 2983 : 
; 2984 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$LN372@xmlSchemaV

; 2985 : 
; 2986 :                     v = xmlSchemaNewValue(XML_SCHEMAS_HEXBINARY);

	push	43					; 0000002bH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 2987 :                     if (v == NULL)

	cmp	DWORD PTR _v$[ebp], 0
	jne	SHORT $LN373@xmlSchemaV

; 2988 :                         goto error;

	jmp	$error$544
$LN373@xmlSchemaV:

; 2989 : 		    /*
; 2990 : 		    * Copy only the normalized piece.
; 2991 : 		    * CRITICAL TODO: Check this.
; 2992 : 		    */
; 2993 :                     cur = xmlStrndup(start, i);

	mov	edx, DWORD PTR _i$24[ebp]
	push	edx
	mov	eax, DWORD PTR _start$27[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	DWORD PTR _cur$28[ebp], eax

; 2994 :                     if (cur == NULL) {

	cmp	DWORD PTR _cur$28[ebp], 0
	jne	SHORT $LN374@xmlSchemaV

; 2995 : 		        xmlSchemaTypeErrMemory(node, "allocating hexbin data");

	push	OFFSET ??_C@_0BH@DMAOOAAN@allocating?5hexbin?5data@
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlSchemaTypeErrMemory
	add	esp, 8

; 2996 :                         xmlFree(v);

	mov	esi, esp
	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2997 :                         goto return1;

	jmp	$return1$546
$LN374@xmlSchemaV:

; 2998 :                     }
; 2999 : 
; 3000 :                     total = i / 2;      /* number of octets */

	mov	eax, DWORD PTR _i$24[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _total$25[ebp], eax

; 3001 : 
; 3002 :                     base = (xmlChar *) cur;

	mov	eax, DWORD PTR _cur$28[ebp]
	mov	DWORD PTR _base$26[ebp], eax
$LN53@xmlSchemaV:

; 3003 :                     while (i-- > 0) {

	mov	ecx, DWORD PTR _i$24[ebp]
	mov	DWORD PTR tv1055[ebp], ecx
	mov	edx, DWORD PTR _i$24[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$24[ebp], edx
	cmp	DWORD PTR tv1055[ebp], 0
	jle	SHORT $LN517@xmlSchemaV
	mov	DWORD PTR tv1056[ebp], 1
	jmp	SHORT $LN518@xmlSchemaV
$LN517@xmlSchemaV:
	mov	DWORD PTR tv1056[ebp], 0
$LN518@xmlSchemaV:
	cmp	DWORD PTR tv1056[ebp], 0
	je	SHORT $LN54@xmlSchemaV

; 3004 :                         if (*base >= 'a')

	mov	eax, DWORD PTR _base$26[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN375@xmlSchemaV

; 3005 :                             *base = *base - ('a' - 'A');

	mov	edx, DWORD PTR _base$26[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _base$26[ebp]
	mov	BYTE PTR [ecx], al
$LN375@xmlSchemaV:

; 3006 :                         base++;

	mov	edx, DWORD PTR _base$26[ebp]
	add	edx, 1
	mov	DWORD PTR _base$26[ebp], edx

; 3007 :                     }

	jmp	SHORT $LN53@xmlSchemaV
$LN54@xmlSchemaV:

; 3008 : 
; 3009 :                     v->value.hex.str = (xmlChar *) cur;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _cur$28[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3010 :                     v->value.hex.total = total;

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _total$25[ebp]
	mov	DWORD PTR [edx+12], eax

; 3011 :                     *val = v;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx], edx
$LN372@xmlSchemaV:

; 3012 :                 }
; 3013 :                 goto return0;

	jmp	$return0$545
$LN376@xmlSchemaV:

; 3014 :             }
; 3015 :         case XML_SCHEMAS_BASE64BINARY:{
; 3016 :                 /* ISSUE:
; 3017 :                  *
; 3018 :                  * Ignore all stray characters? (yes, currently)
; 3019 :                  * Worry about long lines? (no, currently)
; 3020 :                  *
; 3021 :                  * rfc2045.txt:
; 3022 :                  *
; 3023 :                  * "The encoded output stream must be represented in lines of
; 3024 :                  * no more than 76 characters each.  All line breaks or other
; 3025 :                  * characters not found in Table 1 must be ignored by decoding
; 3026 :                  * software.  In base64 data, characters other than those in
; 3027 :                  * Table 1, line breaks, and other white space probably
; 3028 :                  * indicate a transmission error, about which a warning
; 3029 :                  * message or even a message rejection might be appropriate
; 3030 :                  * under some circumstances." */
; 3031 :                 const xmlChar *cur = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$23[ebp], eax

; 3032 :                 xmlChar *base;
; 3033 :                 int total, i = 0, pad = 0;

	mov	DWORD PTR _i$20[ebp], 0
	mov	DWORD PTR _pad$19[ebp], 0

; 3034 : 
; 3035 :                 if (cur == NULL)

	cmp	DWORD PTR _cur$23[ebp], 0
	jne	SHORT $LN377@xmlSchemaV

; 3036 :                     goto return1;

	jmp	$return1$546
$LN377@xmlSchemaV:

; 3037 : 
; 3038 :                 for (; *cur; ++cur) {

	jmp	SHORT $LN57@xmlSchemaV
$LN55@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$23[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$23[ebp], ecx
$LN57@xmlSchemaV:
	mov	edx, DWORD PTR _cur$23[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN56@xmlSchemaV

; 3039 :                     int decc;
; 3040 : 
; 3041 :                     decc = _xmlSchemaBase64Decode(*cur);

	mov	ecx, DWORD PTR _cur$23[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	__xmlSchemaBase64Decode
	add	esp, 4
	mov	DWORD PTR _decc$18[ebp], eax

; 3042 :                     if (decc < 0) ;

	cmp	DWORD PTR _decc$18[ebp], 0
	jge	SHORT $LN378@xmlSchemaV
	jmp	SHORT $LN381@xmlSchemaV
$LN378@xmlSchemaV:

; 3043 :                     else if (decc < 64)

	cmp	DWORD PTR _decc$18[ebp], 64		; 00000040H
	jge	SHORT $LN380@xmlSchemaV

; 3044 :                         i++;

	mov	eax, DWORD PTR _i$20[ebp]
	add	eax, 1
	mov	DWORD PTR _i$20[ebp], eax
	jmp	SHORT $LN381@xmlSchemaV
$LN380@xmlSchemaV:

; 3045 :                     else
; 3046 :                         break;

	jmp	SHORT $LN56@xmlSchemaV
$LN381@xmlSchemaV:

; 3047 :                 }

	jmp	SHORT $LN55@xmlSchemaV
$LN56@xmlSchemaV:

; 3048 :                 for (; *cur; ++cur) {

	jmp	SHORT $LN60@xmlSchemaV
$LN58@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$23[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$23[ebp], ecx
$LN60@xmlSchemaV:
	mov	edx, DWORD PTR _cur$23[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN59@xmlSchemaV

; 3049 :                     int decc;
; 3050 : 
; 3051 :                     decc = _xmlSchemaBase64Decode(*cur);

	mov	ecx, DWORD PTR _cur$23[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	__xmlSchemaBase64Decode
	add	esp, 4
	mov	DWORD PTR _decc$17[ebp], eax

; 3052 :                     if (decc < 0) ;

	cmp	DWORD PTR _decc$17[ebp], 0
	jge	SHORT $LN382@xmlSchemaV
	jmp	SHORT $LN384@xmlSchemaV
$LN382@xmlSchemaV:

; 3053 :                     else if (decc < 64)

	cmp	DWORD PTR _decc$17[ebp], 64		; 00000040H
	jge	SHORT $LN384@xmlSchemaV

; 3054 :                         goto return1;

	jmp	$return1$546
$LN384@xmlSchemaV:

; 3055 :                     if (decc == 64)

	cmp	DWORD PTR _decc$17[ebp], 64		; 00000040H
	jne	SHORT $LN385@xmlSchemaV

; 3056 :                         pad++;

	mov	eax, DWORD PTR _pad$19[ebp]
	add	eax, 1
	mov	DWORD PTR _pad$19[ebp], eax
$LN385@xmlSchemaV:

; 3057 :                 }

	jmp	SHORT $LN58@xmlSchemaV
$LN59@xmlSchemaV:

; 3058 : 
; 3059 :                 /* rfc2045.txt: "Special processing is performed if fewer than
; 3060 :                  * 24 bits are available at the end of the data being encoded.
; 3061 :                  * A full encoding quantum is always completed at the end of a
; 3062 :                  * body.  When fewer than 24 input bits are available in an
; 3063 :                  * input group, zero bits are added (on the right) to form an
; 3064 :                  * integral number of 6-bit groups.  Padding at the end of the
; 3065 :                  * data is performed using the "=" character.  Since all
; 3066 :                  * base64 input is an integral number of octets, only the
; 3067 :                  * following cases can arise: (1) the final quantum of
; 3068 :                  * encoding input is an integral multiple of 24 bits; here,
; 3069 :                  * the final unit of encoded output will be an integral
; 3070 :                  * multiple ofindent: Standard input:701: Warning:old style
; 3071 : 		 * assignment ambiguity in "=*".  Assuming "= *" 4 characters
; 3072 : 		 * with no "=" padding, (2) the final
; 3073 :                  * quantum of encoding input is exactly 8 bits; here, the
; 3074 :                  * final unit of encoded output will be two characters
; 3075 :                  * followed by two "=" padding characters, or (3) the final
; 3076 :                  * quantum of encoding input is exactly 16 bits; here, the
; 3077 :                  * final unit of encoded output will be three characters
; 3078 :                  * followed by one "=" padding character." */
; 3079 : 
; 3080 :                 total = 3 * (i / 4);

	mov	eax, DWORD PTR _i$20[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	imul	ecx, eax, 3
	mov	DWORD PTR _total$21[ebp], ecx

; 3081 :                 if (pad == 0) {

	cmp	DWORD PTR _pad$19[ebp], 0
	jne	SHORT $LN386@xmlSchemaV

; 3082 :                     if (i % 4 != 0)

	mov	edx, DWORD PTR _i$20[ebp]
	and	edx, -2147483645			; 80000003H
	jns	SHORT $LN539@xmlSchemaV
	dec	edx
	or	edx, -4					; fffffffcH
	inc	edx
$LN539@xmlSchemaV:
	test	edx, edx
	je	SHORT $LN388@xmlSchemaV

; 3083 :                         goto return1;

	jmp	$return1$546
$LN388@xmlSchemaV:

; 3084 :                 } else if (pad == 1) {

	jmp	$LN395@xmlSchemaV
$LN386@xmlSchemaV:
	cmp	DWORD PTR _pad$19[ebp], 1
	jne	$LN389@xmlSchemaV

; 3085 :                     int decc;
; 3086 : 
; 3087 :                     if (i % 4 != 3)

	mov	eax, DWORD PTR _i$20[ebp]
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN540@xmlSchemaV
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN540@xmlSchemaV:
	cmp	eax, 3
	je	SHORT $LN391@xmlSchemaV

; 3088 :                         goto return1;

	jmp	$return1$546
$LN391@xmlSchemaV:

; 3089 :                     for (decc = _xmlSchemaBase64Decode(*cur);

	mov	ecx, DWORD PTR _cur$23[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	__xmlSchemaBase64Decode
	add	esp, 4
	mov	DWORD PTR _decc$16[ebp], eax
	jmp	SHORT $LN63@xmlSchemaV
$LN61@xmlSchemaV:

; 3091 :                          decc = _xmlSchemaBase64Decode(*cur))

	mov	eax, DWORD PTR _cur$23[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	__xmlSchemaBase64Decode
	add	esp, 4
	mov	DWORD PTR _decc$16[ebp], eax
$LN63@xmlSchemaV:

; 3090 :                          (decc < 0) || (decc > 63);

	cmp	DWORD PTR _decc$16[ebp], 0
	jl	SHORT $LN392@xmlSchemaV
	cmp	DWORD PTR _decc$16[ebp], 63		; 0000003fH
	jle	SHORT $LN62@xmlSchemaV
$LN392@xmlSchemaV:

; 3092 :                         --cur;

	mov	edx, DWORD PTR _cur$23[ebp]
	sub	edx, 1
	mov	DWORD PTR _cur$23[ebp], edx
	jmp	SHORT $LN61@xmlSchemaV
$LN62@xmlSchemaV:

; 3093 :                     /* 16bits in 24bits means 2 pad bits: nnnnnn nnmmmm mmmm00*/
; 3094 :                     /* 00111100 -> 0x3c */
; 3095 :                     if (decc & ~0x3c)

	mov	eax, DWORD PTR _decc$16[ebp]
	and	eax, -61				; ffffffc3H
	je	SHORT $LN393@xmlSchemaV

; 3096 :                         goto return1;

	jmp	$return1$546
$LN393@xmlSchemaV:

; 3097 :                     total += 2;

	mov	ecx, DWORD PTR _total$21[ebp]
	add	ecx, 2
	mov	DWORD PTR _total$21[ebp], ecx
	jmp	$LN395@xmlSchemaV
$LN389@xmlSchemaV:

; 3098 :                 } else if (pad == 2) {

	cmp	DWORD PTR _pad$19[ebp], 2
	jne	$LN394@xmlSchemaV

; 3099 :                     int decc;
; 3100 : 
; 3101 :                     if (i % 4 != 2)

	mov	edx, DWORD PTR _i$20[ebp]
	and	edx, -2147483645			; 80000003H
	jns	SHORT $LN541@xmlSchemaV
	dec	edx
	or	edx, -4					; fffffffcH
	inc	edx
$LN541@xmlSchemaV:
	cmp	edx, 2
	je	SHORT $LN396@xmlSchemaV

; 3102 :                         goto return1;

	jmp	$return1$546
$LN396@xmlSchemaV:

; 3103 :                     for (decc = _xmlSchemaBase64Decode(*cur);

	mov	eax, DWORD PTR _cur$23[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	__xmlSchemaBase64Decode
	add	esp, 4
	mov	DWORD PTR _decc$15[ebp], eax
	jmp	SHORT $LN66@xmlSchemaV
$LN64@xmlSchemaV:

; 3105 :                          decc = _xmlSchemaBase64Decode(*cur))

	mov	edx, DWORD PTR _cur$23[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	__xmlSchemaBase64Decode
	add	esp, 4
	mov	DWORD PTR _decc$15[ebp], eax
$LN66@xmlSchemaV:

; 3104 :                          (decc < 0) || (decc > 63);

	cmp	DWORD PTR _decc$15[ebp], 0
	jl	SHORT $LN397@xmlSchemaV
	cmp	DWORD PTR _decc$15[ebp], 63		; 0000003fH
	jle	SHORT $LN65@xmlSchemaV
$LN397@xmlSchemaV:

; 3106 :                         --cur;

	mov	ecx, DWORD PTR _cur$23[ebp]
	sub	ecx, 1
	mov	DWORD PTR _cur$23[ebp], ecx
	jmp	SHORT $LN64@xmlSchemaV
$LN65@xmlSchemaV:

; 3107 :                     /* 8bits in 12bits means 4 pad bits: nnnnnn nn0000 */
; 3108 :                     /* 00110000 -> 0x30 */
; 3109 :                     if (decc & ~0x30)

	mov	edx, DWORD PTR _decc$15[ebp]
	and	edx, -49				; ffffffcfH
	je	SHORT $LN398@xmlSchemaV

; 3110 :                         goto return1;

	jmp	$return1$546
$LN398@xmlSchemaV:

; 3111 :                     total += 1;

	mov	eax, DWORD PTR _total$21[ebp]
	add	eax, 1
	mov	DWORD PTR _total$21[ebp], eax

; 3112 :                 } else

	jmp	SHORT $LN395@xmlSchemaV
$LN394@xmlSchemaV:

; 3113 :                     goto return1;

	jmp	$return1$546
$LN395@xmlSchemaV:

; 3114 : 
; 3115 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$LN399@xmlSchemaV

; 3116 :                     v = xmlSchemaNewValue(XML_SCHEMAS_BASE64BINARY);

	push	44					; 0000002cH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 3117 :                     if (v == NULL)

	cmp	DWORD PTR _v$[ebp], 0
	jne	SHORT $LN400@xmlSchemaV

; 3118 :                         goto error;

	jmp	$error$544
$LN400@xmlSchemaV:

; 3119 :                     base =

	mov	ecx, DWORD PTR _pad$19[ebp]
	mov	edx, DWORD PTR _i$20[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _base$22[ebp], eax

; 3120 :                         (xmlChar *) xmlMallocAtomic((i + pad + 1) *
; 3121 :                                                     sizeof(xmlChar));
; 3122 :                     if (base == NULL) {

	cmp	DWORD PTR _base$22[ebp], 0
	jne	SHORT $LN401@xmlSchemaV

; 3123 : 		        xmlSchemaTypeErrMemory(node, "allocating base64 data");

	push	OFFSET ??_C@_0BH@PBMCLKED@allocating?5base64?5data@
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlSchemaTypeErrMemory
	add	esp, 8

; 3124 :                         xmlFree(v);

	mov	esi, esp
	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3125 :                         goto return1;

	jmp	$return1$546
$LN401@xmlSchemaV:

; 3126 :                     }
; 3127 :                     v->value.base64.str = base;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _base$22[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3128 :                     for (cur = value; *cur; ++cur)

	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$23[ebp], edx
	jmp	SHORT $LN69@xmlSchemaV
$LN67@xmlSchemaV:
	mov	eax, DWORD PTR _cur$23[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$23[ebp], eax
$LN69@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$23[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN68@xmlSchemaV

; 3129 :                         if (_xmlSchemaBase64Decode(*cur) >= 0) {

	mov	eax, DWORD PTR _cur$23[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	__xmlSchemaBase64Decode
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN402@xmlSchemaV

; 3130 :                             *base = *cur;

	mov	edx, DWORD PTR _base$22[ebp]
	mov	eax, DWORD PTR _cur$23[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 3131 :                             ++base;

	mov	edx, DWORD PTR _base$22[ebp]
	add	edx, 1
	mov	DWORD PTR _base$22[ebp], edx
$LN402@xmlSchemaV:

; 3132 :                         }

	jmp	SHORT $LN67@xmlSchemaV
$LN68@xmlSchemaV:

; 3133 :                     *base = 0;

	mov	eax, DWORD PTR _base$22[ebp]
	mov	BYTE PTR [eax], 0

; 3134 :                     v->value.base64.total = total;

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _total$21[ebp]
	mov	DWORD PTR [ecx+12], edx

; 3135 :                     *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax], ecx
$LN399@xmlSchemaV:

; 3136 :                 }
; 3137 :                 goto return0;

	jmp	$return0$545
$LN403@xmlSchemaV:

; 3138 :             }
; 3139 :         case XML_SCHEMAS_INTEGER:
; 3140 :         case XML_SCHEMAS_PINTEGER:
; 3141 :         case XML_SCHEMAS_NPINTEGER:
; 3142 :         case XML_SCHEMAS_NINTEGER:
; 3143 :         case XML_SCHEMAS_NNINTEGER:{
; 3144 :                 const xmlChar *cur = value;

	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$14[ebp], edx

; 3145 :                 unsigned long lo, mi, hi;
; 3146 :                 int sign = 0;

	mov	DWORD PTR _sign$10[ebp], 0

; 3147 : 
; 3148 :                 if (cur == NULL)

	cmp	DWORD PTR _cur$14[ebp], 0
	jne	SHORT $LN404@xmlSchemaV

; 3149 :                     goto return1;

	jmp	$return1$546
$LN404@xmlSchemaV:

; 3150 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN71@xmlSchemaV
$LN70@xmlSchemaV:

; 3151 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	eax, DWORD PTR _cur$14[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN406@xmlSchemaV
	mov	edx, DWORD PTR _cur$14[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN407@xmlSchemaV
	mov	ecx, DWORD PTR _cur$14[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN406@xmlSchemaV
$LN407@xmlSchemaV:
	mov	eax, DWORD PTR _cur$14[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN71@xmlSchemaV
$LN406@xmlSchemaV:
	mov	edx, DWORD PTR _cur$14[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$14[ebp], edx
	jmp	SHORT $LN70@xmlSchemaV
$LN71@xmlSchemaV:

; 3152 :                 if (*cur == '-') {

	mov	eax, DWORD PTR _cur$14[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN408@xmlSchemaV

; 3153 :                     sign = 1;

	mov	DWORD PTR _sign$10[ebp], 1

; 3154 :                     cur++;

	mov	edx, DWORD PTR _cur$14[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$14[ebp], edx
	jmp	SHORT $LN410@xmlSchemaV
$LN408@xmlSchemaV:

; 3155 :                 } else if (*cur == '+')

	mov	eax, DWORD PTR _cur$14[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN410@xmlSchemaV

; 3156 :                     cur++;

	mov	edx, DWORD PTR _cur$14[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$14[ebp], edx
$LN410@xmlSchemaV:

; 3157 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);

	lea	eax, DWORD PTR _hi$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _mi$12[ebp]
	push	ecx
	lea	edx, DWORD PTR _lo$13[ebp]
	push	edx
	lea	eax, DWORD PTR _cur$14[ebp]
	push	eax
	call	_xmlSchemaParseUInt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 3158 :                 if (ret < 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN411@xmlSchemaV

; 3159 :                     goto return1;

	jmp	$return1$546
$LN411@xmlSchemaV:

; 3160 : 		if (normOnTheFly)

	cmp	DWORD PTR _normOnTheFly$[ebp], 0
	je	SHORT $LN73@xmlSchemaV
$LN72@xmlSchemaV:

; 3161 : 		    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	ecx, DWORD PTR _cur$14[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN413@xmlSchemaV
	mov	eax, DWORD PTR _cur$14[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN414@xmlSchemaV
	mov	edx, DWORD PTR _cur$14[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN413@xmlSchemaV
$LN414@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$14[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN73@xmlSchemaV
$LN413@xmlSchemaV:
	mov	eax, DWORD PTR _cur$14[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$14[ebp], eax
	jmp	SHORT $LN72@xmlSchemaV
$LN73@xmlSchemaV:

; 3162 :                 if (*cur != 0)

	mov	ecx, DWORD PTR _cur$14[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN415@xmlSchemaV

; 3163 :                     goto return1;

	jmp	$return1$546
$LN415@xmlSchemaV:

; 3164 :                 if (type->builtInType == XML_SCHEMAS_NPINTEGER) {

	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+88], 31			; 0000001fH
	jne	SHORT $LN416@xmlSchemaV

; 3165 :                     if ((sign == 0) &&

	cmp	DWORD PTR _sign$10[ebp], 0
	jne	SHORT $LN418@xmlSchemaV
	cmp	DWORD PTR _hi$11[ebp], 0
	jne	SHORT $LN419@xmlSchemaV
	cmp	DWORD PTR _mi$12[ebp], 0
	jne	SHORT $LN419@xmlSchemaV
	cmp	DWORD PTR _lo$13[ebp], 0
	je	SHORT $LN418@xmlSchemaV
$LN419@xmlSchemaV:

; 3166 :                         ((hi != 0) || (mi != 0) || (lo != 0)))
; 3167 :                         goto return1;

	jmp	$return1$546
$LN418@xmlSchemaV:

; 3168 :                 } else if (type->builtInType == XML_SCHEMAS_PINTEGER) {

	jmp	$LN429@xmlSchemaV
$LN416@xmlSchemaV:
	mov	ecx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [ecx+88], 34			; 00000022H
	jne	SHORT $LN420@xmlSchemaV

; 3169 :                     if (sign == 1)

	cmp	DWORD PTR _sign$10[ebp], 1
	jne	SHORT $LN422@xmlSchemaV

; 3170 :                         goto return1;

	jmp	$return1$546
$LN422@xmlSchemaV:

; 3171 :                     if ((hi == 0) && (mi == 0) && (lo == 0))

	cmp	DWORD PTR _hi$11[ebp], 0
	jne	SHORT $LN423@xmlSchemaV
	cmp	DWORD PTR _mi$12[ebp], 0
	jne	SHORT $LN423@xmlSchemaV
	cmp	DWORD PTR _lo$13[ebp], 0
	jne	SHORT $LN423@xmlSchemaV

; 3172 :                         goto return1;

	jmp	$return1$546
$LN423@xmlSchemaV:

; 3173 :                 } else if (type->builtInType == XML_SCHEMAS_NINTEGER) {

	jmp	SHORT $LN429@xmlSchemaV
$LN420@xmlSchemaV:
	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [edx+88], 32			; 00000020H
	jne	SHORT $LN424@xmlSchemaV

; 3174 :                     if (sign == 0)

	cmp	DWORD PTR _sign$10[ebp], 0
	jne	SHORT $LN426@xmlSchemaV

; 3175 :                         goto return1;

	jmp	$return1$546
$LN426@xmlSchemaV:

; 3176 :                     if ((hi == 0) && (mi == 0) && (lo == 0))

	cmp	DWORD PTR _hi$11[ebp], 0
	jne	SHORT $LN427@xmlSchemaV
	cmp	DWORD PTR _mi$12[ebp], 0
	jne	SHORT $LN427@xmlSchemaV
	cmp	DWORD PTR _lo$13[ebp], 0
	jne	SHORT $LN427@xmlSchemaV

; 3177 :                         goto return1;

	jmp	$return1$546
$LN427@xmlSchemaV:

; 3178 :                 } else if (type->builtInType == XML_SCHEMAS_NNINTEGER) {

	jmp	SHORT $LN429@xmlSchemaV
$LN424@xmlSchemaV:
	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+88], 33			; 00000021H
	jne	SHORT $LN429@xmlSchemaV

; 3179 :                     if ((sign == 1) &&

	cmp	DWORD PTR _sign$10[ebp], 1
	jne	SHORT $LN429@xmlSchemaV
	cmp	DWORD PTR _hi$11[ebp], 0
	jne	SHORT $LN430@xmlSchemaV
	cmp	DWORD PTR _mi$12[ebp], 0
	jne	SHORT $LN430@xmlSchemaV
	cmp	DWORD PTR _lo$13[ebp], 0
	je	SHORT $LN429@xmlSchemaV
$LN430@xmlSchemaV:

; 3180 :                         ((hi != 0) || (mi != 0) || (lo != 0)))
; 3181 :                         goto return1;

	jmp	$return1$546
$LN429@xmlSchemaV:

; 3182 :                 }
; 3183 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$LN432@xmlSchemaV

; 3184 :                     v = xmlSchemaNewValue(type->builtInType);

	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 3185 :                     if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	$LN432@xmlSchemaV

; 3186 : 			if (ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN433@xmlSchemaV

; 3187 : 			    ret++;

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, 1
	mov	DWORD PTR _ret$[ebp], eax
$LN433@xmlSchemaV:

; 3188 :                         v->value.decimal.lo = lo;

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _lo$13[ebp]
	mov	DWORD PTR [ecx+8], edx

; 3189 :                         v->value.decimal.mi = mi;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _mi$12[ebp]
	mov	DWORD PTR [eax+12], ecx

; 3190 :                         v->value.decimal.hi = hi;

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _hi$11[ebp]
	mov	DWORD PTR [edx+16], eax

; 3191 :                         v->value.decimal.sign = sign;

	mov	ecx, DWORD PTR _sign$10[ebp]
	and	ecx, 1
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, -2					; fffffffeH
	or	eax, ecx
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 3192 :                         v->value.decimal.frac = 0;

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, -255				; ffffff01H
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 3193 :                         v->value.decimal.total = ret;

	mov	edx, DWORD PTR _ret$[ebp]
	and	edx, 255				; 000000ffH
	shl	edx, 8
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, -65281				; ffff00ffH
	or	ecx, edx
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 3194 :                         *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax], ecx
$LN432@xmlSchemaV:

; 3195 :                     }
; 3196 :                 }
; 3197 :                 goto return0;

	jmp	$return0$545
$LN434@xmlSchemaV:

; 3198 :             }
; 3199 :         case XML_SCHEMAS_LONG:
; 3200 :         case XML_SCHEMAS_BYTE:
; 3201 :         case XML_SCHEMAS_SHORT:
; 3202 :         case XML_SCHEMAS_INT:{
; 3203 :                 const xmlChar *cur = value;

	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$9[ebp], edx

; 3204 :                 unsigned long lo, mi, hi;
; 3205 :                 int sign = 0;

	mov	DWORD PTR _sign$5[ebp], 0

; 3206 : 
; 3207 :                 if (cur == NULL)

	cmp	DWORD PTR _cur$9[ebp], 0
	jne	SHORT $LN435@xmlSchemaV

; 3208 :                     goto return1;

	jmp	$return1$546
$LN435@xmlSchemaV:

; 3209 :                 if (*cur == '-') {

	mov	eax, DWORD PTR _cur$9[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN436@xmlSchemaV

; 3210 :                     sign = 1;

	mov	DWORD PTR _sign$5[ebp], 1

; 3211 :                     cur++;

	mov	edx, DWORD PTR _cur$9[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$9[ebp], edx
	jmp	SHORT $LN438@xmlSchemaV
$LN436@xmlSchemaV:

; 3212 :                 } else if (*cur == '+')

	mov	eax, DWORD PTR _cur$9[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN438@xmlSchemaV

; 3213 :                     cur++;

	mov	edx, DWORD PTR _cur$9[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$9[ebp], edx
$LN438@xmlSchemaV:

; 3214 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);

	lea	eax, DWORD PTR _hi$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _mi$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _lo$8[ebp]
	push	edx
	lea	eax, DWORD PTR _cur$9[ebp]
	push	eax
	call	_xmlSchemaParseUInt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 3215 :                 if (ret < 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN439@xmlSchemaV

; 3216 :                     goto return1;

	jmp	$return1$546
$LN439@xmlSchemaV:

; 3217 :                 if (*cur != 0)

	mov	ecx, DWORD PTR _cur$9[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN440@xmlSchemaV

; 3218 :                     goto return1;

	jmp	$return1$546
$LN440@xmlSchemaV:

; 3219 :                 if (type->builtInType == XML_SCHEMAS_LONG) {

	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+88], 37			; 00000025H
	jne	SHORT $LN441@xmlSchemaV

; 3220 :                     if (hi >= 922) {

	cmp	DWORD PTR _hi$6[ebp], 922		; 0000039aH
	jb	SHORT $LN448@xmlSchemaV

; 3221 :                         if (hi > 922)

	cmp	DWORD PTR _hi$6[ebp], 922		; 0000039aH
	jbe	SHORT $LN444@xmlSchemaV

; 3222 :                             goto return1;

	jmp	$return1$546
$LN444@xmlSchemaV:

; 3223 :                         if (mi >= 33720368) {

	cmp	DWORD PTR _mi$7[ebp], 33720368		; 02028830H
	jb	SHORT $LN448@xmlSchemaV

; 3224 :                             if (mi > 33720368)

	cmp	DWORD PTR _mi$7[ebp], 33720368		; 02028830H
	jbe	SHORT $LN446@xmlSchemaV

; 3225 :                                 goto return1;

	jmp	$return1$546
$LN446@xmlSchemaV:

; 3226 :                             if ((sign == 0) && (lo > 54775807))

	cmp	DWORD PTR _sign$5[ebp], 0
	jne	SHORT $LN447@xmlSchemaV
	cmp	DWORD PTR _lo$8[ebp], 54775807		; 0343cfffH
	jbe	SHORT $LN447@xmlSchemaV

; 3227 :                                 goto return1;

	jmp	$return1$546
$LN447@xmlSchemaV:

; 3228 :                             if ((sign == 1) && (lo > 54775808))

	cmp	DWORD PTR _sign$5[ebp], 1
	jne	SHORT $LN448@xmlSchemaV
	cmp	DWORD PTR _lo$8[ebp], 54775808		; 0343d000H
	jbe	SHORT $LN448@xmlSchemaV

; 3229 :                                 goto return1;

	jmp	$return1$546
$LN448@xmlSchemaV:

; 3230 :                         }
; 3231 :                     }

	jmp	$LN466@xmlSchemaV
$LN441@xmlSchemaV:

; 3232 :                 } else if (type->builtInType == XML_SCHEMAS_INT) {

	mov	ecx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [ecx+88], 35			; 00000023H
	jne	SHORT $LN449@xmlSchemaV

; 3233 :                     if (hi != 0)

	cmp	DWORD PTR _hi$6[ebp], 0
	je	SHORT $LN451@xmlSchemaV

; 3234 :                         goto return1;

	jmp	$return1$546
$LN451@xmlSchemaV:

; 3235 :                     if (mi >= 21) {

	cmp	DWORD PTR _mi$7[ebp], 21		; 00000015H
	jb	SHORT $LN455@xmlSchemaV

; 3236 :                         if (mi > 21)

	cmp	DWORD PTR _mi$7[ebp], 21		; 00000015H
	jbe	SHORT $LN453@xmlSchemaV

; 3237 :                             goto return1;

	jmp	$return1$546
$LN453@xmlSchemaV:

; 3238 :                         if ((sign == 0) && (lo > 47483647))

	cmp	DWORD PTR _sign$5[ebp], 0
	jne	SHORT $LN454@xmlSchemaV
	cmp	DWORD PTR _lo$8[ebp], 47483647		; 02d48affH
	jbe	SHORT $LN454@xmlSchemaV

; 3239 :                             goto return1;

	jmp	$return1$546
$LN454@xmlSchemaV:

; 3240 :                         if ((sign == 1) && (lo > 47483648))

	cmp	DWORD PTR _sign$5[ebp], 1
	jne	SHORT $LN455@xmlSchemaV
	cmp	DWORD PTR _lo$8[ebp], 47483648		; 02d48b00H
	jbe	SHORT $LN455@xmlSchemaV

; 3241 :                             goto return1;

	jmp	$return1$546
$LN455@xmlSchemaV:

; 3242 :                     }

	jmp	$LN466@xmlSchemaV
$LN449@xmlSchemaV:

; 3243 :                 } else if (type->builtInType == XML_SCHEMAS_SHORT) {

	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [edx+88], 39			; 00000027H
	jne	SHORT $LN456@xmlSchemaV

; 3244 :                     if ((mi != 0) || (hi != 0))

	cmp	DWORD PTR _mi$7[ebp], 0
	jne	SHORT $LN459@xmlSchemaV
	cmp	DWORD PTR _hi$6[ebp], 0
	je	SHORT $LN458@xmlSchemaV
$LN459@xmlSchemaV:

; 3245 :                         goto return1;

	jmp	$return1$546
$LN458@xmlSchemaV:

; 3246 :                     if ((sign == 1) && (lo > 32768))

	cmp	DWORD PTR _sign$5[ebp], 1
	jne	SHORT $LN460@xmlSchemaV
	cmp	DWORD PTR _lo$8[ebp], 32768		; 00008000H
	jbe	SHORT $LN460@xmlSchemaV

; 3247 :                         goto return1;

	jmp	$return1$546
$LN460@xmlSchemaV:

; 3248 :                     if ((sign == 0) && (lo > 32767))

	cmp	DWORD PTR _sign$5[ebp], 0
	jne	SHORT $LN461@xmlSchemaV
	cmp	DWORD PTR _lo$8[ebp], 32767		; 00007fffH
	jbe	SHORT $LN461@xmlSchemaV

; 3249 :                         goto return1;

	jmp	$return1$546
$LN461@xmlSchemaV:

; 3250 :                 } else if (type->builtInType == XML_SCHEMAS_BYTE) {

	jmp	SHORT $LN466@xmlSchemaV
$LN456@xmlSchemaV:
	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+88], 41			; 00000029H
	jne	SHORT $LN466@xmlSchemaV

; 3251 :                     if ((mi != 0) || (hi != 0))

	cmp	DWORD PTR _mi$7[ebp], 0
	jne	SHORT $LN464@xmlSchemaV
	cmp	DWORD PTR _hi$6[ebp], 0
	je	SHORT $LN463@xmlSchemaV
$LN464@xmlSchemaV:

; 3252 :                         goto return1;

	jmp	$return1$546
$LN463@xmlSchemaV:

; 3253 :                     if ((sign == 1) && (lo > 128))

	cmp	DWORD PTR _sign$5[ebp], 1
	jne	SHORT $LN465@xmlSchemaV
	cmp	DWORD PTR _lo$8[ebp], 128		; 00000080H
	jbe	SHORT $LN465@xmlSchemaV

; 3254 :                         goto return1;

	jmp	$return1$546
$LN465@xmlSchemaV:

; 3255 :                     if ((sign == 0) && (lo > 127))

	cmp	DWORD PTR _sign$5[ebp], 0
	jne	SHORT $LN466@xmlSchemaV
	cmp	DWORD PTR _lo$8[ebp], 127		; 0000007fH
	jbe	SHORT $LN466@xmlSchemaV

; 3256 :                         goto return1;

	jmp	$return1$546
$LN466@xmlSchemaV:

; 3257 :                 }
; 3258 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$LN468@xmlSchemaV

; 3259 :                     v = xmlSchemaNewValue(type->builtInType);

	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 3260 :                     if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN468@xmlSchemaV

; 3261 :                         v->value.decimal.lo = lo;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _lo$8[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3262 :                         v->value.decimal.mi = mi;

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _mi$7[ebp]
	mov	DWORD PTR [edx+12], eax

; 3263 :                         v->value.decimal.hi = hi;

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _hi$6[ebp]
	mov	DWORD PTR [ecx+16], edx

; 3264 :                         v->value.decimal.sign = sign;

	mov	eax, DWORD PTR _sign$5[ebp]
	and	eax, 1
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, -2					; fffffffeH
	or	edx, eax
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+24], edx

; 3265 :                         v->value.decimal.frac = 0;

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, -255				; ffffff01H
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+24], edx

; 3266 :                         v->value.decimal.total = ret;

	mov	ecx, DWORD PTR _ret$[ebp]
	and	ecx, 255				; 000000ffH
	shl	ecx, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, -65281				; ffff00ffH
	or	eax, ecx
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 3267 :                         *val = v;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax
$LN468@xmlSchemaV:

; 3268 :                     }
; 3269 :                 }
; 3270 :                 goto return0;

	jmp	$return0$545
$LN469@xmlSchemaV:

; 3271 :             }
; 3272 :         case XML_SCHEMAS_UINT:
; 3273 :         case XML_SCHEMAS_ULONG:
; 3274 :         case XML_SCHEMAS_USHORT:
; 3275 :         case XML_SCHEMAS_UBYTE:{
; 3276 :                 const xmlChar *cur = value;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$4[ebp], ecx

; 3277 :                 unsigned long lo, mi, hi;
; 3278 : 
; 3279 :                 if (cur == NULL)

	cmp	DWORD PTR _cur$4[ebp], 0
	jne	SHORT $LN470@xmlSchemaV

; 3280 :                     goto return1;

	jmp	$return1$546
$LN470@xmlSchemaV:

; 3281 :                 ret = xmlSchemaParseUInt(&cur, &lo, &mi, &hi);

	lea	edx, DWORD PTR _hi$1[ebp]
	push	edx
	lea	eax, DWORD PTR _mi$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _lo$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _cur$4[ebp]
	push	edx
	call	_xmlSchemaParseUInt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 3282 :                 if (ret < 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN471@xmlSchemaV

; 3283 :                     goto return1;

	jmp	$return1$546
$LN471@xmlSchemaV:

; 3284 :                 if (*cur != 0)

	mov	eax, DWORD PTR _cur$4[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN472@xmlSchemaV

; 3285 :                     goto return1;

	jmp	$return1$546
$LN472@xmlSchemaV:

; 3286 :                 if (type->builtInType == XML_SCHEMAS_ULONG) {

	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [edx+88], 38			; 00000026H
	jne	SHORT $LN473@xmlSchemaV

; 3287 :                     if (hi >= 1844) {

	cmp	DWORD PTR _hi$1[ebp], 1844		; 00000734H
	jb	SHORT $LN479@xmlSchemaV

; 3288 :                         if (hi > 1844)

	cmp	DWORD PTR _hi$1[ebp], 1844		; 00000734H
	jbe	SHORT $LN476@xmlSchemaV

; 3289 :                             goto return1;

	jmp	$return1$546
$LN476@xmlSchemaV:

; 3290 :                         if (mi >= 67440737) {

	cmp	DWORD PTR _mi$2[ebp], 67440737		; 04051061H
	jb	SHORT $LN479@xmlSchemaV

; 3291 :                             if (mi > 67440737)

	cmp	DWORD PTR _mi$2[ebp], 67440737		; 04051061H
	jbe	SHORT $LN478@xmlSchemaV

; 3292 :                                 goto return1;

	jmp	$return1$546
$LN478@xmlSchemaV:

; 3293 :                             if (lo > 9551615)

	cmp	DWORD PTR _lo$3[ebp], 9551615		; 0091beffH
	jbe	SHORT $LN479@xmlSchemaV

; 3294 :                                 goto return1;

	jmp	$return1$546
$LN479@xmlSchemaV:

; 3295 :                         }
; 3296 :                     }

	jmp	$LN494@xmlSchemaV
$LN473@xmlSchemaV:

; 3297 :                 } else if (type->builtInType == XML_SCHEMAS_UINT) {

	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax+88], 36			; 00000024H
	jne	SHORT $LN480@xmlSchemaV

; 3298 :                     if (hi != 0)

	cmp	DWORD PTR _hi$1[ebp], 0
	je	SHORT $LN482@xmlSchemaV

; 3299 :                         goto return1;

	jmp	$return1$546
$LN482@xmlSchemaV:

; 3300 :                     if (mi >= 42) {

	cmp	DWORD PTR _mi$2[ebp], 42		; 0000002aH
	jb	SHORT $LN485@xmlSchemaV

; 3301 :                         if (mi > 42)

	cmp	DWORD PTR _mi$2[ebp], 42		; 0000002aH
	jbe	SHORT $LN484@xmlSchemaV

; 3302 :                             goto return1;

	jmp	$return1$546
$LN484@xmlSchemaV:

; 3303 :                         if (lo > 94967295)

	cmp	DWORD PTR _lo$3[ebp], 94967295		; 05a915ffH
	jbe	SHORT $LN485@xmlSchemaV

; 3304 :                             goto return1;

	jmp	$return1$546
$LN485@xmlSchemaV:

; 3305 :                     }

	jmp	SHORT $LN494@xmlSchemaV
$LN480@xmlSchemaV:

; 3306 :                 } else if (type->builtInType == XML_SCHEMAS_USHORT) {

	mov	ecx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [ecx+88], 40			; 00000028H
	jne	SHORT $LN486@xmlSchemaV

; 3307 :                     if ((mi != 0) || (hi != 0))

	cmp	DWORD PTR _mi$2[ebp], 0
	jne	SHORT $LN489@xmlSchemaV
	cmp	DWORD PTR _hi$1[ebp], 0
	je	SHORT $LN488@xmlSchemaV
$LN489@xmlSchemaV:

; 3308 :                         goto return1;

	jmp	$return1$546
$LN488@xmlSchemaV:

; 3309 :                     if (lo > 65535)

	cmp	DWORD PTR _lo$3[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN490@xmlSchemaV

; 3310 :                         goto return1;

	jmp	$return1$546
$LN490@xmlSchemaV:

; 3311 :                 } else if (type->builtInType == XML_SCHEMAS_UBYTE) {

	jmp	SHORT $LN494@xmlSchemaV
$LN486@xmlSchemaV:
	mov	edx, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [edx+88], 42			; 0000002aH
	jne	SHORT $LN494@xmlSchemaV

; 3312 :                     if ((mi != 0) || (hi != 0))

	cmp	DWORD PTR _mi$2[ebp], 0
	jne	SHORT $LN493@xmlSchemaV
	cmp	DWORD PTR _hi$1[ebp], 0
	je	SHORT $LN492@xmlSchemaV
$LN493@xmlSchemaV:

; 3313 :                         goto return1;

	jmp	$return1$546
$LN492@xmlSchemaV:

; 3314 :                     if (lo > 255)

	cmp	DWORD PTR _lo$3[ebp], 255		; 000000ffH
	jbe	SHORT $LN494@xmlSchemaV

; 3315 :                         goto return1;

	jmp	$return1$546
$LN494@xmlSchemaV:

; 3316 :                 }
; 3317 :                 if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$LN496@xmlSchemaV

; 3318 :                     v = xmlSchemaNewValue(type->builtInType);

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 3319 :                     if (v != NULL) {

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN496@xmlSchemaV

; 3320 :                         v->value.decimal.lo = lo;

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR _lo$3[ebp]
	mov	DWORD PTR [edx+8], eax

; 3321 :                         v->value.decimal.mi = mi;

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _mi$2[ebp]
	mov	DWORD PTR [ecx+12], edx

; 3322 :                         v->value.decimal.hi = hi;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _hi$1[ebp]
	mov	DWORD PTR [eax+16], ecx

; 3323 :                         v->value.decimal.sign = 0;

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 3324 :                         v->value.decimal.frac = 0;

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, -255				; ffffff01H
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 3325 :                         v->value.decimal.total = ret;

	mov	edx, DWORD PTR _ret$[ebp]
	and	edx, 255				; 000000ffH
	shl	edx, 8
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, -65281				; ffff00ffH
	or	ecx, edx
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 3326 :                         *val = v;

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax], ecx
$LN496@xmlSchemaV:

; 3327 :                     }
; 3328 :                 }
; 3329 :                 goto return0;

	jmp	SHORT $return0$545
$done$543:

; 3330 :             }
; 3331 :     }
; 3332 : 
; 3333 :   done:
; 3334 :     if (norm != NULL)

	cmp	DWORD PTR _norm$[ebp], 0
	je	SHORT $LN497@xmlSchemaV

; 3335 :         xmlFree(norm);

	mov	esi, esp
	mov	edx, DWORD PTR _norm$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN497@xmlSchemaV:

; 3336 :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlSchemaV
$return3$547:

; 3337 :   return3:
; 3338 :     if (norm != NULL)

	cmp	DWORD PTR _norm$[ebp], 0
	je	SHORT $LN498@xmlSchemaV

; 3339 :         xmlFree(norm);

	mov	esi, esp
	mov	eax, DWORD PTR _norm$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN498@xmlSchemaV:

; 3340 :     return (3);

	mov	eax, 3
	jmp	SHORT $LN1@xmlSchemaV
$return1$546:

; 3341 :   return1:
; 3342 :     if (norm != NULL)

	cmp	DWORD PTR _norm$[ebp], 0
	je	SHORT $LN499@xmlSchemaV

; 3343 :         xmlFree(norm);

	mov	esi, esp
	mov	ecx, DWORD PTR _norm$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN499@xmlSchemaV:

; 3344 :     return (1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaV
$return0$545:

; 3345 :   return0:
; 3346 :     if (norm != NULL)

	cmp	DWORD PTR _norm$[ebp], 0
	je	SHORT $LN500@xmlSchemaV

; 3347 :         xmlFree(norm);

	mov	esi, esp
	mov	edx, DWORD PTR _norm$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN500@xmlSchemaV:

; 3348 :     return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaV
$error$544:

; 3349 :   error:
; 3350 :     if (norm != NULL)

	cmp	DWORD PTR _norm$[ebp], 0
	je	SHORT $LN501@xmlSchemaV

; 3351 :         xmlFree(norm);

	mov	esi, esp
	mov	eax, DWORD PTR _norm$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN501@xmlSchemaV:

; 3352 :     return (-1);

	or	eax, -1
$LN1@xmlSchemaV:

; 3353 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN537@xmlSchemaV
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 496				; 000001f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN537@xmlSchemaV:
	DD	16					; 00000010H
	DD	$LN536@xmlSchemaV
$LN536@xmlSchemaV:
	DD	-72					; ffffffb8H
	DD	25					; 00000019H
	DD	$LN520@xmlSchemaV
	DD	-84					; ffffffacH
	DD	4
	DD	$LN521@xmlSchemaV
	DD	-136					; ffffff78H
	DD	4
	DD	$LN522@xmlSchemaV
	DD	-200					; ffffff38H
	DD	4
	DD	$LN523@xmlSchemaV
	DD	-284					; fffffee4H
	DD	4
	DD	$LN524@xmlSchemaV
	DD	-296					; fffffed8H
	DD	4
	DD	$LN525@xmlSchemaV
	DD	-308					; fffffeccH
	DD	4
	DD	$LN526@xmlSchemaV
	DD	-320					; fffffec0H
	DD	4
	DD	$LN527@xmlSchemaV
	DD	-336					; fffffeb0H
	DD	4
	DD	$LN528@xmlSchemaV
	DD	-348					; fffffea4H
	DD	4
	DD	$LN529@xmlSchemaV
	DD	-360					; fffffe98H
	DD	4
	DD	$LN530@xmlSchemaV
	DD	-372					; fffffe8cH
	DD	4
	DD	$LN531@xmlSchemaV
	DD	-388					; fffffe7cH
	DD	4
	DD	$LN532@xmlSchemaV
	DD	-400					; fffffe70H
	DD	4
	DD	$LN533@xmlSchemaV
	DD	-412					; fffffe64H
	DD	4
	DD	$LN534@xmlSchemaV
	DD	-424					; fffffe58H
	DD	4
	DD	$LN535@xmlSchemaV
$LN535@xmlSchemaV:
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
$LN534@xmlSchemaV:
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	0
$LN533@xmlSchemaV:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	0
$LN532@xmlSchemaV:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
$LN531@xmlSchemaV:
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
$LN530@xmlSchemaV:
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	0
$LN529@xmlSchemaV:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	0
$LN528@xmlSchemaV:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
$LN527@xmlSchemaV:
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
$LN526@xmlSchemaV:
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	0
$LN525@xmlSchemaV:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	0
$LN524@xmlSchemaV:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
$LN523@xmlSchemaV:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	0
$LN522@xmlSchemaV:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	0
$LN521@xmlSchemaV:
	DB	99					; 00000063H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN520@xmlSchemaV:
	DB	99					; 00000063H
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
	npad	1
$LN542@xmlSchemaV:
	DD	$LN83@xmlSchemaV
	DD	$LN88@xmlSchemaV
	DD	$LN110@xmlSchemaV
	DD	$LN123@xmlSchemaV
	DD	$LN154@xmlSchemaV
	DD	$LN155@xmlSchemaV
	DD	$LN156@xmlSchemaV
	DD	$LN207@xmlSchemaV
	DD	$LN239@xmlSchemaV
	DD	$LN251@xmlSchemaV
	DD	$LN258@xmlSchemaV
	DD	$LN263@xmlSchemaV
	DD	$LN266@xmlSchemaV
	DD	$LN273@xmlSchemaV
	DD	$LN288@xmlSchemaV
	DD	$LN292@xmlSchemaV
	DD	$LN302@xmlSchemaV
	DD	$LN308@xmlSchemaV
	DD	$LN312@xmlSchemaV
	DD	$LN322@xmlSchemaV
	DD	$LN328@xmlSchemaV
	DD	$LN350@xmlSchemaV
	DD	$LN403@xmlSchemaV
	DD	$LN434@xmlSchemaV
	DD	$LN469@xmlSchemaV
	DD	$LN359@xmlSchemaV
	DD	$LN376@xmlSchemaV
	DD	$LN84@xmlSchemaV
$LN519@xmlSchemaV:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	5
	DB	6
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
_xmlSchemaValAtomicType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaParseUInt
_TEXT	SEGMENT
_i$ = -28						; size = 4
_ret$ = -24						; size = 4
_cur$ = -20						; size = 4
_tmp$ = -16						; size = 4
_hi$ = -12						; size = 4
_mi$ = -8						; size = 4
_lo$ = -4						; size = 4
_str$ = 8						; size = 4
_llo$ = 12						; size = 4
_lmi$ = 16						; size = 4
_lhi$ = 20						; size = 4
_xmlSchemaParseUInt PROC				; COMDAT

; 2088 :                    unsigned long *lmi, unsigned long *lhi) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 2089 :     unsigned long lo = 0, mi = 0, hi = 0;

	mov	DWORD PTR _lo$[ebp], 0
	mov	DWORD PTR _mi$[ebp], 0
	mov	DWORD PTR _hi$[ebp], 0

; 2090 :     const xmlChar *tmp, *cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 2091 :     int ret = 0, i = 0;

	mov	DWORD PTR _ret$[ebp], 0
	mov	DWORD PTR _i$[ebp], 0

; 2092 : 
; 2093 :     if (!((*cur >= '0') && (*cur <= '9')))

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN13@xmlSchemaP
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN2@xmlSchemaP
$LN13@xmlSchemaP:

; 2094 :         return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlSchemaP
$LN2@xmlSchemaP:

; 2095 : 
; 2096 :     while (*cur == '0') {        /* ignore leading zeroes */

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN3@xmlSchemaP

; 2097 :         cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 2098 :     }

	jmp	SHORT $LN2@xmlSchemaP
$LN3@xmlSchemaP:

; 2099 :     tmp = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax
$LN4@xmlSchemaP:

; 2100 :     while ((*tmp != 0) && (*tmp >= '0') && (*tmp <= '9')) {

	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN5@xmlSchemaP
	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN5@xmlSchemaP
	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN5@xmlSchemaP

; 2101 :         i++;tmp++;ret++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx
	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, 1
	mov	DWORD PTR _ret$[ebp], eax

; 2102 :     }

	jmp	SHORT $LN4@xmlSchemaP
$LN5@xmlSchemaP:

; 2103 :     if (i > 24) {

	cmp	DWORD PTR _i$[ebp], 24			; 00000018H
	jle	SHORT $LN6@xmlSchemaP

; 2104 :         *str = tmp;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [ecx], edx

; 2105 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaP
$LN6@xmlSchemaP:

; 2106 :     }
; 2107 :     while (i > 16) {

	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jle	SHORT $LN8@xmlSchemaP

; 2108 :         hi = hi * 10 + (*cur++ - '0');

	imul	eax, DWORD PTR _hi$[ebp], 10
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-48]
	mov	DWORD PTR _hi$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 2109 :         i--;

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 2110 :     }

	jmp	SHORT $LN6@xmlSchemaP
$LN8@xmlSchemaP:

; 2111 :     while (i > 8) {

	cmp	DWORD PTR _i$[ebp], 8
	jle	SHORT $LN10@xmlSchemaP

; 2112 :         mi = mi * 10 + (*cur++ - '0');

	imul	eax, DWORD PTR _mi$[ebp], 10
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-48]
	mov	DWORD PTR _mi$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 2113 :         i--;

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 2114 :     }

	jmp	SHORT $LN8@xmlSchemaP
$LN10@xmlSchemaP:

; 2115 :     while (i > 0) {

	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN11@xmlSchemaP

; 2116 :         lo = lo * 10 + (*cur++ - '0');

	imul	eax, DWORD PTR _lo$[ebp], 10
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-48]
	mov	DWORD PTR _lo$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 2117 :         i--;

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 2118 :     }

	jmp	SHORT $LN10@xmlSchemaP
$LN11@xmlSchemaP:

; 2119 : 
; 2120 :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 2121 :     *llo = lo;

	mov	edx, DWORD PTR _llo$[ebp]
	mov	eax, DWORD PTR _lo$[ebp]
	mov	DWORD PTR [edx], eax

; 2122 :     *lmi = mi;

	mov	ecx, DWORD PTR _lmi$[ebp]
	mov	edx, DWORD PTR _mi$[ebp]
	mov	DWORD PTR [ecx], edx

; 2123 :     *lhi = hi;

	mov	eax, DWORD PTR _lhi$[ebp]
	mov	ecx, DWORD PTR _hi$[ebp]
	mov	DWORD PTR [eax], ecx

; 2124 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSchemaP:

; 2125 : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaParseUInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValAtomicListNode
_TEXT	SEGMENT
_tmp$ = -20						; size = 4
_nb_values$ = -16					; size = 4
_endval$ = -12						; size = 4
_cur$ = -8						; size = 4
_val$ = -4						; size = 4
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_ret$ = 16						; size = 4
_node$ = 20						; size = 4
_xmlSchemaValAtomicListNode PROC			; COMDAT

; 2019 : 	                   xmlSchemaValPtr *ret, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 2020 :     xmlChar *val, *cur, *endval;
; 2021 :     int nb_values = 0;

	mov	DWORD PTR _nb_values$[ebp], 0

; 2022 :     int tmp = 0;

	mov	DWORD PTR _tmp$[ebp], 0

; 2023 : 
; 2024 :     if (value == NULL) {

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN18@xmlSchemaV

; 2025 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN18@xmlSchemaV:

; 2026 :     }
; 2027 :     val = xmlStrdup(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 2028 :     if (val == NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN19@xmlSchemaV

; 2029 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN19@xmlSchemaV:

; 2030 :     }
; 2031 :     if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN20@xmlSchemaV

; 2032 :         *ret = NULL;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], 0
$LN20@xmlSchemaV:

; 2033 :     }
; 2034 :     cur = val;

	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _cur$[ebp], edx
$LN2@xmlSchemaV:

; 2035 :     /*
; 2036 :      * Split the list
; 2037 :      */
; 2038 :     while (IS_BLANK_CH(*cur)) *cur++ = 0;

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN21@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN22@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN21@xmlSchemaV
$LN22@xmlSchemaV:
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN4@xmlSchemaV
$LN21@xmlSchemaV:
	mov	edx, DWORD PTR _cur$[ebp]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN2@xmlSchemaV
$LN4@xmlSchemaV:

; 2039 :     while (*cur != 0) {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN5@xmlSchemaV

; 2040 : 	if (IS_BLANK_CH(*cur)) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN25@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN26@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN25@xmlSchemaV
$LN26@xmlSchemaV:
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN23@xmlSchemaV
$LN25@xmlSchemaV:

; 2041 : 	    *cur = 0;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	BYTE PTR [edx], 0

; 2042 : 	    cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
$LN6@xmlSchemaV:

; 2043 : 	    while (IS_BLANK_CH(*cur)) *cur++ = 0;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN27@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN28@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN27@xmlSchemaV
$LN28@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN7@xmlSchemaV
$LN27@xmlSchemaV:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN6@xmlSchemaV
$LN7@xmlSchemaV:

; 2044 : 	} else {

	jmp	SHORT $LN24@xmlSchemaV
$LN23@xmlSchemaV:

; 2045 : 	    nb_values++;

	mov	edx, DWORD PTR _nb_values$[ebp]
	add	edx, 1
	mov	DWORD PTR _nb_values$[ebp], edx

; 2046 : 	    cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
$LN8@xmlSchemaV:

; 2047 : 	    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN24@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN24@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN29@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN24@xmlSchemaV
$LN29@xmlSchemaV:
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN24@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN8@xmlSchemaV
$LN24@xmlSchemaV:

; 2048 : 	}
; 2049 :     }

	jmp	$LN4@xmlSchemaV
$LN5@xmlSchemaV:

; 2050 :     if (nb_values == 0) {

	cmp	DWORD PTR _nb_values$[ebp], 0
	jne	SHORT $LN30@xmlSchemaV

; 2051 : 	xmlFree(val);

	mov	esi, esp
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2052 : 	return(nb_values);

	mov	eax, DWORD PTR _nb_values$[ebp]
	jmp	$LN1@xmlSchemaV
$LN30@xmlSchemaV:

; 2053 :     }
; 2054 :     endval = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _endval$[ebp], ecx

; 2055 :     cur = val;

	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _cur$[ebp], edx
$LN10@xmlSchemaV:

; 2056 :     while ((*cur == 0) && (cur != endval)) cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN12@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	edx, DWORD PTR _endval$[ebp]
	je	SHORT $LN12@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN10@xmlSchemaV
$LN12@xmlSchemaV:

; 2057 :     while (cur != endval) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, DWORD PTR _endval$[ebp]
	je	SHORT $LN13@xmlSchemaV

; 2058 : 	tmp = xmlSchemaValPredefTypeNode(type, cur, NULL, node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	call	_xmlSchemaValPredefTypeNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tmp$[ebp], eax

; 2059 : 	if (tmp != 0)

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN14@xmlSchemaV

; 2060 : 	    break;

	jmp	SHORT $LN13@xmlSchemaV
$LN14@xmlSchemaV:

; 2061 : 	while (*cur != 0) cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN16@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN14@xmlSchemaV
$LN16@xmlSchemaV:

; 2062 : 	while ((*cur == 0) && (cur != endval)) cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN17@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, DWORD PTR _endval$[ebp]
	je	SHORT $LN17@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN16@xmlSchemaV
$LN17@xmlSchemaV:

; 2063 :     }

	jmp	SHORT $LN12@xmlSchemaV
$LN13@xmlSchemaV:

; 2064 :     /* TODO what return value ? c.f. bug #158628
; 2065 :     if (ret != NULL) {
; 2066 : 	TODO
; 2067 :     } */
; 2068 :     xmlFree(val);

	mov	esi, esp
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2069 :     if (tmp == 0)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN32@xmlSchemaV

; 2070 : 	return(nb_values);

	mov	eax, DWORD PTR _nb_values$[ebp]
	jmp	SHORT $LN1@xmlSchemaV
$LN32@xmlSchemaV:

; 2071 :     return(-1);

	or	eax, -1
$LN1@xmlSchemaV:

; 2072 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaValAtomicListNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaStrip
_TEXT	SEGMENT
_f$ = -12						; size = 4
_end$ = -8						; size = 4
_start$ = -4						; size = 4
_value$ = 8						; size = 4
_xmlSchemaStrip PROC					; COMDAT

; 1904 : xmlSchemaStrip(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1905 :     const xmlChar *start = value, *end, *f;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 1906 : 
; 1907 :     if (value == NULL) return(NULL);

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@xmlSchemaS
	xor	eax, eax
	jmp	$LN1@xmlSchemaS
$LN2@xmlSchemaS:

; 1908 :     while ((*start != 0) && (IS_BLANK_CH(*start))) start++;

	mov	ecx, DWORD PTR _start$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@xmlSchemaS
	mov	eax, DWORD PTR _start$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN9@xmlSchemaS
	mov	edx, DWORD PTR _start$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN10@xmlSchemaS
	mov	ecx, DWORD PTR _start$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN9@xmlSchemaS
$LN10@xmlSchemaS:
	mov	eax, DWORD PTR _start$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN3@xmlSchemaS
$LN9@xmlSchemaS:
	mov	edx, DWORD PTR _start$[ebp]
	add	edx, 1
	mov	DWORD PTR _start$[ebp], edx
	jmp	SHORT $LN2@xmlSchemaS
$LN3@xmlSchemaS:

; 1909 :     end = start;

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _end$[ebp], eax
$LN4@xmlSchemaS:

; 1910 :     while (*end != 0) end++;

	mov	ecx, DWORD PTR _end$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN5@xmlSchemaS
	mov	eax, DWORD PTR _end$[ebp]
	add	eax, 1
	mov	DWORD PTR _end$[ebp], eax
	jmp	SHORT $LN4@xmlSchemaS
$LN5@xmlSchemaS:

; 1911 :     f = end;

	mov	ecx, DWORD PTR _end$[ebp]
	mov	DWORD PTR _f$[ebp], ecx

; 1912 :     end--;

	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, 1
	mov	DWORD PTR _end$[ebp], edx
$LN6@xmlSchemaS:

; 1913 :     while ((end > start) && (IS_BLANK_CH(*end))) end--;

	mov	eax, DWORD PTR _end$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	jbe	SHORT $LN7@xmlSchemaS
	mov	ecx, DWORD PTR _end$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN11@xmlSchemaS
	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN12@xmlSchemaS
	mov	edx, DWORD PTR _end$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN11@xmlSchemaS
$LN12@xmlSchemaS:
	mov	ecx, DWORD PTR _end$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN7@xmlSchemaS
$LN11@xmlSchemaS:
	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
	jmp	SHORT $LN6@xmlSchemaS
$LN7@xmlSchemaS:

; 1914 :     end++;

	mov	ecx, DWORD PTR _end$[ebp]
	add	ecx, 1
	mov	DWORD PTR _end$[ebp], ecx

; 1915 :     if ((start == value) && (f == end)) return(NULL);

	mov	edx, DWORD PTR _start$[ebp]
	cmp	edx, DWORD PTR _value$[ebp]
	jne	SHORT $LN13@xmlSchemaS
	mov	eax, DWORD PTR _f$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jne	SHORT $LN13@xmlSchemaS
	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaS
$LN13@xmlSchemaS:

; 1916 :     return(xmlStrndup(start, end - start));

	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
$LN1@xmlSchemaS:

; 1917 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaStrip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateDuration
_TEXT	SEGMENT
tv205 = -128						; size = 4
tv82 = -124						; size = 4
tv81 = -120						; size = 4
_mult$1 = -116						; size = 8
_multi$ = -104						; size = 56
_desig$ = -40						; size = 6
_num_type$ = -28					; size = 4
_num$ = -24						; size = 8
_seq$ = -16						; size = 4
_isneg$ = -12						; size = 4
_dur$ = -8						; size = 4
_cur$ = -4						; size = 4
_type$ = 8						; size = 4
_duration$ = 12						; size = 4
_val$ = 16						; size = 4
_collapse$ = 20						; size = 4
_xmlSchemaValidateDuration PROC				; COMDAT

; 1789 : 			   int collapse) {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	edi
	lea	edi, DWORD PTR [ebp-128]
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1790 :     const xmlChar  *cur = duration;

	mov	eax, DWORD PTR _duration$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 1791 :     xmlSchemaValPtr dur;
; 1792 :     int isneg = 0;

	mov	DWORD PTR _isneg$[ebp], 0

; 1793 :     unsigned int seq = 0;

	mov	DWORD PTR _seq$[ebp], 0

; 1794 :     double         num;
; 1795 :     int            num_type = 0;  /* -1 = invalid, 0 = int, 1 = floating */

	mov	DWORD PTR _num_type$[ebp], 0

; 1796 :     const xmlChar  desig[]  = {'Y', 'M', 'D', 'H', 'M', 'S'};

	mov	BYTE PTR _desig$[ebp], 89		; 00000059H
	mov	BYTE PTR _desig$[ebp+1], 77		; 0000004dH
	mov	BYTE PTR _desig$[ebp+2], 68		; 00000044H
	mov	BYTE PTR _desig$[ebp+3], 72		; 00000048H
	mov	BYTE PTR _desig$[ebp+4], 77		; 0000004dH
	mov	BYTE PTR _desig$[ebp+5], 83		; 00000053H

; 1797 :     const double   multi[]  = { 0.0, 0.0, 86400.0, 3600.0, 60.0, 1.0, 0.0};

	xorps	xmm0, xmm0
	movsd	QWORD PTR _multi$[ebp], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _multi$[ebp+8], xmm0
	movsd	xmm0, QWORD PTR __real@40f5180000000000
	movsd	QWORD PTR _multi$[ebp+16], xmm0
	movsd	xmm0, QWORD PTR __real@40ac200000000000
	movsd	QWORD PTR _multi$[ebp+24], xmm0
	movsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR _multi$[ebp+32], xmm0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _multi$[ebp+40], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _multi$[ebp+48], xmm0

; 1798 : 
; 1799 :     if (duration == NULL)

	cmp	DWORD PTR _duration$[ebp], 0
	jne	SHORT $LN16@xmlSchemaV

; 1800 : 	return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN16@xmlSchemaV:

; 1801 : 
; 1802 :     if (collapse)

	cmp	DWORD PTR _collapse$[ebp], 0
	je	SHORT $LN3@xmlSchemaV
$LN2@xmlSchemaV:

; 1803 : 	while IS_WSP_BLANK_CH(*cur) cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN18@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN19@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN18@xmlSchemaV
$LN19@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@xmlSchemaV
$LN18@xmlSchemaV:
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN2@xmlSchemaV
$LN3@xmlSchemaV:

; 1804 : 
; 1805 :     if (*cur == '-') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN20@xmlSchemaV

; 1806 :         isneg = 1;

	mov	DWORD PTR _isneg$[ebp], 1

; 1807 :         cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
$LN20@xmlSchemaV:

; 1808 :     }
; 1809 : 
; 1810 :     /* duration must start with 'P' (after sign) */
; 1811 :     if (*cur++ != 'P')

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv81[ebp], edx
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	cmp	DWORD PTR tv81[ebp], 80			; 00000050H
	je	SHORT $LN54@xmlSchemaV
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN55@xmlSchemaV
$LN54@xmlSchemaV:
	mov	DWORD PTR tv82[ebp], 0
$LN55@xmlSchemaV:
	cmp	DWORD PTR tv82[ebp], 0
	je	SHORT $LN21@xmlSchemaV

; 1812 : 	return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaV
$LN21@xmlSchemaV:

; 1813 : 
; 1814 :     if (*cur == 0)

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN22@xmlSchemaV

; 1815 : 	return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaV
$LN22@xmlSchemaV:

; 1816 : 
; 1817 :     dur = xmlSchemaNewValue(XML_SCHEMAS_DURATION);

	push	12					; 0000000cH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _dur$[ebp], eax

; 1818 :     if (dur == NULL)

	cmp	DWORD PTR _dur$[ebp], 0
	jne	SHORT $LN23@xmlSchemaV

; 1819 : 	return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN23@xmlSchemaV:

; 1820 : 
; 1821 :     while (*cur != 0) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN5@xmlSchemaV

; 1822 : 
; 1823 :         /* input string should be empty or invalid date/time item */
; 1824 :         if (seq >= sizeof(desig))

	cmp	DWORD PTR _seq$[ebp], 6
	jb	SHORT $LN24@xmlSchemaV

; 1825 :             goto error;

	jmp	$error$60
$LN24@xmlSchemaV:

; 1826 : 
; 1827 :         /* T designator must be present for time items */
; 1828 :         if (*cur == 'T') {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 84					; 00000054H
	jne	SHORT $LN25@xmlSchemaV

; 1829 :             if (seq <= 3) {

	cmp	DWORD PTR _seq$[ebp], 3
	ja	SHORT $LN27@xmlSchemaV

; 1830 :                 seq = 3;

	mov	DWORD PTR _seq$[ebp], 3

; 1831 :                 cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 1832 :             } else

	jmp	SHORT $LN28@xmlSchemaV
$LN27@xmlSchemaV:

; 1833 :                 return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaV
$LN28@xmlSchemaV:

; 1834 :         } else if (seq == 3)

	jmp	SHORT $LN29@xmlSchemaV
$LN25@xmlSchemaV:
	cmp	DWORD PTR _seq$[ebp], 3
	jne	SHORT $LN29@xmlSchemaV

; 1835 :             goto error;

	jmp	$error$60
$LN29@xmlSchemaV:

; 1836 : 
; 1837 :         /* parse the number portion of the item */
; 1838 :         PARSE_NUM(num, cur, num_type);

	xorps	xmm0, xmm0
	movsd	QWORD PTR _num$[ebp], xmm0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN32@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN30@xmlSchemaV
$LN32@xmlSchemaV:
	mov	DWORD PTR _num_type$[ebp], -1
	jmp	SHORT $LN7@xmlSchemaV
$LN30@xmlSchemaV:
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN7@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN7@xmlSchemaV
	movsd	xmm0, QWORD PTR _num$[ebp]
	mulsd	xmm0, QWORD PTR __real@4024000000000000
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	sub	edx, 48					; 00000030H
	cvtsi2sd xmm1, edx
	addsd	xmm0, xmm1
	movsd	QWORD PTR _num$[ebp], xmm0
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN30@xmlSchemaV
$LN7@xmlSchemaV:
	cmp	DWORD PTR _num_type$[ebp], 0
	jne	$LN9@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	$LN9@xmlSchemaV
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _mult$1[ebp], xmm0
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN36@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	SHORT $LN34@xmlSchemaV
$LN36@xmlSchemaV:
	mov	DWORD PTR _num_type$[ebp], -1
	jmp	SHORT $LN35@xmlSchemaV
$LN34@xmlSchemaV:
	mov	DWORD PTR _num_type$[ebp], 1
$LN35@xmlSchemaV:
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN9@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN9@xmlSchemaV
	movsd	xmm0, QWORD PTR _mult$1[ebp]
	divsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR _mult$1[ebp], xmm0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 48					; 00000030H
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR _mult$1[ebp]
	addsd	xmm0, QWORD PTR _num$[ebp]
	movsd	QWORD PTR _num$[ebp], xmm0
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN35@xmlSchemaV
$LN9@xmlSchemaV:

; 1839 : 
; 1840 :         if ((num_type == -1) || (*cur == 0))

	cmp	DWORD PTR _num_type$[ebp], -1
	je	SHORT $LN38@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN37@xmlSchemaV
$LN38@xmlSchemaV:

; 1841 :             goto error;

	jmp	$error$60
$LN37@xmlSchemaV:

; 1842 : 
; 1843 :         /* update duration based on item type */
; 1844 :         while (seq < sizeof(desig)) {

	cmp	DWORD PTR _seq$[ebp], 6
	jae	$LN11@xmlSchemaV

; 1845 :             if (*cur == desig[seq]) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _seq$[ebp]
	movzx	edx, BYTE PTR _desig$[ebp+ecx]
	cmp	eax, edx
	jne	SHORT $LN39@xmlSchemaV

; 1846 : 
; 1847 :                 /* verify numeric type; only seconds can be float */
; 1848 :                 if ((num_type != 0) && (seq < (sizeof(desig)-1)))

	cmp	DWORD PTR _num_type$[ebp], 0
	je	SHORT $LN40@xmlSchemaV
	cmp	DWORD PTR _seq$[ebp], 5
	jae	SHORT $LN40@xmlSchemaV

; 1849 :                     goto error;

	jmp	$error$60
$LN40@xmlSchemaV:

; 1850 : 
; 1851 :                 switch (seq) {

	mov	eax, DWORD PTR _seq$[ebp]
	mov	DWORD PTR tv205[ebp], eax
	cmp	DWORD PTR tv205[ebp], 0
	je	SHORT $LN41@xmlSchemaV
	cmp	DWORD PTR tv205[ebp], 1
	je	SHORT $LN42@xmlSchemaV
	jmp	SHORT $LN43@xmlSchemaV
$LN41@xmlSchemaV:

; 1852 :                     case 0:
; 1853 :                         dur->value.dur.mon = (long)num * 12;

	cvttsd2si ecx, QWORD PTR _num$[ebp]
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _dur$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1854 :                         break;

	jmp	SHORT $LN12@xmlSchemaV
$LN42@xmlSchemaV:

; 1855 :                     case 1:
; 1856 :                         dur->value.dur.mon += (long)num;

	cvttsd2si ecx, QWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _dur$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _dur$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1857 :                         break;

	jmp	SHORT $LN12@xmlSchemaV
$LN43@xmlSchemaV:

; 1858 :                     default:
; 1859 :                         /* convert to seconds using multiplier */
; 1860 :                         dur->value.dur.sec += num * multi[seq];

	mov	ecx, DWORD PTR _seq$[ebp]
	movsd	xmm0, QWORD PTR _num$[ebp]
	mulsd	xmm0, QWORD PTR _multi$[ebp+ecx*8]
	mov	edx, DWORD PTR _dur$[ebp]
	addsd	xmm0, QWORD PTR [edx+16]
	mov	eax, DWORD PTR _dur$[ebp]
	movsd	QWORD PTR [eax+16], xmm0

; 1861 :                         seq++;

	mov	ecx, DWORD PTR _seq$[ebp]
	add	ecx, 1
	mov	DWORD PTR _seq$[ebp], ecx
$LN12@xmlSchemaV:

; 1862 :                         break;
; 1863 :                 }
; 1864 : 
; 1865 :                 break;          /* exit loop */

	jmp	SHORT $LN11@xmlSchemaV
$LN39@xmlSchemaV:

; 1866 :             }
; 1867 :             /* no date designators found? */
; 1868 :             if ((++seq == 3) || (seq == 6))

	mov	edx, DWORD PTR _seq$[ebp]
	add	edx, 1
	mov	DWORD PTR _seq$[ebp], edx
	cmp	DWORD PTR _seq$[ebp], 3
	je	SHORT $LN45@xmlSchemaV
	cmp	DWORD PTR _seq$[ebp], 6
	jne	SHORT $LN44@xmlSchemaV
$LN45@xmlSchemaV:

; 1869 :                 goto error;

	jmp	$error$60
$LN44@xmlSchemaV:

; 1870 :         }

	jmp	$LN37@xmlSchemaV
$LN11@xmlSchemaV:

; 1871 : 	cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 1872 : 	if (collapse)

	cmp	DWORD PTR _collapse$[ebp], 0
	je	SHORT $LN15@xmlSchemaV
$LN14@xmlSchemaV:

; 1873 : 	    while IS_WSP_BLANK_CH(*cur) cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN47@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN48@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN47@xmlSchemaV
$LN48@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN15@xmlSchemaV
$LN47@xmlSchemaV:
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN14@xmlSchemaV
$LN15@xmlSchemaV:

; 1874 :     }

	jmp	$LN23@xmlSchemaV
$LN5@xmlSchemaV:

; 1875 : 
; 1876 :     if (isneg) {

	cmp	DWORD PTR _isneg$[ebp], 0
	je	SHORT $LN49@xmlSchemaV

; 1877 :         dur->value.dur.mon = -dur->value.dur.mon;

	mov	ecx, DWORD PTR _dur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	neg	edx
	mov	eax, DWORD PTR _dur$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1878 :         dur->value.dur.day = -dur->value.dur.day;

	mov	ecx, DWORD PTR _dur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	neg	edx
	mov	eax, DWORD PTR _dur$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1879 :         dur->value.dur.sec = -dur->value.dur.sec;

	mov	ecx, DWORD PTR _dur$[ebp]
	movsd	xmm0, QWORD PTR [ecx+16]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	mov	edx, DWORD PTR _dur$[ebp]
	movsd	QWORD PTR [edx+16], xmm0
$LN49@xmlSchemaV:

; 1880 :     }
; 1881 : 
; 1882 :     if (val != NULL)

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN50@xmlSchemaV

; 1883 :         *val = dur;

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _dur$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN51@xmlSchemaV
$LN50@xmlSchemaV:

; 1884 :     else
; 1885 : 	xmlSchemaFreeValue(dur);

	mov	edx, DWORD PTR _dur$[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN51@xmlSchemaV:

; 1886 : 
; 1887 :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaV
$error$60:

; 1888 : 
; 1889 : error:
; 1890 :     if (dur != NULL)

	cmp	DWORD PTR _dur$[ebp], 0
	je	SHORT $LN52@xmlSchemaV

; 1891 : 	xmlSchemaFreeValue(dur);

	mov	eax, DWORD PTR _dur$[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN52@xmlSchemaV:

; 1892 :     return 1;

	mov	eax, 1
$LN1@xmlSchemaV:

; 1893 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN59@xmlSchemaV
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 128				; 00000080H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@xmlSchemaV:
	DD	2
	DD	$LN58@xmlSchemaV
$LN58@xmlSchemaV:
	DD	-40					; ffffffd8H
	DD	6
	DD	$LN56@xmlSchemaV
	DD	-104					; ffffff98H
	DD	56					; 00000038H
	DD	$LN57@xmlSchemaV
$LN57@xmlSchemaV:
	DB	109					; 0000006dH
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	0
$LN56@xmlSchemaV:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
_xmlSchemaValidateDuration ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateDates
_TEXT	SEGMENT
tv423 = -60						; size = 4
tv425 = -56						; size = 4
tv424 = -52						; size = 4
tv343 = -48						; size = 4
tv345 = -44						; size = 4
tv344 = -40						; size = 4
tv194 = -36						; size = 4
tv196 = -32						; size = 4
tv195 = -28						; size = 4
_rewnd$1 = -24						; size = 4
_cur$ = -16						; size = 4
_ret$ = -8						; size = 4
_dt$ = -4						; size = 4
_type$ = 8						; size = 4
_dateTime$ = 12						; size = 4
_val$ = 16						; size = 4
_collapse$ = 20						; size = 4
_xmlSchemaValidateDates PROC				; COMDAT

; 1566 : 			int collapse) {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1567 :     xmlSchemaValPtr dt;
; 1568 :     int ret;
; 1569 :     const xmlChar *cur = dateTime;

	mov	eax, DWORD PTR _dateTime$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 1570 : 
; 1571 : #define RETURN_TYPE_IF_VALID(t)					\
; 1572 :     if (IS_TZO_CHAR(*cur)) {					\
; 1573 : 	ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);	\
; 1574 : 	if (ret == 0) {						\
; 1575 : 	    if (*cur != 0)					\
; 1576 : 		goto error;					\
; 1577 : 	    dt->type = t;					\
; 1578 : 	    goto done;						\
; 1579 : 	}							\
; 1580 :     }
; 1581 : 
; 1582 :     if (dateTime == NULL)

	cmp	DWORD PTR _dateTime$[ebp], 0
	jne	SHORT $LN6@xmlSchemaV

; 1583 : 	return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN6@xmlSchemaV:

; 1584 : 
; 1585 :     if (collapse)

	cmp	DWORD PTR _collapse$[ebp], 0
	je	SHORT $LN3@xmlSchemaV
$LN2@xmlSchemaV:

; 1586 : 	while IS_WSP_BLANK_CH(*cur) cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN8@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN9@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN8@xmlSchemaV
$LN9@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@xmlSchemaV
$LN8@xmlSchemaV:
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN2@xmlSchemaV
$LN3@xmlSchemaV:

; 1587 : 
; 1588 :     if ((*cur != '-') && (*cur < '0') && (*cur > '9'))

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN10@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jge	SHORT $LN10@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN10@xmlSchemaV

; 1589 : 	return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaV
$LN10@xmlSchemaV:

; 1590 : 
; 1591 :     dt = xmlSchemaNewValue(XML_SCHEMAS_UNKNOWN);

	push	0
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _dt$[ebp], eax

; 1592 :     if (dt == NULL)

	cmp	DWORD PTR _dt$[ebp], 0
	jne	SHORT $LN11@xmlSchemaV

; 1593 : 	return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN11@xmlSchemaV:

; 1594 : 
; 1595 :     if ((cur[0] == '-') && (cur[1] == '-')) {

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	jne	$LN12@xmlSchemaV
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	jne	$LN12@xmlSchemaV

; 1596 : 	/*
; 1597 : 	 * It's an incomplete date (xs:gMonthDay, xs:gMonth or
; 1598 : 	 * xs:gDay)
; 1599 : 	 */
; 1600 : 	cur += 2;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 2
	mov	DWORD PTR _cur$[ebp], edx

; 1601 : 
; 1602 : 	/* is it an xs:gDay? */
; 1603 : 	if (*cur == '-') {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	$LN13@xmlSchemaV

; 1604 : 	    if (type == XML_SCHEMAS_GMONTH)

	cmp	DWORD PTR _type$[ebp], 6
	jne	SHORT $LN14@xmlSchemaV

; 1605 : 		goto error;

	jmp	$error$103
$LN14@xmlSchemaV:

; 1606 : 	  ++cur;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 1607 : 	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dt$[ebp]
	add	ecx, 8
	push	ecx
	call	__xmlSchemaParseGDay
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1608 : 	    if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN15@xmlSchemaV

; 1609 : 		goto error;

	jmp	$error$103
$LN15@xmlSchemaV:

; 1610 : 
; 1611 : 	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_GDAY);

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN17@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 90					; 0000005aH
	je	SHORT $LN17@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN17@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN18@xmlSchemaV
$LN17@xmlSchemaV:
	lea	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dt$[ebp]
	add	edx, 8
	push	edx
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN18@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN19@xmlSchemaV
	jmp	$error$103
$LN19@xmlSchemaV:
	mov	edx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [edx], 5
	jmp	$done$104
$LN18@xmlSchemaV:

; 1612 : 
; 1613 : 	    goto error;

	jmp	$error$103
$LN13@xmlSchemaV:

; 1614 : 	}
; 1615 : 
; 1616 : 	/*
; 1617 : 	 * it should be an xs:gMonthDay or xs:gMonth
; 1618 : 	 */
; 1619 : 	ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dt$[ebp]
	add	ecx, 8
	push	ecx
	call	__xmlSchemaParseGMonth
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1620 : 	if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN20@xmlSchemaV

; 1621 : 	    goto error;

	jmp	$error$103
$LN20@xmlSchemaV:

; 1622 : 
; 1623 :         /*
; 1624 :          * a '-' char could indicate this type is xs:gMonthDay or
; 1625 :          * a negative time zone offset. Check for xs:gMonthDay first.
; 1626 :          * Also the first three char's of a negative tzo (-MM:SS) can
; 1627 :          * appear to be a valid day; so even if the day portion
; 1628 :          * of the xs:gMonthDay verifies, we must insure it was not
; 1629 :          * a tzo.
; 1630 :          */
; 1631 :         if (*cur == '-') {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	$LN21@xmlSchemaV

; 1632 :             const xmlChar *rewnd = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rewnd$1[ebp], ecx

; 1633 :             cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 1634 : 
; 1635 : 	    ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dt$[ebp]
	add	ecx, 8
	push	ecx
	call	__xmlSchemaParseGDay
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1636 :             if ((ret == 0) && ((*cur == 0) || (*cur != ':'))) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN24@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN23@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	$LN24@xmlSchemaV
$LN23@xmlSchemaV:

; 1637 : 
; 1638 :                 /*
; 1639 :                  * we can use the VALID_MDAY macro to validate the month
; 1640 :                  * and day because the leap year test will flag year zero
; 1641 :                  * as a leap year (even though zero is an invalid year).
; 1642 : 		 * FUTURE TODO: Zero will become valid in XML Schema 1.1
; 1643 : 		 * probably.
; 1644 :                  */
; 1645 :                 if (VALID_MDAY((&(dt->value.date)))) {

	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN100@xmlSchemaV
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN100@xmlSchemaV:
	test	ecx, ecx
	jne	SHORT $LN76@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN77@xmlSchemaV
$LN76@xmlSchemaV:
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN77@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 15					; 0000000fH
	cmp	eax, DWORD PTR _daysInMonth[edx*4-4]
	ja	SHORT $LN80@xmlSchemaV
	mov	DWORD PTR tv195[ebp], 1
	jmp	SHORT $LN81@xmlSchemaV
$LN80@xmlSchemaV:
	mov	DWORD PTR tv195[ebp], 0
$LN81@xmlSchemaV:
	mov	eax, DWORD PTR tv195[ebp]
	mov	DWORD PTR tv196[ebp], eax
	jmp	SHORT $LN82@xmlSchemaV
$LN77@xmlSchemaV:
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 15					; 0000000fH
	cmp	edx, DWORD PTR _daysInMonthLeap[ecx*4-4]
	ja	SHORT $LN78@xmlSchemaV
	mov	DWORD PTR tv194[ebp], 1
	jmp	SHORT $LN79@xmlSchemaV
$LN78@xmlSchemaV:
	mov	DWORD PTR tv194[ebp], 0
$LN79@xmlSchemaV:
	mov	edx, DWORD PTR tv194[ebp]
	mov	DWORD PTR tv196[ebp], edx
$LN82@xmlSchemaV:
	cmp	DWORD PTR tv196[ebp], 0
	je	SHORT $LN24@xmlSchemaV

; 1646 : 
; 1647 : 	            RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTHDAY);

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN26@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	je	SHORT $LN26@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	je	SHORT $LN26@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN27@xmlSchemaV
$LN26@xmlSchemaV:
	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _dt$[ebp]
	add	eax, 8
	push	eax
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN27@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN28@xmlSchemaV
	jmp	$error$103
$LN28@xmlSchemaV:
	mov	eax, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [eax], 7
	jmp	$done$104
$LN27@xmlSchemaV:

; 1648 : 
; 1649 :                     goto error;

	jmp	$error$103
$LN24@xmlSchemaV:

; 1650 :                 }
; 1651 :             }
; 1652 : 
; 1653 :             /*
; 1654 :              * not xs:gMonthDay so rewind and check if just xs:gMonth
; 1655 :              * with an optional time zone.
; 1656 :              */
; 1657 :             cur = rewnd;

	mov	ecx, DWORD PTR _rewnd$1[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
$LN21@xmlSchemaV:

; 1658 :         }
; 1659 : 
; 1660 : 	RETURN_TYPE_IF_VALID(XML_SCHEMAS_GMONTH);

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN30@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 90					; 0000005aH
	je	SHORT $LN30@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN30@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN31@xmlSchemaV
$LN30@xmlSchemaV:
	lea	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dt$[ebp]
	add	edx, 8
	push	edx
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN31@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN32@xmlSchemaV
	jmp	$error$103
$LN32@xmlSchemaV:
	mov	edx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [edx], 6
	jmp	$done$104
$LN31@xmlSchemaV:

; 1661 : 
; 1662 : 	goto error;

	jmp	$error$103
$LN12@xmlSchemaV:

; 1663 :     }
; 1664 : 
; 1665 :     /*
; 1666 :      * It's a right-truncated date or an xs:time.
; 1667 :      * Try to parse an xs:time then fallback on right-truncated dates.
; 1668 :      */
; 1669 :     if ((*cur >= '0') && (*cur <= '9')) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	$LN37@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jg	$LN37@xmlSchemaV

; 1670 : 	ret = _xmlSchemaParseTime(&(dt->value.date), &cur);

	lea	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dt$[ebp]
	add	edx, 8
	push	edx
	call	__xmlSchemaParseTime
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1671 : 	if (ret == 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN37@xmlSchemaV

; 1672 : 	    /* it's an xs:time */
; 1673 : 	    RETURN_TYPE_IF_VALID(XML_SCHEMAS_TIME);

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN36@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	je	SHORT $LN36@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	je	SHORT $LN36@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN37@xmlSchemaV
$LN36@xmlSchemaV:
	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _dt$[ebp]
	add	eax, 8
	push	eax
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN37@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN38@xmlSchemaV
	jmp	$error$103
$LN38@xmlSchemaV:
	mov	eax, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [eax], 4
	jmp	$done$104
$LN37@xmlSchemaV:

; 1674 : 	}
; 1675 :     }
; 1676 : 
; 1677 :     /* fallback on date parsing */
; 1678 :     cur = dateTime;

	mov	ecx, DWORD PTR _dateTime$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 1679 : 
; 1680 :     ret = _xmlSchemaParseGYear(&(dt->value.date), &cur);

	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _dt$[ebp]
	add	eax, 8
	push	eax
	call	__xmlSchemaParseGYear
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1681 :     if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN39@xmlSchemaV

; 1682 : 	goto error;

	jmp	$error$103
$LN39@xmlSchemaV:

; 1683 : 
; 1684 :     /* is it an xs:gYear? */
; 1685 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEAR);

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN41@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	je	SHORT $LN41@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN41@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN42@xmlSchemaV
$LN41@xmlSchemaV:
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dt$[ebp]
	add	ecx, 8
	push	ecx
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN42@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN43@xmlSchemaV
	jmp	$error$103
$LN43@xmlSchemaV:
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [ecx], 8
	jmp	$done$104
$LN42@xmlSchemaV:

; 1686 : 
; 1687 :     if (*cur != '-')

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN44@xmlSchemaV

; 1688 : 	goto error;

	jmp	$error$103
$LN44@xmlSchemaV:

; 1689 :     cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 1690 : 
; 1691 :     ret = _xmlSchemaParseGMonth(&(dt->value.date), &cur);

	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _dt$[ebp]
	add	eax, 8
	push	eax
	call	__xmlSchemaParseGMonth
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1692 :     if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN45@xmlSchemaV

; 1693 : 	goto error;

	jmp	$error$103
$LN45@xmlSchemaV:

; 1694 : 
; 1695 :     /* is it an xs:gYearMonth? */
; 1696 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_GYEARMONTH);

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN47@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	je	SHORT $LN47@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN47@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN48@xmlSchemaV
$LN47@xmlSchemaV:
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dt$[ebp]
	add	ecx, 8
	push	ecx
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN48@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN49@xmlSchemaV
	jmp	$error$103
$LN49@xmlSchemaV:
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [ecx], 9
	jmp	$done$104
$LN48@xmlSchemaV:

; 1697 : 
; 1698 :     if (*cur != '-')

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN50@xmlSchemaV

; 1699 : 	goto error;

	jmp	$error$103
$LN50@xmlSchemaV:

; 1700 :     cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 1701 : 
; 1702 :     ret = _xmlSchemaParseGDay(&(dt->value.date), &cur);

	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _dt$[ebp]
	add	eax, 8
	push	eax
	call	__xmlSchemaParseGDay
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1703 :     if ((ret != 0) || !VALID_DATE((&(dt->value.date))))

	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN53@xmlSchemaV
	mov	ecx, DWORD PTR _dt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	$LN53@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 15					; 0000000fH
	cmp	eax, 1
	jb	$LN53@xmlSchemaV
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 15					; 0000000fH
	cmp	edx, 12					; 0000000cH
	ja	$LN53@xmlSchemaV
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN101@xmlSchemaV
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN101@xmlSchemaV:
	test	ecx, ecx
	jne	SHORT $LN83@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN84@xmlSchemaV
$LN83@xmlSchemaV:
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN84@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 15					; 0000000fH
	cmp	eax, DWORD PTR _daysInMonth[edx*4-4]
	ja	SHORT $LN87@xmlSchemaV
	mov	DWORD PTR tv344[ebp], 1
	jmp	SHORT $LN88@xmlSchemaV
$LN87@xmlSchemaV:
	mov	DWORD PTR tv344[ebp], 0
$LN88@xmlSchemaV:
	mov	eax, DWORD PTR tv344[ebp]
	mov	DWORD PTR tv345[ebp], eax
	jmp	SHORT $LN89@xmlSchemaV
$LN84@xmlSchemaV:
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 15					; 0000000fH
	cmp	edx, DWORD PTR _daysInMonthLeap[ecx*4-4]
	ja	SHORT $LN85@xmlSchemaV
	mov	DWORD PTR tv343[ebp], 1
	jmp	SHORT $LN86@xmlSchemaV
$LN85@xmlSchemaV:
	mov	DWORD PTR tv343[ebp], 0
$LN86@xmlSchemaV:
	mov	edx, DWORD PTR tv343[ebp]
	mov	DWORD PTR tv345[ebp], edx
$LN89@xmlSchemaV:
	cmp	DWORD PTR tv345[ebp], 0
	jne	SHORT $LN51@xmlSchemaV
$LN53@xmlSchemaV:

; 1704 : 	goto error;

	jmp	$error$103
$LN51@xmlSchemaV:

; 1705 : 
; 1706 :     /* is it an xs:date? */
; 1707 :     RETURN_TYPE_IF_VALID(XML_SCHEMAS_DATE);

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN55@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	je	SHORT $LN55@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	je	SHORT $LN55@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN56@xmlSchemaV
$LN55@xmlSchemaV:
	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _dt$[ebp]
	add	eax, 8
	push	eax
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN56@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN57@xmlSchemaV
	jmp	$error$103
$LN57@xmlSchemaV:
	mov	eax, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [eax], 10			; 0000000aH
	jmp	$done$104
$LN56@xmlSchemaV:

; 1708 : 
; 1709 :     if (*cur != 'T')

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 84					; 00000054H
	je	SHORT $LN58@xmlSchemaV

; 1710 : 	goto error;

	jmp	$error$103
$LN58@xmlSchemaV:

; 1711 :     cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 1712 : 
; 1713 :     /* it should be an xs:dateTime */
; 1714 :     ret = _xmlSchemaParseTime(&(dt->value.date), &cur);

	lea	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dt$[ebp]
	add	edx, 8
	push	edx
	call	__xmlSchemaParseTime
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1715 :     if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN59@xmlSchemaV

; 1716 : 	goto error;

	jmp	$error$103
$LN59@xmlSchemaV:

; 1717 : 
; 1718 :     ret = _xmlSchemaParseTimeZone(&(dt->value.date), &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dt$[ebp]
	add	ecx, 8
	push	ecx
	call	__xmlSchemaParseTimeZone
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1719 :     if (collapse)

	cmp	DWORD PTR _collapse$[ebp], 0
	je	SHORT $LN5@xmlSchemaV
$LN4@xmlSchemaV:

; 1720 : 	while IS_WSP_BLANK_CH(*cur) cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN61@xmlSchemaV
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN62@xmlSchemaV
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN61@xmlSchemaV
$LN62@xmlSchemaV:
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN5@xmlSchemaV
$LN61@xmlSchemaV:
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN4@xmlSchemaV
$LN5@xmlSchemaV:

; 1721 :     if ((ret != 0) || (*cur != 0) || (!(VALID_DATETIME((&(dt->value.date))))))

	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN70@xmlSchemaV
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	$LN70@xmlSchemaV
	mov	ecx, DWORD PTR _dt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	$LN70@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 15					; 0000000fH
	cmp	eax, 1
	jb	$LN70@xmlSchemaV
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 15					; 0000000fH
	cmp	edx, 12					; 0000000cH
	ja	$LN70@xmlSchemaV
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN102@xmlSchemaV
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN102@xmlSchemaV:
	test	ecx, ecx
	jne	SHORT $LN90@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN91@xmlSchemaV
$LN90@xmlSchemaV:
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN91@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 15					; 0000000fH
	cmp	eax, DWORD PTR _daysInMonth[edx*4-4]
	ja	SHORT $LN94@xmlSchemaV
	mov	DWORD PTR tv424[ebp], 1
	jmp	SHORT $LN95@xmlSchemaV
$LN94@xmlSchemaV:
	mov	DWORD PTR tv424[ebp], 0
$LN95@xmlSchemaV:
	mov	eax, DWORD PTR tv424[ebp]
	mov	DWORD PTR tv425[ebp], eax
	jmp	SHORT $LN96@xmlSchemaV
$LN91@xmlSchemaV:
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 15					; 0000000fH
	cmp	edx, DWORD PTR _daysInMonthLeap[ecx*4-4]
	ja	SHORT $LN92@xmlSchemaV
	mov	DWORD PTR tv423[ebp], 1
	jmp	SHORT $LN93@xmlSchemaV
$LN92@xmlSchemaV:
	mov	DWORD PTR tv423[ebp], 0
$LN93@xmlSchemaV:
	mov	edx, DWORD PTR tv423[ebp]
	mov	DWORD PTR tv425[ebp], edx
$LN96@xmlSchemaV:
	cmp	DWORD PTR tv425[ebp], 0
	je	$LN70@xmlSchemaV
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	jb	SHORT $LN69@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 9
	and	eax, 31					; 0000001fH
	cmp	eax, 23					; 00000017H
	ja	SHORT $LN69@xmlSchemaV
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 14					; 0000000eH
	and	edx, 63					; 0000003fH
	jb	SHORT $LN69@xmlSchemaV
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN69@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	movsd	xmm0, QWORD PTR [edx+16]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN69@xmlSchemaV
	mov	eax, DWORD PTR _dt$[ebp]
	movsd	xmm0, QWORD PTR __real@404e000000000000
	comisd	xmm0, QWORD PTR [eax+16]
	ja	SHORT $LN67@xmlSchemaV
$LN69@xmlSchemaV:
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 9
	and	edx, 31					; 0000001fH
	cmp	edx, 24					; 00000018H
	jne	SHORT $LN70@xmlSchemaV
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	jne	SHORT $LN70@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	movsd	xmm0, QWORD PTR [edx+16]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN70@xmlSchemaV
$LN67@xmlSchemaV:
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shl	ecx, 19					; 00000013H
	sar	ecx, 20					; 00000014H
	cmp	ecx, -840				; fffffcb8H
	jle	SHORT $LN70@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	cmp	eax, 840				; 00000348H
	jl	SHORT $LN63@xmlSchemaV
$LN70@xmlSchemaV:

; 1722 : 	goto error;

	jmp	SHORT $error$103
$LN63@xmlSchemaV:

; 1723 : 
; 1724 : 
; 1725 :     dt->type = XML_SCHEMAS_DATETIME;

	mov	ecx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [ecx], 11			; 0000000bH
$done$104:

; 1726 : 
; 1727 : done:
; 1728 : #if 1
; 1729 :     if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type))

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN71@xmlSchemaV
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN71@xmlSchemaV

; 1730 :         goto error;

	jmp	SHORT $error$103
$LN71@xmlSchemaV:

; 1731 : #else
; 1732 :     /*
; 1733 :      * insure the parsed type is equal to or less significant (right
; 1734 :      * truncated) than the desired type.
; 1735 :      */
; 1736 :     if ((type != XML_SCHEMAS_UNKNOWN) && (type != dt->type)) {
; 1737 : 
; 1738 :         /* time only matches time */
; 1739 :         if ((type == XML_SCHEMAS_TIME) && (dt->type == XML_SCHEMAS_TIME))
; 1740 :             goto error;
; 1741 : 
; 1742 :         if ((type == XML_SCHEMAS_DATETIME) &&
; 1743 :             ((dt->type != XML_SCHEMAS_DATE) ||
; 1744 :              (dt->type != XML_SCHEMAS_GYEARMONTH) ||
; 1745 :              (dt->type != XML_SCHEMAS_GYEAR)))
; 1746 :             goto error;
; 1747 : 
; 1748 :         if ((type == XML_SCHEMAS_DATE) &&
; 1749 :             ((dt->type != XML_SCHEMAS_GYEAR) ||
; 1750 :              (dt->type != XML_SCHEMAS_GYEARMONTH)))
; 1751 :             goto error;
; 1752 : 
; 1753 :         if ((type == XML_SCHEMAS_GYEARMONTH) && (dt->type != XML_SCHEMAS_GYEAR))
; 1754 :             goto error;
; 1755 : 
; 1756 :         if ((type == XML_SCHEMAS_GMONTHDAY) && (dt->type != XML_SCHEMAS_GMONTH))
; 1757 :             goto error;
; 1758 :     }
; 1759 : #endif
; 1760 : 
; 1761 :     if (val != NULL)

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN72@xmlSchemaV

; 1762 :         *val = dt;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN73@xmlSchemaV
$LN72@xmlSchemaV:

; 1763 :     else
; 1764 : 	xmlSchemaFreeValue(dt);

	mov	eax, DWORD PTR _dt$[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN73@xmlSchemaV:

; 1765 : 
; 1766 :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaV
$error$103:

; 1767 : 
; 1768 : error:
; 1769 :     if (dt != NULL)

	cmp	DWORD PTR _dt$[ebp], 0
	je	SHORT $LN74@xmlSchemaV

; 1770 : 	xmlSchemaFreeValue(dt);

	mov	ecx, DWORD PTR _dt$[ebp]
	push	ecx
	call	_xmlSchemaFreeValue
	add	esp, 4
$LN74@xmlSchemaV:

; 1771 :     return 1;

	mov	eax, 1
$LN1@xmlSchemaV:

; 1772 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN99@xmlSchemaV
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN99@xmlSchemaV:
	DD	1
	DD	$LN98@xmlSchemaV
$LN98@xmlSchemaV:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN97@xmlSchemaV
$LN97@xmlSchemaV:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
_xmlSchemaValidateDates ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaBase64Decode
_TEXT	SEGMENT
_ch$ = 8						; size = 1
__xmlSchemaBase64Decode PROC				; COMDAT

; 1485 : _xmlSchemaBase64Decode (const xmlChar ch) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1486 :     if (('A' <= ch) && (ch <= 'Z')) return ch - 'A';

	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN2@xmlSchemaB
	movzx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 90					; 0000005aH
	jg	SHORT $LN2@xmlSchemaB
	movzx	eax, BYTE PTR _ch$[ebp]
	sub	eax, 65					; 00000041H
	jmp	SHORT $LN1@xmlSchemaB
$LN2@xmlSchemaB:

; 1487 :     if (('a' <= ch) && (ch <= 'z')) return ch - 'a' + 26;

	movzx	edx, BYTE PTR _ch$[ebp]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN3@xmlSchemaB
	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN3@xmlSchemaB
	movzx	eax, BYTE PTR _ch$[ebp]
	sub	eax, 71					; 00000047H
	jmp	SHORT $LN1@xmlSchemaB
$LN3@xmlSchemaB:

; 1488 :     if (('0' <= ch) && (ch <= '9')) return ch - '0' + 52;

	movzx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN4@xmlSchemaB
	movzx	edx, BYTE PTR _ch$[ebp]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN4@xmlSchemaB
	movzx	eax, BYTE PTR _ch$[ebp]
	add	eax, 4
	jmp	SHORT $LN1@xmlSchemaB
$LN4@xmlSchemaB:

; 1489 :     if ('+' == ch) return 62;

	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN5@xmlSchemaB
	mov	eax, 62					; 0000003eH
	jmp	SHORT $LN1@xmlSchemaB
$LN5@xmlSchemaB:

; 1490 :     if ('/' == ch) return 63;

	movzx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN6@xmlSchemaB
	mov	eax, 63					; 0000003fH
	jmp	SHORT $LN1@xmlSchemaB
$LN6@xmlSchemaB:

; 1491 :     if ('=' == ch) return 64;

	movzx	edx, BYTE PTR _ch$[ebp]
	cmp	edx, 61					; 0000003dH
	jne	SHORT $LN7@xmlSchemaB
	mov	eax, 64					; 00000040H
	jmp	SHORT $LN1@xmlSchemaB
$LN7@xmlSchemaB:

; 1492 :     return -1;

	or	eax, -1
$LN1@xmlSchemaB:

; 1493 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__xmlSchemaBase64Decode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaParseTimeZone
_TEXT	SEGMENT
tv82 = -24						; size = 4
tv66 = -20						; size = 4
_tmp$1 = -16						; size = 4
_isneg$2 = -12						; size = 4
_ret$ = -8						; size = 4
_cur$ = -4						; size = 4
_dt$ = 8						; size = 4
_str$ = 12						; size = 4
__xmlSchemaParseTimeZone PROC				; COMDAT

; 1413 : _xmlSchemaParseTimeZone (xmlSchemaValDatePtr dt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1414 :     const xmlChar *cur;
; 1415 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1416 : 
; 1417 :     if (str == NULL)

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN4@xmlSchemaP

; 1418 : 	return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaP
$LN4@xmlSchemaP:

; 1419 :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 1420 : 
; 1421 :     switch (*cur) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 90			; 0000005aH
	ja	$LN24@xmlSchemaP
	mov	ecx, DWORD PTR tv66[ebp]
	movzx	edx, BYTE PTR $LN28@xmlSchemaP[ecx]
	jmp	DWORD PTR $LN29@xmlSchemaP[edx*4]
$LN5@xmlSchemaP:

; 1422 :     case 0:
; 1423 : 	dt->tz_flag = 0;

	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1424 : 	dt->tzo = 0;

	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -8191				; ffffe001H
	mov	edx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1425 : 	break;

	jmp	$LN2@xmlSchemaP
$LN6@xmlSchemaP:

; 1426 : 
; 1427 :     case 'Z':
; 1428 : 	dt->tz_flag = 1;

	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, 1
	mov	edx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1429 : 	dt->tzo = 0;

	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -8191				; ffffe001H
	mov	edx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1430 : 	cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 1431 : 	break;

	jmp	$LN2@xmlSchemaP
$LN7@xmlSchemaP:

; 1432 : 
; 1433 :     case '+':
; 1434 :     case '-': {
; 1435 : 	int isneg = 0, tmp = 0;

	mov	DWORD PTR _isneg$2[ebp], 0
	mov	DWORD PTR _tmp$1[ebp], 0

; 1436 : 	isneg = (*cur == '-');

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN26@xmlSchemaP
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN27@xmlSchemaP
$LN26@xmlSchemaP:
	mov	DWORD PTR tv82[ebp], 0
$LN27@xmlSchemaP:
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _isneg$2[ebp], eax

; 1437 : 
; 1438 : 	cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 1439 : 
; 1440 : 	PARSE_2_DIGITS(tmp, cur, ret);

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN10@xmlSchemaP
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN10@xmlSchemaP
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN10@xmlSchemaP
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN8@xmlSchemaP
$LN10@xmlSchemaP:
	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN9@xmlSchemaP
$LN8@xmlSchemaP:
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, 48					; 00000030H
	imul	edx, ecx, 10
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	lea	ecx, DWORD PTR [edx+eax-48]
	mov	DWORD PTR _tmp$1[ebp], ecx
$LN9@xmlSchemaP:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 2
	mov	DWORD PTR _cur$[ebp], edx

; 1441 : 	if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN11@xmlSchemaP

; 1442 : 	    return ret;

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlSchemaP
$LN11@xmlSchemaP:

; 1443 : 	if (!VALID_HOUR(tmp))

	cmp	DWORD PTR _tmp$1[ebp], 0
	jl	SHORT $LN13@xmlSchemaP
	cmp	DWORD PTR _tmp$1[ebp], 23		; 00000017H
	jle	SHORT $LN12@xmlSchemaP
$LN13@xmlSchemaP:

; 1444 : 	    return 2;

	mov	eax, 2
	jmp	$LN1@xmlSchemaP
$LN12@xmlSchemaP:

; 1445 : 
; 1446 : 	if (*cur != ':')

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	je	SHORT $LN14@xmlSchemaP

; 1447 : 	    return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaP
$LN14@xmlSchemaP:

; 1448 : 	cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 1449 : 
; 1450 : 	dt->tzo = tmp * 60;

	imul	eax, DWORD PTR _tmp$1[ebp], 60
	and	eax, 4095				; 00000fffH
	shl	eax, 1
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, -8191				; ffffe001H
	or	edx, eax
	mov	eax, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [eax+16], edx

; 1451 : 
; 1452 : 	PARSE_2_DIGITS(tmp, cur, ret);

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN17@xmlSchemaP
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN17@xmlSchemaP
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN17@xmlSchemaP
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN15@xmlSchemaP
$LN17@xmlSchemaP:
	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN16@xmlSchemaP
$LN15@xmlSchemaP:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, 48					; 00000030H
	imul	ecx, eax, 10
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	lea	eax, DWORD PTR [ecx+edx-48]
	mov	DWORD PTR _tmp$1[ebp], eax
$LN16@xmlSchemaP:
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 2
	mov	DWORD PTR _cur$[ebp], ecx

; 1453 : 	if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN18@xmlSchemaP

; 1454 : 	    return ret;

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlSchemaP
$LN18@xmlSchemaP:

; 1455 : 	if (!VALID_MIN(tmp))

	cmp	DWORD PTR _tmp$1[ebp], 0
	jl	SHORT $LN20@xmlSchemaP
	cmp	DWORD PTR _tmp$1[ebp], 59		; 0000003bH
	jle	SHORT $LN19@xmlSchemaP
$LN20@xmlSchemaP:

; 1456 : 	    return 2;

	mov	eax, 2
	jmp	$LN1@xmlSchemaP
$LN19@xmlSchemaP:

; 1457 : 
; 1458 : 	dt->tzo += tmp;

	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	add	eax, DWORD PTR _tmp$1[ebp]
	and	eax, 4095				; 00000fffH
	shl	eax, 1
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, -8191				; ffffe001H
	or	edx, eax
	mov	eax, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [eax+16], edx

; 1459 : 	if (isneg)

	cmp	DWORD PTR _isneg$2[ebp], 0
	je	SHORT $LN21@xmlSchemaP

; 1460 : 	    dt->tzo = - dt->tzo;

	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	shl	edx, 19					; 00000013H
	sar	edx, 20					; 00000014H
	neg	edx
	and	edx, 4095				; 00000fffH
	shl	edx, 1
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -8191				; ffffe001H
	or	ecx, edx
	mov	edx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN21@xmlSchemaP:

; 1461 : 
; 1462 : 	if (!VALID_TZO(dt->tzo))

	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	shl	ecx, 19					; 00000013H
	sar	ecx, 20					; 00000014H
	cmp	ecx, -840				; fffffcb8H
	jle	SHORT $LN23@xmlSchemaP
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	cmp	eax, 840				; 00000348H
	jl	SHORT $LN22@xmlSchemaP
$LN23@xmlSchemaP:

; 1463 : 	    return 2;

	mov	eax, 2
	jmp	SHORT $LN1@xmlSchemaP
$LN22@xmlSchemaP:

; 1464 : 
; 1465 : 	dt->tz_flag = 1;

	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	or	edx, 1
	mov	eax, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [eax+16], edx

; 1466 : 	break;

	jmp	SHORT $LN2@xmlSchemaP
$LN24@xmlSchemaP:

; 1467 :       }
; 1468 :     default:
; 1469 : 	return 1;

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaP
$LN2@xmlSchemaP:

; 1470 :     }
; 1471 : 
; 1472 :     *str = cur;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 1473 :     return 0;

	xor	eax, eax
$LN1@xmlSchemaP:

; 1474 : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlSchemaP:
	DD	$LN5@xmlSchemaP
	DD	$LN7@xmlSchemaP
	DD	$LN6@xmlSchemaP
	DD	$LN24@xmlSchemaP
$LN28@xmlSchemaP:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
__xmlSchemaParseTimeZone ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaParseTime
_TEXT	SEGMENT
_mult$1 = -20						; size = 8
_value$ = -12						; size = 4
_ret$ = -8						; size = 4
_cur$ = -4						; size = 4
_dt$ = 8						; size = 4
_str$ = 12						; size = 4
__xmlSchemaParseTime PROC				; COMDAT

; 1362 : _xmlSchemaParseTime (xmlSchemaValDatePtr dt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1363 :     const xmlChar *cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 1364 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1365 :     int value = 0;

	mov	DWORD PTR _value$[ebp], 0

; 1366 : 
; 1367 :     PARSE_2_DIGITS(value, cur, ret);

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN6@xmlSchemaP
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN6@xmlSchemaP
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN6@xmlSchemaP
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN4@xmlSchemaP
$LN6@xmlSchemaP:
	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN5@xmlSchemaP
$LN4@xmlSchemaP:
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, 48					; 00000030H
	imul	edx, ecx, 10
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	lea	ecx, DWORD PTR [edx+eax-48]
	mov	DWORD PTR _value$[ebp], ecx
$LN5@xmlSchemaP:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 2
	mov	DWORD PTR _cur$[ebp], edx

; 1368 :     if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN7@xmlSchemaP

; 1369 : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlSchemaP
$LN7@xmlSchemaP:

; 1370 :     if (*cur != ':')

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	je	SHORT $LN8@xmlSchemaP

; 1371 : 	return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaP
$LN8@xmlSchemaP:

; 1372 :     if (!VALID_HOUR(value) && value != 24 /* Allow end-of-day hour */)

	cmp	DWORD PTR _value$[ebp], 0
	jl	SHORT $LN10@xmlSchemaP
	cmp	DWORD PTR _value$[ebp], 23		; 00000017H
	jle	SHORT $LN9@xmlSchemaP
$LN10@xmlSchemaP:
	cmp	DWORD PTR _value$[ebp], 24		; 00000018H
	je	SHORT $LN9@xmlSchemaP

; 1373 : 	return 2;

	mov	eax, 2
	jmp	$LN1@xmlSchemaP
$LN9@xmlSchemaP:

; 1374 :     cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 1375 : 
; 1376 :     /* the ':' insures this string is xs:time */
; 1377 :     dt->hour = value;

	mov	eax, DWORD PTR _value$[ebp]
	and	eax, 31					; 0000001fH
	shl	eax, 9
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -15873				; ffffc1ffH
	or	edx, eax
	mov	eax, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1378 : 
; 1379 :     PARSE_2_DIGITS(value, cur, ret);

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN13@xmlSchemaP
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN13@xmlSchemaP
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN13@xmlSchemaP
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN11@xmlSchemaP
$LN13@xmlSchemaP:
	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN12@xmlSchemaP
$LN11@xmlSchemaP:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, 48					; 00000030H
	imul	ecx, eax, 10
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	lea	eax, DWORD PTR [ecx+edx-48]
	mov	DWORD PTR _value$[ebp], eax
$LN12@xmlSchemaP:
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 2
	mov	DWORD PTR _cur$[ebp], ecx

; 1380 :     if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN14@xmlSchemaP

; 1381 : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlSchemaP
$LN14@xmlSchemaP:

; 1382 :     if (!VALID_MIN(value))

	cmp	DWORD PTR _value$[ebp], 0
	jl	SHORT $LN16@xmlSchemaP
	cmp	DWORD PTR _value$[ebp], 59		; 0000003bH
	jle	SHORT $LN15@xmlSchemaP
$LN16@xmlSchemaP:

; 1383 : 	return 2;

	mov	eax, 2
	jmp	$LN1@xmlSchemaP
$LN15@xmlSchemaP:

; 1384 :     dt->min = value;

	mov	edx, DWORD PTR _value$[ebp]
	and	edx, 63					; 0000003fH
	shl	edx, 14					; 0000000eH
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -1032193				; fff03fffH
	or	ecx, edx
	mov	edx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1385 : 
; 1386 :     if (*cur != ':')

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	je	SHORT $LN17@xmlSchemaP

; 1387 : 	return 1;

	mov	eax, 1
	jmp	$LN1@xmlSchemaP
$LN17@xmlSchemaP:

; 1388 :     cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 1389 : 
; 1390 :     PARSE_FLOAT(dt->sec, cur, ret);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN20@xmlSchemaP
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN20@xmlSchemaP
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN20@xmlSchemaP
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 57					; 00000039H
	jle	SHORT $LN18@xmlSchemaP
$LN20@xmlSchemaP:
	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN19@xmlSchemaP
$LN18@xmlSchemaP:
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, 48					; 00000030H
	imul	eax, edx, 10
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	lea	edx, DWORD PTR [eax+ecx-48]
	cvtsi2sd xmm0, edx
	mov	eax, DWORD PTR _dt$[ebp]
	movsd	QWORD PTR [eax+8], xmm0
$LN19@xmlSchemaP:
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 2
	mov	DWORD PTR _cur$[ebp], ecx
	cmp	DWORD PTR _ret$[ebp], 0
	jne	$LN3@xmlSchemaP
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 46					; 0000002eH
	jne	$LN3@xmlSchemaP
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _mult$1[ebp], xmm0
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN23@xmlSchemaP
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN22@xmlSchemaP
$LN23@xmlSchemaP:
	mov	DWORD PTR _ret$[ebp], 1
$LN22@xmlSchemaP:
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN3@xmlSchemaP
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@xmlSchemaP
	movsd	xmm0, QWORD PTR _mult$1[ebp]
	divsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR _mult$1[ebp], xmm0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	sub	edx, 48					; 00000030H
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR _mult$1[ebp]
	mov	eax, DWORD PTR _dt$[ebp]
	addsd	xmm0, QWORD PTR [eax+8]
	mov	ecx, DWORD PTR _dt$[ebp]
	movsd	QWORD PTR [ecx+8], xmm0
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN22@xmlSchemaP
$LN3@xmlSchemaP:

; 1391 :     if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN24@xmlSchemaP

; 1392 : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlSchemaP
$LN24@xmlSchemaP:

; 1393 : 
; 1394 :     if (!VALID_TIME(dt))

	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	jb	SHORT $LN29@xmlSchemaP
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 9
	and	eax, 31					; 0000001fH
	cmp	eax, 23					; 00000017H
	ja	SHORT $LN29@xmlSchemaP
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 14					; 0000000eH
	and	edx, 63					; 0000003fH
	jb	SHORT $LN29@xmlSchemaP
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN29@xmlSchemaP
	mov	edx, DWORD PTR _dt$[ebp]
	movsd	xmm0, QWORD PTR [edx+8]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN29@xmlSchemaP
	mov	eax, DWORD PTR _dt$[ebp]
	movsd	xmm0, QWORD PTR __real@404e000000000000
	comisd	xmm0, QWORD PTR [eax+8]
	ja	SHORT $LN27@xmlSchemaP
$LN29@xmlSchemaP:
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 9
	and	edx, 31					; 0000001fH
	cmp	edx, 24					; 00000018H
	jne	SHORT $LN30@xmlSchemaP
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	jne	SHORT $LN30@xmlSchemaP
	mov	edx, DWORD PTR _dt$[ebp]
	movsd	xmm0, QWORD PTR [edx+8]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN30@xmlSchemaP
$LN27@xmlSchemaP:
	mov	eax, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	shl	ecx, 19					; 00000013H
	sar	ecx, 20					; 00000014H
	cmp	ecx, -840				; fffffcb8H
	jle	SHORT $LN30@xmlSchemaP
	mov	edx, DWORD PTR _dt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	shl	eax, 19					; 00000013H
	sar	eax, 20					; 00000014H
	cmp	eax, 840				; 00000348H
	jl	SHORT $LN25@xmlSchemaP
$LN30@xmlSchemaP:

; 1395 : 	return 2;

	mov	eax, 2
	jmp	SHORT $LN1@xmlSchemaP
$LN25@xmlSchemaP:

; 1396 : 
; 1397 :     *str = cur;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 1398 :     return 0;

	xor	eax, eax
$LN1@xmlSchemaP:

; 1399 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__xmlSchemaParseTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaParseGDay
_TEXT	SEGMENT
_value$ = -12						; size = 4
_ret$ = -8						; size = 4
_cur$ = -4						; size = 4
_dt$ = 8						; size = 4
_str$ = 12						; size = 4
__xmlSchemaParseGDay PROC				; COMDAT

; 1332 : _xmlSchemaParseGDay (xmlSchemaValDatePtr dt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1333 :     const xmlChar *cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 1334 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1335 :     unsigned int value = 0;

	mov	DWORD PTR _value$[ebp], 0

; 1336 : 
; 1337 :     PARSE_2_DIGITS(value, cur, ret);

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN4@xmlSchemaP
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN4@xmlSchemaP
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN4@xmlSchemaP
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN2@xmlSchemaP
$LN4@xmlSchemaP:
	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN3@xmlSchemaP
$LN2@xmlSchemaP:
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, 48					; 00000030H
	imul	edx, ecx, 10
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	lea	ecx, DWORD PTR [edx+eax-48]
	mov	DWORD PTR _value$[ebp], ecx
$LN3@xmlSchemaP:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 2
	mov	DWORD PTR _cur$[ebp], edx

; 1338 :     if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN5@xmlSchemaP

; 1339 : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlSchemaP
$LN5@xmlSchemaP:

; 1340 : 
; 1341 :     if (!VALID_DAY(value))

	cmp	DWORD PTR _value$[ebp], 1
	jb	SHORT $LN7@xmlSchemaP
	cmp	DWORD PTR _value$[ebp], 31		; 0000001fH
	jbe	SHORT $LN6@xmlSchemaP
$LN7@xmlSchemaP:

; 1342 : 	return 2;

	mov	eax, 2
	jmp	SHORT $LN1@xmlSchemaP
$LN6@xmlSchemaP:

; 1343 : 
; 1344 :     dt->day = value;

	mov	eax, DWORD PTR _value$[ebp]
	and	eax, 31					; 0000001fH
	shl	eax, 4
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -497				; fffffe0fH
	or	edx, eax
	mov	eax, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1345 :     *str = cur;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 1346 :     return 0;

	xor	eax, eax
$LN1@xmlSchemaP:

; 1347 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__xmlSchemaParseGDay ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaParseGMonth
_TEXT	SEGMENT
_value$ = -12						; size = 4
_ret$ = -8						; size = 4
_cur$ = -4						; size = 4
_dt$ = 8						; size = 4
_str$ = 12						; size = 4
__xmlSchemaParseGMonth PROC				; COMDAT

; 1302 : _xmlSchemaParseGMonth (xmlSchemaValDatePtr dt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1303 :     const xmlChar *cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 1304 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1305 :     unsigned int value = 0;

	mov	DWORD PTR _value$[ebp], 0

; 1306 : 
; 1307 :     PARSE_2_DIGITS(value, cur, ret);

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN4@xmlSchemaP
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN4@xmlSchemaP
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN4@xmlSchemaP
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN2@xmlSchemaP
$LN4@xmlSchemaP:
	mov	DWORD PTR _ret$[ebp], 1
	jmp	SHORT $LN3@xmlSchemaP
$LN2@xmlSchemaP:
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	sub	ecx, 48					; 00000030H
	imul	edx, ecx, 10
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	lea	ecx, DWORD PTR [edx+eax-48]
	mov	DWORD PTR _value$[ebp], ecx
$LN3@xmlSchemaP:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 2
	mov	DWORD PTR _cur$[ebp], edx

; 1308 :     if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN5@xmlSchemaP

; 1309 : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlSchemaP
$LN5@xmlSchemaP:

; 1310 : 
; 1311 :     if (!VALID_MONTH(value))

	cmp	DWORD PTR _value$[ebp], 1
	jb	SHORT $LN7@xmlSchemaP
	cmp	DWORD PTR _value$[ebp], 12		; 0000000cH
	jbe	SHORT $LN6@xmlSchemaP
$LN7@xmlSchemaP:

; 1312 : 	return 2;

	mov	eax, 2
	jmp	SHORT $LN1@xmlSchemaP
$LN6@xmlSchemaP:

; 1313 : 
; 1314 :     dt->mon = value;

	mov	eax, DWORD PTR _value$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -16				; fffffff0H
	or	edx, eax
	mov	eax, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1315 : 
; 1316 :     *str = cur;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 1317 :     return 0;

	xor	eax, eax
$LN1@xmlSchemaP:

; 1318 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__xmlSchemaParseGMonth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT __xmlSchemaParseGYear
_TEXT	SEGMENT
_digcnt$ = -16						; size = 4
_isneg$ = -12						; size = 4
_firstChar$ = -8					; size = 4
_cur$ = -4						; size = 4
_dt$ = 8						; size = 4
_str$ = 12						; size = 4
__xmlSchemaParseGYear PROC				; COMDAT

; 1209 : _xmlSchemaParseGYear (xmlSchemaValDatePtr dt, const xmlChar **str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1210 :     const xmlChar *cur = *str, *firstChar;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 1211 :     int isneg = 0, digcnt = 0;

	mov	DWORD PTR _isneg$[ebp], 0
	mov	DWORD PTR _digcnt$[ebp], 0

; 1212 : 
; 1213 :     if (((*cur < '0') || (*cur > '9')) &&
; 1214 : 	(*cur != '-') && (*cur != '+'))

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN5@xmlSchemaP
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN4@xmlSchemaP
$LN5@xmlSchemaP:
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN4@xmlSchemaP
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN4@xmlSchemaP

; 1215 : 	return -1;

	or	eax, -1
	jmp	$LN1@xmlSchemaP
$LN4@xmlSchemaP:

; 1216 : 
; 1217 :     if (*cur == '-') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN6@xmlSchemaP

; 1218 : 	isneg = 1;

	mov	DWORD PTR _isneg$[ebp], 1

; 1219 : 	cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
$LN6@xmlSchemaP:

; 1220 :     }
; 1221 : 
; 1222 :     firstChar = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _firstChar$[ebp], ecx
$LN2@xmlSchemaP:

; 1223 : 
; 1224 :     while ((*cur >= '0') && (*cur <= '9')) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@xmlSchemaP
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN3@xmlSchemaP

; 1225 : 	dt->year = dt->year * 10 + (*cur - '0');

	mov	eax, DWORD PTR _dt$[ebp]
	imul	ecx, DWORD PTR [eax], 10
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	edx, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [edx], ecx

; 1226 : 	cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 1227 : 	digcnt++;

	mov	ecx, DWORD PTR _digcnt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _digcnt$[ebp], ecx

; 1228 :     }

	jmp	SHORT $LN2@xmlSchemaP
$LN3@xmlSchemaP:

; 1229 : 
; 1230 :     /* year must be at least 4 digits (CCYY); over 4
; 1231 :      * digits cannot have a leading zero. */
; 1232 :     if ((digcnt < 4) || ((digcnt > 4) && (*firstChar == '0')))

	cmp	DWORD PTR _digcnt$[ebp], 4
	jl	SHORT $LN8@xmlSchemaP
	cmp	DWORD PTR _digcnt$[ebp], 4
	jle	SHORT $LN7@xmlSchemaP
	mov	edx, DWORD PTR _firstChar$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN7@xmlSchemaP
$LN8@xmlSchemaP:

; 1233 : 	return 1;

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaP
$LN7@xmlSchemaP:

; 1234 : 
; 1235 :     if (isneg)

	cmp	DWORD PTR _isneg$[ebp], 0
	je	SHORT $LN9@xmlSchemaP

; 1236 : 	dt->year = - dt->year;

	mov	ecx, DWORD PTR _dt$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	mov	eax, DWORD PTR _dt$[ebp]
	mov	DWORD PTR [eax], edx
$LN9@xmlSchemaP:

; 1237 : 
; 1238 :     if (!VALID_YEAR(dt->year))

	mov	ecx, DWORD PTR _dt$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN10@xmlSchemaP

; 1239 : 	return 2;

	mov	eax, 2
	jmp	SHORT $LN1@xmlSchemaP
$LN10@xmlSchemaP:

; 1240 : 
; 1241 :     *str = cur;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 1242 :     return 0;

	xor	eax, eax
$LN1@xmlSchemaP:

; 1243 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__xmlSchemaParseGYear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaFreeTypeEntry
_TEXT	SEGMENT
_type$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlSchemaFreeTypeEntry PROC				; COMDAT

; 623  : xmlSchemaFreeTypeEntry(void *type, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 624  :     xmlSchemaFreeType((xmlSchemaTypePtr) type);

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	call	_xmlSchemaFreeType
	add	esp, 4

; 625  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaFreeTypeEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaAddParticle
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_xmlSchemaAddParticle PROC				; COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 375  :     xmlSchemaParticlePtr ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 376  : 
; 377  :     ret = (xmlSchemaParticlePtr)

	mov	esi, esp
	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 378  : 	xmlMalloc(sizeof(xmlSchemaParticle));
; 379  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlSchemaA

; 380  : 	xmlSchemaTypeErrMemory(NULL, "allocating particle component");

	push	OFFSET ??_C@_0BO@IIFFCFND@allocating?5particle?5component@
	push	0
	call	_xmlSchemaTypeErrMemory
	add	esp, 8

; 381  : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaA
$LN2@xmlSchemaA:

; 382  :     }
; 383  :     memset(ret, 0, sizeof(xmlSchemaParticle));

	xor	eax, eax
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax

; 384  :     ret->type = XML_SCHEMA_TYPE_PARTICLE;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx], 25			; 00000019H

; 385  :     ret->minOccurs = 1;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+16], 1

; 386  :     ret->maxOccurs = 1;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+20], 1

; 387  :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSchemaA:

; 388  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaAddParticle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaInitBasicType
_TEXT	SEGMENT
tv83 = -12						; size = 4
tv77 = -8						; size = 4
_ret$ = -4						; size = 4
_name$ = 8						; size = 4
_type$ = 12						; size = 4
_baseType$ = 16						; size = 4
_xmlSchemaInitBasicType PROC				; COMDAT

; 267  : 		       xmlSchemaTypePtr baseType) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 268  :     xmlSchemaTypePtr ret;
; 269  : 
; 270  :     ret = (xmlSchemaTypePtr) xmlMalloc(sizeof(xmlSchemaType));

	mov	esi, esp
	push	120					; 00000078H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 271  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN6@xmlSchemaI

; 272  :         xmlSchemaTypeErrMemory(NULL, "could not initialize basic types");

	push	OFFSET ??_C@_0CB@OFGABCMP@could?5not?5initialize?5basic?5type@
	push	0
	call	_xmlSchemaTypeErrMemory
	add	esp, 8

; 273  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSchemaI
$LN6@xmlSchemaI:

; 274  :     }
; 275  :     memset(ret, 0, sizeof(xmlSchemaType));

	push	120					; 00000078H
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 276  :     ret->name = (const xmlChar *)name;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _name$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 277  :     ret->targetNamespace = XML_SCHEMAS_NAMESPACE_NAME;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+112], OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@

; 278  :     ret->type = XML_SCHEMA_TYPE_BASIC;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], 1

; 279  :     ret->baseType = baseType;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _baseType$[ebp]
	mov	DWORD PTR [edx+64], eax

; 280  :     ret->contentType = XML_SCHEMA_CONTENT_BASIC;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+52], 6

; 281  :     /*
; 282  :     * Primitive types.
; 283  :     */
; 284  :     switch (type) {

	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv77[ebp], edx
	mov	eax, DWORD PTR tv77[ebp]
	sub	eax, 1
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 43			; 0000002bH
	ja	SHORT $LN2@xmlSchemaI
	mov	ecx, DWORD PTR tv77[ebp]
	movzx	edx, BYTE PTR $LN13@xmlSchemaI[ecx]
	jmp	DWORD PTR $LN15@xmlSchemaI[edx*4]
$LN7@xmlSchemaI:

; 285  : 	case XML_SCHEMAS_STRING:
; 286  : 	case XML_SCHEMAS_DECIMAL:
; 287  : 	case XML_SCHEMAS_DATE:
; 288  : 	case XML_SCHEMAS_DATETIME:
; 289  : 	case XML_SCHEMAS_TIME:
; 290  : 	case XML_SCHEMAS_GYEAR:
; 291  : 	case XML_SCHEMAS_GYEARMONTH:
; 292  : 	case XML_SCHEMAS_GMONTH:
; 293  : 	case XML_SCHEMAS_GMONTHDAY:
; 294  : 	case XML_SCHEMAS_GDAY:
; 295  : 	case XML_SCHEMAS_DURATION:
; 296  : 	case XML_SCHEMAS_FLOAT:
; 297  : 	case XML_SCHEMAS_DOUBLE:
; 298  : 	case XML_SCHEMAS_BOOLEAN:
; 299  : 	case XML_SCHEMAS_ANYURI:
; 300  : 	case XML_SCHEMAS_HEXBINARY:
; 301  : 	case XML_SCHEMAS_BASE64BINARY:
; 302  : 	case XML_SCHEMAS_QNAME:
; 303  : 	case XML_SCHEMAS_NOTATION:
; 304  : 	    ret->flags |= XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	or	ecx, 16384				; 00004000H
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+48], ecx
$LN2@xmlSchemaI:

; 305  : 	    break;
; 306  : 	default:
; 307  : 	    break;
; 308  :     }
; 309  :     /*
; 310  :     * Set variety.
; 311  :     */
; 312  :     switch (type) {

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv83[ebp], eax
	mov	ecx, DWORD PTR tv83[ebp]
	sub	ecx, 19					; 00000013H
	mov	DWORD PTR tv83[ebp], ecx
	cmp	DWORD PTR tv83[ebp], 27			; 0000001bH
	ja	SHORT $LN11@xmlSchemaI
	mov	edx, DWORD PTR tv83[ebp]
	movzx	eax, BYTE PTR $LN14@xmlSchemaI[edx]
	jmp	DWORD PTR $LN16@xmlSchemaI[eax*4]
$LN9@xmlSchemaI:

; 313  : 	case XML_SCHEMAS_ANYTYPE:
; 314  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 315  : 	    break;

	jmp	SHORT $LN4@xmlSchemaI
$LN10@xmlSchemaI:

; 316  : 	case XML_SCHEMAS_IDREFS:
; 317  : 	case XML_SCHEMAS_NMTOKENS:
; 318  : 	case XML_SCHEMAS_ENTITIES:
; 319  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_LIST;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+48], edx

; 320  : 	    ret->facets = xmlSchemaNewMinLengthFacet(1);

	push	1
	call	_xmlSchemaNewMinLengthFacet
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 321  : 	    ret->flags |= XML_SCHEMAS_TYPE_HAS_FACETS;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+48]
	or	eax, 134217728				; 08000000H
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 322  : 	    break;

	jmp	SHORT $LN4@xmlSchemaI
$LN11@xmlSchemaI:

; 323  : 	default:
; 324  : 	    ret->flags |= XML_SCHEMAS_TYPE_VARIETY_ATOMIC;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+48]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+48], eax
$LN4@xmlSchemaI:

; 325  : 	    break;
; 326  :     }
; 327  :     xmlHashAddEntry2(xmlSchemaTypesBank, ret->name,

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	push	OFFSET ??_C@_0CB@PJCCKICC@http?3?1?1www?4w3?4org?12001?1XMLSchem@
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _xmlSchemaTypesBank
	push	edx
	call	_xmlHashAddEntry2
	add	esp, 16					; 00000010H

; 328  : 	             XML_SCHEMAS_NAMESPACE_NAME, ret);
; 329  :     ret->builtInType = type;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+88], ecx

; 330  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSchemaI:

; 331  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN15@xmlSchemaI:
	DD	$LN7@xmlSchemaI
	DD	$LN2@xmlSchemaI
$LN13@xmlSchemaI:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
$LN16@xmlSchemaI:
	DD	$LN10@xmlSchemaI
	DD	$LN9@xmlSchemaI
	DD	$LN11@xmlSchemaI
$LN14@xmlSchemaI:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
_xmlSchemaInitBasicType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNewMinLengthFacet
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_value$ = 8						; size = 4
_xmlSchemaNewMinLengthFacet PROC			; COMDAT

; 241  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 242  :     xmlSchemaFacetPtr ret;
; 243  : 
; 244  :     ret = xmlSchemaNewFacet();

	call	_xmlSchemaNewFacet
	mov	DWORD PTR _ret$[ebp], eax

; 245  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlSchemaN

; 246  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaN
$LN2@xmlSchemaN:

; 247  :     }
; 248  :     ret->type = XML_SCHEMA_FACET_MINLENGTH;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax], 1011			; 000003f3H

; 249  :     ret->val = xmlSchemaNewValue(XML_SCHEMAS_NNINTEGER);

	push	33					; 00000021H
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 250  :     if (ret->val == NULL) {

	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN3@xmlSchemaN

; 251  :         xmlFree(ret);

	mov	esi, esp
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 252  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaN
$LN3@xmlSchemaN:

; 253  :     }
; 254  :     ret->val->value.decimal.lo = value;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR [edx+8], eax

; 255  :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSchemaN:

; 256  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaNewMinLengthFacet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNewValue
_TEXT	SEGMENT
_value$ = -4						; size = 4
_type$ = 8						; size = 4
_xmlSchemaNewValue PROC					; COMDAT

; 227  : xmlSchemaNewValue(xmlSchemaValType type) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 228  :     xmlSchemaValPtr value;
; 229  : 
; 230  :     value = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	mov	esi, esp
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _value$[ebp], eax

; 231  :     if (value == NULL) {

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@xmlSchemaN

; 232  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaN
$LN2@xmlSchemaN:

; 233  :     }
; 234  :     memset(value, 0, sizeof(xmlSchemaVal));

	xor	eax, eax
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax

; 235  :     value->type = type;

	mov	edx, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx], eax

; 236  :     return(value);

	mov	eax, DWORD PTR _value$[ebp]
$LN1@xmlSchemaN:

; 237  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaNewValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaTypeErrMemory
_TEXT	SEGMENT
_node$ = 8						; size = 4
_extra$ = 12						; size = 4
_xmlSchemaTypeErrMemory PROC				; COMDAT

; 208  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 209  :     __xmlSimpleError(XML_FROM_DATATYPE, XML_ERR_NO_MEMORY, node, NULL, extra);

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	push	2
	push	15					; 0000000fH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 210  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaTypeErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetValType
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlSchemaGetValType PROC				; COMDAT

; 6154 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 6155 :     if (val == NULL)

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN2@xmlSchemaG

; 6156 :         return(XML_SCHEMAS_UNKNOWN);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaG
$LN2@xmlSchemaG:

; 6157 :     return (val->type);

	mov	eax, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [eax]
$LN1@xmlSchemaG:

; 6158 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaGetValType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCopyValue
_TEXT	SEGMENT
tv66 = -16						; size = 4
_cur$ = -12						; size = 4
_prev$ = -8						; size = 4
_ret$ = -4						; size = 4
_val$ = 8						; size = 4
_xmlSchemaCopyValue PROC				; COMDAT

; 3690 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 3691 :     xmlSchemaValPtr ret = NULL, prev = NULL, cur;

	mov	DWORD PTR _ret$[ebp], 0
	mov	DWORD PTR _prev$[ebp], 0
$LN2@xmlSchemaC:

; 3692 : 
; 3693 :     /*
; 3694 :     * Copy the string values.
; 3695 :     */
; 3696 :     while (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$LN3@xmlSchemaC

; 3697 : 	switch (val->type) {

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR tv66[ebp]
	sub	edx, 1
	mov	DWORD PTR tv66[ebp], edx
	cmp	DWORD PTR tv66[ebp], 45			; 0000002dH
	ja	$LN16@xmlSchemaC
	mov	eax, DWORD PTR tv66[ebp]
	movzx	ecx, BYTE PTR $LN20@xmlSchemaC[eax]
	jmp	DWORD PTR $LN21@xmlSchemaC[ecx*4]
$LN6@xmlSchemaC:

; 3698 : 	    case XML_SCHEMAS_ANYTYPE:
; 3699 : 	    case XML_SCHEMAS_IDREFS:
; 3700 : 	    case XML_SCHEMAS_ENTITIES:
; 3701 : 	    case XML_SCHEMAS_NMTOKENS:
; 3702 : 		xmlSchemaFreeValue(ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 3703 : 		return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlSchemaC
$LN7@xmlSchemaC:

; 3704 : 	    case XML_SCHEMAS_ANYSIMPLETYPE:
; 3705 : 	    case XML_SCHEMAS_STRING:
; 3706 : 	    case XML_SCHEMAS_NORMSTRING:
; 3707 : 	    case XML_SCHEMAS_TOKEN:
; 3708 : 	    case XML_SCHEMAS_LANGUAGE:
; 3709 : 	    case XML_SCHEMAS_NAME:
; 3710 : 	    case XML_SCHEMAS_NCNAME:
; 3711 : 	    case XML_SCHEMAS_ID:
; 3712 : 	    case XML_SCHEMAS_IDREF:
; 3713 : 	    case XML_SCHEMAS_ENTITY:
; 3714 : 	    case XML_SCHEMAS_NMTOKEN:
; 3715 : 	    case XML_SCHEMAS_ANYURI:
; 3716 : 		cur = xmlSchemaDupVal(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlSchemaDupVal
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 3717 : 		if (val->value.str != NULL)

	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN8@xmlSchemaC

; 3718 : 		    cur->value.str = xmlStrdup(BAD_CAST val->value.str);

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN8@xmlSchemaC:

; 3719 : 		break;

	jmp	$LN4@xmlSchemaC
$LN9@xmlSchemaC:

; 3720 : 	    case XML_SCHEMAS_QNAME:
; 3721 : 	    case XML_SCHEMAS_NOTATION:
; 3722 : 		cur = xmlSchemaDupVal(val);

	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_xmlSchemaDupVal
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 3723 : 		if (val->value.qname.name != NULL)

	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN10@xmlSchemaC

; 3724 : 		    cur->value.qname.name =

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN10@xmlSchemaC:

; 3725 :                     xmlStrdup(BAD_CAST val->value.qname.name);
; 3726 : 		if (val->value.qname.uri != NULL)

	mov	edx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN11@xmlSchemaC

; 3727 : 		    cur->value.qname.uri =

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN11@xmlSchemaC:

; 3728 :                     xmlStrdup(BAD_CAST val->value.qname.uri);
; 3729 : 		break;

	jmp	SHORT $LN4@xmlSchemaC
$LN12@xmlSchemaC:

; 3730 : 	    case XML_SCHEMAS_HEXBINARY:
; 3731 : 		cur = xmlSchemaDupVal(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlSchemaDupVal
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 3732 : 		if (val->value.hex.str != NULL)

	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN13@xmlSchemaC

; 3733 : 		    cur->value.hex.str = xmlStrdup(BAD_CAST val->value.hex.str);

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN13@xmlSchemaC:

; 3734 : 		break;

	jmp	SHORT $LN4@xmlSchemaC
$LN14@xmlSchemaC:

; 3735 : 	    case XML_SCHEMAS_BASE64BINARY:
; 3736 : 		cur = xmlSchemaDupVal(val);

	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_xmlSchemaDupVal
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax

; 3737 : 		if (val->value.base64.str != NULL)

	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN15@xmlSchemaC

; 3738 : 		    cur->value.base64.str =

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN15@xmlSchemaC:

; 3739 :                     xmlStrdup(BAD_CAST val->value.base64.str);
; 3740 : 		break;

	jmp	SHORT $LN4@xmlSchemaC
$LN16@xmlSchemaC:

; 3741 : 	    default:
; 3742 : 		cur = xmlSchemaDupVal(val);

	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_xmlSchemaDupVal
	add	esp, 4
	mov	DWORD PTR _cur$[ebp], eax
$LN4@xmlSchemaC:

; 3743 : 		break;
; 3744 : 	}
; 3745 : 	if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN17@xmlSchemaC

; 3746 : 	    ret = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN18@xmlSchemaC
$LN17@xmlSchemaC:

; 3747 : 	else
; 3748 : 	    prev->next = cur;

	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN18@xmlSchemaC:

; 3749 : 	prev = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], eax

; 3750 : 	val = val->next;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _val$[ebp], edx

; 3751 :     }

	jmp	$LN2@xmlSchemaC
$LN3@xmlSchemaC:

; 3752 :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSchemaC:

; 3753 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@xmlSchemaC:
	DD	$LN7@xmlSchemaC
	DD	$LN6@xmlSchemaC
	DD	$LN9@xmlSchemaC
	DD	$LN12@xmlSchemaC
	DD	$LN14@xmlSchemaC
	DD	$LN16@xmlSchemaC
$LN20@xmlSchemaC:
	DB	0
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	2
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	1
	DB	2
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
	DB	1
	DB	0
_xmlSchemaCopyValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareValuesWhtsp
_TEXT	SEGMENT
_x$ = 8							; size = 4
_xws$ = 12						; size = 4
_y$ = 16						; size = 4
_yws$ = 20						; size = 4
_xmlSchemaCompareValuesWhtsp PROC			; COMDAT

; 4977 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 4978 :     if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN2@xmlSchemaC
$LN3@xmlSchemaC:

; 4979 : 	return(-2);

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@xmlSchemaC
$LN2@xmlSchemaC:

; 4980 :     return(xmlSchemaCompareValuesInternal(x->type, x, NULL, xws, y->type,

	mov	eax, DWORD PTR _yws$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _xws$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlSchemaCompareValuesInternal
	add	esp, 32					; 00000020H
$LN1@xmlSchemaC:

; 4981 : 	y, NULL, yws));
; 4982 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaCompareValuesWhtsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNewQNameValue
_TEXT	SEGMENT
_val$ = -4						; size = 4
_namespaceName$ = 8					; size = 4
_localName$ = 12					; size = 4
_xmlSchemaNewQNameValue PROC				; COMDAT

; 1006 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1007 :     xmlSchemaValPtr val;
; 1008 : 
; 1009 :     val = xmlSchemaNewValue(XML_SCHEMAS_QNAME);

	push	21					; 00000015H
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 1010 :     if (val == NULL)

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN2@xmlSchemaN

; 1011 : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaN
$LN2@xmlSchemaN:

; 1012 : 
; 1013 :     val->value.qname.name = (xmlChar *) localName;

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _localName$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1014 :     val->value.qname.uri = (xmlChar *) namespaceName;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _namespaceName$[ebp]
	mov	DWORD PTR [edx+12], eax

; 1015 :     return(val);

	mov	eax, DWORD PTR _val$[ebp]
$LN1@xmlSchemaN:

; 1016 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaNewQNameValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNewNOTATIONValue
_TEXT	SEGMENT
_val$ = -4						; size = 4
_name$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlSchemaNewNOTATIONValue PROC				; COMDAT

; 980  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 981  :     xmlSchemaValPtr val;
; 982  : 
; 983  :     val = xmlSchemaNewValue(XML_SCHEMAS_NOTATION);

	push	28					; 0000001cH
	call	_xmlSchemaNewValue
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 984  :     if (val == NULL)

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN2@xmlSchemaN

; 985  : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaN
$LN2@xmlSchemaN:

; 986  : 
; 987  :     val->value.qname.name = (xmlChar *)name;

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _name$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 988  :     if (ns != NULL)

	cmp	DWORD PTR _ns$[ebp], 0
	je	SHORT $LN3@xmlSchemaN

; 989  : 	val->value.qname.uri = (xmlChar *)ns;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _ns$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN3@xmlSchemaN:

; 990  :     return(val);

	mov	eax, DWORD PTR _val$[ebp]
$LN1@xmlSchemaN:

; 991  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaNewNOTATIONValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaNewStringValue
_TEXT	SEGMENT
_val$ = -4						; size = 4
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_xmlSchemaNewStringValue PROC				; COMDAT

; 952  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 953  :     xmlSchemaValPtr val;
; 954  : 
; 955  :     if (type != XML_SCHEMAS_STRING)

	cmp	DWORD PTR _type$[ebp], 1
	je	SHORT $LN2@xmlSchemaN

; 956  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaN
$LN2@xmlSchemaN:

; 957  :     val = (xmlSchemaValPtr) xmlMalloc(sizeof(xmlSchemaVal));

	mov	esi, esp
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _val$[ebp], eax

; 958  :     if (val == NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN3@xmlSchemaN

; 959  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaN
$LN3@xmlSchemaN:

; 960  :     }
; 961  :     memset(val, 0, sizeof(xmlSchemaVal));

	xor	eax, eax
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], eax

; 962  :     val->type = type;

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx], eax

; 963  :     val->value.str = (xmlChar *) value;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 964  :     return(val);

	mov	eax, DWORD PTR _val$[ebp]
$LN1@xmlSchemaN:

; 965  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaNewStringValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValueGetAsBoolean
_TEXT	SEGMENT
_val$ = 8						; size = 4
_xmlSchemaValueGetAsBoolean PROC			; COMDAT

; 930  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 931  :     if ((val == NULL) || (val->type != XML_SCHEMAS_BOOLEAN))

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN3@xmlSchemaV
	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax], 15			; 0000000fH
	je	SHORT $LN2@xmlSchemaV
$LN3@xmlSchemaV:

; 932  : 	return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaV
$LN2@xmlSchemaV:

; 933  :     return (val->value.b);

	mov	ecx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [ecx+8]
$LN1@xmlSchemaV:

; 934  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaValueGetAsBoolean ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValueGetAsString
_TEXT	SEGMENT
tv66 = -4						; size = 4
_val$ = 8						; size = 4
_xmlSchemaValueGetAsString PROC				; COMDAT

; 897  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 898  :     if (val == NULL)

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN4@xmlSchemaV

; 899  : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaV
$LN4@xmlSchemaV:

; 900  :     switch (val->type) {

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR tv66[ebp]
	sub	edx, 1
	mov	DWORD PTR tv66[ebp], edx
	cmp	DWORD PTR tv66[ebp], 45			; 0000002dH
	ja	SHORT $LN2@xmlSchemaV
	mov	eax, DWORD PTR tv66[ebp]
	movzx	ecx, BYTE PTR $LN8@xmlSchemaV[eax]
	jmp	DWORD PTR $LN9@xmlSchemaV[ecx*4]
$LN5@xmlSchemaV:

; 901  : 	case XML_SCHEMAS_STRING:
; 902  : 	case XML_SCHEMAS_NORMSTRING:
; 903  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 904  : 	case XML_SCHEMAS_TOKEN:
; 905  :         case XML_SCHEMAS_LANGUAGE:
; 906  :         case XML_SCHEMAS_NMTOKEN:
; 907  :         case XML_SCHEMAS_NAME:
; 908  :         case XML_SCHEMAS_NCNAME:
; 909  :         case XML_SCHEMAS_ID:
; 910  :         case XML_SCHEMAS_IDREF:
; 911  :         case XML_SCHEMAS_ENTITY:
; 912  :         case XML_SCHEMAS_ANYURI:
; 913  : 	    return (BAD_CAST val->value.str);

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	jmp	SHORT $LN1@xmlSchemaV
$LN2@xmlSchemaV:

; 914  : 	default:
; 915  : 	    break;
; 916  :     }
; 917  :     return (NULL);

	xor	eax, eax
$LN1@xmlSchemaV:

; 918  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN9@xmlSchemaV:
	DD	$LN5@xmlSchemaV
	DD	$LN2@xmlSchemaV
$LN8@xmlSchemaV:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_xmlSchemaValueGetAsString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValueGetNext
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_xmlSchemaValueGetNext PROC				; COMDAT

; 879  : xmlSchemaValueGetNext(xmlSchemaValPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 880  : 
; 881  :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlSchemaV

; 882  : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaV
$LN2@xmlSchemaV:

; 883  :     return (cur->next);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [eax+4]
$LN1@xmlSchemaV:

; 884  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaValueGetNext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValueAppend
_TEXT	SEGMENT
_prev$ = 8						; size = 4
_cur$ = 12						; size = 4
_xmlSchemaValueAppend PROC				; COMDAT

; 861  : xmlSchemaValueAppend(xmlSchemaValPtr prev, xmlSchemaValPtr cur) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 862  : 
; 863  :     if ((prev == NULL) || (cur == NULL))

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN3@xmlSchemaV
	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlSchemaV
$LN3@xmlSchemaV:

; 864  : 	return (-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaV
$LN2@xmlSchemaV:

; 865  :     prev->next = cur;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 866  :     return (0);

	xor	eax, eax
$LN1@xmlSchemaV:

; 867  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaValueAppend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetCanonValueWhtsp
_TEXT	SEGMENT
tv69 = -4						; size = 4
_val$ = 8						; size = 4
_retValue$ = 12						; size = 4
_ws$ = 16						; size = 4
_xmlSchemaGetCanonValueWhtsp PROC			; COMDAT

; 6107 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 6108 :     if ((retValue == NULL) || (val == NULL))

	cmp	DWORD PTR _retValue$[ebp], 0
	je	SHORT $LN5@xmlSchemaG
	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN4@xmlSchemaG
$LN5@xmlSchemaG:

; 6109 : 	return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN4@xmlSchemaG:

; 6110 :     if ((ws == XML_SCHEMA_WHITESPACE_UNKNOWN) ||

	cmp	DWORD PTR _ws$[ebp], 0
	je	SHORT $LN7@xmlSchemaG
	cmp	DWORD PTR _ws$[ebp], 3
	jle	SHORT $LN6@xmlSchemaG
$LN7@xmlSchemaG:

; 6111 : 	(ws > XML_SCHEMA_WHITESPACE_COLLAPSE))
; 6112 : 	return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN6@xmlSchemaG:

; 6113 : 
; 6114 :     *retValue = NULL;

	mov	eax, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [eax], 0

; 6115 :     switch (val->type) {

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv69[ebp], edx
	cmp	DWORD PTR tv69[ebp], 1
	je	SHORT $LN8@xmlSchemaG
	cmp	DWORD PTR tv69[ebp], 2
	je	SHORT $LN15@xmlSchemaG
	jmp	$LN21@xmlSchemaG
$LN8@xmlSchemaG:

; 6116 : 	case XML_SCHEMAS_STRING:
; 6117 : 	    if (val->value.str == NULL)

	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN9@xmlSchemaG

; 6118 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN10@xmlSchemaG
$LN9@xmlSchemaG:

; 6119 : 	    else if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	DWORD PTR _ws$[ebp], 3
	jne	SHORT $LN11@xmlSchemaG

; 6120 : 		*retValue = xmlSchemaCollapseString(val->value.str);

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN10@xmlSchemaG
$LN11@xmlSchemaG:

; 6121 : 	    else if (ws == XML_SCHEMA_WHITESPACE_REPLACE)

	cmp	DWORD PTR _ws$[ebp], 2
	jne	SHORT $LN10@xmlSchemaG

; 6122 : 		*retValue = xmlSchemaWhiteSpaceReplace(val->value.str);

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlSchemaWhiteSpaceReplace
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN10@xmlSchemaG:

; 6123 : 	    if ((*retValue) == NULL)

	mov	edx, DWORD PTR _retValue$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN14@xmlSchemaG

; 6124 : 		*retValue = BAD_CAST xmlStrdup(val->value.str);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN14@xmlSchemaG:

; 6125 : 	    break;

	jmp	SHORT $LN2@xmlSchemaG
$LN15@xmlSchemaG:

; 6126 : 	case XML_SCHEMAS_NORMSTRING:
; 6127 : 	    if (val->value.str == NULL)

	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN16@xmlSchemaG

; 6128 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN17@xmlSchemaG
$LN16@xmlSchemaG:

; 6129 : 	    else {
; 6130 : 		if (ws == XML_SCHEMA_WHITESPACE_COLLAPSE)

	cmp	DWORD PTR _ws$[ebp], 3
	jne	SHORT $LN18@xmlSchemaG

; 6131 : 		    *retValue = xmlSchemaCollapseString(val->value.str);

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN19@xmlSchemaG
$LN18@xmlSchemaG:

; 6132 : 		else
; 6133 : 		    *retValue = xmlSchemaWhiteSpaceReplace(val->value.str);

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlSchemaWhiteSpaceReplace
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN19@xmlSchemaG:

; 6134 : 		if ((*retValue) == NULL)

	mov	edx, DWORD PTR _retValue$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN17@xmlSchemaG

; 6135 : 		    *retValue = BAD_CAST xmlStrdup(val->value.str);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN17@xmlSchemaG:

; 6136 : 	    }
; 6137 : 	    break;

	jmp	SHORT $LN2@xmlSchemaG
$LN21@xmlSchemaG:

; 6138 : 	default:
; 6139 : 	    return (xmlSchemaGetCanonValue(val, retValue));

	mov	eax, DWORD PTR _retValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlSchemaGetCanonValue
	add	esp, 8
	jmp	SHORT $LN1@xmlSchemaG
$LN2@xmlSchemaG:

; 6140 :     }
; 6141 :     return (0);

	xor	eax, eax
$LN1@xmlSchemaG:

; 6142 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaGetCanonValueWhtsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetCanonValue
_TEXT	SEGMENT
tv975 = -660						; size = 4
tv972 = -656						; size = 8
tv970 = -648						; size = 4
tv967 = -642						; size = 2
tv961 = -640						; size = 8
tv954 = -632						; size = 4
tv951 = -628						; size = 8
tv949 = -620						; size = 4
tv946 = -614						; size = 2
tv940 = -612						; size = 8
tv934 = -604						; size = 4
tv928 = -600						; size = 8
tv894 = -592						; size = 4
tv891 = -586						; size = 2
tv885 = -584						; size = 8
tv871 = -576						; size = 8
tv869 = -568						; size = 4
tv866 = -562						; size = 2
tv860 = -560						; size = 8
tv67 = -552						; size = 4
_buf$1 = -544						; size = 40
_buf$2 = -496						; size = 30
_norm$3 = -460						; size = 4
_buf$4 = -452						; size = 50
_norm$5 = -396						; size = 4
_buf$6 = -388						; size = 30
_norm$7 = -352						; size = 4
_buf$8 = -344						; size = 30
_buf$9 = -304						; size = 35
_buf$10 = -260						; size = 30
_left$11 = -224						; size = 8
_sec$12 = -216						; size = 8
_min$13 = -208						; size = 4
_hour$14 = -204						; size = 4
_day$15 = -200						; size = 4
_mon$16 = -196						; size = 4
_year$17 = -192						; size = 4
_buf$18 = -184						; size = 100
_bufsize$19 = -80					; size = 4
_dec$20 = -72						; size = 20
_i$21 = -48						; size = 4
_diff$22 = -44						; size = 4
_offs$23 = -40						; size = 4
_buf$24 = -36						; size = 4
_bufsize$25 = -32					; size = 4
_dec$26 = -24						; size = 20
_val$ = 8						; size = 4
_retValue$ = 12						; size = 4
_xmlSchemaGetCanonValue PROC				; COMDAT

; 5691 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 660				; 00000294H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-660]
	mov	ecx, 165				; 000000a5H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5692 :     if ((retValue == NULL) || (val == NULL))

	cmp	DWORD PTR _retValue$[ebp], 0
	je	SHORT $LN7@xmlSchemaG
	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN6@xmlSchemaG
$LN7@xmlSchemaG:

; 5693 : 	return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN6@xmlSchemaG:

; 5694 :     *retValue = NULL;

	mov	eax, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [eax], 0

; 5695 :     switch (val->type) {

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv67[ebp], edx
	mov	eax, DWORD PTR tv67[ebp]
	sub	eax, 1
	mov	DWORD PTR tv67[ebp], eax
	cmp	DWORD PTR tv67[ebp], 43			; 0000002bH
	ja	$LN89@xmlSchemaG
	mov	ecx, DWORD PTR tv67[ebp]
	movzx	edx, BYTE PTR $LN92@xmlSchemaG[ecx]
	jmp	DWORD PTR $LN105@xmlSchemaG[edx*4]
$LN8@xmlSchemaG:

; 5696 : 	case XML_SCHEMAS_STRING:
; 5697 : 	    if (val->value.str == NULL)

	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN9@xmlSchemaG

; 5698 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN10@xmlSchemaG
$LN9@xmlSchemaG:

; 5699 : 	    else
; 5700 : 		*retValue =

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN10@xmlSchemaG:

; 5701 : 		    BAD_CAST xmlStrdup((const xmlChar *) val->value.str);
; 5702 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN11@xmlSchemaG:

; 5703 : 	case XML_SCHEMAS_NORMSTRING:
; 5704 : 	    if (val->value.str == NULL)

	mov	edx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN12@xmlSchemaG

; 5705 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN14@xmlSchemaG
$LN12@xmlSchemaG:

; 5706 : 	    else {
; 5707 : 		*retValue = xmlSchemaWhiteSpaceReplace(

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlSchemaWhiteSpaceReplace
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 5708 : 		    (const xmlChar *) val->value.str);
; 5709 : 		if ((*retValue) == NULL)

	mov	edx, DWORD PTR _retValue$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN14@xmlSchemaG

; 5710 : 		    *retValue = BAD_CAST xmlStrdup(

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN14@xmlSchemaG:

; 5711 : 			(const xmlChar *) val->value.str);
; 5712 : 	    }
; 5713 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN15@xmlSchemaG:

; 5714 : 	case XML_SCHEMAS_TOKEN:
; 5715 : 	case XML_SCHEMAS_LANGUAGE:
; 5716 : 	case XML_SCHEMAS_NMTOKEN:
; 5717 : 	case XML_SCHEMAS_NAME:
; 5718 : 	case XML_SCHEMAS_NCNAME:
; 5719 : 	case XML_SCHEMAS_ID:
; 5720 : 	case XML_SCHEMAS_IDREF:
; 5721 : 	case XML_SCHEMAS_ENTITY:
; 5722 : 	case XML_SCHEMAS_NOTATION: /* Unclear */
; 5723 : 	case XML_SCHEMAS_ANYURI:   /* Unclear */
; 5724 : 	    if (val->value.str == NULL)

	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN16@xmlSchemaG

; 5725 : 		return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN16@xmlSchemaG:

; 5726 : 	    *retValue =

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlSchemaCollapseString
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 5727 : 		BAD_CAST xmlSchemaCollapseString(BAD_CAST val->value.str);
; 5728 : 	    if (*retValue == NULL)

	mov	edx, DWORD PTR _retValue$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN17@xmlSchemaG

; 5729 : 		*retValue =

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN17@xmlSchemaG:

; 5730 : 		    BAD_CAST xmlStrdup((const xmlChar *) val->value.str);
; 5731 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN18@xmlSchemaG:

; 5732 : 	case XML_SCHEMAS_QNAME:
; 5733 : 	    /* TODO: Unclear in XML Schema 1.0. */
; 5734 : 	    if (val->value.qname.uri == NULL) {

	mov	eax, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN19@xmlSchemaG

; 5735 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.qname.name);

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 5736 : 		return (0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaG

; 5737 : 	    } else {

	jmp	SHORT $LN20@xmlSchemaG
$LN19@xmlSchemaG:

; 5738 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "{");

	push	OFFSET ??_C@_01HCONENDN@?$HL@
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax

; 5739 : 		*retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue),

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 5740 : 		    BAD_CAST val->value.qname.uri);
; 5741 : 		*retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue),

	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 5742 : 		    BAD_CAST "}");
; 5743 : 		*retValue = BAD_CAST xmlStrcat((xmlChar *) (*retValue),

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlStrcat
	add	esp, 8
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN20@xmlSchemaG:

; 5744 : 		    BAD_CAST val->value.qname.uri);
; 5745 : 	    }
; 5746 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN21@xmlSchemaG:

; 5747 : 	case XML_SCHEMAS_DECIMAL:
; 5748 : 	    /*
; 5749 : 	    * TODO: Lookout for a more simple implementation.
; 5750 : 	    */
; 5751 : 	    if ((val->value.decimal.total == 1) &&

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	cmp	eax, 1
	jne	SHORT $LN22@xmlSchemaG
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN22@xmlSchemaG

; 5752 : 		(val->value.decimal.lo == 0)) {
; 5753 : 		*retValue = xmlStrdup(BAD_CAST "0.0");

	push	OFFSET ??_C@_03MDAFIFFL@0?40@
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax

; 5754 : 	    } else {

	jmp	$LN23@xmlSchemaG
$LN22@xmlSchemaG:

; 5755 : 		xmlSchemaValDecimal dec = val->value.decimal;

	mov	eax, DWORD PTR _val$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dec$26[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _dec$26[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _dec$26[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _dec$26[ebp+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _dec$26[ebp+16], eax

; 5756 : 		int bufsize;
; 5757 : 		char *buf = NULL, *offs;

	mov	DWORD PTR _buf$24[ebp], 0

; 5758 : 
; 5759 : 		/* Add room for the decimal point as well. */
; 5760 : 		bufsize = dec.total + 2;

	mov	ecx, DWORD PTR _dec$26[ebp+16]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	add	ecx, 2
	mov	DWORD PTR _bufsize$25[ebp], ecx

; 5761 : 		if (dec.sign)

	mov	edx, DWORD PTR _dec$26[ebp+16]
	and	edx, 1
	je	SHORT $LN24@xmlSchemaG

; 5762 : 		    bufsize++;

	mov	eax, DWORD PTR _bufsize$25[ebp]
	add	eax, 1
	mov	DWORD PTR _bufsize$25[ebp], eax
$LN24@xmlSchemaG:

; 5763 : 		/* Add room for leading/trailing zero. */
; 5764 : 		if ((dec.frac == 0) || (dec.frac == dec.total))

	mov	ecx, DWORD PTR _dec$26[ebp+16]
	shr	ecx, 1
	and	ecx, 127				; 0000007fH
	je	SHORT $LN26@xmlSchemaG
	mov	edx, DWORD PTR _dec$26[ebp+16]
	shr	edx, 1
	and	edx, 127				; 0000007fH
	mov	eax, DWORD PTR _dec$26[ebp+16]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	cmp	edx, eax
	jne	SHORT $LN25@xmlSchemaG
$LN26@xmlSchemaG:

; 5765 : 		    bufsize++;

	mov	ecx, DWORD PTR _bufsize$25[ebp]
	add	ecx, 1
	mov	DWORD PTR _bufsize$25[ebp], ecx
$LN25@xmlSchemaG:

; 5766 : 		buf = xmlMalloc(bufsize);

	mov	esi, esp
	mov	edx, DWORD PTR _bufsize$25[ebp]
	push	edx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buf$24[ebp], eax

; 5767 : 		if (buf == NULL)

	cmp	DWORD PTR _buf$24[ebp], 0
	jne	SHORT $LN27@xmlSchemaG

; 5768 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN27@xmlSchemaG:

; 5769 : 		offs = buf;

	mov	eax, DWORD PTR _buf$24[ebp]
	mov	DWORD PTR _offs$23[ebp], eax

; 5770 : 		if (dec.sign)

	mov	ecx, DWORD PTR _dec$26[ebp+16]
	and	ecx, 1
	je	SHORT $LN28@xmlSchemaG

; 5771 : 		    *offs++ = '-';

	mov	edx, DWORD PTR _offs$23[ebp]
	mov	BYTE PTR [edx], 45			; 0000002dH
	mov	eax, DWORD PTR _offs$23[ebp]
	add	eax, 1
	mov	DWORD PTR _offs$23[ebp], eax
$LN28@xmlSchemaG:

; 5772 : 		if (dec.frac == dec.total) {

	mov	ecx, DWORD PTR _dec$26[ebp+16]
	shr	ecx, 1
	and	ecx, 127				; 0000007fH
	mov	edx, DWORD PTR _dec$26[ebp+16]
	shr	edx, 8
	and	edx, 255				; 000000ffH
	cmp	ecx, edx
	jne	SHORT $LN29@xmlSchemaG

; 5773 : 		    *offs++ = '0';

	mov	eax, DWORD PTR _offs$23[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	mov	ecx, DWORD PTR _offs$23[ebp]
	add	ecx, 1
	mov	DWORD PTR _offs$23[ebp], ecx

; 5774 : 		    *offs++ = '.';

	mov	edx, DWORD PTR _offs$23[ebp]
	mov	BYTE PTR [edx], 46			; 0000002eH
	mov	eax, DWORD PTR _offs$23[ebp]
	add	eax, 1
	mov	DWORD PTR _offs$23[ebp], eax
$LN29@xmlSchemaG:

; 5775 : 		}
; 5776 : 		if (dec.hi != 0)

	cmp	DWORD PTR _dec$26[ebp+8], 0
	je	SHORT $LN30@xmlSchemaG

; 5777 : 		    snprintf(offs, bufsize - (offs - buf),

	mov	ecx, DWORD PTR _dec$26[ebp]
	push	ecx
	mov	edx, DWORD PTR _dec$26[ebp+4]
	push	edx
	mov	eax, DWORD PTR _dec$26[ebp+8]
	push	eax
	push	OFFSET ??_C@_09LMAOOEAH@?$CFlu?$CFlu?$CFlu@
	mov	ecx, DWORD PTR _offs$23[ebp]
	sub	ecx, DWORD PTR _buf$24[ebp]
	mov	edx, DWORD PTR _bufsize$25[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _offs$23[ebp]
	push	eax
	call	_snprintf
	add	esp, 24					; 00000018H
	jmp	SHORT $LN33@xmlSchemaG
$LN30@xmlSchemaG:

; 5778 : 			"%lu%lu%lu", dec.hi, dec.mi, dec.lo);
; 5779 : 		else if (dec.mi != 0)

	cmp	DWORD PTR _dec$26[ebp+4], 0
	je	SHORT $LN32@xmlSchemaG

; 5780 : 		    snprintf(offs, bufsize - (offs - buf),

	mov	ecx, DWORD PTR _dec$26[ebp]
	push	ecx
	mov	edx, DWORD PTR _dec$26[ebp+4]
	push	edx
	push	OFFSET ??_C@_06DFHLHGNP@?$CFlu?$CFlu@
	mov	eax, DWORD PTR _offs$23[ebp]
	sub	eax, DWORD PTR _buf$24[ebp]
	mov	ecx, DWORD PTR _bufsize$25[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _offs$23[ebp]
	push	edx
	call	_snprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN33@xmlSchemaG
$LN32@xmlSchemaG:

; 5781 : 			"%lu%lu", dec.mi, dec.lo);
; 5782 : 		else
; 5783 : 		    snprintf(offs, bufsize - (offs - buf),

	mov	eax, DWORD PTR _dec$26[ebp]
	push	eax
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu@
	mov	ecx, DWORD PTR _offs$23[ebp]
	sub	ecx, DWORD PTR _buf$24[ebp]
	mov	edx, DWORD PTR _bufsize$25[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _offs$23[ebp]
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN33@xmlSchemaG:

; 5784 : 			"%lu", dec.lo);
; 5785 : 
; 5786 : 		if (dec.frac != 0) {

	mov	ecx, DWORD PTR _dec$26[ebp+16]
	shr	ecx, 1
	and	ecx, 127				; 0000007fH
	je	$LN34@xmlSchemaG

; 5787 : 		    if (dec.frac != dec.total) {

	mov	edx, DWORD PTR _dec$26[ebp+16]
	shr	edx, 1
	and	edx, 127				; 0000007fH
	mov	eax, DWORD PTR _dec$26[ebp+16]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	cmp	edx, eax
	je	SHORT $LN36@xmlSchemaG

; 5788 : 			int diff = dec.total - dec.frac;

	mov	ecx, DWORD PTR _dec$26[ebp+16]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _dec$26[ebp+16]
	shr	edx, 1
	and	edx, 127				; 0000007fH
	sub	ecx, edx
	mov	DWORD PTR _diff$22[ebp], ecx

; 5789 : 			/*
; 5790 : 			* Insert the decimal point.
; 5791 : 			*/
; 5792 : 			memmove(offs + diff + 1, offs + diff, dec.frac +1);

	mov	eax, DWORD PTR _dec$26[ebp+16]
	shr	eax, 1
	and	eax, 127				; 0000007fH
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _offs$23[ebp]
	add	ecx, DWORD PTR _diff$22[ebp]
	push	ecx
	mov	edx, DWORD PTR _diff$22[ebp]
	mov	eax, DWORD PTR _offs$23[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 5793 : 			offs[diff] = '.';

	mov	edx, DWORD PTR _offs$23[ebp]
	add	edx, DWORD PTR _diff$22[ebp]
	mov	BYTE PTR [edx], 46			; 0000002eH

; 5794 : 		    } else {

	jmp	SHORT $LN38@xmlSchemaG
$LN36@xmlSchemaG:

; 5795 : 			unsigned int i = 0;

	mov	DWORD PTR _i$21[ebp], 0
$LN4@xmlSchemaG:

; 5796 : 			/*
; 5797 : 			* Insert missing zeroes behind the decimal point.
; 5798 : 			*/
; 5799 : 			while (*(offs + i) != 0)

	mov	eax, DWORD PTR _offs$23[ebp]
	add	eax, DWORD PTR _i$21[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@xmlSchemaG

; 5800 : 			    i++;

	mov	edx, DWORD PTR _i$21[ebp]
	add	edx, 1
	mov	DWORD PTR _i$21[ebp], edx
	jmp	SHORT $LN4@xmlSchemaG
$LN5@xmlSchemaG:

; 5801 : 			if (i < dec.total) {

	mov	eax, DWORD PTR _dec$26[ebp+16]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	cmp	DWORD PTR _i$21[ebp], eax
	jae	SHORT $LN38@xmlSchemaG

; 5802 : 			    memmove(offs + (dec.total - i), offs, i +1);

	mov	ecx, DWORD PTR _i$21[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _offs$23[ebp]
	push	edx
	mov	eax, DWORD PTR _dec$26[ebp+16]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	sub	eax, DWORD PTR _i$21[ebp]
	add	eax, DWORD PTR _offs$23[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 5803 : 			    memset(offs, '0', dec.total - i);

	mov	ecx, DWORD PTR _dec$26[ebp+16]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	sub	ecx, DWORD PTR _i$21[ebp]
	push	ecx
	push	48					; 00000030H
	mov	edx, DWORD PTR _offs$23[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN38@xmlSchemaG:

; 5804 : 			}
; 5805 : 		    }
; 5806 : 		} else {

	jmp	SHORT $LN35@xmlSchemaG
$LN34@xmlSchemaG:

; 5807 : 		    /*
; 5808 : 		    * Append decimal point and zero.
; 5809 : 		    */
; 5810 : 		    offs = buf + bufsize - 1;

	mov	eax, DWORD PTR _bufsize$25[ebp]
	mov	ecx, DWORD PTR _buf$24[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _offs$23[ebp], edx

; 5811 : 		    *offs-- = 0;

	mov	eax, DWORD PTR _offs$23[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _offs$23[ebp]
	sub	ecx, 1
	mov	DWORD PTR _offs$23[ebp], ecx

; 5812 : 		    *offs-- = '0';

	mov	edx, DWORD PTR _offs$23[ebp]
	mov	BYTE PTR [edx], 48			; 00000030H
	mov	eax, DWORD PTR _offs$23[ebp]
	sub	eax, 1
	mov	DWORD PTR _offs$23[ebp], eax

; 5813 : 		    *offs-- = '.';

	mov	ecx, DWORD PTR _offs$23[ebp]
	mov	BYTE PTR [ecx], 46			; 0000002eH
	mov	edx, DWORD PTR _offs$23[ebp]
	sub	edx, 1
	mov	DWORD PTR _offs$23[ebp], edx
$LN35@xmlSchemaG:

; 5814 : 		}
; 5815 : 		*retValue = BAD_CAST buf;

	mov	eax, DWORD PTR _retValue$[ebp]
	mov	ecx, DWORD PTR _buf$24[ebp]
	mov	DWORD PTR [eax], ecx
$LN23@xmlSchemaG:

; 5816 : 	    }
; 5817 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN39@xmlSchemaG:

; 5818 : 	case XML_SCHEMAS_INTEGER:
; 5819 :         case XML_SCHEMAS_PINTEGER:
; 5820 :         case XML_SCHEMAS_NPINTEGER:
; 5821 :         case XML_SCHEMAS_NINTEGER:
; 5822 :         case XML_SCHEMAS_NNINTEGER:
; 5823 : 	case XML_SCHEMAS_LONG:
; 5824 :         case XML_SCHEMAS_BYTE:
; 5825 :         case XML_SCHEMAS_SHORT:
; 5826 :         case XML_SCHEMAS_INT:
; 5827 : 	case XML_SCHEMAS_UINT:
; 5828 :         case XML_SCHEMAS_ULONG:
; 5829 :         case XML_SCHEMAS_USHORT:
; 5830 :         case XML_SCHEMAS_UBYTE:
; 5831 : 	    if ((val->value.decimal.total == 1) &&

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	cmp	eax, 1
	jne	SHORT $LN40@xmlSchemaG
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN40@xmlSchemaG

; 5832 : 		(val->value.decimal.lo == 0))
; 5833 : 		*retValue = xmlStrdup(BAD_CAST "0");

	push	OFFSET ??_C@_01GBGANLPD@0@
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax
	jmp	$LN53@xmlSchemaG
$LN40@xmlSchemaG:

; 5834 : 	    else {
; 5835 : 		xmlSchemaValDecimal dec = val->value.decimal;

	mov	eax, DWORD PTR _val$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dec$20[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _dec$20[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _dec$20[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _dec$20[ebp+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _dec$20[ebp+16], eax

; 5836 : 		int bufsize = dec.total + 1;

	mov	ecx, DWORD PTR _dec$20[ebp+16]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	add	ecx, 1
	mov	DWORD PTR _bufsize$19[ebp], ecx

; 5837 : 
; 5838 : 		/* Add room for the decimal point as well. */
; 5839 : 		if (dec.sign)

	mov	edx, DWORD PTR _dec$20[ebp+16]
	and	edx, 1
	je	SHORT $LN42@xmlSchemaG

; 5840 : 		    bufsize++;

	mov	eax, DWORD PTR _bufsize$19[ebp]
	add	eax, 1
	mov	DWORD PTR _bufsize$19[ebp], eax
$LN42@xmlSchemaG:

; 5841 : 		*retValue = xmlMalloc(bufsize);

	mov	esi, esp
	mov	ecx, DWORD PTR _bufsize$19[ebp]
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax

; 5842 : 		if (*retValue == NULL)

	mov	eax, DWORD PTR _retValue$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN43@xmlSchemaG

; 5843 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN43@xmlSchemaG:

; 5844 : 		if (dec.hi != 0) {

	cmp	DWORD PTR _dec$20[ebp+8], 0
	je	SHORT $LN44@xmlSchemaG

; 5845 : 		    if (dec.sign)

	mov	ecx, DWORD PTR _dec$20[ebp+16]
	and	ecx, 1
	je	SHORT $LN46@xmlSchemaG

; 5846 : 			snprintf((char *) *retValue, bufsize,

	mov	edx, DWORD PTR _dec$20[ebp]
	push	edx
	mov	eax, DWORD PTR _dec$20[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _dec$20[ebp+8]
	push	ecx
	push	OFFSET ??_C@_0L@HJALPPEN@?9?$CFlu?$CFlu?$CFlu@
	mov	edx, DWORD PTR _bufsize$19[ebp]
	push	edx
	mov	eax, DWORD PTR _retValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_snprintf
	add	esp, 24					; 00000018H
	jmp	SHORT $LN47@xmlSchemaG
$LN46@xmlSchemaG:

; 5847 : 			    "-%lu%lu%lu", dec.hi, dec.mi, dec.lo);
; 5848 : 		    else
; 5849 : 			snprintf((char *) *retValue, bufsize,

	mov	edx, DWORD PTR _dec$20[ebp]
	push	edx
	mov	eax, DWORD PTR _dec$20[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _dec$20[ebp+8]
	push	ecx
	push	OFFSET ??_C@_09LMAOOEAH@?$CFlu?$CFlu?$CFlu@
	mov	edx, DWORD PTR _bufsize$19[ebp]
	push	edx
	mov	eax, DWORD PTR _retValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_snprintf
	add	esp, 24					; 00000018H
$LN47@xmlSchemaG:

; 5850 : 			    "%lu%lu%lu", dec.hi, dec.mi, dec.lo);
; 5851 : 		} else if (dec.mi != 0) {

	jmp	$LN53@xmlSchemaG
$LN44@xmlSchemaG:
	cmp	DWORD PTR _dec$20[ebp+4], 0
	je	SHORT $LN48@xmlSchemaG

; 5852 : 		    if (dec.sign)

	mov	edx, DWORD PTR _dec$20[ebp+16]
	and	edx, 1
	je	SHORT $LN50@xmlSchemaG

; 5853 : 			snprintf((char *) *retValue, bufsize,

	mov	eax, DWORD PTR _dec$20[ebp]
	push	eax
	mov	ecx, DWORD PTR _dec$20[ebp+4]
	push	ecx
	push	OFFSET ??_C@_07KPEGABEP@?9?$CFlu?$CFlu@
	mov	edx, DWORD PTR _bufsize$19[ebp]
	push	edx
	mov	eax, DWORD PTR _retValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_snprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN51@xmlSchemaG
$LN50@xmlSchemaG:

; 5854 : 			    "-%lu%lu", dec.mi, dec.lo);
; 5855 : 		    else
; 5856 : 			snprintf((char *) *retValue, bufsize,

	mov	edx, DWORD PTR _dec$20[ebp]
	push	edx
	mov	eax, DWORD PTR _dec$20[ebp+4]
	push	eax
	push	OFFSET ??_C@_06DFHLHGNP@?$CFlu?$CFlu@
	mov	ecx, DWORD PTR _bufsize$19[ebp]
	push	ecx
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H
$LN51@xmlSchemaG:

; 5857 : 			    "%lu%lu", dec.mi, dec.lo);
; 5858 : 		} else {

	jmp	SHORT $LN53@xmlSchemaG
$LN48@xmlSchemaG:

; 5859 : 		    if (dec.sign)

	mov	ecx, DWORD PTR _dec$20[ebp+16]
	and	ecx, 1
	je	SHORT $LN52@xmlSchemaG

; 5860 : 			snprintf((char *) *retValue, bufsize, "-%lu", dec.lo);

	mov	edx, DWORD PTR _dec$20[ebp]
	push	edx
	push	OFFSET ??_C@_04IEOFADKM@?9?$CFlu@
	mov	eax, DWORD PTR _bufsize$19[ebp]
	push	eax
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN53@xmlSchemaG
$LN52@xmlSchemaG:

; 5861 : 		    else
; 5862 : 			snprintf((char *) *retValue, bufsize, "%lu", dec.lo);

	mov	eax, DWORD PTR _dec$20[ebp]
	push	eax
	push	OFFSET ??_C@_03FKNCMABI@?$CFlu@
	mov	ecx, DWORD PTR _bufsize$19[ebp]
	push	ecx
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
$LN53@xmlSchemaG:

; 5863 : 		}
; 5864 : 	    }
; 5865 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN54@xmlSchemaG:

; 5866 : 	case XML_SCHEMAS_BOOLEAN:
; 5867 : 	    if (val->value.b)

	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN55@xmlSchemaG

; 5868 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "true");

	push	OFFSET ??_C@_04LOAJBDKD@true@
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN56@xmlSchemaG
$LN55@xmlSchemaG:

; 5869 : 	    else
; 5870 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST "false");

	push	OFFSET ??_C@_05LAPONLG@false@
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN56@xmlSchemaG:

; 5871 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN57@xmlSchemaG:

; 5872 : 	case XML_SCHEMAS_DURATION: {
; 5873 : 		char buf[100];
; 5874 : 		unsigned long year;
; 5875 : 		unsigned long mon, day, hour = 0, min = 0;

	mov	DWORD PTR _hour$14[ebp], 0
	mov	DWORD PTR _min$13[ebp], 0

; 5876 : 		double sec = 0, left;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _sec$12[ebp], xmm0

; 5877 : 
; 5878 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5879 : 		/*
; 5880 : 		* TODO: This results in a normalized output of the value
; 5881 : 		* - which is NOT conformant to the spec -
; 5882 : 		* since the exact values of each property are not
; 5883 : 		* recoverable. Think about extending the structure to
; 5884 : 		* provide a field for every property.
; 5885 : 		*/
; 5886 : 		year = (unsigned long) FQUOTIENT(labs(val->value.dur.mon), 12);

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR tv860[ebp], xmm0
	fld	QWORD PTR tv860[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fnstcw	WORD PTR tv866[ebp]
	movzx	eax, WORD PTR tv866[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv869[ebp], eax
	fldcw	WORD PTR tv869[ebp]
	fistp	QWORD PTR tv871[ebp]
	fldcw	WORD PTR tv866[ebp]
	mov	eax, DWORD PTR tv871[ebp]
	mov	DWORD PTR _year$17[ebp], eax

; 5887 : 		mon = labs(val->value.dur.mon) - 12 * year;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	edx, DWORD PTR _year$17[ebp], 12
	sub	eax, edx
	mov	DWORD PTR _mon$16[ebp], eax

; 5888 : 
; 5889 : 		day = (unsigned long) FQUOTIENT(fabs(val->value.dur.sec), 86400);

	mov	eax, DWORD PTR _val$[ebp]
	movsd	xmm0, QWORD PTR [eax+16]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	divsd	xmm0, QWORD PTR __real@40f5180000000000
	movsd	QWORD PTR tv885[ebp], xmm0
	fld	QWORD PTR tv885[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fnstcw	WORD PTR tv891[ebp]
	movzx	eax, WORD PTR tv891[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv894[ebp], eax
	fldcw	WORD PTR tv894[ebp]
	fistp	QWORD PTR tv928[ebp]
	fldcw	WORD PTR tv891[ebp]
	mov	ecx, DWORD PTR tv928[ebp]
	mov	DWORD PTR _day$15[ebp], ecx

; 5890 : 		left = fabs(val->value.dur.sec) - day * 86400;

	mov	edx, DWORD PTR _val$[ebp]
	movsd	xmm0, QWORD PTR [edx+16]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	imul	eax, DWORD PTR _day$15[ebp], 86400
	mov	DWORD PTR tv934[ebp], eax
	cvtsi2sd xmm1, DWORD PTR tv934[ebp]
	mov	ecx, DWORD PTR tv934[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	subsd	xmm0, xmm1
	movsd	QWORD PTR _left$11[ebp], xmm0

; 5891 : 		if (left > 0) {

	movsd	xmm0, QWORD PTR _left$11[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	$LN59@xmlSchemaG

; 5892 : 		    hour = (unsigned long) FQUOTIENT(left, 3600);

	movsd	xmm0, QWORD PTR _left$11[ebp]
	divsd	xmm0, QWORD PTR __real@40ac200000000000
	movsd	QWORD PTR tv940[ebp], xmm0
	fld	QWORD PTR tv940[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fnstcw	WORD PTR tv946[ebp]
	movzx	eax, WORD PTR tv946[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv949[ebp], eax
	fldcw	WORD PTR tv949[ebp]
	fistp	QWORD PTR tv951[ebp]
	fldcw	WORD PTR tv946[ebp]
	mov	edx, DWORD PTR tv951[ebp]
	mov	DWORD PTR _hour$14[ebp], edx

; 5893 : 		    left = left - (hour * 3600);

	imul	eax, DWORD PTR _hour$14[ebp], 3600
	mov	DWORD PTR tv954[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv954[ebp]
	mov	ecx, DWORD PTR tv954[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	xmm1, QWORD PTR _left$11[ebp]
	subsd	xmm1, xmm0
	movsd	QWORD PTR _left$11[ebp], xmm1

; 5894 : 		    if (left > 0) {

	movsd	xmm0, QWORD PTR _left$11[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	$LN59@xmlSchemaG

; 5895 : 			min = (unsigned long) FQUOTIENT(left, 60);

	movsd	xmm0, QWORD PTR _left$11[ebp]
	divsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR tv961[ebp], xmm0
	fld	QWORD PTR tv961[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fnstcw	WORD PTR tv967[ebp]
	movzx	eax, WORD PTR tv967[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv970[ebp], eax
	fldcw	WORD PTR tv970[ebp]
	fistp	QWORD PTR tv972[ebp]
	fldcw	WORD PTR tv967[ebp]
	mov	edx, DWORD PTR tv972[ebp]
	mov	DWORD PTR _min$13[ebp], edx

; 5896 : 			sec = left - (min * 60);

	imul	eax, DWORD PTR _min$13[ebp], 60
	mov	DWORD PTR tv975[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv975[ebp]
	mov	ecx, DWORD PTR tv975[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	xmm1, QWORD PTR _left$11[ebp]
	subsd	xmm1, xmm0
	movsd	QWORD PTR _sec$12[ebp], xmm1
$LN59@xmlSchemaG:

; 5897 : 		    }
; 5898 : 		}
; 5899 : 		if ((val->value.dur.mon < 0) || (val->value.dur.sec < 0))

	mov	edx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jl	SHORT $LN62@xmlSchemaG
	mov	eax, DWORD PTR _val$[ebp]
	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR [eax+16]
	jbe	SHORT $LN60@xmlSchemaG
$LN62@xmlSchemaG:

; 5900 : 		    snprintf(buf, 100, "P%luY%luM%luDT%luH%luM%.14gS",

	sub	esp, 8
	movsd	xmm0, QWORD PTR _sec$12[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _min$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _hour$14[ebp]
	push	edx
	mov	eax, DWORD PTR _day$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _mon$16[ebp]
	push	ecx
	mov	edx, DWORD PTR _year$17[ebp]
	push	edx
	push	OFFSET ??_C@_0BN@KBIIDNPF@P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@
	push	100					; 00000064H
	lea	eax, DWORD PTR _buf$18[ebp]
	push	eax
	call	_snprintf
	add	esp, 40					; 00000028H
	jmp	SHORT $LN61@xmlSchemaG
$LN60@xmlSchemaG:

; 5901 : 			year, mon, day, hour, min, sec);
; 5902 : 		else
; 5903 : 		    snprintf(buf, 100, "-P%luY%luM%luDT%luH%luM%.14gS",

	sub	esp, 8
	movsd	xmm0, QWORD PTR _sec$12[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _min$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _hour$14[ebp]
	push	edx
	mov	eax, DWORD PTR _day$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _mon$16[ebp]
	push	ecx
	mov	edx, DWORD PTR _year$17[ebp]
	push	edx
	push	OFFSET ??_C@_0BO@LOJFMPEL@?9P?$CFluY?$CFluM?$CFluDT?$CFluH?$CFluM?$CF?414gS@
	push	100					; 00000064H
	lea	eax, DWORD PTR _buf$18[ebp]
	push	eax
	call	_snprintf
	add	esp, 40					; 00000028H
$LN61@xmlSchemaG:

; 5904 : 			year, mon, day, hour, min, sec);
; 5905 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	ecx, DWORD PTR _buf$18[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax

; 5906 : 	    }
; 5907 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN63@xmlSchemaG:

; 5908 : 	case XML_SCHEMAS_GYEAR: {
; 5909 : 		char buf[30];
; 5910 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5911 : 		/* TODO: What to do with the timezone? */
; 5912 : 		snprintf(buf, 30, "%04ld", val->value.date.year);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_05IHGIIBEO@?$CF04ld@
	push	30					; 0000001eH
	lea	edx, DWORD PTR _buf$10[ebp]
	push	edx
	call	_snprintf
	add	esp, 16					; 00000010H

; 5913 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$10[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 5914 : 	    }
; 5915 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN64@xmlSchemaG:

; 5916 : 	case XML_SCHEMAS_GMONTH: {
; 5917 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5918 : 		/* TODO: What to do with the timezone? */
; 5919 : 		*retValue = xmlMalloc(6);

	mov	esi, esp
	push	6
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax

; 5920 : 		if (*retValue == NULL)

	mov	eax, DWORD PTR _retValue$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN65@xmlSchemaG

; 5921 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN65@xmlSchemaG:

; 5922 : 		snprintf((char *) *retValue, 6, "--%02u",

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 15					; 0000000fH
	push	edx
	push	OFFSET ??_C@_06PLGGIKKN@?9?9?$CF02u@
	push	6
	mov	eax, DWORD PTR _retValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_snprintf
	add	esp, 16					; 00000010H

; 5923 : 		    val->value.date.mon);
; 5924 : 	    }
; 5925 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN66@xmlSchemaG:

; 5926 :         case XML_SCHEMAS_GDAY: {
; 5927 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5928 : 		/* TODO: What to do with the timezone? */
; 5929 : 		*retValue = xmlMalloc(6);

	mov	esi, esp
	push	6
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax

; 5930 : 		if (*retValue == NULL)

	mov	eax, DWORD PTR _retValue$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN67@xmlSchemaG

; 5931 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN67@xmlSchemaG:

; 5932 : 		snprintf((char *) *retValue, 6, "---%02u",

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	push	edx
	push	OFFSET ??_C@_07GBFLPNDN@?9?9?9?$CF02u@
	push	6
	mov	eax, DWORD PTR _retValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_snprintf
	add	esp, 16					; 00000010H

; 5933 : 		    val->value.date.day);
; 5934 : 	    }
; 5935 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN68@xmlSchemaG:

; 5936 :         case XML_SCHEMAS_GMONTHDAY: {
; 5937 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5938 : 		/* TODO: What to do with the timezone? */
; 5939 : 		*retValue = xmlMalloc(8);

	mov	esi, esp
	push	8
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax

; 5940 : 		if (*retValue == NULL)

	mov	eax, DWORD PTR _retValue$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN69@xmlSchemaG

; 5941 : 		    return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN69@xmlSchemaG:

; 5942 : 		snprintf((char *) *retValue, 8, "--%02u-%02u",

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 15					; 0000000fH
	push	ecx
	push	OFFSET ??_C@_0M@IGNOHAOM@?9?9?$CF02u?9?$CF02u@
	push	8
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H

; 5943 : 		    val->value.date.mon, val->value.date.day);
; 5944 : 	    }
; 5945 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN70@xmlSchemaG:

; 5946 :         case XML_SCHEMAS_GYEARMONTH: {
; 5947 : 		char buf[35];
; 5948 : 		/* TODO: Unclear in XML Schema 1.0 */
; 5949 : 		/* TODO: What to do with the timezone? */
; 5950 : 		if (val->value.date.year < 0)

	mov	ecx, DWORD PTR _val$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jge	SHORT $LN71@xmlSchemaG

; 5951 : 		    snprintf(buf, 35, "-%04ld-%02u",

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cdq
	xor	eax, edx
	sub	eax, edx
	push	eax
	push	OFFSET ??_C@_0M@CBHDPMIH@?9?$CF04ld?9?$CF02u@
	push	35					; 00000023H
	lea	edx, DWORD PTR _buf$9[ebp]
	push	edx
	call	_snprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN72@xmlSchemaG
$LN71@xmlSchemaG:

; 5952 : 			labs(val->value.date.year),
; 5953 : 			val->value.date.mon);
; 5954 : 		else
; 5955 : 		    snprintf(buf, 35, "%04ld-%02u",

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 15					; 0000000fH
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_0L@LHLPFBBC@?$CF04ld?9?$CF02u@
	push	35					; 00000023H
	lea	ecx, DWORD PTR _buf$9[ebp]
	push	ecx
	call	_snprintf
	add	esp, 20					; 00000014H
$LN72@xmlSchemaG:

; 5956 : 			val->value.date.year, val->value.date.mon);
; 5957 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	edx, DWORD PTR _buf$9[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 5958 : 	    }
; 5959 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN73@xmlSchemaG:

; 5960 : 	case XML_SCHEMAS_TIME:
; 5961 : 	    {
; 5962 : 		char buf[30];
; 5963 : 
; 5964 : 		if (val->value.date.tz_flag) {

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 1
	je	$LN74@xmlSchemaG

; 5965 : 		    xmlSchemaValPtr norm;
; 5966 : 
; 5967 : 		    norm = xmlSchemaDateNormalize(val, 0);

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlSchemaDateNormalize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _norm$7[ebp], eax

; 5968 : 		    if (norm == NULL)

	cmp	DWORD PTR _norm$7[ebp], 0
	jne	SHORT $LN76@xmlSchemaG

; 5969 : 			return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN76@xmlSchemaG:

; 5970 : 		    /*
; 5971 : 		    * TODO: Check if "%.14g" is portable.
; 5972 : 		    */
; 5973 : 		    snprintf(buf, 30,

	mov	edx, DWORD PTR _norm$7[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [edx+16]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _norm$7[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	push	ecx
	mov	edx, DWORD PTR _norm$7[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 9
	and	eax, 31					; 0000001fH
	push	eax
	push	OFFSET ??_C@_0BD@EKHIMNMI@?$CF02u?3?$CF02u?3?$CF02?414gZ@
	push	30					; 0000001eH
	lea	ecx, DWORD PTR _buf$8[ebp]
	push	ecx
	call	_snprintf
	add	esp, 28					; 0000001cH

; 5974 : 			"%02u:%02u:%02.14gZ",
; 5975 : 			norm->value.date.hour,
; 5976 : 			norm->value.date.min,
; 5977 : 			norm->value.date.sec);
; 5978 : 		    xmlSchemaFreeValue(norm);

	mov	edx, DWORD PTR _norm$7[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 5979 : 		} else {

	jmp	SHORT $LN75@xmlSchemaG
$LN74@xmlSchemaG:

; 5980 : 		    snprintf(buf, 30,

	mov	eax, DWORD PTR _val$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+16]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 14					; 0000000eH
	and	edx, 63					; 0000003fH
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	push	ecx
	push	OFFSET ??_C@_0BC@CMNGDBIO@?$CF02u?3?$CF02u?3?$CF02?414g@
	push	30					; 0000001eH
	lea	edx, DWORD PTR _buf$8[ebp]
	push	edx
	call	_snprintf
	add	esp, 28					; 0000001cH
$LN75@xmlSchemaG:

; 5981 : 			"%02u:%02u:%02.14g",
; 5982 : 			val->value.date.hour,
; 5983 : 			val->value.date.min,
; 5984 : 			val->value.date.sec);
; 5985 : 		}
; 5986 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$8[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 5987 : 	    }
; 5988 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN77@xmlSchemaG:

; 5989 :         case XML_SCHEMAS_DATE:
; 5990 : 	    {
; 5991 : 		char buf[30];
; 5992 : 
; 5993 : 		if (val->value.date.tz_flag) {

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 1
	je	SHORT $LN78@xmlSchemaG

; 5994 : 		    xmlSchemaValPtr norm;
; 5995 : 
; 5996 : 		    norm = xmlSchemaDateNormalize(val, 0);

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlSchemaDateNormalize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _norm$5[ebp], eax

; 5997 : 		    if (norm == NULL)

	cmp	DWORD PTR _norm$5[ebp], 0
	jne	SHORT $LN80@xmlSchemaG

; 5998 : 			return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN80@xmlSchemaG:

; 5999 : 		    /*
; 6000 : 		    * TODO: Append the canonical value of the
; 6001 : 		    * recoverable timezone and not "Z".
; 6002 : 		    */
; 6003 : 		    snprintf(buf, 30,

	mov	edx, DWORD PTR _norm$5[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	push	eax
	mov	ecx, DWORD PTR _norm$5[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 15					; 0000000fH
	push	edx
	mov	eax, DWORD PTR _norm$5[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0BB@EPCAOJB@?$CF04ld?3?$CF02u?3?$CF02uZ@
	push	30					; 0000001eH
	lea	edx, DWORD PTR _buf$6[ebp]
	push	edx
	call	_snprintf
	add	esp, 24					; 00000018H

; 6004 : 			"%04ld:%02u:%02uZ",
; 6005 : 			norm->value.date.year, norm->value.date.mon,
; 6006 : 			norm->value.date.day);
; 6007 : 		    xmlSchemaFreeValue(norm);

	mov	eax, DWORD PTR _norm$5[ebp]
	push	eax
	call	_xmlSchemaFreeValue
	add	esp, 4

; 6008 : 		} else {

	jmp	SHORT $LN79@xmlSchemaG
$LN78@xmlSchemaG:

; 6009 : 		    snprintf(buf, 30,

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 15					; 0000000fH
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_0BA@KCJGDMGM@?$CF04ld?3?$CF02u?3?$CF02u@
	push	30					; 0000001eH
	lea	ecx, DWORD PTR _buf$6[ebp]
	push	ecx
	call	_snprintf
	add	esp, 24					; 00000018H
$LN79@xmlSchemaG:

; 6010 : 			"%04ld:%02u:%02u",
; 6011 : 			val->value.date.year, val->value.date.mon,
; 6012 : 			val->value.date.day);
; 6013 : 		}
; 6014 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	edx, DWORD PTR _buf$6[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 6015 : 	    }
; 6016 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN81@xmlSchemaG:

; 6017 :         case XML_SCHEMAS_DATETIME:
; 6018 : 	    {
; 6019 : 		char buf[50];
; 6020 : 
; 6021 : 		if (val->value.date.tz_flag) {

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+24]
	and	eax, 1
	je	$LN82@xmlSchemaG

; 6022 : 		    xmlSchemaValPtr norm;
; 6023 : 
; 6024 : 		    norm = xmlSchemaDateNormalize(val, 0);

	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_xmlSchemaDateNormalize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _norm$3[ebp], eax

; 6025 : 		    if (norm == NULL)

	cmp	DWORD PTR _norm$3[ebp], 0
	jne	SHORT $LN84@xmlSchemaG

; 6026 : 			return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaG
$LN84@xmlSchemaG:

; 6027 : 		    /*
; 6028 : 		    * TODO: Check if "%.14g" is portable.
; 6029 : 		    */
; 6030 : 		    snprintf(buf, 50,

	mov	edx, DWORD PTR _norm$3[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [edx+16]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _norm$3[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 14					; 0000000eH
	and	ecx, 63					; 0000003fH
	push	ecx
	mov	edx, DWORD PTR _norm$3[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 9
	and	eax, 31					; 0000001fH
	push	eax
	mov	ecx, DWORD PTR _norm$3[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 4
	and	edx, 31					; 0000001fH
	push	edx
	mov	eax, DWORD PTR _norm$3[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 15					; 0000000fH
	push	ecx
	mov	edx, DWORD PTR _norm$3[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_0CD@NGIOFKDM@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@
	push	50					; 00000032H
	lea	ecx, DWORD PTR _buf$4[ebp]
	push	ecx
	call	_snprintf
	add	esp, 40					; 00000028H

; 6031 : 			"%04ld:%02u:%02uT%02u:%02u:%02.14gZ",
; 6032 : 			norm->value.date.year, norm->value.date.mon,
; 6033 : 			norm->value.date.day, norm->value.date.hour,
; 6034 : 			norm->value.date.min, norm->value.date.sec);
; 6035 : 		    xmlSchemaFreeValue(norm);

	mov	edx, DWORD PTR _norm$3[ebp]
	push	edx
	call	_xmlSchemaFreeValue
	add	esp, 4

; 6036 : 		} else {

	jmp	SHORT $LN83@xmlSchemaG
$LN82@xmlSchemaG:

; 6037 : 		    snprintf(buf, 50,

	mov	eax, DWORD PTR _val$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+16]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shr	edx, 14					; 0000000eH
	and	edx, 63					; 0000003fH
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shr	ecx, 9
	and	ecx, 31					; 0000001fH
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+12]
	shr	eax, 4
	and	eax, 31					; 0000001fH
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 15					; 0000000fH
	push	edx
	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0CC@NDEHGMEK@?$CF04ld?3?$CF02u?3?$CF02uT?$CF02u?3?$CF02u?3?$CF02?41@
	push	50					; 00000032H
	lea	edx, DWORD PTR _buf$4[ebp]
	push	edx
	call	_snprintf
	add	esp, 40					; 00000028H
$LN83@xmlSchemaG:

; 6038 : 			"%04ld:%02u:%02uT%02u:%02u:%02.14g",
; 6039 : 			val->value.date.year, val->value.date.mon,
; 6040 : 			val->value.date.day, val->value.date.hour,
; 6041 : 			val->value.date.min, val->value.date.sec);
; 6042 : 		}
; 6043 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	eax, DWORD PTR _buf$4[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 6044 : 	    }
; 6045 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN85@xmlSchemaG:

; 6046 : 	case XML_SCHEMAS_HEXBINARY:
; 6047 : 	    *retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.hex.str);

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 6048 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN86@xmlSchemaG:

; 6049 : 	case XML_SCHEMAS_BASE64BINARY:
; 6050 : 	    /*
; 6051 : 	    * TODO: Is the following spec piece implemented?:
; 6052 : 	    * SPEC: "Note: For some values the canonical form defined
; 6053 : 	    * above does not conform to [RFC 2045], which requires breaking
; 6054 : 	    * with linefeeds at appropriate intervals."
; 6055 : 	    */
; 6056 : 	    *retValue = BAD_CAST xmlStrdup(BAD_CAST val->value.base64.str);

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 6057 : 	    break;

	jmp	$LN2@xmlSchemaG
$LN87@xmlSchemaG:

; 6058 : 	case XML_SCHEMAS_FLOAT: {
; 6059 : 		char buf[30];
; 6060 : 		/*
; 6061 : 		* |m| < 16777216, -149 <= e <= 104.
; 6062 : 		* TODO: Handle, NaN, INF, -INF. The format is not
; 6063 : 		* yet conformant. The c type float does not cover
; 6064 : 		* the whole range.
; 6065 : 		*/
; 6066 : 		snprintf(buf, 30, "%01.14e", val->value.f);

	mov	edx, DWORD PTR _val$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+8]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07EBIAOBPB@?$CF01?414e@
	push	30					; 0000001eH
	lea	eax, DWORD PTR _buf$2[ebp]
	push	eax
	call	_snprintf
	add	esp, 20					; 00000014H

; 6067 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	ecx, DWORD PTR _buf$2[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax

; 6068 : 	    }
; 6069 : 	    break;

	jmp	SHORT $LN2@xmlSchemaG
$LN88@xmlSchemaG:

; 6070 : 	case XML_SCHEMAS_DOUBLE: {
; 6071 : 		char buf[40];
; 6072 : 		/* |m| < 9007199254740992, -1075 <= e <= 970 */
; 6073 : 		/*
; 6074 : 		* TODO: Handle, NaN, INF, -INF. The format is not
; 6075 : 		* yet conformant. The c type float does not cover
; 6076 : 		* the whole range.
; 6077 : 		*/
; 6078 : 		snprintf(buf, 40, "%01.14e", val->value.d);

	mov	eax, DWORD PTR _val$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+8]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07EBIAOBPB@?$CF01?414e@
	push	40					; 00000028H
	lea	ecx, DWORD PTR _buf$1[ebp]
	push	ecx
	call	_snprintf
	add	esp, 20					; 00000014H

; 6079 : 		*retValue = BAD_CAST xmlStrdup(BAD_CAST buf);

	lea	edx, DWORD PTR _buf$1[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 6080 : 	    }
; 6081 : 	    break;

	jmp	SHORT $LN2@xmlSchemaG
$LN89@xmlSchemaG:

; 6082 : 	default:
; 6083 : 	    *retValue = BAD_CAST xmlStrdup(BAD_CAST "???");

	push	OFFSET ??_C@_03BBKEAIF@?$DP?$DP?$DP@
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _retValue$[ebp]
	mov	DWORD PTR [edx], eax

; 6084 : 	    return (1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaG
$LN2@xmlSchemaG:

; 6085 :     }
; 6086 :     if (*retValue == NULL)

	mov	eax, DWORD PTR _retValue$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN90@xmlSchemaG

; 6087 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaG
$LN90@xmlSchemaG:

; 6088 :     return (0);

	xor	eax, eax
$LN1@xmlSchemaG:

; 6089 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN104@xmlSchemaG
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 660				; 00000294H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN104@xmlSchemaG:
	DD	10					; 0000000aH
	DD	$LN103@xmlSchemaG
$LN103@xmlSchemaG:
	DD	-24					; ffffffe8H
	DD	20					; 00000014H
	DD	$LN93@xmlSchemaG
	DD	-72					; ffffffb8H
	DD	20					; 00000014H
	DD	$LN94@xmlSchemaG
	DD	-184					; ffffff48H
	DD	100					; 00000064H
	DD	$LN95@xmlSchemaG
	DD	-260					; fffffefcH
	DD	30					; 0000001eH
	DD	$LN96@xmlSchemaG
	DD	-304					; fffffed0H
	DD	35					; 00000023H
	DD	$LN97@xmlSchemaG
	DD	-344					; fffffea8H
	DD	30					; 0000001eH
	DD	$LN98@xmlSchemaG
	DD	-388					; fffffe7cH
	DD	30					; 0000001eH
	DD	$LN99@xmlSchemaG
	DD	-452					; fffffe3cH
	DD	50					; 00000032H
	DD	$LN100@xmlSchemaG
	DD	-496					; fffffe10H
	DD	30					; 0000001eH
	DD	$LN101@xmlSchemaG
	DD	-544					; fffffde0H
	DD	40					; 00000028H
	DD	$LN102@xmlSchemaG
$LN102@xmlSchemaG:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN101@xmlSchemaG:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN100@xmlSchemaG:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN99@xmlSchemaG:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN98@xmlSchemaG:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN97@xmlSchemaG:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN96@xmlSchemaG:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN95@xmlSchemaG:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN94@xmlSchemaG:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	0
$LN93@xmlSchemaG:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	0
$LN105@xmlSchemaG:
	DD	$LN8@xmlSchemaG
	DD	$LN11@xmlSchemaG
	DD	$LN21@xmlSchemaG
	DD	$LN73@xmlSchemaG
	DD	$LN66@xmlSchemaG
	DD	$LN64@xmlSchemaG
	DD	$LN68@xmlSchemaG
	DD	$LN63@xmlSchemaG
	DD	$LN70@xmlSchemaG
	DD	$LN77@xmlSchemaG
	DD	$LN81@xmlSchemaG
	DD	$LN57@xmlSchemaG
	DD	$LN87@xmlSchemaG
	DD	$LN88@xmlSchemaG
	DD	$LN54@xmlSchemaG
	DD	$LN15@xmlSchemaG
	DD	$LN18@xmlSchemaG
	DD	$LN39@xmlSchemaG
	DD	$LN85@xmlSchemaG
	DD	$LN86@xmlSchemaG
	DD	$LN89@xmlSchemaG
$LN92@xmlSchemaG:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	20					; 00000014H
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	20					; 00000014H
	DB	15					; 0000000fH
	DB	20					; 00000014H
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
_xmlSchemaGetCanonValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValPredefTypeNodeNoNorm
_TEXT	SEGMENT
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_val$ = 16						; size = 4
_node$ = 20						; size = 4
_xmlSchemaValPredefTypeNodeNoNorm PROC			; COMDAT

; 3391 : 				 xmlSchemaValPtr *val, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 3392 :     return(xmlSchemaValAtomicType(type, value, val, node, 1,

	push	1
	push	0
	push	1
	push	0
	push	1
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	call	_xmlSchemaValAtomicType
	add	esp, 36					; 00000024H

; 3393 : 	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 0, 1));
; 3394 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaValPredefTypeNodeNoNorm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateLengthFacetWhtsp
_TEXT	SEGMENT
_facet$ = 8						; size = 4
_valType$ = 12						; size = 4
_value$ = 16						; size = 4
_val$ = 20						; size = 4
_length$ = 24						; size = 4
_ws$ = 28						; size = 4
_xmlSchemaValidateLengthFacetWhtsp PROC			; COMDAT

; 5292 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5293 :     return (xmlSchemaValidateLengthFacetInternal(facet, valType, value, val,

	mov	eax, DWORD PTR _ws$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _valType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _facet$[ebp]
	push	edx
	call	_xmlSchemaValidateLengthFacetInternal
	add	esp, 24					; 00000018H

; 5294 : 	length, ws));
; 5295 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaValidateLengthFacetWhtsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateLengthFacet
_TEXT	SEGMENT
_type$ = 8						; size = 4
_facet$ = 12						; size = 4
_value$ = 16						; size = 4
_val$ = 20						; size = 4
_length$ = 24						; size = 4
_xmlSchemaValidateLengthFacet PROC			; COMDAT

; 5262 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5263 :     if (type == NULL)

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN2@xmlSchemaV

; 5264 :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlSchemaV
$LN2@xmlSchemaV:

; 5265 :     return (xmlSchemaValidateLengthFacetInternal(facet,

	push	0
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	mov	edx, DWORD PTR _facet$[ebp]
	push	edx
	call	_xmlSchemaValidateLengthFacetInternal
	add	esp, 24					; 00000018H
$LN1@xmlSchemaV:

; 5266 : 	type->builtInType, value, val, length,
; 5267 : 	XML_SCHEMA_WHITESPACE_UNKNOWN));
; 5268 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaValidateLengthFacet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetFacetValueAsULong
_TEXT	SEGMENT
_facet$ = 8						; size = 4
_xmlSchemaGetFacetValueAsULong PROC			; COMDAT

; 5066 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5067 :     /*
; 5068 :     * TODO: Check if this is a decimal.
; 5069 :     */
; 5070 :     if (facet == NULL)

	cmp	DWORD PTR _facet$[ebp], 0
	jne	SHORT $LN2@xmlSchemaG

; 5071 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaG
$LN2@xmlSchemaG:

; 5072 :     return ((unsigned long) facet->val->value.decimal.lo);

	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [ecx+8]
$LN1@xmlSchemaG:

; 5073 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaGetFacetValueAsULong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaWhiteSpaceReplace
_TEXT	SEGMENT
_mcur$ = -12						; size = 4
_ret$ = -8						; size = 4
_cur$ = -4						; size = 4
_value$ = 8						; size = 4
_xmlSchemaWhiteSpaceReplace PROC			; COMDAT

; 1928 : xmlSchemaWhiteSpaceReplace(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1929 :     const xmlChar *cur = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 1930 :     xmlChar *ret = NULL, *mcur;

	mov	DWORD PTR _ret$[ebp], 0

; 1931 : 
; 1932 :     if (value == NULL)

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@xmlSchemaW

; 1933 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSchemaW
$LN2@xmlSchemaW:

; 1934 : 
; 1935 :     while ((*cur != 0) &&

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@xmlSchemaW
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN3@xmlSchemaW
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	je	SHORT $LN3@xmlSchemaW
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN3@xmlSchemaW

; 1936 : 	(((*cur) != 0xd) && ((*cur) != 0x9) && ((*cur) != 0xa))) {
; 1937 : 	cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 1938 :     }

	jmp	SHORT $LN2@xmlSchemaW
$LN3@xmlSchemaW:

; 1939 :     if (*cur == 0)

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN8@xmlSchemaW

; 1940 : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaW
$LN8@xmlSchemaW:

; 1941 :     ret = xmlStrdup(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 1942 :     /* TODO FIXME: I guess gcc will bark at this. */
; 1943 :     mcur = (xmlChar *)  (ret + (cur - value));

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _value$[ebp]
	add	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _mcur$[ebp], ecx
$LN6@xmlSchemaW:

; 1944 :     do {
; 1945 : 	if ( ((*mcur) == 0xd) || ((*mcur) == 0x9) || ((*mcur) == 0xa) )

	mov	edx, DWORD PTR _mcur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN10@xmlSchemaW
	mov	ecx, DWORD PTR _mcur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	je	SHORT $LN10@xmlSchemaW
	mov	eax, DWORD PTR _mcur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN9@xmlSchemaW
$LN10@xmlSchemaW:

; 1946 : 	    *mcur = ' ';

	mov	edx, DWORD PTR _mcur$[ebp]
	mov	BYTE PTR [edx], 32			; 00000020H
$LN9@xmlSchemaW:

; 1947 : 	mcur++;

	mov	eax, DWORD PTR _mcur$[ebp]
	add	eax, 1
	mov	DWORD PTR _mcur$[ebp], eax

; 1948 :     } while (*mcur != 0);

	mov	ecx, DWORD PTR _mcur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN6@xmlSchemaW

; 1949 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlSchemaW:

; 1950 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaWhiteSpaceReplace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCollapseString
_TEXT	SEGMENT
_col$ = -20						; size = 4
_g$ = -16						; size = 4
_f$ = -12						; size = 4
_end$ = -8						; size = 4
_start$ = -4						; size = 4
_value$ = 8						; size = 4
_xmlSchemaCollapseString PROC				; COMDAT

; 1961 : xmlSchemaCollapseString(const xmlChar *value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1962 :     const xmlChar *start = value, *end, *f;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 1963 :     xmlChar *g;
; 1964 :     int col = 0;

	mov	DWORD PTR _col$[ebp], 0

; 1965 : 
; 1966 :     if (value == NULL) return(NULL);

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@xmlSchemaC
	xor	eax, eax
	jmp	$LN1@xmlSchemaC
$LN2@xmlSchemaC:

; 1967 :     while ((*start != 0) && (IS_BLANK_CH(*start))) start++;

	mov	ecx, DWORD PTR _start$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@xmlSchemaC
	mov	eax, DWORD PTR _start$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN13@xmlSchemaC
	mov	edx, DWORD PTR _start$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN14@xmlSchemaC
	mov	ecx, DWORD PTR _start$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN13@xmlSchemaC
$LN14@xmlSchemaC:
	mov	eax, DWORD PTR _start$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN3@xmlSchemaC
$LN13@xmlSchemaC:
	mov	edx, DWORD PTR _start$[ebp]
	add	edx, 1
	mov	DWORD PTR _start$[ebp], edx
	jmp	SHORT $LN2@xmlSchemaC
$LN3@xmlSchemaC:

; 1968 :     end = start;

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _end$[ebp], eax
$LN4@xmlSchemaC:

; 1969 :     while (*end != 0) {

	mov	ecx, DWORD PTR _end$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN5@xmlSchemaC

; 1970 : 	if ((*end == ' ') && (IS_BLANK_CH(end[1]))) {

	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN15@xmlSchemaC
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN17@xmlSchemaC
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 9
	jl	SHORT $LN18@xmlSchemaC
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN17@xmlSchemaC
$LN18@xmlSchemaC:
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN15@xmlSchemaC
$LN17@xmlSchemaC:

; 1971 : 	    col = end - start;

	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _col$[ebp], edx

; 1972 : 	    break;

	jmp	SHORT $LN5@xmlSchemaC
	jmp	SHORT $LN16@xmlSchemaC
$LN15@xmlSchemaC:

; 1973 : 	} else if ((*end == 0xa) || (*end == 0x9) || (*end == 0xd)) {

	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN20@xmlSchemaC
	mov	edx, DWORD PTR _end$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	je	SHORT $LN20@xmlSchemaC
	mov	ecx, DWORD PTR _end$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN16@xmlSchemaC
$LN20@xmlSchemaC:

; 1974 : 	    col = end - start;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _col$[ebp], eax

; 1975 : 	    break;

	jmp	SHORT $LN5@xmlSchemaC
$LN16@xmlSchemaC:

; 1976 : 	}
; 1977 : 	end++;

	mov	ecx, DWORD PTR _end$[ebp]
	add	ecx, 1
	mov	DWORD PTR _end$[ebp], ecx

; 1978 :     }

	jmp	$LN4@xmlSchemaC
$LN5@xmlSchemaC:

; 1979 :     if (col == 0) {

	cmp	DWORD PTR _col$[ebp], 0
	jne	$LN21@xmlSchemaC

; 1980 : 	f = end;

	mov	edx, DWORD PTR _end$[ebp]
	mov	DWORD PTR _f$[ebp], edx

; 1981 : 	end--;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
$LN6@xmlSchemaC:

; 1982 : 	while ((end > start) && (IS_BLANK_CH(*end))) end--;

	mov	ecx, DWORD PTR _end$[ebp]
	cmp	ecx, DWORD PTR _start$[ebp]
	jbe	SHORT $LN7@xmlSchemaC
	mov	edx, DWORD PTR _end$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN22@xmlSchemaC
	mov	ecx, DWORD PTR _end$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN23@xmlSchemaC
	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jle	SHORT $LN22@xmlSchemaC
$LN23@xmlSchemaC:
	mov	edx, DWORD PTR _end$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN7@xmlSchemaC
$LN22@xmlSchemaC:
	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _end$[ebp], ecx
	jmp	SHORT $LN6@xmlSchemaC
$LN7@xmlSchemaC:

; 1983 : 	end++;

	mov	edx, DWORD PTR _end$[ebp]
	add	edx, 1
	mov	DWORD PTR _end$[ebp], edx

; 1984 : 	if ((start == value) && (f == end)) return(NULL);

	mov	eax, DWORD PTR _start$[ebp]
	cmp	eax, DWORD PTR _value$[ebp]
	jne	SHORT $LN24@xmlSchemaC
	mov	ecx, DWORD PTR _f$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jne	SHORT $LN24@xmlSchemaC
	xor	eax, eax
	jmp	$LN1@xmlSchemaC
$LN24@xmlSchemaC:

; 1985 : 	return(xmlStrndup(start, end - start));

	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	jmp	$LN1@xmlSchemaC
$LN21@xmlSchemaC:

; 1986 :     }
; 1987 :     start = xmlStrdup(start);

	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _start$[ebp], eax

; 1988 :     if (start == NULL) return(NULL);

	cmp	DWORD PTR _start$[ebp], 0
	jne	SHORT $LN25@xmlSchemaC
	xor	eax, eax
	jmp	$LN1@xmlSchemaC
$LN25@xmlSchemaC:

; 1989 :     g = (xmlChar *) (start + col);

	mov	edx, DWORD PTR _start$[ebp]
	add	edx, DWORD PTR _col$[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 1990 :     end = g;

	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR _end$[ebp], eax
$LN8@xmlSchemaC:

; 1991 :     while (*end != 0) {

	mov	ecx, DWORD PTR _end$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN9@xmlSchemaC

; 1992 : 	if (IS_BLANK_CH(*end)) {

	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN28@xmlSchemaC
	mov	edx, DWORD PTR _end$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN29@xmlSchemaC
	mov	ecx, DWORD PTR _end$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN28@xmlSchemaC
$LN29@xmlSchemaC:
	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN26@xmlSchemaC
$LN28@xmlSchemaC:

; 1993 : 	    end++;

	mov	edx, DWORD PTR _end$[ebp]
	add	edx, 1
	mov	DWORD PTR _end$[ebp], edx
$LN10@xmlSchemaC:

; 1994 : 	    while (IS_BLANK_CH(*end)) end++;

	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN30@xmlSchemaC
	mov	edx, DWORD PTR _end$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN31@xmlSchemaC
	mov	ecx, DWORD PTR _end$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN30@xmlSchemaC
$LN31@xmlSchemaC:
	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN11@xmlSchemaC
$LN30@xmlSchemaC:
	mov	edx, DWORD PTR _end$[ebp]
	add	edx, 1
	mov	DWORD PTR _end$[ebp], edx
	jmp	SHORT $LN10@xmlSchemaC
$LN11@xmlSchemaC:

; 1995 : 	    if (*end != 0)

	mov	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN32@xmlSchemaC

; 1996 : 		*g++ = ' ';

	mov	edx, DWORD PTR _g$[ebp]
	mov	BYTE PTR [edx], 32			; 00000020H
	mov	eax, DWORD PTR _g$[ebp]
	add	eax, 1
	mov	DWORD PTR _g$[ebp], eax
$LN32@xmlSchemaC:

; 1997 : 	} else

	jmp	SHORT $LN27@xmlSchemaC
$LN26@xmlSchemaC:

; 1998 : 	    *g++ = *end++;

	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR _end$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _g$[ebp]
	add	ecx, 1
	mov	DWORD PTR _g$[ebp], ecx
	mov	edx, DWORD PTR _end$[ebp]
	add	edx, 1
	mov	DWORD PTR _end$[ebp], edx
$LN27@xmlSchemaC:

; 1999 :     }

	jmp	$LN8@xmlSchemaC
$LN9@xmlSchemaC:

; 2000 :     *g = 0;

	mov	eax, DWORD PTR _g$[ebp]
	mov	BYTE PTR [eax], 0

; 2001 :     return((xmlChar *) start);

	mov	eax, DWORD PTR _start$[ebp]
$LN1@xmlSchemaC:

; 2002 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCollapseString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaIsBuiltInTypeFacet
_TEXT	SEGMENT
tv68 = -4						; size = 4
_type$ = 8						; size = 4
_facetType$ = 12					; size = 4
_xmlSchemaIsBuiltInTypeFacet PROC			; COMDAT

; 671  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 672  :     if (type == NULL)

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN4@xmlSchemaI

; 673  : 	return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaI
$LN4@xmlSchemaI:

; 674  :     if (type->type != XML_SCHEMA_TYPE_BASIC)

	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN5@xmlSchemaI

; 675  : 	return (-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaI
$LN5@xmlSchemaI:

; 676  :     switch (type->builtInType) {

	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR tv68[ebp], edx
	mov	eax, DWORD PTR tv68[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 43			; 0000002bH
	ja	$LN2@xmlSchemaI
	mov	ecx, DWORD PTR tv68[ebp]
	movzx	edx, BYTE PTR $LN24@xmlSchemaI[ecx]
	jmp	DWORD PTR $LN25@xmlSchemaI[edx*4]
$LN6@xmlSchemaI:

; 677  : 	case XML_SCHEMAS_BOOLEAN:
; 678  : 	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||

	cmp	DWORD PTR _facetType$[ebp], 1006	; 000003eeH
	je	SHORT $LN9@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1008	; 000003f0H
	jne	SHORT $LN7@xmlSchemaI
$LN9@xmlSchemaI:

; 679  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE))
; 680  : 		return (1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaI
	jmp	SHORT $LN10@xmlSchemaI
$LN7@xmlSchemaI:

; 681  : 	    else
; 682  : 		return (0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaI
$LN10@xmlSchemaI:

; 683  : 	case XML_SCHEMAS_STRING:
; 684  : 	case XML_SCHEMAS_NOTATION:
; 685  : 	case XML_SCHEMAS_QNAME:
; 686  : 	case XML_SCHEMAS_ANYURI:
; 687  : 	case XML_SCHEMAS_BASE64BINARY:
; 688  : 	case XML_SCHEMAS_HEXBINARY:
; 689  : 	    if ((facetType == XML_SCHEMA_FACET_LENGTH) ||
; 690  : 		(facetType == XML_SCHEMA_FACET_MINLENGTH) ||
; 691  : 		(facetType == XML_SCHEMA_FACET_MAXLENGTH) ||
; 692  : 		(facetType == XML_SCHEMA_FACET_PATTERN) ||
; 693  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||

	cmp	DWORD PTR _facetType$[ebp], 1009	; 000003f1H
	je	SHORT $LN13@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1011	; 000003f3H
	je	SHORT $LN13@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1010	; 000003f2H
	je	SHORT $LN13@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1006	; 000003eeH
	je	SHORT $LN13@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1007	; 000003efH
	je	SHORT $LN13@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1008	; 000003f0H
	jne	SHORT $LN11@xmlSchemaI
$LN13@xmlSchemaI:

; 694  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE))
; 695  : 		return (1);

	mov	eax, 1
	jmp	$LN1@xmlSchemaI
	jmp	SHORT $LN14@xmlSchemaI
$LN11@xmlSchemaI:

; 696  : 	    else
; 697  : 		return (0);

	xor	eax, eax
	jmp	$LN1@xmlSchemaI
$LN14@xmlSchemaI:

; 698  : 	case XML_SCHEMAS_DECIMAL:
; 699  : 	    if ((facetType == XML_SCHEMA_FACET_TOTALDIGITS) ||
; 700  : 		(facetType == XML_SCHEMA_FACET_FRACTIONDIGITS) ||
; 701  : 		(facetType == XML_SCHEMA_FACET_PATTERN) ||
; 702  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
; 703  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 704  : 		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
; 705  : 		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
; 706  : 		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||

	cmp	DWORD PTR _facetType$[ebp], 1004	; 000003ecH
	je	SHORT $LN17@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1005	; 000003edH
	je	SHORT $LN17@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1006	; 000003eeH
	je	SHORT $LN17@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1008	; 000003f0H
	je	SHORT $LN17@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1007	; 000003efH
	je	SHORT $LN17@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1002	; 000003eaH
	je	SHORT $LN17@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1003	; 000003ebH
	je	SHORT $LN17@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1000	; 000003e8H
	je	SHORT $LN17@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1001	; 000003e9H
	jne	SHORT $LN15@xmlSchemaI
$LN17@xmlSchemaI:

; 707  : 		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
; 708  : 		return (1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaI
	jmp	SHORT $LN18@xmlSchemaI
$LN15@xmlSchemaI:

; 709  : 	    else
; 710  : 		return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaI
$LN18@xmlSchemaI:

; 711  : 	case XML_SCHEMAS_TIME:
; 712  : 	case XML_SCHEMAS_GDAY:
; 713  : 	case XML_SCHEMAS_GMONTH:
; 714  : 	case XML_SCHEMAS_GMONTHDAY:
; 715  : 	case XML_SCHEMAS_GYEAR:
; 716  : 	case XML_SCHEMAS_GYEARMONTH:
; 717  : 	case XML_SCHEMAS_DATE:
; 718  : 	case XML_SCHEMAS_DATETIME:
; 719  : 	case XML_SCHEMAS_DURATION:
; 720  : 	case XML_SCHEMAS_FLOAT:
; 721  : 	case XML_SCHEMAS_DOUBLE:
; 722  : 	    if ((facetType == XML_SCHEMA_FACET_PATTERN) ||
; 723  : 		(facetType == XML_SCHEMA_FACET_ENUMERATION) ||
; 724  : 		(facetType == XML_SCHEMA_FACET_WHITESPACE) ||
; 725  : 		(facetType == XML_SCHEMA_FACET_MAXINCLUSIVE) ||
; 726  : 		(facetType == XML_SCHEMA_FACET_MAXEXCLUSIVE) ||
; 727  : 		(facetType == XML_SCHEMA_FACET_MININCLUSIVE) ||

	cmp	DWORD PTR _facetType$[ebp], 1006	; 000003eeH
	je	SHORT $LN21@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1007	; 000003efH
	je	SHORT $LN21@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1008	; 000003f0H
	je	SHORT $LN21@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1002	; 000003eaH
	je	SHORT $LN21@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1003	; 000003ebH
	je	SHORT $LN21@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1000	; 000003e8H
	je	SHORT $LN21@xmlSchemaI
	cmp	DWORD PTR _facetType$[ebp], 1001	; 000003e9H
	jne	SHORT $LN19@xmlSchemaI
$LN21@xmlSchemaI:

; 728  : 		(facetType == XML_SCHEMA_FACET_MINEXCLUSIVE))
; 729  : 		return (1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlSchemaI
	jmp	SHORT $LN2@xmlSchemaI
$LN19@xmlSchemaI:

; 730  : 	    else
; 731  : 		return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaI
$LN2@xmlSchemaI:

; 732  : 	default:
; 733  : 	    break;
; 734  :     }
; 735  :     return (0);

	xor	eax, eax
$LN1@xmlSchemaI:

; 736  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@xmlSchemaI:
	DD	$LN10@xmlSchemaI
	DD	$LN14@xmlSchemaI
	DD	$LN18@xmlSchemaI
	DD	$LN6@xmlSchemaI
	DD	$LN2@xmlSchemaI
$LN24@xmlSchemaI:
	DB	0
	DB	4
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
_xmlSchemaIsBuiltInTypeFacet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetBuiltInType
_TEXT	SEGMENT
tv65 = -4						; size = 4
_type$ = 8						; size = 4
_xmlSchemaGetBuiltInType PROC				; COMDAT

; 749  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 750  :     if (xmlSchemaTypesInitialized == 0)

	cmp	DWORD PTR _xmlSchemaTypesInitialized, 0
	jne	SHORT $LN4@xmlSchemaG

; 751  : 	xmlSchemaInitTypes();

	call	_xmlSchemaInitTypes
$LN4@xmlSchemaG:

; 752  :     switch (type) {

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 45			; 0000002dH
	ja	$LN51@xmlSchemaG
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN53@xmlSchemaG[edx*4]
$LN5@xmlSchemaG:

; 753  : 
; 754  : 	case XML_SCHEMAS_ANYSIMPLETYPE:
; 755  : 	    return (xmlSchemaTypeAnySimpleTypeDef);

	mov	eax, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	jmp	$LN1@xmlSchemaG
$LN6@xmlSchemaG:

; 756  : 	case XML_SCHEMAS_STRING:
; 757  : 	    return (xmlSchemaTypeStringDef);

	mov	eax, DWORD PTR _xmlSchemaTypeStringDef
	jmp	$LN1@xmlSchemaG
$LN7@xmlSchemaG:

; 758  : 	case XML_SCHEMAS_NORMSTRING:
; 759  : 	    return (xmlSchemaTypeNormStringDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNormStringDef
	jmp	$LN1@xmlSchemaG
$LN8@xmlSchemaG:

; 760  : 	case XML_SCHEMAS_DECIMAL:
; 761  : 	    return (xmlSchemaTypeDecimalDef);

	mov	eax, DWORD PTR _xmlSchemaTypeDecimalDef
	jmp	$LN1@xmlSchemaG
$LN9@xmlSchemaG:

; 762  : 	case XML_SCHEMAS_TIME:
; 763  : 	    return (xmlSchemaTypeTimeDef);

	mov	eax, DWORD PTR _xmlSchemaTypeTimeDef
	jmp	$LN1@xmlSchemaG
$LN10@xmlSchemaG:

; 764  : 	case XML_SCHEMAS_GDAY:
; 765  : 	    return (xmlSchemaTypeGDayDef);

	mov	eax, DWORD PTR _xmlSchemaTypeGDayDef
	jmp	$LN1@xmlSchemaG
$LN11@xmlSchemaG:

; 766  : 	case XML_SCHEMAS_GMONTH:
; 767  : 	    return (xmlSchemaTypeGMonthDef);

	mov	eax, DWORD PTR _xmlSchemaTypeGMonthDef
	jmp	$LN1@xmlSchemaG
$LN12@xmlSchemaG:

; 768  : 	case XML_SCHEMAS_GMONTHDAY:
; 769  : 	    return (xmlSchemaTypeGMonthDayDef);

	mov	eax, DWORD PTR _xmlSchemaTypeGMonthDayDef
	jmp	$LN1@xmlSchemaG
$LN13@xmlSchemaG:

; 770  : 	case XML_SCHEMAS_GYEAR:
; 771  : 	    return (xmlSchemaTypeGYearDef);

	mov	eax, DWORD PTR _xmlSchemaTypeGYearDef
	jmp	$LN1@xmlSchemaG
$LN14@xmlSchemaG:

; 772  : 	case XML_SCHEMAS_GYEARMONTH:
; 773  : 	    return (xmlSchemaTypeGYearMonthDef);

	mov	eax, DWORD PTR _xmlSchemaTypeGYearMonthDef
	jmp	$LN1@xmlSchemaG
$LN15@xmlSchemaG:

; 774  : 	case XML_SCHEMAS_DATE:
; 775  : 	    return (xmlSchemaTypeDateDef);

	mov	eax, DWORD PTR _xmlSchemaTypeDateDef
	jmp	$LN1@xmlSchemaG
$LN16@xmlSchemaG:

; 776  : 	case XML_SCHEMAS_DATETIME:
; 777  : 	    return (xmlSchemaTypeDatetimeDef);

	mov	eax, DWORD PTR _xmlSchemaTypeDatetimeDef
	jmp	$LN1@xmlSchemaG
$LN17@xmlSchemaG:

; 778  : 	case XML_SCHEMAS_DURATION:
; 779  : 	    return (xmlSchemaTypeDurationDef);

	mov	eax, DWORD PTR _xmlSchemaTypeDurationDef
	jmp	$LN1@xmlSchemaG
$LN18@xmlSchemaG:

; 780  : 	case XML_SCHEMAS_FLOAT:
; 781  : 	    return (xmlSchemaTypeFloatDef);

	mov	eax, DWORD PTR _xmlSchemaTypeFloatDef
	jmp	$LN1@xmlSchemaG
$LN19@xmlSchemaG:

; 782  : 	case XML_SCHEMAS_DOUBLE:
; 783  : 	    return (xmlSchemaTypeDoubleDef);

	mov	eax, DWORD PTR _xmlSchemaTypeDoubleDef
	jmp	$LN1@xmlSchemaG
$LN20@xmlSchemaG:

; 784  : 	case XML_SCHEMAS_BOOLEAN:
; 785  : 	    return (xmlSchemaTypeBooleanDef);

	mov	eax, DWORD PTR _xmlSchemaTypeBooleanDef
	jmp	$LN1@xmlSchemaG
$LN21@xmlSchemaG:

; 786  : 	case XML_SCHEMAS_TOKEN:
; 787  : 	    return (xmlSchemaTypeTokenDef);

	mov	eax, DWORD PTR _xmlSchemaTypeTokenDef
	jmp	$LN1@xmlSchemaG
$LN22@xmlSchemaG:

; 788  : 	case XML_SCHEMAS_LANGUAGE:
; 789  : 	    return (xmlSchemaTypeLanguageDef);

	mov	eax, DWORD PTR _xmlSchemaTypeLanguageDef
	jmp	$LN1@xmlSchemaG
$LN23@xmlSchemaG:

; 790  : 	case XML_SCHEMAS_NMTOKEN:
; 791  : 	    return (xmlSchemaTypeNmtokenDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNmtokenDef
	jmp	$LN1@xmlSchemaG
$LN24@xmlSchemaG:

; 792  : 	case XML_SCHEMAS_NMTOKENS:
; 793  : 	    return (xmlSchemaTypeNmtokensDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNmtokensDef
	jmp	$LN1@xmlSchemaG
$LN25@xmlSchemaG:

; 794  : 	case XML_SCHEMAS_NAME:
; 795  : 	    return (xmlSchemaTypeNameDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNameDef
	jmp	$LN1@xmlSchemaG
$LN26@xmlSchemaG:

; 796  : 	case XML_SCHEMAS_QNAME:
; 797  : 	    return (xmlSchemaTypeQNameDef);

	mov	eax, DWORD PTR _xmlSchemaTypeQNameDef
	jmp	$LN1@xmlSchemaG
$LN27@xmlSchemaG:

; 798  : 	case XML_SCHEMAS_NCNAME:
; 799  : 	    return (xmlSchemaTypeNCNameDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNCNameDef
	jmp	$LN1@xmlSchemaG
$LN28@xmlSchemaG:

; 800  : 	case XML_SCHEMAS_ID:
; 801  : 	    return (xmlSchemaTypeIdDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIdDef
	jmp	$LN1@xmlSchemaG
$LN29@xmlSchemaG:

; 802  : 	case XML_SCHEMAS_IDREF:
; 803  : 	    return (xmlSchemaTypeIdrefDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIdrefDef
	jmp	$LN1@xmlSchemaG
$LN30@xmlSchemaG:

; 804  : 	case XML_SCHEMAS_IDREFS:
; 805  : 	    return (xmlSchemaTypeIdrefsDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIdrefsDef
	jmp	$LN1@xmlSchemaG
$LN31@xmlSchemaG:

; 806  : 	case XML_SCHEMAS_ENTITY:
; 807  : 	    return (xmlSchemaTypeEntityDef);

	mov	eax, DWORD PTR _xmlSchemaTypeEntityDef
	jmp	$LN1@xmlSchemaG
$LN32@xmlSchemaG:

; 808  : 	case XML_SCHEMAS_ENTITIES:
; 809  : 	    return (xmlSchemaTypeEntitiesDef);

	mov	eax, DWORD PTR _xmlSchemaTypeEntitiesDef
	jmp	$LN1@xmlSchemaG
$LN33@xmlSchemaG:

; 810  : 	case XML_SCHEMAS_NOTATION:
; 811  : 	    return (xmlSchemaTypeNotationDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNotationDef
	jmp	SHORT $LN1@xmlSchemaG
$LN34@xmlSchemaG:

; 812  : 	case XML_SCHEMAS_ANYURI:
; 813  : 	    return (xmlSchemaTypeAnyURIDef);

	mov	eax, DWORD PTR _xmlSchemaTypeAnyURIDef
	jmp	SHORT $LN1@xmlSchemaG
$LN35@xmlSchemaG:

; 814  : 	case XML_SCHEMAS_INTEGER:
; 815  : 	    return (xmlSchemaTypeIntegerDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIntegerDef
	jmp	SHORT $LN1@xmlSchemaG
$LN36@xmlSchemaG:

; 816  : 	case XML_SCHEMAS_NPINTEGER:
; 817  : 	    return (xmlSchemaTypeNonPositiveIntegerDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNonPositiveIntegerDef
	jmp	SHORT $LN1@xmlSchemaG
$LN37@xmlSchemaG:

; 818  : 	case XML_SCHEMAS_NINTEGER:
; 819  : 	    return (xmlSchemaTypeNegativeIntegerDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNegativeIntegerDef
	jmp	SHORT $LN1@xmlSchemaG
$LN38@xmlSchemaG:

; 820  : 	case XML_SCHEMAS_NNINTEGER:
; 821  : 	    return (xmlSchemaTypeNonNegativeIntegerDef);

	mov	eax, DWORD PTR _xmlSchemaTypeNonNegativeIntegerDef
	jmp	SHORT $LN1@xmlSchemaG
$LN39@xmlSchemaG:

; 822  : 	case XML_SCHEMAS_PINTEGER:
; 823  : 	    return (xmlSchemaTypePositiveIntegerDef);

	mov	eax, DWORD PTR _xmlSchemaTypePositiveIntegerDef
	jmp	SHORT $LN1@xmlSchemaG
$LN40@xmlSchemaG:

; 824  : 	case XML_SCHEMAS_INT:
; 825  : 	    return (xmlSchemaTypeIntDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIntDef
	jmp	SHORT $LN1@xmlSchemaG
$LN41@xmlSchemaG:

; 826  : 	case XML_SCHEMAS_UINT:
; 827  : 	    return (xmlSchemaTypeUnsignedIntDef);

	mov	eax, DWORD PTR _xmlSchemaTypeUnsignedIntDef
	jmp	SHORT $LN1@xmlSchemaG
$LN42@xmlSchemaG:

; 828  : 	case XML_SCHEMAS_LONG:
; 829  : 	    return (xmlSchemaTypeLongDef);

	mov	eax, DWORD PTR _xmlSchemaTypeLongDef
	jmp	SHORT $LN1@xmlSchemaG
$LN43@xmlSchemaG:

; 830  : 	case XML_SCHEMAS_ULONG:
; 831  : 	    return (xmlSchemaTypeUnsignedLongDef);

	mov	eax, DWORD PTR _xmlSchemaTypeUnsignedLongDef
	jmp	SHORT $LN1@xmlSchemaG
$LN44@xmlSchemaG:

; 832  : 	case XML_SCHEMAS_SHORT:
; 833  : 	    return (xmlSchemaTypeShortDef);

	mov	eax, DWORD PTR _xmlSchemaTypeShortDef
	jmp	SHORT $LN1@xmlSchemaG
$LN45@xmlSchemaG:

; 834  : 	case XML_SCHEMAS_USHORT:
; 835  : 	    return (xmlSchemaTypeUnsignedShortDef);

	mov	eax, DWORD PTR _xmlSchemaTypeUnsignedShortDef
	jmp	SHORT $LN1@xmlSchemaG
$LN46@xmlSchemaG:

; 836  : 	case XML_SCHEMAS_BYTE:
; 837  : 	    return (xmlSchemaTypeByteDef);

	mov	eax, DWORD PTR _xmlSchemaTypeByteDef
	jmp	SHORT $LN1@xmlSchemaG
$LN47@xmlSchemaG:

; 838  : 	case XML_SCHEMAS_UBYTE:
; 839  : 	    return (xmlSchemaTypeUnsignedByteDef);

	mov	eax, DWORD PTR _xmlSchemaTypeUnsignedByteDef
	jmp	SHORT $LN1@xmlSchemaG
$LN48@xmlSchemaG:

; 840  : 	case XML_SCHEMAS_HEXBINARY:
; 841  : 	    return (xmlSchemaTypeHexBinaryDef);

	mov	eax, DWORD PTR _xmlSchemaTypeHexBinaryDef
	jmp	SHORT $LN1@xmlSchemaG
$LN49@xmlSchemaG:

; 842  : 	case XML_SCHEMAS_BASE64BINARY:
; 843  : 	    return (xmlSchemaTypeBase64BinaryDef);

	mov	eax, DWORD PTR _xmlSchemaTypeBase64BinaryDef
	jmp	SHORT $LN1@xmlSchemaG
$LN50@xmlSchemaG:

; 844  : 	case XML_SCHEMAS_ANYTYPE:
; 845  : 	    return (xmlSchemaTypeAnyTypeDef);

	mov	eax, DWORD PTR _xmlSchemaTypeAnyTypeDef
	jmp	SHORT $LN1@xmlSchemaG
$LN51@xmlSchemaG:

; 846  : 	default:
; 847  : 	    return (NULL);

	xor	eax, eax
$LN1@xmlSchemaG:

; 848  :     }
; 849  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@xmlSchemaG:
	DD	$LN6@xmlSchemaG
	DD	$LN7@xmlSchemaG
	DD	$LN8@xmlSchemaG
	DD	$LN9@xmlSchemaG
	DD	$LN10@xmlSchemaG
	DD	$LN11@xmlSchemaG
	DD	$LN12@xmlSchemaG
	DD	$LN13@xmlSchemaG
	DD	$LN14@xmlSchemaG
	DD	$LN15@xmlSchemaG
	DD	$LN16@xmlSchemaG
	DD	$LN17@xmlSchemaG
	DD	$LN18@xmlSchemaG
	DD	$LN19@xmlSchemaG
	DD	$LN20@xmlSchemaG
	DD	$LN21@xmlSchemaG
	DD	$LN22@xmlSchemaG
	DD	$LN23@xmlSchemaG
	DD	$LN24@xmlSchemaG
	DD	$LN25@xmlSchemaG
	DD	$LN26@xmlSchemaG
	DD	$LN27@xmlSchemaG
	DD	$LN28@xmlSchemaG
	DD	$LN29@xmlSchemaG
	DD	$LN30@xmlSchemaG
	DD	$LN31@xmlSchemaG
	DD	$LN32@xmlSchemaG
	DD	$LN33@xmlSchemaG
	DD	$LN34@xmlSchemaG
	DD	$LN35@xmlSchemaG
	DD	$LN36@xmlSchemaG
	DD	$LN37@xmlSchemaG
	DD	$LN38@xmlSchemaG
	DD	$LN39@xmlSchemaG
	DD	$LN40@xmlSchemaG
	DD	$LN41@xmlSchemaG
	DD	$LN42@xmlSchemaG
	DD	$LN43@xmlSchemaG
	DD	$LN44@xmlSchemaG
	DD	$LN45@xmlSchemaG
	DD	$LN46@xmlSchemaG
	DD	$LN47@xmlSchemaG
	DD	$LN48@xmlSchemaG
	DD	$LN49@xmlSchemaG
	DD	$LN50@xmlSchemaG
	DD	$LN5@xmlSchemaG
_xmlSchemaGetBuiltInType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateListSimpleTypeFacet
_TEXT	SEGMENT
_facet$ = 8						; size = 4
_value$ = 12						; size = 4
_actualLen$ = 16					; size = 4
_expectedLen$ = 20					; size = 4
_xmlSchemaValidateListSimpleTypeFacet PROC		; COMDAT

; 5092 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5093 :     if (facet == NULL)

	cmp	DWORD PTR _facet$[ebp], 0
	jne	SHORT $LN2@xmlSchemaV

; 5094 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlSchemaV
$LN2@xmlSchemaV:

; 5095 :     /*
; 5096 :     * TODO: Check if this will work with large numbers.
; 5097 :     * (compare value.decimal.mi and value.decimal.hi as well?).
; 5098 :     */
; 5099 :     if (facet->type == XML_SCHEMA_FACET_LENGTH) {

	mov	eax, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [eax], 1009			; 000003f1H
	jne	SHORT $LN3@xmlSchemaV

; 5100 : 	if (actualLen != facet->val->value.decimal.lo) {

	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _actualLen$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN5@xmlSchemaV

; 5101 : 	    if (expectedLen != NULL)

	cmp	DWORD PTR _expectedLen$[ebp], 0
	je	SHORT $LN6@xmlSchemaV

; 5102 : 		*expectedLen = facet->val->value.decimal.lo;

	mov	ecx, DWORD PTR _facet$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _expectedLen$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax], ecx
$LN6@xmlSchemaV:

; 5103 : 	    return (XML_SCHEMAV_CVC_LENGTH_VALID);

	mov	eax, 1830				; 00000726H
	jmp	$LN1@xmlSchemaV
$LN5@xmlSchemaV:

; 5104 : 	}

	jmp	$LN4@xmlSchemaV
$LN3@xmlSchemaV:

; 5105 :     } else if (facet->type == XML_SCHEMA_FACET_MINLENGTH) {

	mov	edx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [edx], 1011			; 000003f3H
	jne	SHORT $LN7@xmlSchemaV

; 5106 : 	if (actualLen < facet->val->value.decimal.lo) {

	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _actualLen$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN9@xmlSchemaV

; 5107 : 	    if (expectedLen != NULL)

	cmp	DWORD PTR _expectedLen$[ebp], 0
	je	SHORT $LN10@xmlSchemaV

; 5108 : 		*expectedLen = facet->val->value.decimal.lo;

	mov	eax, DWORD PTR _facet$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _expectedLen$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
$LN10@xmlSchemaV:

; 5109 : 	    return (XML_SCHEMAV_CVC_MINLENGTH_VALID);

	mov	eax, 1831				; 00000727H
	jmp	SHORT $LN1@xmlSchemaV
$LN9@xmlSchemaV:

; 5110 : 	}

	jmp	SHORT $LN4@xmlSchemaV
$LN7@xmlSchemaV:

; 5111 :     } else if (facet->type == XML_SCHEMA_FACET_MAXLENGTH) {

	mov	ecx, DWORD PTR _facet$[ebp]
	cmp	DWORD PTR [ecx], 1010			; 000003f2H
	jne	SHORT $LN11@xmlSchemaV

; 5112 : 	if (actualLen > facet->val->value.decimal.lo) {

	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _actualLen$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jbe	SHORT $LN13@xmlSchemaV

; 5113 : 	    if (expectedLen != NULL)

	cmp	DWORD PTR _expectedLen$[ebp], 0
	je	SHORT $LN14@xmlSchemaV

; 5114 : 		*expectedLen = facet->val->value.decimal.lo;

	mov	edx, DWORD PTR _facet$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _expectedLen$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx], edx
$LN14@xmlSchemaV:

; 5115 : 	    return (XML_SCHEMAV_CVC_MAXLENGTH_VALID);

	mov	eax, 1832				; 00000728H
	jmp	SHORT $LN1@xmlSchemaV
$LN13@xmlSchemaV:

; 5116 : 	}
; 5117 :     } else

	jmp	SHORT $LN4@xmlSchemaV
$LN11@xmlSchemaV:

; 5118 : 	/*
; 5119 : 	* NOTE: That we can pass NULL as xmlSchemaValPtr to
; 5120 : 	* xmlSchemaValidateFacet, since the remaining facet types
; 5121 : 	* are: XML_SCHEMA_FACET_PATTERN, XML_SCHEMA_FACET_ENUMERATION.
; 5122 : 	*/
; 5123 : 	return(xmlSchemaValidateFacet(NULL, facet, value, NULL));

	push	0
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _facet$[ebp]
	push	ecx
	push	0
	call	_xmlSchemaValidateFacet
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@xmlSchemaV
$LN4@xmlSchemaV:

; 5124 :     return (0);

	xor	eax, eax
$LN1@xmlSchemaV:

; 5125 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaValidateListSimpleTypeFacet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetBuiltInListSimpleTypeItemType
_TEXT	SEGMENT
tv68 = -4						; size = 4
_type$ = 8						; size = 4
_xmlSchemaGetBuiltInListSimpleTypeItemType PROC		; COMDAT

; 1101 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1102 :     if ((type == NULL) || (type->type != XML_SCHEMA_TYPE_BASIC))

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN5@xmlSchemaG
	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN4@xmlSchemaG
$LN5@xmlSchemaG:

; 1103 : 	return (NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaG
$LN4@xmlSchemaG:

; 1104 :     switch (type->builtInType) {

	mov	ecx, DWORD PTR _type$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 19			; 00000013H
	je	SHORT $LN6@xmlSchemaG
	cmp	DWORD PTR tv68[ebp], 25			; 00000019H
	je	SHORT $LN7@xmlSchemaG
	cmp	DWORD PTR tv68[ebp], 27			; 0000001bH
	je	SHORT $LN8@xmlSchemaG
	jmp	SHORT $LN9@xmlSchemaG
$LN6@xmlSchemaG:

; 1105 : 	case XML_SCHEMAS_NMTOKENS:
; 1106 : 	    return (xmlSchemaTypeNmtokenDef );

	mov	eax, DWORD PTR _xmlSchemaTypeNmtokenDef
	jmp	SHORT $LN1@xmlSchemaG
$LN7@xmlSchemaG:

; 1107 : 	case XML_SCHEMAS_IDREFS:
; 1108 : 	    return (xmlSchemaTypeIdrefDef);

	mov	eax, DWORD PTR _xmlSchemaTypeIdrefDef
	jmp	SHORT $LN1@xmlSchemaG
$LN8@xmlSchemaG:

; 1109 : 	case XML_SCHEMAS_ENTITIES:
; 1110 : 	    return (xmlSchemaTypeEntityDef);

	mov	eax, DWORD PTR _xmlSchemaTypeEntityDef
	jmp	SHORT $LN1@xmlSchemaG
$LN9@xmlSchemaG:

; 1111 : 	default:
; 1112 : 	    return (NULL);

	xor	eax, eax
$LN1@xmlSchemaG:

; 1113 :     }
; 1114 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaGetBuiltInListSimpleTypeItemType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCompareValues
_TEXT	SEGMENT
_yws$ = -8						; size = 4
_xws$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_xmlSchemaCompareValues PROC				; COMDAT

; 4937 : xmlSchemaCompareValues(xmlSchemaValPtr x, xmlSchemaValPtr y) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 4938 :     xmlSchemaWhitespaceValueType xws, yws;
; 4939 : 
; 4940 :     if ((x == NULL) || (y == NULL))

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@xmlSchemaC
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN2@xmlSchemaC
$LN3@xmlSchemaC:

; 4941 :         return(-2);

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@xmlSchemaC
$LN2@xmlSchemaC:

; 4942 :     if (x->type == XML_SCHEMAS_STRING)

	mov	eax, DWORD PTR _x$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN4@xmlSchemaC

; 4943 : 	xws = XML_SCHEMA_WHITESPACE_PRESERVE;

	mov	DWORD PTR _xws$[ebp], 1
	jmp	SHORT $LN5@xmlSchemaC
$LN4@xmlSchemaC:

; 4944 :     else if (x->type == XML_SCHEMAS_NORMSTRING)

	mov	ecx, DWORD PTR _x$[ebp]
	cmp	DWORD PTR [ecx], 2
	jne	SHORT $LN6@xmlSchemaC

; 4945 :         xws = XML_SCHEMA_WHITESPACE_REPLACE;

	mov	DWORD PTR _xws$[ebp], 2
	jmp	SHORT $LN5@xmlSchemaC
$LN6@xmlSchemaC:

; 4946 :     else
; 4947 :         xws = XML_SCHEMA_WHITESPACE_COLLAPSE;

	mov	DWORD PTR _xws$[ebp], 3
$LN5@xmlSchemaC:

; 4948 : 
; 4949 :     if (y->type == XML_SCHEMAS_STRING)

	mov	edx, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $LN8@xmlSchemaC

; 4950 : 	yws = XML_SCHEMA_WHITESPACE_PRESERVE;

	mov	DWORD PTR _yws$[ebp], 1
	jmp	SHORT $LN9@xmlSchemaC
$LN8@xmlSchemaC:

; 4951 :     else if (y->type == XML_SCHEMAS_NORMSTRING)

	mov	eax, DWORD PTR _y$[ebp]
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN10@xmlSchemaC

; 4952 :         yws = XML_SCHEMA_WHITESPACE_REPLACE;

	mov	DWORD PTR _yws$[ebp], 2
	jmp	SHORT $LN9@xmlSchemaC
$LN10@xmlSchemaC:

; 4953 :     else
; 4954 :         yws = XML_SCHEMA_WHITESPACE_COLLAPSE;

	mov	DWORD PTR _yws$[ebp], 3
$LN9@xmlSchemaC:

; 4955 : 
; 4956 :     return(xmlSchemaCompareValuesInternal(x->type, x, NULL, xws, y->type,

	mov	ecx, DWORD PTR _yws$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _xws$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlSchemaCompareValuesInternal
	add	esp, 32					; 00000020H
$LN1@xmlSchemaC:

; 4957 : 	y, NULL, yws));
; 4958 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCompareValues ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaFreeValue
_TEXT	SEGMENT
tv66 = -8						; size = 4
_prev$ = -4						; size = 4
_value$ = 8						; size = 4
_xmlSchemaFreeValue PROC				; COMDAT

; 1025 : xmlSchemaFreeValue(xmlSchemaValPtr value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlSchemaF:

; 1026 :     xmlSchemaValPtr prev;
; 1027 : 
; 1028 :     while (value != NULL) {

	cmp	DWORD PTR _value$[ebp], 0
	je	$LN1@xmlSchemaF

; 1029 : 	switch (value->type) {

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR tv66[ebp]
	sub	edx, 1
	mov	DWORD PTR tv66[ebp], edx
	cmp	DWORD PTR tv66[ebp], 45			; 0000002dH
	ja	$LN4@xmlSchemaF
	mov	eax, DWORD PTR tv66[ebp]
	movzx	ecx, BYTE PTR $LN17@xmlSchemaF[eax]
	jmp	DWORD PTR $LN18@xmlSchemaF[ecx*4]
$LN6@xmlSchemaF:

; 1030 : 	    case XML_SCHEMAS_STRING:
; 1031 : 	    case XML_SCHEMAS_NORMSTRING:
; 1032 : 	    case XML_SCHEMAS_TOKEN:
; 1033 : 	    case XML_SCHEMAS_LANGUAGE:
; 1034 : 	    case XML_SCHEMAS_NMTOKEN:
; 1035 : 	    case XML_SCHEMAS_NMTOKENS:
; 1036 : 	    case XML_SCHEMAS_NAME:
; 1037 : 	    case XML_SCHEMAS_NCNAME:
; 1038 : 	    case XML_SCHEMAS_ID:
; 1039 : 	    case XML_SCHEMAS_IDREF:
; 1040 : 	    case XML_SCHEMAS_IDREFS:
; 1041 : 	    case XML_SCHEMAS_ENTITY:
; 1042 : 	    case XML_SCHEMAS_ENTITIES:
; 1043 : 	    case XML_SCHEMAS_ANYURI:
; 1044 : 	    case XML_SCHEMAS_ANYSIMPLETYPE:
; 1045 : 		if (value->value.str != NULL)

	mov	edx, DWORD PTR _value$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN7@xmlSchemaF

; 1046 : 		    xmlFree(value->value.str);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlSchemaF:

; 1047 : 		break;

	jmp	$LN4@xmlSchemaF
$LN8@xmlSchemaF:

; 1048 : 	    case XML_SCHEMAS_NOTATION:
; 1049 : 	    case XML_SCHEMAS_QNAME:
; 1050 : 		if (value->value.qname.uri != NULL)

	mov	edx, DWORD PTR _value$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN9@xmlSchemaF

; 1051 : 		    xmlFree(value->value.qname.uri);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlSchemaF:

; 1052 : 		if (value->value.qname.name != NULL)

	mov	edx, DWORD PTR _value$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN10@xmlSchemaF

; 1053 : 		    xmlFree(value->value.qname.name);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlSchemaF:

; 1054 : 		break;

	jmp	SHORT $LN4@xmlSchemaF
$LN11@xmlSchemaF:

; 1055 : 	    case XML_SCHEMAS_HEXBINARY:
; 1056 : 		if (value->value.hex.str != NULL)

	mov	edx, DWORD PTR _value$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN12@xmlSchemaF

; 1057 : 		    xmlFree(value->value.hex.str);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlSchemaF:

; 1058 : 		break;

	jmp	SHORT $LN4@xmlSchemaF
$LN13@xmlSchemaF:

; 1059 : 	    case XML_SCHEMAS_BASE64BINARY:
; 1060 : 		if (value->value.base64.str != NULL)

	mov	edx, DWORD PTR _value$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN4@xmlSchemaF

; 1061 : 		    xmlFree(value->value.base64.str);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlSchemaF:

; 1062 : 		break;
; 1063 : 	    default:
; 1064 : 		break;
; 1065 : 	}
; 1066 : 	prev = value;

	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _prev$[ebp], edx

; 1067 : 	value = value->next;

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _value$[ebp], ecx

; 1068 : 	xmlFree(prev);

	mov	esi, esp
	mov	edx, DWORD PTR _prev$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1069 :     }

	jmp	$LN2@xmlSchemaF
$LN1@xmlSchemaF:

; 1070 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN18@xmlSchemaF:
	DD	$LN6@xmlSchemaF
	DD	$LN8@xmlSchemaF
	DD	$LN11@xmlSchemaF
	DD	$LN13@xmlSchemaF
	DD	$LN4@xmlSchemaF
$LN17@xmlSchemaF:
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	3
	DB	4
	DB	0
_xmlSchemaFreeValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateFacetWhtsp
_TEXT	SEGMENT
_facet$ = 8						; size = 4
_fws$ = 12						; size = 4
_valType$ = 16						; size = 4
_value$ = 20						; size = 4
_val$ = 24						; size = 4
_ws$ = 28						; size = 4
_xmlSchemaValidateFacetWhtsp PROC			; COMDAT

; 5585 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5586 :      return(xmlSchemaValidateFacetInternal(facet, fws, valType,

	mov	eax, DWORD PTR _ws$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _valType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fws$[ebp]
	push	ecx
	mov	edx, DWORD PTR _facet$[ebp]
	push	edx
	call	_xmlSchemaValidateFacetInternal
	add	esp, 24					; 00000018H

; 5587 : 	 value, val, ws));
; 5588 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaValidateFacetWhtsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidateFacet
_TEXT	SEGMENT
_base$ = 8						; size = 4
_facet$ = 12						; size = 4
_value$ = 16						; size = 4
_val$ = 20						; size = 4
_xmlSchemaValidateFacet PROC				; COMDAT

; 5544 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 5545 :     /*
; 5546 :     * This tries to ensure API compatibility regarding the old
; 5547 :     * xmlSchemaValidateFacet() and the new xmlSchemaValidateFacetInternal() and
; 5548 :     * xmlSchemaValidateFacetWhtsp().
; 5549 :     */
; 5550 :     if (val != NULL)

	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN2@xmlSchemaV

; 5551 : 	return(xmlSchemaValidateFacetInternal(facet,

	push	0
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	mov	ecx, DWORD PTR _facet$[ebp]
	push	ecx
	call	_xmlSchemaValidateFacetInternal
	add	esp, 24					; 00000018H
	jmp	SHORT $LN1@xmlSchemaV
	jmp	SHORT $LN3@xmlSchemaV
$LN2@xmlSchemaV:

; 5552 : 	    XML_SCHEMA_WHITESPACE_UNKNOWN, val->type, value, val,
; 5553 : 	    XML_SCHEMA_WHITESPACE_UNKNOWN));
; 5554 :     else if (base != NULL)

	cmp	DWORD PTR _base$[ebp], 0
	je	SHORT $LN3@xmlSchemaV

; 5555 : 	return(xmlSchemaValidateFacetInternal(facet,

	push	0
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _base$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	push	0
	mov	eax, DWORD PTR _facet$[ebp]
	push	eax
	call	_xmlSchemaValidateFacetInternal
	add	esp, 24					; 00000018H
	jmp	SHORT $LN1@xmlSchemaV
$LN3@xmlSchemaV:

; 5556 : 	    XML_SCHEMA_WHITESPACE_UNKNOWN, base->builtInType, value, val,
; 5557 : 	    XML_SCHEMA_WHITESPACE_UNKNOWN));
; 5558 :     return(-1);

	or	eax, -1
$LN1@xmlSchemaV:

; 5559 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaValidateFacet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValPredefTypeNode
_TEXT	SEGMENT
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_val$ = 16						; size = 4
_node$ = 20						; size = 4
_xmlSchemaValPredefTypeNode PROC			; COMDAT

; 3370 : 	                   xmlSchemaValPtr *val, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 3371 :     return(xmlSchemaValAtomicType(type, value, val, node, 0,

	push	0
	push	1
	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	call	_xmlSchemaValAtomicType
	add	esp, 36					; 00000024H

; 3372 : 	XML_SCHEMA_WHITESPACE_UNKNOWN, 1, 1, 0));
; 3373 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaValPredefTypeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaValidatePredefinedType
_TEXT	SEGMENT
_type$ = 8						; size = 4
_value$ = 12						; size = 4
_val$ = 16						; size = 4
_xmlSchemaValidatePredefinedType PROC			; COMDAT

; 3410 : 	                        xmlSchemaValPtr *val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 3411 :     return(xmlSchemaValPredefTypeNode(type, value, val, NULL));

	push	0
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	call	_xmlSchemaValPredefTypeNode
	add	esp, 16					; 00000010H

; 3412 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaValidatePredefinedType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaGetPredefinedType
_TEXT	SEGMENT
_name$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlSchemaGetPredefinedType PROC			; COMDAT

; 1082 : xmlSchemaGetPredefinedType(const xmlChar *name, const xmlChar *ns) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 1083 :     if (xmlSchemaTypesInitialized == 0)

	cmp	DWORD PTR _xmlSchemaTypesInitialized, 0
	jne	SHORT $LN2@xmlSchemaG

; 1084 : 	xmlSchemaInitTypes();

	call	_xmlSchemaInitTypes
$LN2@xmlSchemaG:

; 1085 :     if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN3@xmlSchemaG

; 1086 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSchemaG
$LN3@xmlSchemaG:

; 1087 :     return((xmlSchemaTypePtr) xmlHashLookup2(xmlSchemaTypesBank, name, ns));

	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _xmlSchemaTypesBank
	push	edx
	call	_xmlHashLookup2
	add	esp, 12					; 0000000cH
$LN1@xmlSchemaG:

; 1088 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlSchemaGetPredefinedType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaCleanupTypes
_TEXT	SEGMENT
_particle$1 = -4					; size = 4
_xmlSchemaCleanupTypes PROC				; COMDAT

; 633  : xmlSchemaCleanupTypes(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 634  :     if (xmlSchemaTypesInitialized == 0)

	cmp	DWORD PTR _xmlSchemaTypesInitialized, 0
	jne	SHORT $LN2@xmlSchemaC

; 635  : 	return;

	jmp	$LN1@xmlSchemaC
$LN2@xmlSchemaC:

; 636  :     /*
; 637  :     * Free xs:anyType.
; 638  :     */
; 639  :     {
; 640  : 	xmlSchemaParticlePtr particle;
; 641  : 	/* Attribute wildcard. */
; 642  : 	xmlSchemaFreeWildcard(xmlSchemaTypeAnyTypeDef->attributeWildcard);

	mov	eax, DWORD PTR _xmlSchemaTypeAnyTypeDef
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	call	_xmlSchemaFreeWildcard
	add	esp, 4

; 643  : 	/* Content type. */
; 644  : 	particle = (xmlSchemaParticlePtr) xmlSchemaTypeAnyTypeDef->subtypes;

	mov	edx, DWORD PTR _xmlSchemaTypeAnyTypeDef
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _particle$1[ebp], eax

; 645  : 	/* Wildcard. */
; 646  : 	xmlSchemaFreeWildcard((xmlSchemaWildcardPtr)

	mov	ecx, DWORD PTR _particle$1[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlSchemaFreeWildcard
	add	esp, 4

; 647  : 	    particle->children->children->children);
; 648  : 	xmlFree((xmlSchemaParticlePtr) particle->children->children);

	mov	edx, DWORD PTR _particle$1[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 649  : 	/* Sequence model group. */
; 650  : 	xmlFree((xmlSchemaModelGroupPtr) particle->children);

	mov	esi, esp
	mov	edx, DWORD PTR _particle$1[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 651  : 	xmlFree((xmlSchemaParticlePtr) particle);

	mov	esi, esp
	mov	ecx, DWORD PTR _particle$1[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 652  : 	xmlSchemaTypeAnyTypeDef->subtypes = NULL;

	mov	edx, DWORD PTR _xmlSchemaTypeAnyTypeDef
	mov	DWORD PTR [edx+28], 0

; 653  :     }
; 654  :     xmlHashFree(xmlSchemaTypesBank, xmlSchemaFreeTypeEntry);

	push	OFFSET _xmlSchemaFreeTypeEntry
	mov	eax, DWORD PTR _xmlSchemaTypesBank
	push	eax
	call	_xmlHashFree
	add	esp, 8

; 655  :     xmlSchemaTypesInitialized = 0;

	mov	DWORD PTR _xmlSchemaTypesInitialized, 0
$LN1@xmlSchemaC:

; 656  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaCleanupTypes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlschemastypes.c
;	COMDAT _xmlSchemaInitTypes
_TEXT	SEGMENT
_wild$1 = -12						; size = 4
_sequence$2 = -8					; size = 4
_particle$3 = -4					; size = 4
_xmlSchemaInitTypes PROC				; COMDAT

; 397  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __74485836_xmlschemastypes@c
	call	@__CheckForDebuggerJustMyCode@4

; 398  :     if (xmlSchemaTypesInitialized != 0)

	cmp	DWORD PTR _xmlSchemaTypesInitialized, 0
	je	SHORT $LN2@xmlSchemaI

; 399  :         return;

	jmp	$LN1@xmlSchemaI
$LN2@xmlSchemaI:

; 400  :     xmlSchemaTypesBank = xmlHashCreate(40);

	push	40					; 00000028H
	call	_xmlHashCreate
	add	esp, 4
	mov	DWORD PTR _xmlSchemaTypesBank, eax

; 401  : 
; 402  : 
; 403  :     /*
; 404  :     * 3.4.7 Built-in Complex Type Definition
; 405  :     */
; 406  :     xmlSchemaTypeAnyTypeDef = xmlSchemaInitBasicType("anyType",

	push	0
	push	45					; 0000002dH
	push	OFFSET ??_C@_07OGOHJKKN@anyType@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeAnyTypeDef, eax

; 407  :                                                      XML_SCHEMAS_ANYTYPE,
; 408  : 						     NULL);
; 409  :     xmlSchemaTypeAnyTypeDef->baseType = xmlSchemaTypeAnyTypeDef;

	mov	eax, DWORD PTR _xmlSchemaTypeAnyTypeDef
	mov	ecx, DWORD PTR _xmlSchemaTypeAnyTypeDef
	mov	DWORD PTR [eax+64], ecx

; 410  :     xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;

	mov	edx, DWORD PTR _xmlSchemaTypeAnyTypeDef
	mov	DWORD PTR [edx+52], 3

; 411  :     /*
; 412  :     * Init the content type.
; 413  :     */
; 414  :     xmlSchemaTypeAnyTypeDef->contentType = XML_SCHEMA_CONTENT_MIXED;

	mov	eax, DWORD PTR _xmlSchemaTypeAnyTypeDef
	mov	DWORD PTR [eax+52], 3

; 415  :     {
; 416  : 	xmlSchemaParticlePtr particle;
; 417  : 	xmlSchemaModelGroupPtr sequence;
; 418  : 	xmlSchemaWildcardPtr wild;
; 419  : 	/* First particle. */
; 420  : 	particle = xmlSchemaAddParticle();

	call	_xmlSchemaAddParticle
	mov	DWORD PTR _particle$3[ebp], eax

; 421  : 	if (particle == NULL)

	cmp	DWORD PTR _particle$3[ebp], 0
	jne	SHORT $LN3@xmlSchemaI

; 422  : 	    return;

	jmp	$LN1@xmlSchemaI
$LN3@xmlSchemaI:

; 423  : 	xmlSchemaTypeAnyTypeDef->subtypes = (xmlSchemaTypePtr) particle;

	mov	ecx, DWORD PTR _xmlSchemaTypeAnyTypeDef
	mov	edx, DWORD PTR _particle$3[ebp]
	mov	DWORD PTR [ecx+28], edx

; 424  : 	/* Sequence model group. */
; 425  : 	sequence = (xmlSchemaModelGroupPtr)

	mov	esi, esp
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _sequence$2[ebp], eax

; 426  : 	    xmlMalloc(sizeof(xmlSchemaModelGroup));
; 427  : 	if (sequence == NULL) {

	cmp	DWORD PTR _sequence$2[ebp], 0
	jne	SHORT $LN4@xmlSchemaI

; 428  : 	    xmlSchemaTypeErrMemory(NULL, "allocating model group component");

	push	OFFSET ??_C@_0CB@MIJFJDPK@allocating?5model?5group?5componen@
	push	0
	call	_xmlSchemaTypeErrMemory
	add	esp, 8

; 429  : 	    return;

	jmp	$LN1@xmlSchemaI
$LN4@xmlSchemaI:

; 430  : 	}
; 431  : 	memset(sequence, 0, sizeof(xmlSchemaModelGroup));

	xor	eax, eax
	mov	ecx, DWORD PTR _sequence$2[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax

; 432  : 	sequence->type = XML_SCHEMA_TYPE_SEQUENCE;

	mov	edx, DWORD PTR _sequence$2[ebp]
	mov	DWORD PTR [edx], 6

; 433  : 	particle->children = (xmlSchemaTreeItemPtr) sequence;

	mov	eax, DWORD PTR _particle$3[ebp]
	mov	ecx, DWORD PTR _sequence$2[ebp]
	mov	DWORD PTR [eax+12], ecx

; 434  : 	/* Second particle. */
; 435  : 	particle = xmlSchemaAddParticle();

	call	_xmlSchemaAddParticle
	mov	DWORD PTR _particle$3[ebp], eax

; 436  : 	if (particle == NULL)

	cmp	DWORD PTR _particle$3[ebp], 0
	jne	SHORT $LN5@xmlSchemaI

; 437  : 	    return;

	jmp	$LN1@xmlSchemaI
$LN5@xmlSchemaI:

; 438  : 	particle->minOccurs = 0;

	mov	edx, DWORD PTR _particle$3[ebp]
	mov	DWORD PTR [edx+16], 0

; 439  : 	particle->maxOccurs = UNBOUNDED;

	mov	eax, DWORD PTR _particle$3[ebp]
	mov	DWORD PTR [eax+20], 1073741824		; 40000000H

; 440  : 	sequence->children = (xmlSchemaTreeItemPtr) particle;

	mov	ecx, DWORD PTR _sequence$2[ebp]
	mov	edx, DWORD PTR _particle$3[ebp]
	mov	DWORD PTR [ecx+12], edx

; 441  : 	/* The wildcard */
; 442  : 	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));

	mov	esi, esp
	push	44					; 0000002cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _wild$1[ebp], eax

; 443  : 	if (wild == NULL) {

	cmp	DWORD PTR _wild$1[ebp], 0
	jne	SHORT $LN6@xmlSchemaI

; 444  : 	    xmlSchemaTypeErrMemory(NULL, "allocating wildcard component");

	push	OFFSET ??_C@_0BO@DGENAAFP@allocating?5wildcard?5component@
	push	0
	call	_xmlSchemaTypeErrMemory
	add	esp, 8

; 445  : 	    return;

	jmp	$LN1@xmlSchemaI
$LN6@xmlSchemaI:

; 446  : 	}
; 447  : 	memset(wild, 0, sizeof(xmlSchemaWildcard));

	push	44					; 0000002cH
	push	0
	mov	eax, DWORD PTR _wild$1[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 448  : 	wild->type = XML_SCHEMA_TYPE_ANY;

	mov	ecx, DWORD PTR _wild$1[ebp]
	mov	DWORD PTR [ecx], 2

; 449  : 	wild->any = 1;

	mov	edx, DWORD PTR _wild$1[ebp]
	mov	DWORD PTR [edx+28], 1

; 450  : 	wild->processContents = XML_SCHEMAS_ANY_LAX;

	mov	eax, DWORD PTR _wild$1[ebp]
	mov	DWORD PTR [eax+24], 2

; 451  : 	particle->children = (xmlSchemaTreeItemPtr) wild;

	mov	ecx, DWORD PTR _particle$3[ebp]
	mov	edx, DWORD PTR _wild$1[ebp]
	mov	DWORD PTR [ecx+12], edx

; 452  : 	/*
; 453  : 	* Create the attribute wildcard.
; 454  : 	*/
; 455  : 	wild = (xmlSchemaWildcardPtr) xmlMalloc(sizeof(xmlSchemaWildcard));

	mov	esi, esp
	push	44					; 0000002cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _wild$1[ebp], eax

; 456  : 	if (wild == NULL) {

	cmp	DWORD PTR _wild$1[ebp], 0
	jne	SHORT $LN7@xmlSchemaI

; 457  : 	    xmlSchemaTypeErrMemory(NULL, "could not create an attribute "

	push	OFFSET ??_C@_0DC@HFHHKPAL@could?5not?5create?5an?5attribute?5w@
	push	0
	call	_xmlSchemaTypeErrMemory
	add	esp, 8

; 458  : 		"wildcard on anyType");
; 459  : 	    return;

	jmp	$LN1@xmlSchemaI
$LN7@xmlSchemaI:

; 460  : 	}
; 461  : 	memset(wild, 0, sizeof(xmlSchemaWildcard));

	push	44					; 0000002cH
	push	0
	mov	eax, DWORD PTR _wild$1[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 462  : 	wild->any = 1;

	mov	ecx, DWORD PTR _wild$1[ebp]
	mov	DWORD PTR [ecx+28], 1

; 463  : 	wild->processContents = XML_SCHEMAS_ANY_LAX;

	mov	edx, DWORD PTR _wild$1[ebp]
	mov	DWORD PTR [edx+24], 2

; 464  : 	xmlSchemaTypeAnyTypeDef->attributeWildcard = wild;

	mov	eax, DWORD PTR _xmlSchemaTypeAnyTypeDef
	mov	ecx, DWORD PTR _wild$1[ebp]
	mov	DWORD PTR [eax+84], ecx

; 465  :     }
; 466  :     xmlSchemaTypeAnySimpleTypeDef = xmlSchemaInitBasicType("anySimpleType",

	mov	edx, DWORD PTR _xmlSchemaTypeAnyTypeDef
	push	edx
	push	46					; 0000002eH
	push	OFFSET ??_C@_0O@DMECCPMH@anySimpleType@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeAnySimpleTypeDef, eax

; 467  :                                                            XML_SCHEMAS_ANYSIMPLETYPE,
; 468  : 							   xmlSchemaTypeAnyTypeDef);
; 469  :     /*
; 470  :     * primitive datatypes
; 471  :     */
; 472  :     xmlSchemaTypeStringDef = xmlSchemaInitBasicType("string",

	mov	eax, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	eax
	push	1
	push	OFFSET ??_C@_06ICGJLFIM@string@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeStringDef, eax

; 473  :                                                     XML_SCHEMAS_STRING,
; 474  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 475  :     xmlSchemaTypeDecimalDef = xmlSchemaInitBasicType("decimal",

	mov	ecx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	ecx
	push	3
	push	OFFSET ??_C@_07EEKBCPDP@decimal@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeDecimalDef, eax

; 476  :                                                      XML_SCHEMAS_DECIMAL,
; 477  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 478  :     xmlSchemaTypeDateDef = xmlSchemaInitBasicType("date",

	mov	edx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	edx
	push	10					; 0000000aH
	push	OFFSET ??_C@_04JNIHBGGH@date@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeDateDef, eax

; 479  :                                                   XML_SCHEMAS_DATE,
; 480  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 481  :     xmlSchemaTypeDatetimeDef = xmlSchemaInitBasicType("dateTime",

	mov	eax, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	eax
	push	11					; 0000000bH
	push	OFFSET ??_C@_08JHBOOHBO@dateTime@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeDatetimeDef, eax

; 482  :                                                       XML_SCHEMAS_DATETIME,
; 483  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 484  :     xmlSchemaTypeTimeDef = xmlSchemaInitBasicType("time",

	mov	ecx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	ecx
	push	4
	push	OFFSET ??_C@_04CLCEDBPF@time@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeTimeDef, eax

; 485  :                                                   XML_SCHEMAS_TIME,
; 486  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 487  :     xmlSchemaTypeGYearDef = xmlSchemaInitBasicType("gYear",

	mov	edx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	edx
	push	8
	push	OFFSET ??_C@_05DGCLHBFG@gYear@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeGYearDef, eax

; 488  :                                                    XML_SCHEMAS_GYEAR,
; 489  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 490  :     xmlSchemaTypeGYearMonthDef = xmlSchemaInitBasicType("gYearMonth",

	mov	eax, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	eax
	push	9
	push	OFFSET ??_C@_0L@FEFFJNNL@gYearMonth@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeGYearMonthDef, eax

; 491  :                                                         XML_SCHEMAS_GYEARMONTH,
; 492  : 							xmlSchemaTypeAnySimpleTypeDef);
; 493  :     xmlSchemaTypeGMonthDef = xmlSchemaInitBasicType("gMonth",

	mov	ecx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	ecx
	push	6
	push	OFFSET ??_C@_06KBADAKNH@gMonth@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeGMonthDef, eax

; 494  :                                                     XML_SCHEMAS_GMONTH,
; 495  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 496  :     xmlSchemaTypeGMonthDayDef = xmlSchemaInitBasicType("gMonthDay",

	mov	edx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	edx
	push	7
	push	OFFSET ??_C@_09EILODGOG@gMonthDay@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeGMonthDayDef, eax

; 497  :                                                        XML_SCHEMAS_GMONTHDAY,
; 498  : 						       xmlSchemaTypeAnySimpleTypeDef);
; 499  :     xmlSchemaTypeGDayDef = xmlSchemaInitBasicType("gDay",

	mov	eax, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	eax
	push	5
	push	OFFSET ??_C@_04LBFBAPHN@gDay@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeGDayDef, eax

; 500  :                                                   XML_SCHEMAS_GDAY,
; 501  : 						  xmlSchemaTypeAnySimpleTypeDef);
; 502  :     xmlSchemaTypeDurationDef = xmlSchemaInitBasicType("duration",

	mov	ecx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	ecx
	push	12					; 0000000cH
	push	OFFSET ??_C@_08LGBPINEC@duration@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeDurationDef, eax

; 503  :                                                       XML_SCHEMAS_DURATION,
; 504  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 505  :     xmlSchemaTypeFloatDef = xmlSchemaInitBasicType("float",

	mov	edx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	edx
	push	13					; 0000000dH
	push	OFFSET ??_C@_05KNFBNCOH@float@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeFloatDef, eax

; 506  :                                                    XML_SCHEMAS_FLOAT,
; 507  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 508  :     xmlSchemaTypeDoubleDef = xmlSchemaInitBasicType("double",

	mov	eax, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	eax
	push	14					; 0000000eH
	push	OFFSET ??_C@_06BNJCAIGJ@double@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeDoubleDef, eax

; 509  :                                                     XML_SCHEMAS_DOUBLE,
; 510  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 511  :     xmlSchemaTypeBooleanDef = xmlSchemaInitBasicType("boolean",

	mov	ecx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	ecx
	push	15					; 0000000fH
	push	OFFSET ??_C@_07GOBOHMJA@boolean@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeBooleanDef, eax

; 512  :                                                      XML_SCHEMAS_BOOLEAN,
; 513  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 514  :     xmlSchemaTypeAnyURIDef = xmlSchemaInitBasicType("anyURI",

	mov	edx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	edx
	push	29					; 0000001dH
	push	OFFSET ??_C@_06DLDOHKEG@anyURI@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeAnyURIDef, eax

; 515  :                                                     XML_SCHEMAS_ANYURI,
; 516  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 517  :     xmlSchemaTypeHexBinaryDef = xmlSchemaInitBasicType("hexBinary",

	mov	eax, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	eax
	push	43					; 0000002bH
	push	OFFSET ??_C@_09EHHLIAMK@hexBinary@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeHexBinaryDef, eax

; 518  :                                                      XML_SCHEMAS_HEXBINARY,
; 519  : 						     xmlSchemaTypeAnySimpleTypeDef);
; 520  :     xmlSchemaTypeBase64BinaryDef
; 521  :         = xmlSchemaInitBasicType("base64Binary", XML_SCHEMAS_BASE64BINARY,

	mov	ecx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	ecx
	push	44					; 0000002cH
	push	OFFSET ??_C@_0N@NBAOPEBP@base64Binary@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeBase64BinaryDef, eax

; 522  : 	xmlSchemaTypeAnySimpleTypeDef);
; 523  :     xmlSchemaTypeNotationDef = xmlSchemaInitBasicType("NOTATION",

	mov	edx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	edx
	push	28					; 0000001cH
	push	OFFSET ??_C@_08NCDGCBCC@NOTATION@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeNotationDef, eax

; 524  :                                                     XML_SCHEMAS_NOTATION,
; 525  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 526  :     xmlSchemaTypeQNameDef = xmlSchemaInitBasicType("QName",

	mov	eax, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	eax
	push	21					; 00000015H
	push	OFFSET ??_C@_05LFDDDENB@QName@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeQNameDef, eax

; 527  :                                                    XML_SCHEMAS_QNAME,
; 528  : 						   xmlSchemaTypeAnySimpleTypeDef);
; 529  : 
; 530  :     /*
; 531  :      * derived datatypes
; 532  :      */
; 533  :     xmlSchemaTypeIntegerDef = xmlSchemaInitBasicType("integer",

	mov	ecx, DWORD PTR _xmlSchemaTypeDecimalDef
	push	ecx
	push	30					; 0000001eH
	push	OFFSET ??_C@_07LKHFMGFB@integer@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeIntegerDef, eax

; 534  :                                                      XML_SCHEMAS_INTEGER,
; 535  : 						     xmlSchemaTypeDecimalDef);
; 536  :     xmlSchemaTypeNonPositiveIntegerDef =

	mov	edx, DWORD PTR _xmlSchemaTypeIntegerDef
	push	edx
	push	31					; 0000001fH
	push	OFFSET ??_C@_0BD@FMNGDL@nonPositiveInteger@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeNonPositiveIntegerDef, eax

; 537  :         xmlSchemaInitBasicType("nonPositiveInteger",
; 538  :                                XML_SCHEMAS_NPINTEGER,
; 539  : 			       xmlSchemaTypeIntegerDef);
; 540  :     xmlSchemaTypeNegativeIntegerDef =

	mov	eax, DWORD PTR _xmlSchemaTypeNonPositiveIntegerDef
	push	eax
	push	32					; 00000020H
	push	OFFSET ??_C@_0BA@HJODLFEP@negativeInteger@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeNegativeIntegerDef, eax

; 541  :         xmlSchemaInitBasicType("negativeInteger", XML_SCHEMAS_NINTEGER,
; 542  : 	xmlSchemaTypeNonPositiveIntegerDef);
; 543  :     xmlSchemaTypeLongDef =

	mov	ecx, DWORD PTR _xmlSchemaTypeIntegerDef
	push	ecx
	push	37					; 00000025H
	push	OFFSET ??_C@_04GOKPGOLB@long@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeLongDef, eax

; 544  :         xmlSchemaInitBasicType("long", XML_SCHEMAS_LONG,
; 545  : 	xmlSchemaTypeIntegerDef);
; 546  :     xmlSchemaTypeIntDef = xmlSchemaInitBasicType("int", XML_SCHEMAS_INT,

	mov	edx, DWORD PTR _xmlSchemaTypeLongDef
	push	edx
	push	35					; 00000023H
	push	OFFSET ??_C@_03JBIPMCLC@int@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeIntDef, eax

; 547  : 	xmlSchemaTypeLongDef);
; 548  :     xmlSchemaTypeShortDef = xmlSchemaInitBasicType("short",

	mov	eax, DWORD PTR _xmlSchemaTypeIntDef
	push	eax
	push	39					; 00000027H
	push	OFFSET ??_C@_05BFKKPKCG@short@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeShortDef, eax

; 549  :                                                    XML_SCHEMAS_SHORT,
; 550  : 						   xmlSchemaTypeIntDef);
; 551  :     xmlSchemaTypeByteDef = xmlSchemaInitBasicType("byte",

	mov	ecx, DWORD PTR _xmlSchemaTypeShortDef
	push	ecx
	push	41					; 00000029H
	push	OFFSET ??_C@_04IHGKJMLH@byte@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeByteDef, eax

; 552  :                                                   XML_SCHEMAS_BYTE,
; 553  : 						  xmlSchemaTypeShortDef);
; 554  :     xmlSchemaTypeNonNegativeIntegerDef =

	mov	edx, DWORD PTR _xmlSchemaTypeIntegerDef
	push	edx
	push	33					; 00000021H
	push	OFFSET ??_C@_0BD@IEOLADAC@nonNegativeInteger@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeNonNegativeIntegerDef, eax

; 555  :         xmlSchemaInitBasicType("nonNegativeInteger",
; 556  :                                XML_SCHEMAS_NNINTEGER,
; 557  : 			       xmlSchemaTypeIntegerDef);
; 558  :     xmlSchemaTypeUnsignedLongDef =

	mov	eax, DWORD PTR _xmlSchemaTypeNonNegativeIntegerDef
	push	eax
	push	38					; 00000026H
	push	OFFSET ??_C@_0N@PNDKOLAJ@unsignedLong@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeUnsignedLongDef, eax

; 559  :         xmlSchemaInitBasicType("unsignedLong", XML_SCHEMAS_ULONG,
; 560  : 	xmlSchemaTypeNonNegativeIntegerDef);
; 561  :     xmlSchemaTypeUnsignedIntDef =

	mov	ecx, DWORD PTR _xmlSchemaTypeUnsignedLongDef
	push	ecx
	push	36					; 00000024H
	push	OFFSET ??_C@_0M@NPFOHDP@unsignedInt@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeUnsignedIntDef, eax

; 562  :         xmlSchemaInitBasicType("unsignedInt", XML_SCHEMAS_UINT,
; 563  : 	xmlSchemaTypeUnsignedLongDef);
; 564  :     xmlSchemaTypeUnsignedShortDef =

	mov	edx, DWORD PTR _xmlSchemaTypeUnsignedIntDef
	push	edx
	push	40					; 00000028H
	push	OFFSET ??_C@_0O@NAIDFEBN@unsignedShort@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeUnsignedShortDef, eax

; 565  :         xmlSchemaInitBasicType("unsignedShort", XML_SCHEMAS_USHORT,
; 566  : 	xmlSchemaTypeUnsignedIntDef);
; 567  :     xmlSchemaTypeUnsignedByteDef =

	mov	eax, DWORD PTR _xmlSchemaTypeUnsignedShortDef
	push	eax
	push	42					; 0000002aH
	push	OFFSET ??_C@_0N@BEPPBJAP@unsignedByte@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeUnsignedByteDef, eax

; 568  :         xmlSchemaInitBasicType("unsignedByte", XML_SCHEMAS_UBYTE,
; 569  : 	xmlSchemaTypeUnsignedShortDef);
; 570  :     xmlSchemaTypePositiveIntegerDef =

	mov	ecx, DWORD PTR _xmlSchemaTypeNonNegativeIntegerDef
	push	ecx
	push	34					; 00000022H
	push	OFFSET ??_C@_0BA@PNFEGAHG@positiveInteger@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypePositiveIntegerDef, eax

; 571  :         xmlSchemaInitBasicType("positiveInteger", XML_SCHEMAS_PINTEGER,
; 572  : 	xmlSchemaTypeNonNegativeIntegerDef);
; 573  :     xmlSchemaTypeNormStringDef = xmlSchemaInitBasicType("normalizedString",

	mov	edx, DWORD PTR _xmlSchemaTypeStringDef
	push	edx
	push	2
	push	OFFSET ??_C@_0BB@HPFKIGKN@normalizedString@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeNormStringDef, eax

; 574  :                                                         XML_SCHEMAS_NORMSTRING,
; 575  : 							xmlSchemaTypeStringDef);
; 576  :     xmlSchemaTypeTokenDef = xmlSchemaInitBasicType("token",

	mov	eax, DWORD PTR _xmlSchemaTypeNormStringDef
	push	eax
	push	16					; 00000010H
	push	OFFSET ??_C@_05JMKJMOPH@token@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeTokenDef, eax

; 577  :                                                    XML_SCHEMAS_TOKEN,
; 578  : 						   xmlSchemaTypeNormStringDef);
; 579  :     xmlSchemaTypeLanguageDef = xmlSchemaInitBasicType("language",

	mov	ecx, DWORD PTR _xmlSchemaTypeTokenDef
	push	ecx
	push	17					; 00000011H
	push	OFFSET ??_C@_08JGCCIMAA@language@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeLanguageDef, eax

; 580  :                                                       XML_SCHEMAS_LANGUAGE,
; 581  : 						      xmlSchemaTypeTokenDef);
; 582  :     xmlSchemaTypeNameDef = xmlSchemaInitBasicType("Name",

	mov	edx, DWORD PTR _xmlSchemaTypeTokenDef
	push	edx
	push	20					; 00000014H
	push	OFFSET ??_C@_04FABLJDN@Name@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeNameDef, eax

; 583  :                                                   XML_SCHEMAS_NAME,
; 584  : 						  xmlSchemaTypeTokenDef);
; 585  :     xmlSchemaTypeNmtokenDef = xmlSchemaInitBasicType("NMTOKEN",

	mov	eax, DWORD PTR _xmlSchemaTypeTokenDef
	push	eax
	push	18					; 00000012H
	push	OFFSET ??_C@_07JKBEJDBF@NMTOKEN@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeNmtokenDef, eax

; 586  :                                                      XML_SCHEMAS_NMTOKEN,
; 587  : 						     xmlSchemaTypeTokenDef);
; 588  :     xmlSchemaTypeNCNameDef = xmlSchemaInitBasicType("NCName",

	mov	ecx, DWORD PTR _xmlSchemaTypeNameDef
	push	ecx
	push	22					; 00000016H
	push	OFFSET ??_C@_06MDLHOHLI@NCName@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeNCNameDef, eax

; 589  :                                                     XML_SCHEMAS_NCNAME,
; 590  : 						    xmlSchemaTypeNameDef);
; 591  :     xmlSchemaTypeIdDef = xmlSchemaInitBasicType("ID", XML_SCHEMAS_ID,

	mov	edx, DWORD PTR _xmlSchemaTypeNCNameDef
	push	edx
	push	23					; 00000017H
	push	OFFSET ??_C@_02OLOABKKD@ID@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeIdDef, eax

; 592  : 						    xmlSchemaTypeNCNameDef);
; 593  :     xmlSchemaTypeIdrefDef = xmlSchemaInitBasicType("IDREF",

	mov	eax, DWORD PTR _xmlSchemaTypeNCNameDef
	push	eax
	push	24					; 00000018H
	push	OFFSET ??_C@_05HKGPJLPA@IDREF@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeIdrefDef, eax

; 594  :                                                    XML_SCHEMAS_IDREF,
; 595  : 						   xmlSchemaTypeNCNameDef);
; 596  :     xmlSchemaTypeEntityDef = xmlSchemaInitBasicType("ENTITY",

	mov	ecx, DWORD PTR _xmlSchemaTypeNCNameDef
	push	ecx
	push	26					; 0000001aH
	push	OFFSET ??_C@_06GKLBAPIO@ENTITY@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeEntityDef, eax

; 597  :                                                     XML_SCHEMAS_ENTITY,
; 598  : 						    xmlSchemaTypeNCNameDef);
; 599  :     /*
; 600  :     * Derived list types.
; 601  :     */
; 602  :     /* ENTITIES */
; 603  :     xmlSchemaTypeEntitiesDef = xmlSchemaInitBasicType("ENTITIES",

	mov	edx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	edx
	push	27					; 0000001bH
	push	OFFSET ??_C@_08ICGBNEMG@ENTITIES@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeEntitiesDef, eax

; 604  :                                                       XML_SCHEMAS_ENTITIES,
; 605  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 606  :     xmlSchemaTypeEntitiesDef->subtypes = xmlSchemaTypeEntityDef;

	mov	eax, DWORD PTR _xmlSchemaTypeEntitiesDef
	mov	ecx, DWORD PTR _xmlSchemaTypeEntityDef
	mov	DWORD PTR [eax+28], ecx

; 607  :     /* IDREFS */
; 608  :     xmlSchemaTypeIdrefsDef = xmlSchemaInitBasicType("IDREFS",

	mov	edx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	edx
	push	25					; 00000019H
	push	OFFSET ??_C@_06CMFBJDBA@IDREFS@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeIdrefsDef, eax

; 609  :                                                     XML_SCHEMAS_IDREFS,
; 610  : 						    xmlSchemaTypeAnySimpleTypeDef);
; 611  :     xmlSchemaTypeIdrefsDef->subtypes = xmlSchemaTypeIdrefDef;

	mov	eax, DWORD PTR _xmlSchemaTypeIdrefsDef
	mov	ecx, DWORD PTR _xmlSchemaTypeIdrefDef
	mov	DWORD PTR [eax+28], ecx

; 612  : 
; 613  :     /* NMTOKENS */
; 614  :     xmlSchemaTypeNmtokensDef = xmlSchemaInitBasicType("NMTOKENS",

	mov	edx, DWORD PTR _xmlSchemaTypeAnySimpleTypeDef
	push	edx
	push	19					; 00000013H
	push	OFFSET ??_C@_08PMNBPOOP@NMTOKENS@
	call	_xmlSchemaInitBasicType
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlSchemaTypeNmtokensDef, eax

; 615  :                                                       XML_SCHEMAS_NMTOKENS,
; 616  : 						      xmlSchemaTypeAnySimpleTypeDef);
; 617  :     xmlSchemaTypeNmtokensDef->subtypes = xmlSchemaTypeNmtokenDef;

	mov	eax, DWORD PTR _xmlSchemaTypeNmtokensDef
	mov	ecx, DWORD PTR _xmlSchemaTypeNmtokenDef
	mov	DWORD PTR [eax+28], ecx

; 618  : 
; 619  :     xmlSchemaTypesInitialized = 1;

	mov	DWORD PTR _xmlSchemaTypesInitialized, 1
$LN1@xmlSchemaI:

; 620  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSchemaInitTypes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2270 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 2271 :         int _Result;
; 2272 :         va_list _ArgList;
; 2273 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 2176 :         return __stdio_common_vsscanf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_scanf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 2275 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 2276 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2277 :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 96   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 97   :         static unsigned __int64 _OptionsStorage;
; 98   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 99   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
