; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\debugXML.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__6FBE7998_debugxml@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_sscanf
PUBLIC	_xmlDebugDumpString
PUBLIC	_xmlDebugDumpAttr
PUBLIC	_xmlDebugDumpAttrList
PUBLIC	_xmlDebugDumpOneNode
PUBLIC	_xmlDebugDumpNode
PUBLIC	_xmlDebugDumpNodeList
PUBLIC	_xmlDebugDumpDocumentHead
PUBLIC	_xmlDebugDumpDocument
PUBLIC	_xmlDebugDumpDTD
PUBLIC	_xmlDebugDumpEntities
PUBLIC	_xmlDebugCheckDocument
PUBLIC	_xmlLsOneNode
PUBLIC	_xmlLsCountNode
PUBLIC	_xmlBoolToText
PUBLIC	_xmlShellPrintXPathError
PUBLIC	_xmlShellPrintXPathResult
PUBLIC	_xmlShellList
PUBLIC	_xmlShellBase
PUBLIC	_xmlShellDir
PUBLIC	_xmlShellLoad
PUBLIC	_xmlShellPrintNode
PUBLIC	_xmlShellCat
PUBLIC	_xmlShellWrite
PUBLIC	_xmlShellSave
PUBLIC	_xmlShellValidate
PUBLIC	_xmlShellDu
PUBLIC	_xmlShellPwd
PUBLIC	_xmlShell
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0CN@CCCBCKMJ@Reference?5to?5default?5namespace?5@ ; `string'
PUBLIC	??_C@_0CK@KJADECB@Reference?5to?5namespace?5?8?$CFs?8?5not@ ; `string'
PUBLIC	??_C@_0DA@PAHGLCCL@Reference?5to?5default?5namespace?5@ ; `string'
PUBLIC	??_C@_0CN@DPKAIPNO@Reference?5to?5namespace?5?8?$CFs?8?5not@ ; `string'
PUBLIC	??_C@_0BH@GLDOBOAB@String?5is?5not?5UTF?98?5?$CFs@ ; `string'
PUBLIC	??_C@_0N@BLMILKM@Name?5is?5NULL@		; `string'
PUBLIC	??_C@_0BL@DKJDBHCK@Name?5is?5not?5an?5NCName?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_0CO@NDFCBACJ@Name?5is?5not?5from?5the?5document?5d@ ; `string'
PUBLIC	??_C@_0BE@EPLMDKLB@Node?5has?5no?5parent?6@	; `string'
PUBLIC	??_C@_0BB@MOKKDMAC@Node?5has?5no?5doc?6@	; `string'
PUBLIC	??_C@_0L@OLLEMIAI@pseudoroot@			; `string'
PUBLIC	??_C@_0CE@LOLNJJIM@Node?5doc?5differs?5from?5parent?8s?5@ ; `string'
PUBLIC	??_C@_0CN@CJJLPFI@Attr?5has?5no?5prev?5and?5not?5first?5@ ; `string'
PUBLIC	??_C@_0CP@FIFBDLN@Node?5has?5no?5prev?5and?5not?5first?5@ ; `string'
PUBLIC	??_C@_0CD@LGMLKLGH@Node?5prev?9?$DOnext?5?3?5back?5link?5wro@ ; `string'
PUBLIC	??_C@_0CO@INOGIHKC@Node?5has?5no?5next?5and?5not?5last?5o@ ; `string'
PUBLIC	??_C@_0CG@PBIAHHPM@Node?5next?9?$DOprev?5?3?5forward?5link?5@ ; `string'
PUBLIC	??_C@_07DALNPEGO@nbktext@			; `string'
PUBLIC	??_C@_0BO@PNOOIGPO@Text?5node?5has?5wrong?5name?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_0CB@NIALDOAB@Comment?5node?5has?5wrong?5name?5?8?$CFs@ ; `string'
PUBLIC	??_C@_0CF@EPPJHKJE@CData?5section?5has?5non?5NULL?5name@ ; `string'
PUBLIC	??_C@_06LHGEHABH@?$CINULL?$CJ@			; `string'
PUBLIC	??_C@_03CANIHDGE@?$CD?$CFX@			; `string'
PUBLIC	??_C@_03KHICJKCI@?4?4?4@			; `string'
PUBLIC	??_C@_0BC@MDLFLLHC@DTD?5node?5is?5NULL?6@	; `string'
PUBLIC	??_C@_0BC@MBEMJEOJ@Node?5is?5not?5a?5DTD@	; `string'
PUBLIC	??_C@_07PFBLHE@DTD?$CI?$CFs?$CJ@		; `string'
PUBLIC	??_C@_03DFGNODOE@DTD@				; `string'
PUBLIC	??_C@_0M@NLONAAOP@?0?5PUBLIC?5?$CFs@		; `string'
PUBLIC	??_C@_0M@PKDMNFPO@?0?5SYSTEM?5?$CFs@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BP@BAGDAOMH@Attribute?5declaration?5is?5NULL?6@ ; `string'
PUBLIC	??_C@_0CF@DOMFFPAF@Node?5is?5not?5an?5attribute?5declar@ ; `string'
PUBLIC	??_C@_0N@EBLNCBKJ@ATTRDECL?$CI?$CFs?$CJ@	; `string'
PUBLIC	??_C@_0CH@PBLLGJEB@Node?5attribute?5declaration?5has?5@ ; `string'
PUBLIC	??_C@_07GLNLDEDP@?5for?5?$CFs@			; `string'
PUBLIC	??_C@_0CP@BPDBFHFF@Node?5attribute?5declaration?5has?5@ ; `string'
PUBLIC	??_C@_06CIOOFICG@?5CDATA@			; `string'
PUBLIC	??_C@_03JFNHLDJD@?5ID@				; `string'
PUBLIC	??_C@_06JJHMNMLB@?5IDREF@			; `string'
PUBLIC	??_C@_07CNGJPBFB@?5IDREFS@			; `string'
PUBLIC	??_C@_07GLIJGNMP@?5ENTITY@			; `string'
PUBLIC	??_C@_09MILPKLMO@?5ENTITIES@			; `string'
PUBLIC	??_C@_08JLMONKHB@?5NMTOKEN@			; `string'
PUBLIC	??_C@_09LGAPIBOH@?5NMTOKENS@			; `string'
PUBLIC	??_C@_0N@DAGLJCMJ@?5ENUMERATION@		; `string'
PUBLIC	??_C@_0L@EOKHAFCK@?5NOTATION?5@			; `string'
PUBLIC	??_C@_03MFMGJBPJ@?$HM?$CFs@			; `string'
PUBLIC	??_C@_04KHAOAOAJ@?5?$CI?$CFs@			; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ@				; `string'
PUBLIC	??_C@_04HBFELFIL@?4?4?4?$CJ@			; `string'
PUBLIC	??_C@_09GBLDHCFM@?5REQUIRED@			; `string'
PUBLIC	??_C@_08BNNMMLKP@?5IMPLIED@			; `string'
PUBLIC	??_C@_06MNDBCIDD@?5FIXED@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_0BN@LDLGNJBO@Element?5declaration?5is?5NULL?6@ ; `string'
PUBLIC	??_C@_0CD@MEOODKKF@Node?5is?5not?5an?5element?5declarat@ ; `string'
PUBLIC	??_C@_09LBEHMBNA@ELEMDECL?$CI@			; `string'
PUBLIC	??_C@_0CA@CBJEJFEP@Element?5declaration?5has?5no?5name@ ; `string'
PUBLIC	??_C@_0M@PIGJBKAD@?0?5UNDEFINED@		; `string'
PUBLIC	??_C@_07MPIOAGOH@?0?5EMPTY@			; `string'
PUBLIC	??_C@_05MNEHMNJK@?0?5ANY@			; `string'
PUBLIC	??_C@_08MPHAJKBG@?0?5MIXED?5@			; `string'
PUBLIC	??_C@_0BM@BBOCCNBN@Entity?5declaration?5is?5NULL?6@ ; `string'
PUBLIC	??_C@_0CC@CMGFHOFN@Node?5is?5not?5an?5entity?5declarati@ ; `string'
PUBLIC	??_C@_0M@KEJNLLDB@ENTITYDECL?$CI@		; `string'
PUBLIC	??_C@_0BP@DPAEJKOA@Entity?5declaration?5has?5no?5name@ ; `string'
PUBLIC	??_C@_0M@PBKIGNE@?0?5internal?6@		; `string'
PUBLIC	??_C@_0BD@BCOHBEKD@?0?5external?5parsed?6@	; `string'
PUBLIC	??_C@_0M@FLIMFIIH@?0?5unparsed?6@		; `string'
PUBLIC	??_C@_0N@NMAFEAAG@?0?5parameter?6@		; `string'
PUBLIC	??_C@_0BG@OKFDOFBK@?0?5external?5parameter?6@	; `string'
PUBLIC	??_C@_0O@OLDJNJL@?0?5predefined?6@		; `string'
PUBLIC	??_C@_0BA@GMOODANC@?5ExternalID?$DN?$CFs?6@	; `string'
PUBLIC	??_C@_0O@MKEBLMD@?5SystemID?$DN?$CFs?6@		; `string'
PUBLIC	??_C@_08HINJCKNC@?5URI?$DN?$CFs?6@		; `string'
PUBLIC	??_C@_09MHAMBDHP@?5content?$DN@			; `string'
PUBLIC	??_C@_0BI@HODGPHLJ@namespace?5node?5is?5NULL?6@	; `string'
PUBLIC	??_C@_0CE@MGJPGGJB@Node?5is?5not?5a?5namespace?5declara@ ; `string'
PUBLIC	??_C@_0CD@FKAEBHOG@Incomplete?5namespace?5?$CFs?5href?$DNNU@ ; `string'
PUBLIC	??_C@_0CI@MFMJLJFK@Incomplete?5default?5namespace?5hr@ ; `string'
PUBLIC	??_C@_0BD@IHBOEJJJ@namespace?5?$CFs?5href?$DN@	; `string'
PUBLIC	??_C@_0BI@BIAGHAFN@default?5namespace?5href?$DN@ ; `string'
PUBLIC	??_C@_0BA@PFFLDDAJ@Entity?5is?5NULL?6@		; `string'
PUBLIC	??_C@_0BJ@MJDLDDEN@INTERNAL_GENERAL_ENTITY?5@	; `string'
PUBLIC	??_C@_0CA@NAIMNBBA@EXTERNAL_GENERAL_PARSED_ENTITY?5@ ; `string'
PUBLIC	??_C@_0CC@EADOHJCE@EXTERNAL_GENERAL_UNPARSED_ENTIT@ ; `string'
PUBLIC	??_C@_0BL@ECACNHOO@INTERNAL_PARAMETER_ENTITY?5@	; `string'
PUBLIC	??_C@_0BL@HEENOMOI@EXTERNAL_PARAMETER_ENTITY?5@	; `string'
PUBLIC	??_C@_0N@KEBDPOGN@ENTITY_?$CFd?5?$CB?5@		; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0P@EALJADBN@ExternalID?$DN?$CFs?6@	; `string'
PUBLIC	??_C@_0N@BPAPFMFO@SystemID?$DN?$CFs?6@		; `string'
PUBLIC	??_C@_07HJADGDLG@URI?$DN?$CFs?6@		; `string'
PUBLIC	??_C@_08INNCGMHH@content?$DN@			; `string'
PUBLIC	??_C@_0N@KCLOKEKK@Attr?5is?5NULL@		; `string'
PUBLIC	??_C@_0L@MPLGGCMF@ATTRIBUTE?5@			; `string'
PUBLIC	??_C@_0BG@HFHKPGJL@Attribute?5has?5no?5name@	; `string'
PUBLIC	??_C@_0O@IPKFPFDL@node?5is?5NULL?6@		; `string'
PUBLIC	??_C@_08EDNNGDCO@ELEMENT?5@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_0BN@DLOCDHBF@Error?0?5ATTRIBUTE?5found?5here?6@ ; `string'
PUBLIC	??_C@_0M@IDMICFJC@TEXT?5no?5enc@		; `string'
PUBLIC	??_C@_04OEPMCOLO@TEXT@				; `string'
PUBLIC	??_C@_09PKJIJFNN@?5compact?6@			; `string'
PUBLIC	??_C@_0L@IDACKBMB@?5interned?6@			; `string'
PUBLIC	??_C@_0P@HFCBAJGN@CDATA_SECTION?6@		; `string'
PUBLIC	??_C@_0BA@FMOACEBO@ENTITY_REF?$CI?$CFs?$CJ?6@	; `string'
PUBLIC	??_C@_07PAIFPHKC@ENTITY?6@			; `string'
PUBLIC	??_C@_06JDGENMBJ@PI?5?$CFs?6@			; `string'
PUBLIC	??_C@_08OCMMJPAI@COMMENT?6@			; `string'
PUBLIC	??_C@_0BM@DKGLPLJE@Error?0?5DOCUMENT?5found?5here?6@ ; `string'
PUBLIC	??_C@_0P@EJFIBKNL@DOCUMENT_TYPE?6@		; `string'
PUBLIC	??_C@_0P@JLLHGMMO@DOCUMENT_FRAG?6@		; `string'
PUBLIC	??_C@_09CPFNJPEP@NOTATION?6@			; `string'
PUBLIC	??_C@_0P@MIINKGDA@INCLUDE?5START?6@		; `string'
PUBLIC	??_C@_0N@DKMEHMHH@INCLUDE?5END?6@		; `string'
PUBLIC	??_C@_0BG@ILEBNOHM@Unknown?5node?5type?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BG@LCJECPKH@PBM?3?5doc?5?$DN?$DN?5NULL?5?$CB?$CB?$CB?6@ ; `string'
PUBLIC	??_C@_0BE@NJEBDCCE@DOCUMENT?5?$DN?$DN?5NULL?5?$CB?6@ ; `string'
PUBLIC	??_C@_0BI@IHFNOEDM@Misplaced?5ELEMENT?5node?6@	; `string'
PUBLIC	??_C@_0BK@DMGHGOPO@Misplaced?5ATTRIBUTE?5node?6@ ; `string'
PUBLIC	??_C@_0BF@JFJFJLGA@Misplaced?5TEXT?5node?6@	; `string'
PUBLIC	??_C@_0BG@JKLDMKBF@Misplaced?5CDATA?5node?6@	; `string'
PUBLIC	??_C@_0BK@FAHNDMGM@Misplaced?5ENTITYREF?5node?6@ ; `string'
PUBLIC	??_C@_0BH@NGEMGAKL@Misplaced?5ENTITY?5node?6@	; `string'
PUBLIC	??_C@_0BD@LAMDNLOB@Misplaced?5PI?5node?6@	; `string'
PUBLIC	??_C@_0BI@MEFJLFLK@Misplaced?5COMMENT?5node?6@	; `string'
PUBLIC	??_C@_09JFLEHAPI@DOCUMENT?6@			; `string'
PUBLIC	??_C@_0P@NDGMGMGG@HTML?5DOCUMENT?6@		; `string'
PUBLIC	??_C@_0BI@HEJPPPBK@Misplaced?5DOCTYPE?5node?6@	; `string'
PUBLIC	??_C@_0BJ@EDIFACFE@Misplaced?5FRAGMENT?5node?6@	; `string'
PUBLIC	??_C@_0BJ@CONGBBKN@Misplaced?5NOTATION?5node?6@	; `string'
PUBLIC	??_C@_05DFCJAACA@name?$DN@			; `string'
PUBLIC	??_C@_08CLMDBNEB@version?$DN@			; `string'
PUBLIC	??_C@_09GHEONEIE@encoding?$DN@			; `string'
PUBLIC	??_C@_04LLECLDGK@URL?$DN@			; `string'
PUBLIC	??_C@_0BB@IPNIJGMI@standalone?$DNtrue?6@	; `string'
PUBLIC	??_C@_0P@LECCLHEJ@Entity?5is?5NULL@		; `string'
PUBLIC	??_C@_05LLGELLBM@?$CFs?5?3?5@			; `string'
PUBLIC	??_C@_0BD@JEHEGLEK@INTERNAL?5GENERAL?0?5@	; `string'
PUBLIC	??_C@_0BC@LPMELAMM@EXTERNAL?5PARSED?0?5@	; `string'
PUBLIC	??_C@_0BE@EAFADDI@EXTERNAL?5UNPARSED?0?5@	; `string'
PUBLIC	??_C@_0BF@DHEHKNNP@INTERNAL?5PARAMETER?0?5@	; `string'
PUBLIC	??_C@_0BF@GEKJJGOC@EXTERNAL?5PARAMETER?0?5@	; `string'
PUBLIC	??_C@_0BI@PGEHOKHI@Unknown?5entity?5type?5?$CFd?6@ ; `string'
PUBLIC	??_C@_07MGAPBOEN@ID?5?$CC?$CFs?$CC@		; `string'
PUBLIC	??_C@_0M@CPEEBBLL@SYSTEM?5?$CC?$CFs?$CC@	; `string'
PUBLIC	??_C@_0M@ENMJJFAE@?6?5orig?5?$CC?$CFs?$CC@	; `string'
PUBLIC	??_C@_0P@IHEOBAMO@?6?5content?5?$CC?$CFs?$CC@	; `string'
PUBLIC	??_C@_0BN@DMKNOAIC@Entities?5in?5internal?5subset?6@ ; `string'
PUBLIC	??_C@_0CA@JBOJHEJF@No?5entities?5in?5internal?5subset?6@ ; `string'
PUBLIC	??_C@_0BN@BMADNPKJ@Entities?5in?5external?5subset?6@ ; `string'
PUBLIC	??_C@_0CA@LBEHELLO@No?5entities?5in?5external?5subset?6@ ; `string'
PUBLIC	??_C@_0N@BBKAICJC@DTD?5is?5NULL?6@		; `string'
PUBLIC	??_C@_0BC@JMCKHIKF@?5?5?5?5DTD?5is?5empty?6@	; `string'
PUBLIC	??_C@_05NJDBAOFA@NULL?6@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_01MCMALHOG@a@				; `string'
PUBLIC	??_C@_01PFHFFBPC@t@				; `string'
PUBLIC	??_C@_01GFHCPBMG@C@				; `string'
PUBLIC	??_C@_01KGKMHCOC@e@				; `string'
PUBLIC	??_C@_01DDCIFGEA@E@				; `string'
PUBLIC	??_C@_01JBBJJEPG@p@				; `string'
PUBLIC	??_C@_01PAPGNFGE@c@				; `string'
PUBLIC	??_C@_01LPLHEDKD@d@				; `string'
PUBLIC	??_C@_01BDACAMKP@h@				; `string'
PUBLIC	??_C@_01GAPBHFFA@T@				; `string'
PUBLIC	??_C@_01BIAFAFID@F@				; `string'
PUBLIC	??_C@_01NANMIPIL@N@				; `string'
PUBLIC	??_C@_01EFFIKLCJ@n@				; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP@				; `string'
PUBLIC	??_C@_05KPHFGMAO@?5?$CF8d?5@			; `string'
PUBLIC	??_C@_03DKEJHHJP@?$CFs?3@			; `string'
PUBLIC	??_C@_0O@IMMJOEMC@default?5?9?$DO?5?$CFs@	; `string'
PUBLIC	??_C@_08DHHJCFN@?$CFs?5?9?$DO?5?$CFs@		; `string'
PUBLIC	??_C@_04HPMIDMKH@True@				; `string'
PUBLIC	??_C@_05MKDOIIA@False@				; `string'
PUBLIC	??_C@_06GGONACPB@Result@			; `string'
PUBLIC	??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@	; `string'
PUBLIC	??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@	; `string'
PUBLIC	??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@	; `string'
PUBLIC	??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@	; `string'
PUBLIC	??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@	; `string'
PUBLIC	??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@	; `string'
PUBLIC	??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@	; `string'
PUBLIC	??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@ ; `string'
PUBLIC	??_C@_0BA@ILOEDOOH@Empty?5node?5set?6@		; `string'
PUBLIC	??_C@_0BB@EPJNDGE@Is?5a?5Boolean?3?$CFs?6@	; `string'
PUBLIC	??_C@_0BB@MGNNLCBN@Is?5a?5number?3?$CF0g?6@	; `string'
PUBLIC	??_C@_0BA@GGJONEIB@Is?5a?5string?3?$CFs?6@	; `string'
PUBLIC	??_C@_0BE@GMLBNCCG@?5No?5base?5found?5?$CB?$CB?$CB?6@ ; `string'
PUBLIC	??_C@_0CA@IOLKGPPF@setns?3?5prefix?$DN?$FLnsuri?$FN?5required?6@ ; `string'
PUBLIC	??_C@_0DN@JOGKKGFC@Error?3?5unable?5to?5register?5NS?5wi@ ; `string'
PUBLIC	??_C@_09EMODOEOP@defaultns@			; `string'
PUBLIC	??_C@_0BJ@CJOBHPHB@failed?5to?5parse?5content?6@ ; `string'
PUBLIC	??_C@_0CG@ILOKJIOB@Relax?9NG?5schema?5?$CFs?5failed?5to?5co@ ; `string'
PUBLIC	??_C@_0O@DFGOKOFF@?$CFs?5validates?6@		; `string'
PUBLIC	??_C@_0BG@JNPIFKED@?$CFs?5fails?5to?5validate?6@ ; `string'
PUBLIC	??_C@_0CL@PGHBNCEH@?$CFs?5validation?5generated?5an?5inte@ ; `string'
PUBLIC	??_C@_0BH@HNGJDIHJ@Failed?5to?5write?5to?5?$CFs?6@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0BG@HDDIGIBB@Failed?5to?5save?5to?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DL@KLJNMADF@To?5save?5to?5subparts?5of?5a?5docume@ ; `string'
PUBLIC	??_C@_02MJEAMPLK@?1?6@				; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5@				; `string'
PUBLIC	??_C@_04GBAPPDDB@?1?5?$DO?5@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_05LMGNBDMA@?$CFs?5?$DO?5@			; `string'
PUBLIC	??_C@_08NAMANEO@?$CFs?3?$CFs?5?$DO?5@		; `string'
PUBLIC	??_C@_04BOPGELD@?$DP?5?$DO?5@			; `string'
PUBLIC	??_C@_04MKNBDEPB@exit@				; `string'
PUBLIC	??_C@_04KNNLNNGO@quit@				; `string'
PUBLIC	??_C@_03MDONDFG@bye@				; `string'
PUBLIC	??_C@_04PCJFHION@help@				; `string'
PUBLIC	??_C@_0CM@NDCHEKFM@?7base?5?5?5?5?5?5?5?5?5display?5XML?5base?5@ ; `string'
PUBLIC	??_C@_0CP@IHKKPKPH@?7setbase?5URI?5?5change?5the?5XML?5ba@ ; `string'
PUBLIC	??_C@_0BL@PONCJHLM@?7bye?5?5?5?5?5?5?5?5?5?5leave?5shell?6@ ; `string'
PUBLIC	??_C@_0CM@PEHFLABL@?7cat?5?$FLnode?$FN?5?5?5display?5node?5or?5c@ ; `string'
PUBLIC	??_C@_0DD@INLKBBOJ@?7cd?5?$FLpath?$FN?5?5?5?5change?5directory?5@ ; `string'
PUBLIC	??_C@_0FC@CJOILHDF@?7dir?5?$FLpath?$FN?5?5?5dumps?5information@ ; `string'
PUBLIC	??_C@_0FA@JDAPDGGD@?7du?5?$FLpath?$FN?5?5?5?5show?5the?5structur@ ; `string'
PUBLIC	??_C@_0BL@DMHFOAJK@?7exit?5?5?5?5?5?5?5?5?5leave?5shell?6@ ; `string'
PUBLIC	??_C@_0CB@KJCEEKOD@?7help?5?5?5?5?5?5?5?5?5display?5this?5help@ ; `string'
PUBLIC	??_C@_0CE@EBLDPJOB@?7free?5?5?5?5?5?5?5?5?5display?5memory?5us@ ; `string'
PUBLIC	??_C@_0CN@FDDLIHG@?7load?5?$FLname?$FN?5?5load?5a?5new?5docume@ ; `string'
PUBLIC	??_C@_0DO@BNGPDHN@?7ls?5?$FLpath?$FN?5?5?5?5list?5contents?5of?5@ ; `string'
PUBLIC	??_C@_0FI@EINANLEN@?7set?5xml_fragment?5replace?5the?5c@ ; `string'
PUBLIC	??_C@_0FC@MFFCIEFJ@?7xpath?5expr?5?5?5evaluate?5the?5XPat@ ; `string'
PUBLIC	??_C@_0FA@BEOPGMKK@?7setns?5nsreg?5?5register?5a?5namesp@ ; `string'
PUBLIC	??_C@_0FC@FBKBHIJ@?7?5?5?5?5?5?5?5?5?5?5?5?5?5format?5for?5nsreg?5@ ; `string'
PUBLIC	??_C@_0EA@FAEACHOL@?7setrootns?5?5?5?5register?5all?5name@ ; `string'
PUBLIC	??_C@_0EE@CPGFHAIM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5the?5default?5names@ ; `string'
PUBLIC	??_C@_0DB@GHFOJJKM@?7pwd?5?5?5?5?5?5?5?5?5?5display?5current?5w@ ; `string'
PUBLIC	??_C@_0EM@EFGOHPBI@?7whereis?5?5?5?5?5?5display?5absolute?5@ ; `string'
PUBLIC	??_C@_0BL@MOIOGEHO@?7quit?5?5?5?5?5?5?5?5?5leave?5shell?6@ ; `string'
PUBLIC	??_C@_0DP@KEMKGHON@?7save?5?$FLname?$FN?5?5save?5this?5documen@ ; `string'
PUBLIC	??_C@_0DG@GCDJELAH@?7write?5?$FLname?$FN?5write?5the?5current@ ; `string'
PUBLIC	??_C@_0CN@LCGGCNEC@?7validate?5?5?5?5?5check?5the?5documen@ ; `string'
PUBLIC	??_C@_0EC@OAJIGDJF@?7relaxng?5rng?5?5validate?5the?5docu@ ; `string'
PUBLIC	??_C@_0DC@LPOKEKPE@?7grep?5string?5?5search?5for?5a?5stri@ ; `string'
PUBLIC	??_C@_08EBLJJHKN@validate@			; `string'
PUBLIC	??_C@_04EONOHKEP@load@				; `string'
PUBLIC	??_C@_07LADMNHNM@relaxng@			; `string'
PUBLIC	??_C@_04EMMDIJJL@save@				; `string'
PUBLIC	??_C@_05NGFEDHGN@write@				; `string'
PUBLIC	??_C@_0CM@DPLMFOBB@Write?5command?5requires?5a?5filena@ ; `string'
PUBLIC	??_C@_04LCNKLLJF@grep@				; `string'
PUBLIC	??_C@_04LIAPHEDB@free@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_03OFKLFAAJ@pwd@				; `string'
PUBLIC	??_C@_02BNCIMIKC@du@				; `string'
PUBLIC	??_C@_04BHIIPFEC@base@				; `string'
PUBLIC	??_C@_03KCHOJKKI@set@				; `string'
PUBLIC	??_C@_05DAFPCCNK@setns@				; `string'
PUBLIC	??_C@_09ENEJFFG@setrootns@			; `string'
PUBLIC	??_C@_05CNNIIAHK@xpath@				; `string'
PUBLIC	??_C@_0BM@BHIKJLIK@xpath?3?5expression?5required?6@ ; `string'
PUBLIC	??_C@_07NPGKGHNA@setbase@			; `string'
PUBLIC	??_C@_02EFGBDOJM@ls@				; `string'
PUBLIC	??_C@_03DAPAKLGM@dir@				; `string'
PUBLIC	??_C@_07BANGEKHA@whereis@			; `string'
PUBLIC	??_C@_02ELLOPNDH@cd@				; `string'
PUBLIC	??_C@_0BI@IHADHLCC@cannot?5cd?5to?5namespace?6@	; `string'
PUBLIC	??_C@_0BF@LLGICLLC@?$CFs?5is?5a?5?$CFd?5Node?5Set?6@ ; `string'
PUBLIC	??_C@_0BJ@MNAPMPFB@?$CFs?5is?5an?5empty?5Node?5Set?6@ ; `string'
PUBLIC	??_C@_03PFGOGFOL@cat@				; `string'
PUBLIC	??_C@_09PGMOGJPB@?5?9?9?9?9?9?9?9?6@		; `string'
PUBLIC	??_C@_0BE@LMHBCIGK@Unknown?5command?5?$CFs?6@	; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrstr:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlCheckUTF8:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fputc:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	__imp__free:PROC
EXTRN	_xmlMemShow:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictOwns:PROC
EXTRN	_xmlValidateName:PROC
EXTRN	_xmlFreeDtd:PROC
EXTRN	_xmlFreeDoc:PROC
EXTRN	_xmlGetNodePath:PROC
EXTRN	_xmlDocGetRootElement:PROC
EXTRN	_xmlAddChildList:PROC
EXTRN	_xmlFreeNodeList:PROC
EXTRN	_xmlNodeGetBase:PROC
EXTRN	_xmlNodeSetBase:PROC
EXTRN	_xmlDocDump:PROC
EXTRN	_xmlElemDump:PROC
EXTRN	_xmlSaveFile:PROC
EXTRN	_xmlHashScan:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	_xmlSnprintfElementContent:PROC
EXTRN	_xmlValidateDtd:PROC
EXTRN	_xmlValidateDocument:PROC
EXTRN	_xmlGetDocEntity:PROC
EXTRN	_xmlParseDTD:PROC
EXTRN	_xmlParseInNodeContext:PROC
EXTRN	_xmlReadFile:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_htmlParseFile:PROC
EXTRN	_xmlXPathFreeObject:PROC
EXTRN	_xmlXPathNewContext:PROC
EXTRN	_xmlXPathFreeContext:PROC
EXTRN	_xmlXPathEval:PROC
EXTRN	_htmlDocDump:PROC
EXTRN	_htmlSaveFile:PROC
EXTRN	_htmlNodeDumpFile:PROC
EXTRN	_xmlXPathDebugDumpObject:PROC
EXTRN	_xmlXPathRegisterNs:PROC
EXTRN	_xmlCanonicPath:PROC
EXTRN	_xmlRelaxNGNewParserCtxt:PROC
EXTRN	_xmlRelaxNGFreeParserCtxt:PROC
EXTRN	_xmlRelaxNGSetParserErrors:PROC
EXTRN	_xmlRelaxNGParse:PROC
EXTRN	_xmlRelaxNGFree:PROC
EXTRN	_xmlRelaxNGSetValidErrors:PROC
EXTRN	_xmlRelaxNGNewValidCtxt:PROC
EXTRN	_xmlRelaxNGFreeValidCtxt:PROC
EXTRN	_xmlRelaxNGValidateDoc:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_xmlStringText:BYTE
EXTRN	_xmlStringTextNoenc:BYTE
EXTRN	_xmlStringComment:BYTE
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BE@LMHBCIGK@Unknown?5command?5?$CFs?6@
CONST	SEGMENT
??_C@_0BE@LMHBCIGK@Unknown?5command?5?$CFs?6@ DB 'Unknown command %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09PGMOGJPB@?5?9?9?9?9?9?9?9?6@
CONST	SEGMENT
??_C@_09PGMOGJPB@?5?9?9?9?9?9?9?9?6@ DB ' -------', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFGOGFOL@cat@
CONST	SEGMENT
??_C@_03PFGOGFOL@cat@ DB 'cat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MNAPMPFB@?$CFs?5is?5an?5empty?5Node?5Set?6@
CONST	SEGMENT
??_C@_0BJ@MNAPMPFB@?$CFs?5is?5an?5empty?5Node?5Set?6@ DB '%s is an empty '
	DB	'Node Set', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LLGICLLC@?$CFs?5is?5a?5?$CFd?5Node?5Set?6@
CONST	SEGMENT
??_C@_0BF@LLGICLLC@?$CFs?5is?5a?5?$CFd?5Node?5Set?6@ DB '%s is a %d Node '
	DB	'Set', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IHADHLCC@cannot?5cd?5to?5namespace?6@
CONST	SEGMENT
??_C@_0BI@IHADHLCC@cannot?5cd?5to?5namespace?6@ DB 'cannot cd to namespac'
	DB	'e', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02ELLOPNDH@cd@
CONST	SEGMENT
??_C@_02ELLOPNDH@cd@ DB 'cd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BANGEKHA@whereis@
CONST	SEGMENT
??_C@_07BANGEKHA@whereis@ DB 'whereis', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAPAKLGM@dir@
CONST	SEGMENT
??_C@_03DAPAKLGM@dir@ DB 'dir', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EFGBDOJM@ls@
CONST	SEGMENT
??_C@_02EFGBDOJM@ls@ DB 'ls', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NPGKGHNA@setbase@
CONST	SEGMENT
??_C@_07NPGKGHNA@setbase@ DB 'setbase', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BHIKJLIK@xpath?3?5expression?5required?6@
CONST	SEGMENT
??_C@_0BM@BHIKJLIK@xpath?3?5expression?5required?6@ DB 'xpath: expression'
	DB	' required', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CNNIIAHK@xpath@
CONST	SEGMENT
??_C@_05CNNIIAHK@xpath@ DB 'xpath', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09ENEJFFG@setrootns@
CONST	SEGMENT
??_C@_09ENEJFFG@setrootns@ DB 'setrootns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DAFPCCNK@setns@
CONST	SEGMENT
??_C@_05DAFPCCNK@setns@ DB 'setns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCHOJKKI@set@
CONST	SEGMENT
??_C@_03KCHOJKKI@set@ DB 'set', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base@
CONST	SEGMENT
??_C@_04BHIIPFEC@base@ DB 'base', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BNCIMIKC@du@
CONST	SEGMENT
??_C@_02BNCIMIKC@du@ DB 'du', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFKLFAAJ@pwd@
CONST	SEGMENT
??_C@_03OFKLFAAJ@pwd@ DB 'pwd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LIAPHEDB@free@
CONST	SEGMENT
??_C@_04LIAPHEDB@free@ DB 'free', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LCNKLLJF@grep@
CONST	SEGMENT
??_C@_04LCNKLLJF@grep@ DB 'grep', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DPLMFOBB@Write?5command?5requires?5a?5filena@
CONST	SEGMENT
??_C@_0CM@DPLMFOBB@Write?5command?5requires?5a?5filena@ DB 'Write command'
	DB	' requires a filename argument', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write@
CONST	SEGMENT
??_C@_05NGFEDHGN@write@ DB 'write', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EMMDIJJL@save@
CONST	SEGMENT
??_C@_04EMMDIJJL@save@ DB 'save', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LADMNHNM@relaxng@
CONST	SEGMENT
??_C@_07LADMNHNM@relaxng@ DB 'relaxng', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EONOHKEP@load@
CONST	SEGMENT
??_C@_04EONOHKEP@load@ DB 'load', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBLJJHKN@validate@
CONST	SEGMENT
??_C@_08EBLJJHKN@validate@ DB 'validate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LPOKEKPE@?7grep?5string?5?5search?5for?5a?5stri@
CONST	SEGMENT
??_C@_0DC@LPOKEKPE@?7grep?5string?5?5search?5for?5a?5stri@ DB 09H, 'grep '
	DB	'string  search for a string in the subtree', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@OAJIGDJF@?7relaxng?5rng?5?5validate?5the?5docu@
CONST	SEGMENT
??_C@_0EC@OAJIGDJF@?7relaxng?5rng?5?5validate?5the?5docu@ DB 09H, 'relaxn'
	DB	'g rng  validate the document against the Relax-NG schemas', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LCGGCNEC@?7validate?5?5?5?5?5check?5the?5documen@
CONST	SEGMENT
??_C@_0CN@LCGGCNEC@?7validate?5?5?5?5?5check?5the?5documen@ DB 09H, 'vali'
	DB	'date     check the document for errors', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GCDJELAH@?7write?5?$FLname?$FN?5write?5the?5current@
CONST	SEGMENT
??_C@_0DG@GCDJELAH@?7write?5?$FLname?$FN?5write?5the?5current@ DB 09H, 'w'
	DB	'rite [name] write the current node to the filename', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KEMKGHON@?7save?5?$FLname?$FN?5?5save?5this?5documen@
CONST	SEGMENT
??_C@_0DP@KEMKGHON@?7save?5?$FLname?$FN?5?5save?5this?5documen@ DB 09H, 's'
	DB	'ave [name]  save this document to name or the original name', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MOIOGEHO@?7quit?5?5?5?5?5?5?5?5?5leave?5shell?6@
CONST	SEGMENT
??_C@_0BL@MOIOGEHO@?7quit?5?5?5?5?5?5?5?5?5leave?5shell?6@ DB 09H, 'quit '
	DB	'        leave shell', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@EFGOHPBI@?7whereis?5?5?5?5?5?5display?5absolute?5@
CONST	SEGMENT
??_C@_0EM@EFGOHPBI@?7whereis?5?5?5?5?5?5display?5absolute?5@ DB 09H, 'whe'
	DB	'reis      display absolute path of [path] or current working '
	DB	'directory', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GHFOJJKM@?7pwd?5?5?5?5?5?5?5?5?5?5display?5current?5w@
CONST	SEGMENT
??_C@_0DB@GHFOJJKM@?7pwd?5?5?5?5?5?5?5?5?5?5display?5current?5w@ DB 09H, 'p'
	DB	'wd          display current working directory', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@CPGFHAIM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5the?5default?5names@
CONST	SEGMENT
??_C@_0EE@CPGFHAIM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5the?5default?5names@ DB 09H
	DB	'             the default namespace if any uses ''defaultns'' '
	DB	'prefix', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FAEACHOL@?7setrootns?5?5?5?5register?5all?5name@
CONST	SEGMENT
??_C@_0EA@FAEACHOL@?7setrootns?5?5?5?5register?5all?5name@ DB 09H, 'setro'
	DB	'otns    register all namespace found on the root element', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@FBKBHIJ@?7?5?5?5?5?5?5?5?5?5?5?5?5?5format?5for?5nsreg?5@
CONST	SEGMENT
??_C@_0FC@FBKBHIJ@?7?5?5?5?5?5?5?5?5?5?5?5?5?5format?5for?5nsreg?5@ DB 09H
	DB	'             format for nsreg is: prefix=[nsuri] (i.e. prefix'
	DB	'= unsets a prefix)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BEOPGMKK@?7setns?5nsreg?5?5register?5a?5namesp@
CONST	SEGMENT
??_C@_0FA@BEOPGMKK@?7setns?5nsreg?5?5register?5a?5namesp@ DB 09H, 'setns '
	DB	'nsreg  register a namespace to a prefix in the XPath evaluati'
	DB	'on context', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@MFFCIEFJ@?7xpath?5expr?5?5?5evaluate?5the?5XPat@
CONST	SEGMENT
??_C@_0FC@MFFCIEFJ@?7xpath?5expr?5?5?5evaluate?5the?5XPat@ DB 09H, 'xpath'
	DB	' expr   evaluate the XPath expression in that context and pri'
	DB	'nt the result', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@EINANLEN@?7set?5xml_fragment?5replace?5the?5c@
CONST	SEGMENT
??_C@_0FI@EINANLEN@?7set?5xml_fragment?5replace?5the?5c@ DB 09H, 'set xml'
	DB	'_fragment replace the current node content with the fragment '
	DB	'parsed in context', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@BNGPDHN@?7ls?5?$FLpath?$FN?5?5?5?5list?5contents?5of?5@
CONST	SEGMENT
??_C@_0DO@BNGPDHN@?7ls?5?$FLpath?$FN?5?5?5?5list?5contents?5of?5@ DB 09H, 'l'
	DB	's [path]    list contents of path or the current directory', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FDDLIHG@?7load?5?$FLname?$FN?5?5load?5a?5new?5docume@
CONST	SEGMENT
??_C@_0CN@FDDLIHG@?7load?5?$FLname?$FN?5?5load?5a?5new?5docume@ DB 09H, 'l'
	DB	'oad [name]  load a new document with name', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EBLDPJOB@?7free?5?5?5?5?5?5?5?5?5display?5memory?5us@
CONST	SEGMENT
??_C@_0CE@EBLDPJOB@?7free?5?5?5?5?5?5?5?5?5display?5memory?5us@ DB 09H, 'f'
	DB	'ree         display memory usage', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KJCEEKOD@?7help?5?5?5?5?5?5?5?5?5display?5this?5help@
CONST	SEGMENT
??_C@_0CB@KJCEEKOD@?7help?5?5?5?5?5?5?5?5?5display?5this?5help@ DB 09H, 'h'
	DB	'elp         display this help', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DMHFOAJK@?7exit?5?5?5?5?5?5?5?5?5leave?5shell?6@
CONST	SEGMENT
??_C@_0BL@DMHFOAJK@?7exit?5?5?5?5?5?5?5?5?5leave?5shell?6@ DB 09H, 'exit '
	DB	'        leave shell', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@JDAPDGGD@?7du?5?$FLpath?$FN?5?5?5?5show?5the?5structur@
CONST	SEGMENT
??_C@_0FA@JDAPDGGD@?7du?5?$FLpath?$FN?5?5?5?5show?5the?5structur@ DB 09H, 'd'
	DB	'u [path]    show the structure of the subtree under path or t'
	DB	'he current node', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@CJOILHDF@?7dir?5?$FLpath?$FN?5?5?5dumps?5information@
CONST	SEGMENT
??_C@_0FC@CJOILHDF@?7dir?5?$FLpath?$FN?5?5?5dumps?5information@ DB 09H, 'd'
	DB	'ir [path]   dumps informations about the node (namespace, att'
	DB	'ributes, content)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@INLKBBOJ@?7cd?5?$FLpath?$FN?5?5?5?5change?5directory?5@
CONST	SEGMENT
??_C@_0DD@INLKBBOJ@?7cd?5?$FLpath?$FN?5?5?5?5change?5directory?5@ DB 09H, 'c'
	DB	'd [path]    change directory to path or to root', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PEHFLABL@?7cat?5?$FLnode?$FN?5?5?5display?5node?5or?5c@
CONST	SEGMENT
??_C@_0CM@PEHFLABL@?7cat?5?$FLnode?$FN?5?5?5display?5node?5or?5c@ DB 09H, 'c'
	DB	'at [node]   display node or current node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PONCJHLM@?7bye?5?5?5?5?5?5?5?5?5?5leave?5shell?6@
CONST	SEGMENT
??_C@_0BL@PONCJHLM@?7bye?5?5?5?5?5?5?5?5?5?5leave?5shell?6@ DB 09H, 'bye '
	DB	'         leave shell', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IHKKPKPH@?7setbase?5URI?5?5change?5the?5XML?5ba@
CONST	SEGMENT
??_C@_0CP@IHKKPKPH@?7setbase?5URI?5?5change?5the?5XML?5ba@ DB 09H, 'setba'
	DB	'se URI  change the XML base of the node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NDCHEKFM@?7base?5?5?5?5?5?5?5?5?5display?5XML?5base?5@
CONST	SEGMENT
??_C@_0CM@NDCHEKFM@?7base?5?5?5?5?5?5?5?5?5display?5XML?5base?5@ DB 09H, 'b'
	DB	'ase         display XML base of the node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help@
CONST	SEGMENT
??_C@_04PCJFHION@help@ DB 'help', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDONDFG@bye@
CONST	SEGMENT
??_C@_03MDONDFG@bye@ DB 'bye', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNNLNNGO@quit@
CONST	SEGMENT
??_C@_04KNNLNNGO@quit@ DB 'quit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit@ DB 'exit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BOPGELD@?$DP?5?$DO?5@
CONST	SEGMENT
??_C@_04BOPGELD@?$DP?5?$DO?5@ DB '? > ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NAMANEO@?$CFs?3?$CFs?5?$DO?5@
CONST	SEGMENT
??_C@_08NAMANEO@?$CFs?3?$CFs?5?$DO?5@ DB '%s:%s > ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LMGNBDMA@?$CFs?5?$DO?5@
CONST	SEGMENT
??_C@_05LMGNBDMA@?$CFs?5?$DO?5@ DB '%s > ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GBAPPDDB@?1?5?$DO?5@
CONST	SEGMENT
??_C@_04GBAPPDDB@?1?5?$DO?5@ DB '/ > ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MJEAMPLK@?1?6@
CONST	SEGMENT
??_C@_02MJEAMPLK@?1?6@ DB '/', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@KLJNMADF@To?5save?5to?5subparts?5of?5a?5docume@
CONST	SEGMENT
??_C@_0DL@KLJNMADF@To?5save?5to?5subparts?5of?5a?5docume@ DB 'To save to '
	DB	'subparts of a document use the ''write'' command', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HDDIGIBB@Failed?5to?5save?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@HDDIGIBB@Failed?5to?5save?5to?5?$CFs?6@ DB 'Failed to save to %'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HNGJDIHJ@Failed?5to?5write?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@HNGJDIHJ@Failed?5to?5write?5to?5?$CFs?6@ DB 'Failed to write to'
	DB	' %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PGHBNCEH@?$CFs?5validation?5generated?5an?5inte@
CONST	SEGMENT
??_C@_0CL@PGHBNCEH@?$CFs?5validation?5generated?5an?5inte@ DB '%s validat'
	DB	'ion generated an internal error', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JNPIFKED@?$CFs?5fails?5to?5validate?6@
CONST	SEGMENT
??_C@_0BG@JNPIFKED@?$CFs?5fails?5to?5validate?6@ DB '%s fails to validate'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DFGOKOFF@?$CFs?5validates?6@
CONST	SEGMENT
??_C@_0O@DFGOKOFF@?$CFs?5validates?6@ DB '%s validates', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ILOKJIOB@Relax?9NG?5schema?5?$CFs?5failed?5to?5co@
CONST	SEGMENT
??_C@_0CG@ILOKJIOB@Relax?9NG?5schema?5?$CFs?5failed?5to?5co@ DB 'Relax-NG'
	DB	' schema %s failed to compile', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CJOBHPHB@failed?5to?5parse?5content?6@
CONST	SEGMENT
??_C@_0BJ@CJOBHPHB@failed?5to?5parse?5content?6@ DB 'failed to parse cont'
	DB	'ent', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09EMODOEOP@defaultns@
CONST	SEGMENT
??_C@_09EMODOEOP@defaultns@ DB 'defaultns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JOGKKGFC@Error?3?5unable?5to?5register?5NS?5wi@
CONST	SEGMENT
??_C@_0DN@JOGKKGFC@Error?3?5unable?5to?5register?5NS?5wi@ DB 'Error: unab'
	DB	'le to register NS with prefix="%s" and href="%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IOLKGPPF@setns?3?5prefix?$DN?$FLnsuri?$FN?5required?6@
CONST	SEGMENT
??_C@_0CA@IOLKGPPF@setns?3?5prefix?$DN?$FLnsuri?$FN?5required?6@ DB 'setn'
	DB	's: prefix=[nsuri] required', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GMLBNCCG@?5No?5base?5found?5?$CB?$CB?$CB?6@
CONST	SEGMENT
??_C@_0BE@GMLBNCCG@?5No?5base?5found?5?$CB?$CB?$CB?6@ DB ' No base found '
	DB	'!!!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GGJONEIB@Is?5a?5string?3?$CFs?6@
CONST	SEGMENT
??_C@_0BA@GGJONEIB@Is?5a?5string?3?$CFs?6@ DB 'Is a string:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MGNNLCBN@Is?5a?5number?3?$CF0g?6@
CONST	SEGMENT
??_C@_0BB@MGNNLCBN@Is?5a?5number?3?$CF0g?6@ DB 'Is a number:%0g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPJNDGE@Is?5a?5Boolean?3?$CFs?6@
CONST	SEGMENT
??_C@_0BB@EPJNDGE@Is?5a?5Boolean?3?$CFs?6@ DB 'Is a Boolean:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILOEDOOH@Empty?5node?5set?6@
CONST	SEGMENT
??_C@_0BA@ILOEDOOH@Empty?5node?5set?6@ DB 'Empty node set', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@
CONST	SEGMENT
??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@ DB '%s is an XSLT '
	DB	'value tree', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@
CONST	SEGMENT
??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@ DB '%s is user-defined', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
CONST	SEGMENT
??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@ DB '%s is a range', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@
CONST	SEGMENT
??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@ DB '%s is a point', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@
CONST	SEGMENT
??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@ DB '%s is a string', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@
CONST	SEGMENT
??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@ DB '%s is a number', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@
CONST	SEGMENT
??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@ DB '%s is a Boolean', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
CONST	SEGMENT
??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@ DB '%s: no such node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GGONACPB@Result@
CONST	SEGMENT
??_C@_06GGONACPB@Result@ DB 'Result', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MKDOIIA@False@
CONST	SEGMENT
??_C@_05MKDOIIA@False@ DB 'False', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPMIDMKH@True@
CONST	SEGMENT
??_C@_04HPMIDMKH@True@ DB 'True', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DHHJCFN@?$CFs?5?9?$DO?5?$CFs@
CONST	SEGMENT
??_C@_08DHHJCFN@?$CFs?5?9?$DO?5?$CFs@ DB '%s -> %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IMMJOEMC@default?5?9?$DO?5?$CFs@
CONST	SEGMENT
??_C@_0O@IMMJOEMC@default?5?9?$DO?5?$CFs@ DB 'default -> %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DKEJHHJP@?$CFs?3@
CONST	SEGMENT
??_C@_03DKEJHHJP@?$CFs?3@ DB '%s:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KPHFGMAO@?5?$CF8d?5@
CONST	SEGMENT
??_C@_05KPHFGMAO@?5?$CF8d?5@ DB ' %8d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n@ DB 'n', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01NANMIPIL@N@
CONST	SEGMENT
??_C@_01NANMIPIL@N@ DB 'N', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01BIAFAFID@F@
CONST	SEGMENT
??_C@_01BIAFAFID@F@ DB 'F', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GAPBHFFA@T@
CONST	SEGMENT
??_C@_01GAPBHFFA@T@ DB 'T', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01BDACAMKP@h@
CONST	SEGMENT
??_C@_01BDACAMKP@h@ DB 'h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d@
CONST	SEGMENT
??_C@_01LPLHEDKD@d@ DB 'd', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01PAPGNFGE@c@
CONST	SEGMENT
??_C@_01PAPGNFGE@c@ DB 'c', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p@
CONST	SEGMENT
??_C@_01JBBJJEPG@p@ DB 'p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E@
CONST	SEGMENT
??_C@_01DDCIFGEA@E@ DB 'E', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e@
CONST	SEGMENT
??_C@_01KGKMHCOC@e@ DB 'e', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C@
CONST	SEGMENT
??_C@_01GFHCPBMG@C@ DB 'C', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01PFHFFBPC@t@
CONST	SEGMENT
??_C@_01PFHFFBPC@t@ DB 't', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a@
CONST	SEGMENT
??_C@_01MCMALHOG@a@ DB 'a', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NJDBAOFA@NULL?6@
CONST	SEGMENT
??_C@_05NJDBAOFA@NULL?6@ DB 'NULL', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JMCKHIKF@?5?5?5?5DTD?5is?5empty?6@
CONST	SEGMENT
??_C@_0BC@JMCKHIKF@?5?5?5?5DTD?5is?5empty?6@ DB '    DTD is empty', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBKAICJC@DTD?5is?5NULL?6@
CONST	SEGMENT
??_C@_0N@BBKAICJC@DTD?5is?5NULL?6@ DB 'DTD is NULL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LBEHELLO@No?5entities?5in?5external?5subset?6@
CONST	SEGMENT
??_C@_0CA@LBEHELLO@No?5entities?5in?5external?5subset?6@ DB 'No entities '
	DB	'in external subset', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BMADNPKJ@Entities?5in?5external?5subset?6@
CONST	SEGMENT
??_C@_0BN@BMADNPKJ@Entities?5in?5external?5subset?6@ DB 'Entities in exte'
	DB	'rnal subset', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JBOJHEJF@No?5entities?5in?5internal?5subset?6@
CONST	SEGMENT
??_C@_0CA@JBOJHEJF@No?5entities?5in?5internal?5subset?6@ DB 'No entities '
	DB	'in internal subset', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DMKNOAIC@Entities?5in?5internal?5subset?6@
CONST	SEGMENT
??_C@_0BN@DMKNOAIC@Entities?5in?5internal?5subset?6@ DB 'Entities in inte'
	DB	'rnal subset', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IHEOBAMO@?6?5content?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0P@IHEOBAMO@?6?5content?5?$CC?$CFs?$CC@ DB 0aH, ' content "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ENMJJFAE@?6?5orig?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0M@ENMJJFAE@?6?5orig?5?$CC?$CFs?$CC@ DB 0aH, ' orig "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CPEEBBLL@SYSTEM?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0M@CPEEBBLL@SYSTEM?5?$CC?$CFs?$CC@ DB 'SYSTEM "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MGAPBOEN@ID?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_07MGAPBOEN@ID?5?$CC?$CFs?$CC@ DB 'ID "%s"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PGEHOKHI@Unknown?5entity?5type?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@PGEHOKHI@Unknown?5entity?5type?5?$CFd?6@ DB 'Unknown entity typ'
	DB	'e %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GEKJJGOC@EXTERNAL?5PARAMETER?0?5@
CONST	SEGMENT
??_C@_0BF@GEKJJGOC@EXTERNAL?5PARAMETER?0?5@ DB 'EXTERNAL PARAMETER, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DHEHKNNP@INTERNAL?5PARAMETER?0?5@
CONST	SEGMENT
??_C@_0BF@DHEHKNNP@INTERNAL?5PARAMETER?0?5@ DB 'INTERNAL PARAMETER, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EAFADDI@EXTERNAL?5UNPARSED?0?5@
CONST	SEGMENT
??_C@_0BE@EAFADDI@EXTERNAL?5UNPARSED?0?5@ DB 'EXTERNAL UNPARSED, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LPMELAMM@EXTERNAL?5PARSED?0?5@
CONST	SEGMENT
??_C@_0BC@LPMELAMM@EXTERNAL?5PARSED?0?5@ DB 'EXTERNAL PARSED, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JEHEGLEK@INTERNAL?5GENERAL?0?5@
CONST	SEGMENT
??_C@_0BD@JEHEGLEK@INTERNAL?5GENERAL?0?5@ DB 'INTERNAL GENERAL, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LLGELLBM@?$CFs?5?3?5@
CONST	SEGMENT
??_C@_05LLGELLBM@?$CFs?5?3?5@ DB '%s : ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LECCLHEJ@Entity?5is?5NULL@
CONST	SEGMENT
??_C@_0P@LECCLHEJ@Entity?5is?5NULL@ DB 'Entity is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IPNIJGMI@standalone?$DNtrue?6@
CONST	SEGMENT
??_C@_0BB@IPNIJGMI@standalone?$DNtrue?6@ DB 'standalone=true', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLECLDGK@URL?$DN@
CONST	SEGMENT
??_C@_04LLECLDGK@URL?$DN@ DB 'URL=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GHEONEIE@encoding?$DN@
CONST	SEGMENT
??_C@_09GHEONEIE@encoding?$DN@ DB 'encoding=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLMDBNEB@version?$DN@
CONST	SEGMENT
??_C@_08CLMDBNEB@version?$DN@ DB 'version=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFCJAACA@name?$DN@
CONST	SEGMENT
??_C@_05DFCJAACA@name?$DN@ DB 'name=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CONGBBKN@Misplaced?5NOTATION?5node?6@
CONST	SEGMENT
??_C@_0BJ@CONGBBKN@Misplaced?5NOTATION?5node?6@ DB 'Misplaced NOTATION no'
	DB	'de', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EDIFACFE@Misplaced?5FRAGMENT?5node?6@
CONST	SEGMENT
??_C@_0BJ@EDIFACFE@Misplaced?5FRAGMENT?5node?6@ DB 'Misplaced FRAGMENT no'
	DB	'de', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HEJPPPBK@Misplaced?5DOCTYPE?5node?6@
CONST	SEGMENT
??_C@_0BI@HEJPPPBK@Misplaced?5DOCTYPE?5node?6@ DB 'Misplaced DOCTYPE node'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NDGMGMGG@HTML?5DOCUMENT?6@
CONST	SEGMENT
??_C@_0P@NDGMGMGG@HTML?5DOCUMENT?6@ DB 'HTML DOCUMENT', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JFLEHAPI@DOCUMENT?6@
CONST	SEGMENT
??_C@_09JFLEHAPI@DOCUMENT?6@ DB 'DOCUMENT', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MEFJLFLK@Misplaced?5COMMENT?5node?6@
CONST	SEGMENT
??_C@_0BI@MEFJLFLK@Misplaced?5COMMENT?5node?6@ DB 'Misplaced COMMENT node'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LAMDNLOB@Misplaced?5PI?5node?6@
CONST	SEGMENT
??_C@_0BD@LAMDNLOB@Misplaced?5PI?5node?6@ DB 'Misplaced PI node', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NGEMGAKL@Misplaced?5ENTITY?5node?6@
CONST	SEGMENT
??_C@_0BH@NGEMGAKL@Misplaced?5ENTITY?5node?6@ DB 'Misplaced ENTITY node', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FAHNDMGM@Misplaced?5ENTITYREF?5node?6@
CONST	SEGMENT
??_C@_0BK@FAHNDMGM@Misplaced?5ENTITYREF?5node?6@ DB 'Misplaced ENTITYREF '
	DB	'node', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JKLDMKBF@Misplaced?5CDATA?5node?6@
CONST	SEGMENT
??_C@_0BG@JKLDMKBF@Misplaced?5CDATA?5node?6@ DB 'Misplaced CDATA node', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JFJFJLGA@Misplaced?5TEXT?5node?6@
CONST	SEGMENT
??_C@_0BF@JFJFJLGA@Misplaced?5TEXT?5node?6@ DB 'Misplaced TEXT node', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DMGHGOPO@Misplaced?5ATTRIBUTE?5node?6@
CONST	SEGMENT
??_C@_0BK@DMGHGOPO@Misplaced?5ATTRIBUTE?5node?6@ DB 'Misplaced ATTRIBUTE '
	DB	'node', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IHFNOEDM@Misplaced?5ELEMENT?5node?6@
CONST	SEGMENT
??_C@_0BI@IHFNOEDM@Misplaced?5ELEMENT?5node?6@ DB 'Misplaced ELEMENT node'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NJEBDCCE@DOCUMENT?5?$DN?$DN?5NULL?5?$CB?6@
CONST	SEGMENT
??_C@_0BE@NJEBDCCE@DOCUMENT?5?$DN?$DN?5NULL?5?$CB?6@ DB 'DOCUMENT == NULL'
	DB	' !', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LCJECPKH@PBM?3?5doc?5?$DN?$DN?5NULL?5?$CB?$CB?$CB?6@
CONST	SEGMENT
??_C@_0BG@LCJECPKH@PBM?3?5doc?5?$DN?$DN?5NULL?5?$CB?$CB?$CB?6@ DB 'PBM: d'
	DB	'oc == NULL !!!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ILEBNOHM@Unknown?5node?5type?5?$CFd?6@
CONST	SEGMENT
??_C@_0BG@ILEBNOHM@Unknown?5node?5type?5?$CFd?6@ DB 'Unknown node type %d'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DKMEHMHH@INCLUDE?5END?6@
CONST	SEGMENT
??_C@_0N@DKMEHMHH@INCLUDE?5END?6@ DB 'INCLUDE END', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MIINKGDA@INCLUDE?5START?6@
CONST	SEGMENT
??_C@_0P@MIINKGDA@INCLUDE?5START?6@ DB 'INCLUDE START', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CPFNJPEP@NOTATION?6@
CONST	SEGMENT
??_C@_09CPFNJPEP@NOTATION?6@ DB 'NOTATION', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLLHGMMO@DOCUMENT_FRAG?6@
CONST	SEGMENT
??_C@_0P@JLLHGMMO@DOCUMENT_FRAG?6@ DB 'DOCUMENT_FRAG', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EJFIBKNL@DOCUMENT_TYPE?6@
CONST	SEGMENT
??_C@_0P@EJFIBKNL@DOCUMENT_TYPE?6@ DB 'DOCUMENT_TYPE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DKGLPLJE@Error?0?5DOCUMENT?5found?5here?6@
CONST	SEGMENT
??_C@_0BM@DKGLPLJE@Error?0?5DOCUMENT?5found?5here?6@ DB 'Error, DOCUMENT '
	DB	'found here', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OCMMJPAI@COMMENT?6@
CONST	SEGMENT
??_C@_08OCMMJPAI@COMMENT?6@ DB 'COMMENT', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JDGENMBJ@PI?5?$CFs?6@
CONST	SEGMENT
??_C@_06JDGENMBJ@PI?5?$CFs?6@ DB 'PI %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PAIFPHKC@ENTITY?6@
CONST	SEGMENT
??_C@_07PAIFPHKC@ENTITY?6@ DB 'ENTITY', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FMOACEBO@ENTITY_REF?$CI?$CFs?$CJ?6@
CONST	SEGMENT
??_C@_0BA@FMOACEBO@ENTITY_REF?$CI?$CFs?$CJ?6@ DB 'ENTITY_REF(%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HFCBAJGN@CDATA_SECTION?6@
CONST	SEGMENT
??_C@_0P@HFCBAJGN@CDATA_SECTION?6@ DB 'CDATA_SECTION', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IDACKBMB@?5interned?6@
CONST	SEGMENT
??_C@_0L@IDACKBMB@?5interned?6@ DB ' interned', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKJIJFNN@?5compact?6@
CONST	SEGMENT
??_C@_09PKJIJFNN@?5compact?6@ DB ' compact', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OEPMCOLO@TEXT@
CONST	SEGMENT
??_C@_04OEPMCOLO@TEXT@ DB 'TEXT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IDMICFJC@TEXT?5no?5enc@
CONST	SEGMENT
??_C@_0M@IDMICFJC@TEXT?5no?5enc@ DB 'TEXT no enc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DLOCDHBF@Error?0?5ATTRIBUTE?5found?5here?6@
CONST	SEGMENT
??_C@_0BN@DLOCDHBF@Error?0?5ATTRIBUTE?5found?5here?6@ DB 'Error, ATTRIBUT'
	DB	'E found here', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08EDNNGDCO@ELEMENT?5@
CONST	SEGMENT
??_C@_08EDNNGDCO@ELEMENT?5@ DB 'ELEMENT ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IPKFPFDL@node?5is?5NULL?6@
CONST	SEGMENT
??_C@_0O@IPKFPFDL@node?5is?5NULL?6@ DB 'node is NULL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HFHKPGJL@Attribute?5has?5no?5name@
CONST	SEGMENT
??_C@_0BG@HFHKPGJL@Attribute?5has?5no?5name@ DB 'Attribute has no name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPLGGCMF@ATTRIBUTE?5@
CONST	SEGMENT
??_C@_0L@MPLGGCMF@ATTRIBUTE?5@ DB 'ATTRIBUTE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KCLOKEKK@Attr?5is?5NULL@
CONST	SEGMENT
??_C@_0N@KCLOKEKK@Attr?5is?5NULL@ DB 'Attr is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08INNCGMHH@content?$DN@
CONST	SEGMENT
??_C@_08INNCGMHH@content?$DN@ DB 'content=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HJADGDLG@URI?$DN?$CFs?6@
CONST	SEGMENT
??_C@_07HJADGDLG@URI?$DN?$CFs?6@ DB 'URI=%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BPAPFMFO@SystemID?$DN?$CFs?6@
CONST	SEGMENT
??_C@_0N@BPAPFMFO@SystemID?$DN?$CFs?6@ DB 'SystemID=%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EALJADBN@ExternalID?$DN?$CFs?6@
CONST	SEGMENT
??_C@_0P@EALJADBN@ExternalID?$DN?$CFs?6@ DB 'ExternalID=%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KEBDPOGN@ENTITY_?$CFd?5?$CB?5@
CONST	SEGMENT
??_C@_0N@KEBDPOGN@ENTITY_?$CFd?5?$CB?5@ DB 'ENTITY_%d ! ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HEENOMOI@EXTERNAL_PARAMETER_ENTITY?5@
CONST	SEGMENT
??_C@_0BL@HEENOMOI@EXTERNAL_PARAMETER_ENTITY?5@ DB 'EXTERNAL_PARAMETER_EN'
	DB	'TITY ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ECACNHOO@INTERNAL_PARAMETER_ENTITY?5@
CONST	SEGMENT
??_C@_0BL@ECACNHOO@INTERNAL_PARAMETER_ENTITY?5@ DB 'INTERNAL_PARAMETER_EN'
	DB	'TITY ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EADOHJCE@EXTERNAL_GENERAL_UNPARSED_ENTIT@
CONST	SEGMENT
??_C@_0CC@EADOHJCE@EXTERNAL_GENERAL_UNPARSED_ENTIT@ DB 'EXTERNAL_GENERAL_'
	DB	'UNPARSED_ENTITY ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NAIMNBBA@EXTERNAL_GENERAL_PARSED_ENTITY?5@
CONST	SEGMENT
??_C@_0CA@NAIMNBBA@EXTERNAL_GENERAL_PARSED_ENTITY?5@ DB 'EXTERNAL_GENERAL'
	DB	'_PARSED_ENTITY ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MJDLDDEN@INTERNAL_GENERAL_ENTITY?5@
CONST	SEGMENT
??_C@_0BJ@MJDLDDEN@INTERNAL_GENERAL_ENTITY?5@ DB 'INTERNAL_GENERAL_ENTITY'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PFFLDDAJ@Entity?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BA@PFFLDDAJ@Entity?5is?5NULL?6@ DB 'Entity is NULL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BIAGHAFN@default?5namespace?5href?$DN@
CONST	SEGMENT
??_C@_0BI@BIAGHAFN@default?5namespace?5href?$DN@ DB 'default namespace hr'
	DB	'ef=', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IHBOEJJJ@namespace?5?$CFs?5href?$DN@
CONST	SEGMENT
??_C@_0BD@IHBOEJJJ@namespace?5?$CFs?5href?$DN@ DB 'namespace %s href=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MFMJLJFK@Incomplete?5default?5namespace?5hr@
CONST	SEGMENT
??_C@_0CI@MFMJLJFK@Incomplete?5default?5namespace?5hr@ DB 'Incomplete def'
	DB	'ault namespace href=NULL', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FKAEBHOG@Incomplete?5namespace?5?$CFs?5href?$DNNU@
CONST	SEGMENT
??_C@_0CD@FKAEBHOG@Incomplete?5namespace?5?$CFs?5href?$DNNU@ DB 'Incomple'
	DB	'te namespace %s href=NULL', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MGJPGGJB@Node?5is?5not?5a?5namespace?5declara@
CONST	SEGMENT
??_C@_0CE@MGJPGGJB@Node?5is?5not?5a?5namespace?5declara@ DB 'Node is not '
	DB	'a namespace declaration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HODGPHLJ@namespace?5node?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BI@HODGPHLJ@namespace?5node?5is?5NULL?6@ DB 'namespace node is NUL'
	DB	'L', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09MHAMBDHP@?5content?$DN@
CONST	SEGMENT
??_C@_09MHAMBDHP@?5content?$DN@ DB ' content=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HINJCKNC@?5URI?$DN?$CFs?6@
CONST	SEGMENT
??_C@_08HINJCKNC@?5URI?$DN?$CFs?6@ DB ' URI=%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MKEBLMD@?5SystemID?$DN?$CFs?6@
CONST	SEGMENT
??_C@_0O@MKEBLMD@?5SystemID?$DN?$CFs?6@ DB ' SystemID=%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMOODANC@?5ExternalID?$DN?$CFs?6@
CONST	SEGMENT
??_C@_0BA@GMOODANC@?5ExternalID?$DN?$CFs?6@ DB ' ExternalID=%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OLDJNJL@?0?5predefined?6@
CONST	SEGMENT
??_C@_0O@OLDJNJL@?0?5predefined?6@ DB ', predefined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OKFDOFBK@?0?5external?5parameter?6@
CONST	SEGMENT
??_C@_0BG@OKFDOFBK@?0?5external?5parameter?6@ DB ', external parameter', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NMAFEAAG@?0?5parameter?6@
CONST	SEGMENT
??_C@_0N@NMAFEAAG@?0?5parameter?6@ DB ', parameter', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FLIMFIIH@?0?5unparsed?6@
CONST	SEGMENT
??_C@_0M@FLIMFIIH@?0?5unparsed?6@ DB ', unparsed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BCOHBEKD@?0?5external?5parsed?6@
CONST	SEGMENT
??_C@_0BD@BCOHBEKD@?0?5external?5parsed?6@ DB ', external parsed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PBKIGNE@?0?5internal?6@
CONST	SEGMENT
??_C@_0M@PBKIGNE@?0?5internal?6@ DB ', internal', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DPAEJKOA@Entity?5declaration?5has?5no?5name@
CONST	SEGMENT
??_C@_0BP@DPAEJKOA@Entity?5declaration?5has?5no?5name@ DB 'Entity declara'
	DB	'tion has no name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KEJNLLDB@ENTITYDECL?$CI@
CONST	SEGMENT
??_C@_0M@KEJNLLDB@ENTITYDECL?$CI@ DB 'ENTITYDECL(', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CMGFHOFN@Node?5is?5not?5an?5entity?5declarati@
CONST	SEGMENT
??_C@_0CC@CMGFHOFN@Node?5is?5not?5an?5entity?5declarati@ DB 'Node is not '
	DB	'an entity declaration', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BBOCCNBN@Entity?5declaration?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BM@BBOCCNBN@Entity?5declaration?5is?5NULL?6@ DB 'Entity declaratio'
	DB	'n is NULL', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MPHAJKBG@?0?5MIXED?5@
CONST	SEGMENT
??_C@_08MPHAJKBG@?0?5MIXED?5@ DB ', MIXED ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNEHMNJK@?0?5ANY@
CONST	SEGMENT
??_C@_05MNEHMNJK@?0?5ANY@ DB ', ANY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MPIOAGOH@?0?5EMPTY@
CONST	SEGMENT
??_C@_07MPIOAGOH@?0?5EMPTY@ DB ', EMPTY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PIGJBKAD@?0?5UNDEFINED@
CONST	SEGMENT
??_C@_0M@PIGJBKAD@?0?5UNDEFINED@ DB ', UNDEFINED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CBJEJFEP@Element?5declaration?5has?5no?5name@
CONST	SEGMENT
??_C@_0CA@CBJEJFEP@Element?5declaration?5has?5no?5name@ DB 'Element decla'
	DB	'ration has no name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09LBEHMBNA@ELEMDECL?$CI@
CONST	SEGMENT
??_C@_09LBEHMBNA@ELEMDECL?$CI@ DB 'ELEMDECL(', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MEOODKKF@Node?5is?5not?5an?5element?5declarat@
CONST	SEGMENT
??_C@_0CD@MEOODKKF@Node?5is?5not?5an?5element?5declarat@ DB 'Node is not '
	DB	'an element declaration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LDLGNJBO@Element?5declaration?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BN@LDLGNJBO@Element?5declaration?5is?5NULL?6@ DB 'Element declarat'
	DB	'ion is NULL', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MNDBCIDD@?5FIXED@
CONST	SEGMENT
??_C@_06MNDBCIDD@?5FIXED@ DB ' FIXED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNNMMLKP@?5IMPLIED@
CONST	SEGMENT
??_C@_08BNNMMLKP@?5IMPLIED@ DB ' IMPLIED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GBLDHCFM@?5REQUIRED@
CONST	SEGMENT
??_C@_09GBLDHCFM@?5REQUIRED@ DB ' REQUIRED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HBFELFIL@?4?4?4?$CJ@
CONST	SEGMENT
??_C@_04HBFELFIL@?4?4?4?$CJ@ DB '...)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KHAOAOAJ@?5?$CI?$CFs@
CONST	SEGMENT
??_C@_04KHAOAOAJ@?5?$CI?$CFs@ DB ' (%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MFMGJBPJ@?$HM?$CFs@
CONST	SEGMENT
??_C@_03MFMGJBPJ@?$HM?$CFs@ DB '|%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EOKHAFCK@?5NOTATION?5@
CONST	SEGMENT
??_C@_0L@EOKHAFCK@?5NOTATION?5@ DB ' NOTATION ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DAGLJCMJ@?5ENUMERATION@
CONST	SEGMENT
??_C@_0N@DAGLJCMJ@?5ENUMERATION@ DB ' ENUMERATION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGAPIBOH@?5NMTOKENS@
CONST	SEGMENT
??_C@_09LGAPIBOH@?5NMTOKENS@ DB ' NMTOKENS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JLMONKHB@?5NMTOKEN@
CONST	SEGMENT
??_C@_08JLMONKHB@?5NMTOKEN@ DB ' NMTOKEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MILPKLMO@?5ENTITIES@
CONST	SEGMENT
??_C@_09MILPKLMO@?5ENTITIES@ DB ' ENTITIES', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GLIJGNMP@?5ENTITY@
CONST	SEGMENT
??_C@_07GLIJGNMP@?5ENTITY@ DB ' ENTITY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNGJPBFB@?5IDREFS@
CONST	SEGMENT
??_C@_07CNGJPBFB@?5IDREFS@ DB ' IDREFS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJHMNMLB@?5IDREF@
CONST	SEGMENT
??_C@_06JJHMNMLB@?5IDREF@ DB ' IDREF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFNHLDJD@?5ID@
CONST	SEGMENT
??_C@_03JFNHLDJD@?5ID@ DB ' ID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CIOOFICG@?5CDATA@
CONST	SEGMENT
??_C@_06CIOOFICG@?5CDATA@ DB ' CDATA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BPDBFHFF@Node?5attribute?5declaration?5has?5@
CONST	SEGMENT
??_C@_0CP@BPDBFHFF@Node?5attribute?5declaration?5has?5@ DB 'Node attribut'
	DB	'e declaration has no element name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GLNLDEDP@?5for?5?$CFs@
CONST	SEGMENT
??_C@_07GLNLDEDP@?5for?5?$CFs@ DB ' for %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PBLLGJEB@Node?5attribute?5declaration?5has?5@
CONST	SEGMENT
??_C@_0CH@PBLLGJEB@Node?5attribute?5declaration?5has?5@ DB 'Node attribut'
	DB	'e declaration has no name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EBLNCBKJ@ATTRDECL?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0N@EBLNCBKJ@ATTRDECL?$CI?$CFs?$CJ@ DB 'ATTRDECL(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DOMFFPAF@Node?5is?5not?5an?5attribute?5declar@
CONST	SEGMENT
??_C@_0CF@DOMFFPAF@Node?5is?5not?5an?5attribute?5declar@ DB 'Node is not '
	DB	'an attribute declaration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BAGDAOMH@Attribute?5declaration?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BP@BAGDAOMH@Attribute?5declaration?5is?5NULL?6@ DB 'Attribute decl'
	DB	'aration is NULL', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PKDMNFPO@?0?5SYSTEM?5?$CFs@
CONST	SEGMENT
??_C@_0M@PKDMNFPO@?0?5SYSTEM?5?$CFs@ DB ', SYSTEM %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NLONAAOP@?0?5PUBLIC?5?$CFs@
CONST	SEGMENT
??_C@_0M@NLONAAOP@?0?5PUBLIC?5?$CFs@ DB ', PUBLIC %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DFGNODOE@DTD@
CONST	SEGMENT
??_C@_03DFGNODOE@DTD@ DB 'DTD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFBLHE@DTD?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_07PFBLHE@DTD?$CI?$CFs?$CJ@ DB 'DTD(%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MBEMJEOJ@Node?5is?5not?5a?5DTD@
CONST	SEGMENT
??_C@_0BC@MBEMJEOJ@Node?5is?5not?5a?5DTD@ DB 'Node is not a DTD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MDLFLLHC@DTD?5node?5is?5NULL?6@
CONST	SEGMENT
??_C@_0BC@MDLFLLHC@DTD?5node?5is?5NULL?6@ DB 'DTD node is NULL', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHICJKCI@?4?4?4@
CONST	SEGMENT
??_C@_03KHICJKCI@?4?4?4@ DB '...', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CANIHDGE@?$CD?$CFX@
CONST	SEGMENT
??_C@_03CANIHDGE@?$CD?$CFX@ DB '#%X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LHGEHABH@?$CINULL?$CJ@
CONST	SEGMENT
??_C@_06LHGEHABH@?$CINULL?$CJ@ DB '(NULL)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EPPJHKJE@CData?5section?5has?5non?5NULL?5name@
CONST	SEGMENT
??_C@_0CF@EPPJHKJE@CData?5section?5has?5non?5NULL?5name@ DB 'CData sectio'
	DB	'n has non NULL name ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NIALDOAB@Comment?5node?5has?5wrong?5name?5?8?$CFs@
CONST	SEGMENT
??_C@_0CB@NIALDOAB@Comment?5node?5has?5wrong?5name?5?8?$CFs@ DB 'Comment '
	DB	'node has wrong name ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PNOOIGPO@Text?5node?5has?5wrong?5name?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BO@PNOOIGPO@Text?5node?5has?5wrong?5name?5?8?$CFs?8@ DB 'Text node'
	DB	' has wrong name ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DALNPEGO@nbktext@
CONST	SEGMENT
??_C@_07DALNPEGO@nbktext@ DB 'nbktext', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PBIAHHPM@Node?5next?9?$DOprev?5?3?5forward?5link?5@
CONST	SEGMENT
??_C@_0CG@PBIAHHPM@Node?5next?9?$DOprev?5?3?5forward?5link?5@ DB 'Node ne'
	DB	'xt->prev : forward link wrong', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@INOGIHKC@Node?5has?5no?5next?5and?5not?5last?5o@
CONST	SEGMENT
??_C@_0CO@INOGIHKC@Node?5has?5no?5next?5and?5not?5last?5o@ DB 'Node has n'
	DB	'o next and not last of parent list', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LGMLKLGH@Node?5prev?9?$DOnext?5?3?5back?5link?5wro@
CONST	SEGMENT
??_C@_0CD@LGMLKLGH@Node?5prev?9?$DOnext?5?3?5back?5link?5wro@ DB 'Node pr'
	DB	'ev->next : back link wrong', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FIFBDLN@Node?5has?5no?5prev?5and?5not?5first?5@
CONST	SEGMENT
??_C@_0CP@FIFBDLN@Node?5has?5no?5prev?5and?5not?5first?5@ DB 'Node has no'
	DB	' prev and not first of parent list', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CJJLPFI@Attr?5has?5no?5prev?5and?5not?5first?5@
CONST	SEGMENT
??_C@_0CN@CJJLPFI@Attr?5has?5no?5prev?5and?5not?5first?5@ DB 'Attr has no'
	DB	' prev and not first of attr list', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LOLNJJIM@Node?5doc?5differs?5from?5parent?8s?5@
CONST	SEGMENT
??_C@_0CE@LOLNJJIM@Node?5doc?5differs?5from?5parent?8s?5@ DB 'Node doc di'
	DB	'ffers from parent''s one', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OLLEMIAI@pseudoroot@
CONST	SEGMENT
??_C@_0L@OLLEMIAI@pseudoroot@ DB 'pseudoroot', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOKKDMAC@Node?5has?5no?5doc?6@
CONST	SEGMENT
??_C@_0BB@MOKKDMAC@Node?5has?5no?5doc?6@ DB 'Node has no doc', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EPLMDKLB@Node?5has?5no?5parent?6@
CONST	SEGMENT
??_C@_0BE@EPLMDKLB@Node?5has?5no?5parent?6@ DB 'Node has no parent', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@NDFCBACJ@Name?5is?5not?5from?5the?5document?5d@
CONST	SEGMENT
??_C@_0CO@NDFCBACJ@Name?5is?5not?5from?5the?5document?5d@ DB 'Name is not'
	DB	' from the document dictionary ''%s''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DKJDBHCK@Name?5is?5not?5an?5NCName?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BL@DKJDBHCK@Name?5is?5not?5an?5NCName?5?8?$CFs?8@ DB 'Name is not '
	DB	'an NCName ''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BLMILKM@Name?5is?5NULL@
CONST	SEGMENT
??_C@_0N@BLMILKM@Name?5is?5NULL@ DB 'Name is NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GLDOBOAB@String?5is?5not?5UTF?98?5?$CFs@
CONST	SEGMENT
??_C@_0BH@GLDOBOAB@String?5is?5not?5UTF?98?5?$CFs@ DB 'String is not UTF-'
	DB	'8 %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DPKAIPNO@Reference?5to?5namespace?5?8?$CFs?8?5not@
CONST	SEGMENT
??_C@_0CN@DPKAIPNO@Reference?5to?5namespace?5?8?$CFs?8?5not@ DB 'Referenc'
	DB	'e to namespace ''%s'' not on ancestor', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PAHGLCCL@Reference?5to?5default?5namespace?5@
CONST	SEGMENT
??_C@_0DA@PAHGLCCL@Reference?5to?5default?5namespace?5@ DB 'Reference to '
	DB	'default namespace not on ancestor', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KJADECB@Reference?5to?5namespace?5?8?$CFs?8?5not@
CONST	SEGMENT
??_C@_0CK@KJADECB@Reference?5to?5namespace?5?8?$CFs?8?5not@ DB 'Reference'
	DB	' to namespace ''%s'' not in scope', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CCCBCKMJ@Reference?5to?5default?5namespace?5@
CONST	SEGMENT
??_C@_0CN@CCCBCKMJ@Reference?5to?5default?5namespace?5@ DB 'Reference to '
	DB	'default namespace not in scope', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellRNGValidate
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_vctxt$ = -12						; size = 4
_ctxt$ = -8						; size = 4
_relaxngschemas$ = -4					; size = 4
_sctxt$ = 8						; size = 4
_schemas$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellRNGValidate PROC				; COMDAT

; 2359 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2360 :     xmlRelaxNGPtr relaxngschemas;
; 2361 :     xmlRelaxNGParserCtxtPtr ctxt;
; 2362 :     xmlRelaxNGValidCtxtPtr vctxt;
; 2363 :     int ret;
; 2364 : 
; 2365 :     ctxt = xmlRelaxNGNewParserCtxt(schemas);

	mov	eax, DWORD PTR _schemas$[ebp]
	push	eax
	call	_xmlRelaxNGNewParserCtxt
	add	esp, 4
	mov	DWORD PTR _ctxt$[ebp], eax

; 2366 :     xmlRelaxNGSetParserErrors(ctxt,

	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET _fprintf
	push	OFFSET _fprintf
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlRelaxNGSetParserErrors
	add	esp, 16					; 00000010H

; 2367 : 	    (xmlRelaxNGValidityErrorFunc) fprintf,
; 2368 : 	    (xmlRelaxNGValidityWarningFunc) fprintf,
; 2369 : 	    stderr);
; 2370 :     relaxngschemas = xmlRelaxNGParse(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlRelaxNGParse
	add	esp, 4
	mov	DWORD PTR _relaxngschemas$[ebp], eax

; 2371 :     xmlRelaxNGFreeParserCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlRelaxNGFreeParserCtxt
	add	esp, 4

; 2372 :     if (relaxngschemas == NULL) {

	cmp	DWORD PTR _relaxngschemas$[ebp], 0
	jne	SHORT $LN2@xmlShellRN

; 2373 : 	xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _schemas$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CG@ILOKJIOB@Relax?9NG?5schema?5?$CFs?5failed?5to?5co@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2374 : 		"Relax-NG schema %s failed to compile\n", schemas);
; 2375 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlShellRN
$LN2@xmlShellRN:

; 2376 :     }
; 2377 :     vctxt = xmlRelaxNGNewValidCtxt(relaxngschemas);

	mov	ecx, DWORD PTR _relaxngschemas$[ebp]
	push	ecx
	call	_xmlRelaxNGNewValidCtxt
	add	esp, 4
	mov	DWORD PTR _vctxt$[ebp], eax

; 2378 :     xmlRelaxNGSetValidErrors(vctxt,

	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	OFFSET _fprintf
	push	OFFSET _fprintf
	mov	edx, DWORD PTR _vctxt$[ebp]
	push	edx
	call	_xmlRelaxNGSetValidErrors
	add	esp, 16					; 00000010H

; 2379 : 	    (xmlRelaxNGValidityErrorFunc) fprintf,
; 2380 : 	    (xmlRelaxNGValidityWarningFunc) fprintf,
; 2381 : 	    stderr);
; 2382 :     ret = xmlRelaxNGValidateDoc(vctxt, sctxt->doc);

	mov	eax, DWORD PTR _sctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _vctxt$[ebp]
	push	edx
	call	_xmlRelaxNGValidateDoc
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2383 :     if (ret == 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN3@xmlShellRN

; 2384 : 	fprintf(stderr, "%s validates\n", sctxt->filename);

	mov	eax, DWORD PTR _sctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0O@DFGOKOFF@?$CFs?5validates?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@xmlShellRN
$LN3@xmlShellRN:

; 2385 :     } else if (ret > 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jle	SHORT $LN5@xmlShellRN

; 2386 : 	fprintf(stderr, "%s fails to validate\n", sctxt->filename);

	mov	edx, DWORD PTR _sctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0BG@JNPIFKED@?$CFs?5fails?5to?5validate?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 2387 :     } else {

	jmp	SHORT $LN4@xmlShellRN
$LN5@xmlShellRN:

; 2388 : 	fprintf(stderr, "%s validation generated an internal error\n",

	mov	ecx, DWORD PTR _sctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0CL@PGHBNCEH@?$CFs?5validation?5generated?5an?5inte@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN4@xmlShellRN:

; 2389 : 	       sctxt->filename);
; 2390 :     }
; 2391 :     xmlRelaxNGFreeValidCtxt(vctxt);

	mov	eax, DWORD PTR _vctxt$[ebp]
	push	eax
	call	_xmlRelaxNGFreeValidCtxt
	add	esp, 4

; 2392 :     if (relaxngschemas != NULL)

	cmp	DWORD PTR _relaxngschemas$[ebp], 0
	je	SHORT $LN7@xmlShellRN

; 2393 : 	xmlRelaxNGFree(relaxngschemas);

	mov	ecx, DWORD PTR _relaxngschemas$[ebp]
	push	ecx
	call	_xmlRelaxNGFree
	add	esp, 4
$LN7@xmlShellRN:

; 2394 :     return(0);

	xor	eax, eax
$LN1@xmlShellRN:

; 2395 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellRNGValidate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellSetContent
_TEXT	SEGMENT
tv78 = -32						; size = 4
tv141 = -25						; size = 1
tv138 = -24						; size = 4
tv135 = -20						; size = 4
_ret$ = -16						; size = 4
_results$ = -8						; size = 4
_ctxt$ = 8						; size = 4
_value$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellSetContent PROC				; COMDAT

; 2313 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2314 :     xmlNodePtr results;
; 2315 :     xmlParserErrors ret;
; 2316 : 
; 2317 :     if (!ctxt)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlShellSe

; 2318 :         return (0);

	xor	eax, eax
	jmp	$LN1@xmlShellSe
$LN2@xmlShellSe:

; 2319 :     if (node == NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN3@xmlShellSe

; 2320 : 	fprintf(ctxt->output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2321 : 	return (0);

	xor	eax, eax
	jmp	$LN1@xmlShellSe
$LN3@xmlShellSe:

; 2322 :     }
; 2323 :     if (value == NULL) {

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN4@xmlShellSe

; 2324 :         fprintf(ctxt->output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8

; 2325 : 	return (0);

	xor	eax, eax
	jmp	$LN1@xmlShellSe
$LN4@xmlShellSe:

; 2326 :     }
; 2327 : 
; 2328 :     ret = xmlParseInNodeContext(node, value, strlen(value), 0, &results);

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	mov	edx, DWORD PTR tv135[ebp]
	add	edx, 1
	mov	DWORD PTR tv138[ebp], edx
$LL9@xmlShellSe:
	mov	eax, DWORD PTR tv135[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv141[ebp], cl
	add	DWORD PTR tv135[ebp], 1
	cmp	BYTE PTR tv141[ebp], 0
	jne	SHORT $LL9@xmlShellSe
	mov	edx, DWORD PTR tv135[ebp]
	sub	edx, DWORD PTR tv138[ebp]
	mov	DWORD PTR tv78[ebp], edx
	lea	eax, DWORD PTR _results$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR tv78[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	_xmlParseInNodeContext
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$[ebp], eax

; 2329 :     if (ret == XML_ERR_OK) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN5@xmlShellSe

; 2330 : 	if (node->children != NULL) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN7@xmlShellSe

; 2331 : 	    xmlFreeNodeList(node->children);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlFreeNodeList
	add	esp, 4

; 2332 : 	    node->children = NULL;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 2333 : 	    node->last = NULL;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+16], 0
$LN7@xmlShellSe:

; 2334 : 	}
; 2335 : 	xmlAddChildList(node, results);

	mov	eax, DWORD PTR _results$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlAddChildList
	add	esp, 8

; 2336 :     } else {

	jmp	SHORT $LN6@xmlShellSe
$LN5@xmlShellSe:

; 2337 :         fprintf(ctxt->output, "failed to parse content\n");

	push	OFFSET ??_C@_0BJ@CJOBHPHB@failed?5to?5parse?5content?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8
$LN6@xmlShellSe:

; 2338 :     }
; 2339 :     return (0);

	xor	eax, eax
$LN1@xmlShellSe:

; 2340 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@xmlShellSe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@xmlShellSe:
	DD	1
	DD	$LN11@xmlShellSe
$LN11@xmlShellSe:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN10@xmlShellSe
$LN10@xmlShellSe:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
_xmlShellSetContent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellGrep
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellGrep PROC					; COMDAT

; 2200 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2201 :     if (!ctxt)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN6@xmlShellGr

; 2202 :         return (0);

	xor	eax, eax
	jmp	$LN1@xmlShellGr
$LN6@xmlShellGr:

; 2203 :     if (node == NULL)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN7@xmlShellGr

; 2204 : 	return (0);

	xor	eax, eax
	jmp	$LN1@xmlShellGr
$LN7@xmlShellGr:

; 2205 :     if (arg == NULL)

	cmp	DWORD PTR _arg$[ebp], 0
	jne	SHORT $LN8@xmlShellGr

; 2206 : 	return (0);

	xor	eax, eax
	jmp	$LN1@xmlShellGr
$LN8@xmlShellGr:

; 2207 : #ifdef LIBXML_REGEXP_ENABLED
; 2208 :     if ((xmlStrchr((xmlChar *) arg, '?')) ||
; 2209 : 	(xmlStrchr((xmlChar *) arg, '*')) ||
; 2210 : 	(xmlStrchr((xmlChar *) arg, '.')) ||

	push	63					; 0000003fH
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@xmlShellGr
	push	42					; 0000002aH
	mov	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@xmlShellGr
	push	46					; 0000002eH
	mov	edx, DWORD PTR _arg$[ebp]
	push	edx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@xmlShellGr
	push	91					; 0000005bH
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_xmlStrchr
	add	esp, 8
$LN2@xmlShellGr:

; 2211 : 	(xmlStrchr((xmlChar *) arg, '['))) {
; 2212 :     }
; 2213 : #endif
; 2214 :     while (node != NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	je	$LN3@xmlShellGr

; 2215 :         if (node->type == XML_COMMENT_NODE) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 8
	jne	SHORT $LN11@xmlShellGr

; 2216 : 	    if (xmlStrstr(node->content, (xmlChar *) arg)) {

	mov	edx, DWORD PTR _arg$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_xmlStrstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlShellGr

; 2217 : 
; 2218 : 		fprintf(ctxt->output, "%s : ", xmlGetNodePath(node));

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	call	_xmlGetNodePath
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_05LLGELLBM@?$CFs?5?3?5@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 2219 :                 xmlShellList(ctxt, NULL, node, NULL);

	push	0
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlShellList
	add	esp, 16					; 00000010H
$LN13@xmlShellGr:

; 2220 : 	    }

	jmp	SHORT $LN12@xmlShellGr
$LN11@xmlShellGr:

; 2221 :         } else if (node->type == XML_TEXT_NODE) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 3
	jne	SHORT $LN12@xmlShellGr

; 2222 : 	    if (xmlStrstr(node->content, (xmlChar *) arg)) {

	mov	edx, DWORD PTR _arg$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_xmlStrstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@xmlShellGr

; 2223 : 
; 2224 : 		fprintf(ctxt->output, "%s : ", xmlGetNodePath(node->parent));

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlGetNodePath
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_05LLGELLBM@?$CFs?5?3?5@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 2225 :                 xmlShellList(ctxt, NULL, node->parent, NULL);

	push	0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlShellList
	add	esp, 16					; 00000010H
$LN12@xmlShellGr:

; 2226 : 	    }
; 2227 :         }
; 2228 : 
; 2229 :         /*
; 2230 :          * Browse the full subtree, deep first
; 2231 :          */
; 2232 : 
; 2233 :         if ((node->type == XML_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 9
	je	SHORT $LN18@xmlShellGr
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	jne	SHORT $LN16@xmlShellGr
$LN18@xmlShellGr:

; 2234 :             (node->type == XML_HTML_DOCUMENT_NODE)) {
; 2235 :             node = ((xmlDocPtr) node)->children;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _node$[ebp], eax

; 2236 :         } else if ((node->children != NULL)

	jmp	SHORT $LN17@xmlShellGr
$LN16@xmlShellGr:

; 2237 :                    && (node->type != XML_ENTITY_REF_NODE)) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN19@xmlShellGr
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 5
	je	SHORT $LN19@xmlShellGr

; 2238 :             /* deep first */
; 2239 :             node = node->children;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _node$[ebp], ecx
	jmp	SHORT $LN17@xmlShellGr
$LN19@xmlShellGr:

; 2240 :         } else if (node->next != NULL) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN4@xmlShellGr

; 2241 :             /* then siblings */
; 2242 :             node = node->next;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _node$[ebp], ecx

; 2243 :         } else {

	jmp	SHORT $LN17@xmlShellGr
$LN4@xmlShellGr:

; 2244 :             /* go up to parents->next if needed */
; 2245 :             while (node != NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN17@xmlShellGr

; 2246 :                 if (node->parent != NULL) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN23@xmlShellGr

; 2247 :                     node = node->parent;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _node$[ebp], ecx
$LN23@xmlShellGr:

; 2248 :                 }
; 2249 :                 if (node->next != NULL) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN24@xmlShellGr

; 2250 :                     node = node->next;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _node$[ebp], ecx

; 2251 :                     break;

	jmp	SHORT $LN17@xmlShellGr
$LN24@xmlShellGr:

; 2252 :                 }
; 2253 :                 if (node->parent == NULL) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN25@xmlShellGr

; 2254 :                     node = NULL;

	mov	DWORD PTR _node$[ebp], 0

; 2255 :                     break;

	jmp	SHORT $LN17@xmlShellGr
$LN25@xmlShellGr:

; 2256 :                 }
; 2257 :             }

	jmp	SHORT $LN4@xmlShellGr
$LN17@xmlShellGr:

; 2258 : 	}
; 2259 :     }

	jmp	$LN2@xmlShellGr
$LN3@xmlShellGr:

; 2260 :     return (0);

	xor	eax, eax
$LN1@xmlShellGr:

; 2261 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlShellGrep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellRegisterRootNamespaces
_TEXT	SEGMENT
_ns$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_root$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellRegisterRootNamespaces PROC			; COMDAT

; 2167 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2168 :     xmlNsPtr ns;
; 2169 : 
; 2170 :     if ((root == NULL) || (root->type != XML_ELEMENT_NODE) ||
; 2171 :         (root->nsDef == NULL) || (ctxt == NULL) || (ctxt->pctxt == NULL))

	cmp	DWORD PTR _root$[ebp], 0
	je	SHORT $LN5@xmlShellRe
	mov	eax, DWORD PTR _root$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN5@xmlShellRe
	mov	ecx, DWORD PTR _root$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN5@xmlShellRe
	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN5@xmlShellRe
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN4@xmlShellRe
$LN5@xmlShellRe:

; 2172 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlShellRe
$LN4@xmlShellRe:

; 2173 :     ns = root->nsDef;

	mov	eax, DWORD PTR _root$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _ns$[ebp], ecx
$LN2@xmlShellRe:

; 2174 :     while (ns != NULL) {

	cmp	DWORD PTR _ns$[ebp], 0
	je	SHORT $LN3@xmlShellRe

; 2175 :         if (ns->prefix == NULL)

	mov	edx, DWORD PTR _ns$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN6@xmlShellRe

; 2176 : 	    xmlXPathRegisterNs(ctxt->pctxt, BAD_CAST "defaultns", ns->href);

	mov	eax, DWORD PTR _ns$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_09EMODOEOP@defaultns@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@xmlShellRe
$LN6@xmlShellRe:

; 2177 : 	else
; 2178 : 	    xmlXPathRegisterNs(ctxt->pctxt, ns->prefix, ns->href);

	mov	ecx, DWORD PTR _ns$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _ns$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH
$LN7@xmlShellRe:

; 2179 :         ns = ns->next;

	mov	ecx, DWORD PTR _ns$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ns$[ebp], edx

; 2180 :     }

	jmp	SHORT $LN2@xmlShellRe
$LN3@xmlShellRe:

; 2181 :     return(0);

	xor	eax, eax
$LN1@xmlShellRe:

; 2182 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellRegisterRootNamespaces ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellRegisterNamespace
_TEXT	SEGMENT
_next$ = -16						; size = 4
_href$ = -12						; size = 4
_prefix$ = -8						; size = 4
_nsListDup$ = -4					; size = 4
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellRegisterNamespace PROC				; COMDAT

; 2111 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2112 :     xmlChar* nsListDup;
; 2113 :     xmlChar* prefix;
; 2114 :     xmlChar* href;
; 2115 :     xmlChar* next;
; 2116 : 
; 2117 :     nsListDup = xmlStrdup((xmlChar *) arg);

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _nsListDup$[ebp], eax

; 2118 :     next = nsListDup;

	mov	ecx, DWORD PTR _nsListDup$[ebp]
	mov	DWORD PTR _next$[ebp], ecx
$LN2@xmlShellRe:

; 2119 :     while(next != NULL) {

	cmp	DWORD PTR _next$[ebp], 0
	je	$LN3@xmlShellRe

; 2120 : 	/* skip spaces */
; 2121 : 	/*while((*next) == ' ') next++;*/
; 2122 : 	if((*next) == '\0') break;

	mov	edx, DWORD PTR _next$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN4@xmlShellRe
	jmp	$LN3@xmlShellRe
$LN4@xmlShellRe:

; 2123 : 
; 2124 : 	/* find prefix */
; 2125 : 	prefix = next;

	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _prefix$[ebp], ecx

; 2126 : 	next = (xmlChar*)xmlStrchr(next, '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _next$[ebp]
	push	edx
	call	_xmlStrchr
	add	esp, 8
	mov	DWORD PTR _next$[ebp], eax

; 2127 : 	if(next == NULL) {

	cmp	DWORD PTR _next$[ebp], 0
	jne	SHORT $LN5@xmlShellRe

; 2128 : 	    fprintf(ctxt->output, "setns: prefix=[nsuri] required\n");

	push	OFFSET ??_C@_0CA@IOLKGPPF@setns?3?5prefix?$DN?$FLnsuri?$FN?5required?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2129 : 	    xmlFree(nsListDup);

	mov	esi, esp
	mov	edx, DWORD PTR _nsListDup$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2130 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlShellRe
$LN5@xmlShellRe:

; 2131 : 	}
; 2132 : 	*(next++) = '\0';

	mov	eax, DWORD PTR _next$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _next$[ebp]
	add	ecx, 1
	mov	DWORD PTR _next$[ebp], ecx

; 2133 : 
; 2134 : 	/* find href */
; 2135 : 	href = next;

	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _href$[ebp], edx

; 2136 : 	next = (xmlChar*)xmlStrchr(next, ' ');

	push	32					; 00000020H
	mov	eax, DWORD PTR _next$[ebp]
	push	eax
	call	_xmlStrchr
	add	esp, 8
	mov	DWORD PTR _next$[ebp], eax

; 2137 : 	if(next != NULL) {

	cmp	DWORD PTR _next$[ebp], 0
	je	SHORT $LN6@xmlShellRe

; 2138 : 	    *(next++) = '\0';

	mov	ecx, DWORD PTR _next$[ebp]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _next$[ebp]
	add	edx, 1
	mov	DWORD PTR _next$[ebp], edx
$LN6@xmlShellRe:

; 2139 : 	}
; 2140 : 
; 2141 : 	/* do register namespace */
; 2142 : 	if(xmlXPathRegisterNs(ctxt->pctxt, prefix, href) != 0) {

	mov	eax, DWORD PTR _href$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@xmlShellRe

; 2143 : 	    fprintf(ctxt->output,"Error: unable to register NS with prefix=\"%s\" and href=\"%s\"\n", prefix, href);

	mov	ecx, DWORD PTR _href$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	push	OFFSET ??_C@_0DN@JOGKKGFC@Error?3?5unable?5to?5register?5NS?5wi@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 16					; 00000010H

; 2144 : 	    xmlFree(nsListDup);

	mov	esi, esp
	mov	edx, DWORD PTR _nsListDup$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2145 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlShellRe
$LN7@xmlShellRe:

; 2146 : 	}
; 2147 :     }

	jmp	$LN2@xmlShellRe
$LN3@xmlShellRe:

; 2148 : 
; 2149 :     xmlFree(nsListDup);

	mov	esi, esp
	mov	eax, DWORD PTR _nsListDup$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2150 :     return(0);

	xor	eax, eax
$LN1@xmlShellRe:

; 2151 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellRegisterNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellSetBase
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellSetBase PROC					; COMDAT

; 2088 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2089 :     xmlNodeSetBase(node, (xmlChar*) arg);

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlNodeSetBase
	add	esp, 8

; 2090 :     return (0);

	xor	eax, eax

; 2091 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlShellSetBase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPrintXPathResultCtxt
_TEXT	SEGMENT
tv67 = -8						; size = 4
_indx$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_list$ = 12						; size = 4
_xmlShellPrintXPathResultCtxt PROC			; COMDAT

; 1934 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1935 :     if (!ctxt)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN7@xmlShellPr

; 1936 :        return;

	jmp	$LN2@xmlShellPr
$LN7@xmlShellPr:

; 1937 : 
; 1938 :     if (list != NULL) {

	cmp	DWORD PTR _list$[ebp], 0
	je	$LN2@xmlShellPr

; 1939 :         switch (list->type) {

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv67[ebp], ecx
	mov	edx, DWORD PTR tv67[ebp]
	sub	edx, 1
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 3
	ja	$LN15@xmlShellPr
	mov	eax, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN17@xmlShellPr[eax*4]
$LN9@xmlShellPr:

; 1940 :             case XPATH_NODESET:{
; 1941 : #ifdef LIBXML_OUTPUT_ENABLED
; 1942 :                     int indx;
; 1943 : 
; 1944 :                     if (list->nodesetval) {

	mov	ecx, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN10@xmlShellPr

; 1945 :                         for (indx = 0; indx < list->nodesetval->nodeNr;

	mov	DWORD PTR _indx$1[ebp], 0
	jmp	SHORT $LN6@xmlShellPr
$LN4@xmlShellPr:

; 1946 :                              indx++) {

	mov	edx, DWORD PTR _indx$1[ebp]
	add	edx, 1
	mov	DWORD PTR _indx$1[ebp], edx
$LN6@xmlShellPr:

; 1945 :                         for (indx = 0; indx < list->nodesetval->nodeNr;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _indx$1[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN5@xmlShellPr

; 1947 :                             xmlShellPrintNodeCtxt(ctxt,

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _indx$1[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlShellPrintNodeCtxt
	add	esp, 8

; 1948 : 				    list->nodesetval->nodeTab[indx]);
; 1949 :                         }

	jmp	SHORT $LN4@xmlShellPr
$LN5@xmlShellPr:

; 1950 :                     } else {

	jmp	SHORT $LN11@xmlShellPr
$LN10@xmlShellPr:

; 1951 :                         xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0BA@ILOEDOOH@Empty?5node?5set?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlShellPr:

; 1952 :                                         "Empty node set\n");
; 1953 :                     }
; 1954 :                     break;

	jmp	$LN2@xmlShellPr
$LN12@xmlShellPr:

; 1955 : #else
; 1956 : 		    xmlGenericError(xmlGenericErrorContext,
; 1957 : 				    "Node set\n");
; 1958 : #endif /* LIBXML_OUTPUT_ENABLED */
; 1959 :                 }
; 1960 :             case XPATH_BOOLEAN:
; 1961 :                 xmlGenericError(xmlGenericErrorContext,

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlBoolToText
	add	esp, 4
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0BB@EPJNDGE@Is?5a?5Boolean?3?$CFs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1962 :                                 "Is a Boolean:%s\n",
; 1963 :                                 xmlBoolToText(list->boolval));
; 1964 :                 break;

	jmp	SHORT $LN2@xmlShellPr
$LN13@xmlShellPr:

; 1965 :             case XPATH_NUMBER:
; 1966 :                 xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _list$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+16]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BB@MGNNLCBN@Is?5a?5number?3?$CF0g?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1967 :                                 "Is a number:%0g\n", list->floatval);
; 1968 :                 break;

	jmp	SHORT $LN2@xmlShellPr
$LN14@xmlShellPr:

; 1969 :             case XPATH_STRING:
; 1970 :                 xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET ??_C@_0BA@GGJONEIB@Is?5a?5string?3?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1971 :                                 "Is a string:%s\n", list->stringval);
; 1972 :                 break;

	jmp	SHORT $LN2@xmlShellPr
$LN15@xmlShellPr:

; 1973 : 
; 1974 :             default:
; 1975 :                 xmlShellPrintXPathError(list->type, NULL);

	push	0
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlShellPrintXPathError
	add	esp, 8
$LN2@xmlShellPr:

; 1976 :         }
; 1977 :     }
; 1978 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN17@xmlShellPr:
	DD	$LN9@xmlShellPr
	DD	$LN12@xmlShellPr
	DD	$LN13@xmlShellPr
	DD	$LN14@xmlShellPr
_xmlShellPrintXPathResultCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPrintNodeCtxt
_TEXT	SEGMENT
_fp$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlShellPrintNodeCtxt PROC				; COMDAT

; 1892 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1893 :     FILE *fp;
; 1894 : 
; 1895 :     if (!node)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN2@xmlShellPr

; 1896 :         return;

	jmp	$LN1@xmlShellPr
$LN2@xmlShellPr:

; 1897 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN3@xmlShellPr

; 1898 : 	fp = stdout;

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fp$[ebp], eax
	jmp	SHORT $LN4@xmlShellPr
$LN3@xmlShellPr:

; 1899 :     else
; 1900 : 	fp = ctxt->output;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _fp$[ebp], ecx
$LN4@xmlShellPr:

; 1901 : 
; 1902 :     if (node->type == XML_DOCUMENT_NODE)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 9
	jne	SHORT $LN5@xmlShellPr

; 1903 :         xmlDocDump(fp, (xmlDocPtr) node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_xmlDocDump
	add	esp, 8
	jmp	SHORT $LN6@xmlShellPr
$LN5@xmlShellPr:

; 1904 :     else if (node->type == XML_ATTRIBUTE_NODE)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 2
	jne	SHORT $LN7@xmlShellPr

; 1905 :         xmlDebugDumpAttrList(fp, (xmlAttrPtr) node, 0);

	push	0
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_xmlDebugDumpAttrList
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@xmlShellPr
$LN7@xmlShellPr:

; 1906 :     else
; 1907 :         xmlElemDump(fp, node->doc, node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_xmlElemDump
	add	esp, 12					; 0000000cH
$LN6@xmlShellPr:

; 1908 : 
; 1909 :     fprintf(fp, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
$LN1@xmlShellPr:

; 1910 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellPrintNodeCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpDTD
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_dtd$ = 12						; size = 4
_xmlCtxtDumpDTD PROC					; COMDAT

; 1318 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1319 :     if (dtd == NULL) {

	cmp	DWORD PTR _dtd$[ebp], 0
	jne	SHORT $LN2@xmlCtxtDum

; 1320 :         if (!ctxt->check)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN3@xmlCtxtDum

; 1321 :             fprintf(ctxt->output, "DTD is NULL\n");

	push	OFFSET ??_C@_0N@BBKAICJC@DTD?5is?5NULL?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN3@xmlCtxtDum:

; 1322 :         return;

	jmp	SHORT $LN1@xmlCtxtDum
$LN2@xmlCtxtDum:

; 1323 :     }
; 1324 :     xmlCtxtDumpDtdNode(ctxt, dtd);

	mov	eax, DWORD PTR _dtd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpDtdNode
	add	esp, 8

; 1325 :     if (dtd->children == NULL)

	mov	edx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN4@xmlCtxtDum

; 1326 :         fprintf(ctxt->output, "    DTD is empty\n");

	push	OFFSET ??_C@_0BC@JMCKHIKF@?5?5?5?5DTD?5is?5empty?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN1@xmlCtxtDum
$LN4@xmlCtxtDum:

; 1327 :     else {
; 1328 :         ctxt->depth++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+108]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+108], eax

; 1329 :         xmlCtxtDumpNodeList(ctxt, dtd->children);

	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpNodeList
	add	esp, 8

; 1330 :         ctxt->depth--;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+108]
	sub	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+108], eax
$LN1@xmlCtxtDum:

; 1331 :     }
; 1332 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpDTD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpEntities
_TEXT	SEGMENT
_table$1 = -8						; size = 4
_table$2 = -4						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlCtxtDumpEntities PROC				; COMDAT

; 1286 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1287 :     if (doc == NULL) return;

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN2@xmlCtxtDum
	jmp	$LN1@xmlCtxtDum
$LN2@xmlCtxtDum:

; 1288 :     xmlCtxtDumpDocHead(ctxt, doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpDocHead
	add	esp, 8

; 1289 :     if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN3@xmlCtxtDum
	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN3@xmlCtxtDum

; 1290 :         xmlEntitiesTablePtr table = (xmlEntitiesTablePtr)

	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _table$2[ebp], ecx

; 1291 :             doc->intSubset->entities;
; 1292 : 
; 1293 :         if (!ctxt->check)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN5@xmlCtxtDum

; 1294 :             fprintf(ctxt->output, "Entities in internal subset\n");

	push	OFFSET ??_C@_0BN@DMKNOAIC@Entities?5in?5internal?5subset?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN5@xmlCtxtDum:

; 1295 :         xmlHashScan(table, xmlCtxtDumpEntityCallback, ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	push	OFFSET _xmlCtxtDumpEntityCallback
	mov	eax, DWORD PTR _table$2[ebp]
	push	eax
	call	_xmlHashScan
	add	esp, 12					; 0000000cH

; 1296 :     } else

	jmp	SHORT $LN4@xmlCtxtDum
$LN3@xmlCtxtDum:

; 1297 :         fprintf(ctxt->output, "No entities in internal subset\n");

	push	OFFSET ??_C@_0CA@JBOJHEJF@No?5entities?5in?5internal?5subset?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN4@xmlCtxtDum:

; 1298 :     if ((doc->extSubset != NULL) && (doc->extSubset->entities != NULL)) {

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN6@xmlCtxtDum
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN6@xmlCtxtDum

; 1299 :         xmlEntitiesTablePtr table = (xmlEntitiesTablePtr)

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _table$1[ebp], edx

; 1300 :             doc->extSubset->entities;
; 1301 : 
; 1302 :         if (!ctxt->check)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN8@xmlCtxtDum

; 1303 :             fprintf(ctxt->output, "Entities in external subset\n");

	push	OFFSET ??_C@_0BN@BMADNPKJ@Entities?5in?5external?5subset?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN8@xmlCtxtDum:

; 1304 :         xmlHashScan(table, xmlCtxtDumpEntityCallback, ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	push	OFFSET _xmlCtxtDumpEntityCallback
	mov	ecx, DWORD PTR _table$1[ebp]
	push	ecx
	call	_xmlHashScan
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@xmlCtxtDum
$LN6@xmlCtxtDum:

; 1305 :     } else if (!ctxt->check)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN1@xmlCtxtDum

; 1306 :         fprintf(ctxt->output, "No entities in external subset\n");

	push	OFFSET ??_C@_0CA@LBEHELLO@No?5entities?5in?5external?5subset?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN1@xmlCtxtDum:

; 1307 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtDumpEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpEntityCallback
_TEXT	SEGMENT
tv78 = -12						; size = 4
_ctxt$ = -8						; size = 4
_cur$ = -4						; size = 4
_payload$ = 8						; size = 4
_data$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlCtxtDumpEntityCallback PROC				; COMDAT

; 1234 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1235 :     xmlEntityPtr cur = (xmlEntityPtr) payload;

	mov	eax, DWORD PTR _payload$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 1236 :     xmlDebugCtxtPtr ctxt = (xmlDebugCtxtPtr) data;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR _ctxt$[ebp], ecx

; 1237 :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN4@xmlCtxtDum

; 1238 :         if (!ctxt->check)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN5@xmlCtxtDum

; 1239 :             fprintf(ctxt->output, "Entity is NULL");

	push	OFFSET ??_C@_0P@LECCLHEJ@Entity?5is?5NULL@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN5@xmlCtxtDum:

; 1240 :         return;

	jmp	$LN1@xmlCtxtDum
$LN4@xmlCtxtDum:

; 1241 :     }
; 1242 :     if (!ctxt->check) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	$LN1@xmlCtxtDum

; 1243 :         fprintf(ctxt->output, "%s : ", (char *) cur->name);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_05LLGELLBM@?$CFs?5?3?5@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1244 :         switch (cur->etype) {

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR tv78[ebp], edx
	mov	eax, DWORD PTR tv78[ebp]
	sub	eax, 1
	mov	DWORD PTR tv78[ebp], eax
	cmp	DWORD PTR tv78[ebp], 4
	ja	SHORT $LN12@xmlCtxtDum
	mov	ecx, DWORD PTR tv78[ebp]
	jmp	DWORD PTR $LN18@xmlCtxtDum[ecx*4]
$LN7@xmlCtxtDum:

; 1245 :             case XML_INTERNAL_GENERAL_ENTITY:
; 1246 :                 fprintf(ctxt->output, "INTERNAL GENERAL, ");

	push	OFFSET ??_C@_0BD@JEHEGLEK@INTERNAL?5GENERAL?0?5@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 1247 :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN8@xmlCtxtDum:

; 1248 :             case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 1249 :                 fprintf(ctxt->output, "EXTERNAL PARSED, ");

	push	OFFSET ??_C@_0BC@LPMELAMM@EXTERNAL?5PARSED?0?5@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 1250 :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN9@xmlCtxtDum:

; 1251 :             case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 1252 :                 fprintf(ctxt->output, "EXTERNAL UNPARSED, ");

	push	OFFSET ??_C@_0BE@EAFADDI@EXTERNAL?5UNPARSED?0?5@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 1253 :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN10@xmlCtxtDum:

; 1254 :             case XML_INTERNAL_PARAMETER_ENTITY:
; 1255 :                 fprintf(ctxt->output, "INTERNAL PARAMETER, ");

	push	OFFSET ??_C@_0BF@DHEHKNNP@INTERNAL?5PARAMETER?0?5@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 1256 :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN11@xmlCtxtDum:

; 1257 :             case XML_EXTERNAL_PARAMETER_ENTITY:
; 1258 :                 fprintf(ctxt->output, "EXTERNAL PARAMETER, ");

	push	OFFSET ??_C@_0BF@GEKJJGOC@EXTERNAL?5PARAMETER?0?5@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 1259 :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN12@xmlCtxtDum:

; 1260 :             default:
; 1261 : 		xmlDebugErr2(ctxt, XML_CHECK_ENTITY_TYPE,

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	push	OFFSET ??_C@_0BI@PGEHOKHI@Unknown?5entity?5type?5?$CFd?6@
	push	5012					; 00001394H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr2
	add	esp, 16					; 00000010H
$LN2@xmlCtxtDum:

; 1262 : 			     "Unknown entity type %d\n", cur->etype);
; 1263 :         }
; 1264 :         if (cur->ExternalID != NULL)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN13@xmlCtxtDum

; 1265 :             fprintf(ctxt->output, "ID \"%s\"", (char *) cur->ExternalID);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	push	OFFSET ??_C@_07MGAPBOEN@ID?5?$CC?$CFs?$CC@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN13@xmlCtxtDum:

; 1266 :         if (cur->SystemID != NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+56], 0
	je	SHORT $LN14@xmlCtxtDum

; 1267 :             fprintf(ctxt->output, "SYSTEM \"%s\"", (char *) cur->SystemID);

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	push	OFFSET ??_C@_0M@CPEEBBLL@SYSTEM?5?$CC?$CFs?$CC@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN14@xmlCtxtDum:

; 1268 :         if (cur->orig != NULL)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN15@xmlCtxtDum

; 1269 :             fprintf(ctxt->output, "\n orig \"%s\"", (char *) cur->orig);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	push	OFFSET ??_C@_0M@ENMJJFAE@?6?5orig?5?$CC?$CFs?$CC@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN15@xmlCtxtDum:

; 1270 :         if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL))

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN16@xmlCtxtDum
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN16@xmlCtxtDum

; 1271 :             fprintf(ctxt->output, "\n content \"%s\"",

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	push	OFFSET ??_C@_0P@IHEOBAMO@?6?5content?5?$CC?$CFs?$CC@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN16@xmlCtxtDum:

; 1272 :                     (char *) cur->content);
; 1273 :         fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN1@xmlCtxtDum:

; 1274 :     }
; 1275 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN18@xmlCtxtDum:
	DD	$LN7@xmlCtxtDum
	DD	$LN8@xmlCtxtDum
	DD	$LN9@xmlCtxtDum
	DD	$LN10@xmlCtxtDum
	DD	$LN11@xmlCtxtDum
_xmlCtxtDumpEntityCallback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpDocument
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlCtxtDumpDocument PROC				; COMDAT

; 1215 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1216 :     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN2@xmlCtxtDum

; 1217 :         if (!ctxt->check)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN3@xmlCtxtDum

; 1218 :             fprintf(ctxt->output, "DOCUMENT == NULL !\n");

	push	OFFSET ??_C@_0BE@NJEBDCCE@DOCUMENT?5?$DN?$DN?5NULL?5?$CB?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN3@xmlCtxtDum:

; 1219 :         return;

	jmp	SHORT $LN1@xmlCtxtDum
$LN2@xmlCtxtDum:

; 1220 :     }
; 1221 :     xmlCtxtDumpDocumentHead(ctxt, doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpDocumentHead
	add	esp, 8

; 1222 :     if (((doc->type == XML_DOCUMENT_NODE) ||
; 1223 :          (doc->type == XML_HTML_DOCUMENT_NODE))
; 1224 :         && (doc->children != NULL)) {

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+4], 9
	je	SHORT $LN5@xmlCtxtDum
	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN1@xmlCtxtDum
$LN5@xmlCtxtDum:
	mov	ecx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN1@xmlCtxtDum

; 1225 :         ctxt->depth++;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+108]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+108], eax

; 1226 :         xmlCtxtDumpNodeList(ctxt, doc->children);

	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpNodeList
	add	esp, 8

; 1227 :         ctxt->depth--;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+108]
	sub	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+108], eax
$LN1@xmlCtxtDum:

; 1228 :     }
; 1229 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpDocument ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpDocumentHead
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlCtxtDumpDocumentHead PROC				; COMDAT

; 1175 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1176 :     if (doc == NULL) return;

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN2@xmlCtxtDum
	jmp	$LN1@xmlCtxtDum
$LN2@xmlCtxtDum:

; 1177 :     xmlCtxtDumpDocHead(ctxt, doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpDocHead
	add	esp, 8

; 1178 :     if (!ctxt->check) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	$LN3@xmlCtxtDum

; 1179 :         if (doc->name != NULL) {

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN4@xmlCtxtDum

; 1180 :             fprintf(ctxt->output, "name=");

	push	OFFSET ??_C@_05DFCJAACA@name?$DN@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 1181 :             xmlCtxtDumpString(ctxt, BAD_CAST doc->name);

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpString
	add	esp, 8

; 1182 :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN4@xmlCtxtDum:

; 1183 :         }
; 1184 :         if (doc->version != NULL) {

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+56], 0
	je	SHORT $LN5@xmlCtxtDum

; 1185 :             fprintf(ctxt->output, "version=");

	push	OFFSET ??_C@_08CLMDBNEB@version?$DN@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 1186 :             xmlCtxtDumpString(ctxt, doc->version);

	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpString
	add	esp, 8

; 1187 :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN5@xmlCtxtDum:

; 1188 :         }
; 1189 :         if (doc->encoding != NULL) {

	mov	ecx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	je	SHORT $LN6@xmlCtxtDum

; 1190 :             fprintf(ctxt->output, "encoding=");

	push	OFFSET ??_C@_09GHEONEIE@encoding?$DN@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 1191 :             xmlCtxtDumpString(ctxt, doc->encoding);

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpString
	add	esp, 8

; 1192 :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN6@xmlCtxtDum:

; 1193 :         }
; 1194 :         if (doc->URL != NULL) {

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $LN7@xmlCtxtDum

; 1195 :             fprintf(ctxt->output, "URL=");

	push	OFFSET ??_C@_04LLECLDGK@URL?$DN@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 1196 :             xmlCtxtDumpString(ctxt, doc->URL);

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpString
	add	esp, 8

; 1197 :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN7@xmlCtxtDum:

; 1198 :         }
; 1199 :         if (doc->standalone)

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN3@xmlCtxtDum

; 1200 :             fprintf(ctxt->output, "standalone=true\n");

	push	OFFSET ??_C@_0BB@IPNIJGMI@standalone?$DNtrue?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN3@xmlCtxtDum:

; 1201 :     }
; 1202 :     if (doc->oldNs != NULL)

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN1@xmlCtxtDum

; 1203 :         xmlCtxtDumpNamespaceList(ctxt, doc->oldNs);

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpNamespaceList
	add	esp, 8
$LN1@xmlCtxtDum:

; 1204 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpDocumentHead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpDocHead
_TEXT	SEGMENT
tv72 = -4						; size = 4
_ctxt$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlCtxtDumpDocHead PROC				; COMDAT

; 1099 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1100 :     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN4@xmlCtxtDum

; 1101 :         if (!ctxt->check)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN5@xmlCtxtDum

; 1102 :             fprintf(ctxt->output, "DOCUMENT == NULL !\n");

	push	OFFSET ??_C@_0BE@NJEBDCCE@DOCUMENT?5?$DN?$DN?5NULL?5?$CB?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN5@xmlCtxtDum:

; 1103 :         return;

	jmp	$LN1@xmlCtxtDum
$LN4@xmlCtxtDum:

; 1104 :     }
; 1105 :     ctxt->node = (xmlNodePtr) doc;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [eax+116], ecx

; 1106 : 
; 1107 :     switch (doc->type) {

	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR tv72[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 12			; 0000000cH
	ja	$LN21@xmlCtxtDum
	mov	edx, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN23@xmlCtxtDum[edx*4]
$LN6@xmlCtxtDum:

; 1108 :         case XML_ELEMENT_NODE:
; 1109 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_ELEMENT,

	push	OFFSET ??_C@_0BI@IHFNOEDM@Misplaced?5ELEMENT?5node?6@
	push	5000					; 00001388H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 1110 : 	                "Misplaced ELEMENT node\n");
; 1111 :             break;

	jmp	$LN1@xmlCtxtDum
$LN7@xmlCtxtDum:

; 1112 :         case XML_ATTRIBUTE_NODE:
; 1113 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_ATTRIBUTE,

	push	OFFSET ??_C@_0BK@DMGHGOPO@Misplaced?5ATTRIBUTE?5node?6@
	push	5001					; 00001389H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 1114 : 	                "Misplaced ATTRIBUTE node\n");
; 1115 :             break;

	jmp	$LN1@xmlCtxtDum
$LN8@xmlCtxtDum:

; 1116 :         case XML_TEXT_NODE:
; 1117 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_TEXT,

	push	OFFSET ??_C@_0BF@JFJFJLGA@Misplaced?5TEXT?5node?6@
	push	5002					; 0000138aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 1118 : 	                "Misplaced TEXT node\n");
; 1119 :             break;

	jmp	$LN1@xmlCtxtDum
$LN9@xmlCtxtDum:

; 1120 :         case XML_CDATA_SECTION_NODE:
; 1121 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_CDATA,

	push	OFFSET ??_C@_0BG@JKLDMKBF@Misplaced?5CDATA?5node?6@
	push	5003					; 0000138bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 1122 : 	                "Misplaced CDATA node\n");
; 1123 :             break;

	jmp	$LN1@xmlCtxtDum
$LN10@xmlCtxtDum:

; 1124 :         case XML_ENTITY_REF_NODE:
; 1125 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_ENTITYREF,

	push	OFFSET ??_C@_0BK@FAHNDMGM@Misplaced?5ENTITYREF?5node?6@
	push	5004					; 0000138cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 1126 : 	                "Misplaced ENTITYREF node\n");
; 1127 :             break;

	jmp	$LN1@xmlCtxtDum
$LN11@xmlCtxtDum:

; 1128 :         case XML_ENTITY_NODE:
; 1129 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_ENTITY,

	push	OFFSET ??_C@_0BH@NGEMGAKL@Misplaced?5ENTITY?5node?6@
	push	5005					; 0000138dH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 1130 : 	                "Misplaced ENTITY node\n");
; 1131 :             break;

	jmp	$LN1@xmlCtxtDum
$LN12@xmlCtxtDum:

; 1132 :         case XML_PI_NODE:
; 1133 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_PI,

	push	OFFSET ??_C@_0BD@LAMDNLOB@Misplaced?5PI?5node?6@
	push	5006					; 0000138eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 1134 : 	                "Misplaced PI node\n");
; 1135 :             break;

	jmp	$LN1@xmlCtxtDum
$LN13@xmlCtxtDum:

; 1136 :         case XML_COMMENT_NODE:
; 1137 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_COMMENT,

	push	OFFSET ??_C@_0BI@MEFJLFLK@Misplaced?5COMMENT?5node?6@
	push	5007					; 0000138fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 1138 : 	                "Misplaced COMMENT node\n");
; 1139 :             break;

	jmp	$LN1@xmlCtxtDum
$LN14@xmlCtxtDum:

; 1140 :         case XML_DOCUMENT_NODE:
; 1141 : 	    if (!ctxt->check)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN15@xmlCtxtDum

; 1142 : 		fprintf(ctxt->output, "DOCUMENT\n");

	push	OFFSET ??_C@_09JFLEHAPI@DOCUMENT?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN15@xmlCtxtDum:

; 1143 :             break;

	jmp	$LN1@xmlCtxtDum
$LN16@xmlCtxtDum:

; 1144 :         case XML_HTML_DOCUMENT_NODE:
; 1145 : 	    if (!ctxt->check)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN17@xmlCtxtDum

; 1146 : 		fprintf(ctxt->output, "HTML DOCUMENT\n");

	push	OFFSET ??_C@_0P@NDGMGMGG@HTML?5DOCUMENT?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN17@xmlCtxtDum:

; 1147 :             break;

	jmp	SHORT $LN1@xmlCtxtDum
$LN18@xmlCtxtDum:

; 1148 :         case XML_DOCUMENT_TYPE_NODE:
; 1149 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_DOCTYPE,

	push	OFFSET ??_C@_0BI@HEJPPPBK@Misplaced?5DOCTYPE?5node?6@
	push	5008					; 00001390H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 1150 : 	                "Misplaced DOCTYPE node\n");
; 1151 :             break;

	jmp	SHORT $LN1@xmlCtxtDum
$LN19@xmlCtxtDum:

; 1152 :         case XML_DOCUMENT_FRAG_NODE:
; 1153 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_FRAGMENT,

	push	OFFSET ??_C@_0BJ@EDIFACFE@Misplaced?5FRAGMENT?5node?6@
	push	5009					; 00001391H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 1154 : 	                "Misplaced FRAGMENT node\n");
; 1155 :             break;

	jmp	SHORT $LN1@xmlCtxtDum
$LN20@xmlCtxtDum:

; 1156 :         case XML_NOTATION_NODE:
; 1157 : 	    xmlDebugErr(ctxt, XML_CHECK_FOUND_NOTATION,

	push	OFFSET ??_C@_0BJ@CONGBBKN@Misplaced?5NOTATION?5node?6@
	push	5010					; 00001392H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 1158 : 	                "Misplaced NOTATION node\n");
; 1159 :             break;

	jmp	SHORT $LN1@xmlCtxtDum
$LN21@xmlCtxtDum:

; 1160 :         default:
; 1161 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,

	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_0BG@ILEBNOHM@Unknown?5node?5type?5?$CFd?6@
	push	5011					; 00001393H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr2
	add	esp, 16					; 00000010H
$LN1@xmlCtxtDum:

; 1162 : 	                "Unknown node type %d\n", doc->type);
; 1163 :     }
; 1164 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN23@xmlCtxtDum:
	DD	$LN6@xmlCtxtDum
	DD	$LN7@xmlCtxtDum
	DD	$LN8@xmlCtxtDum
	DD	$LN9@xmlCtxtDum
	DD	$LN10@xmlCtxtDum
	DD	$LN11@xmlCtxtDum
	DD	$LN12@xmlCtxtDum
	DD	$LN13@xmlCtxtDum
	DD	$LN14@xmlCtxtDum
	DD	$LN18@xmlCtxtDum
	DD	$LN19@xmlCtxtDum
	DD	$LN20@xmlCtxtDum
	DD	$LN16@xmlCtxtDum
_xmlCtxtDumpDocHead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlCtxtDumpNode PROC					; COMDAT

; 1063 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1064 :     if (node == NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN2@xmlCtxtDum

; 1065 :         if (!ctxt->check) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN3@xmlCtxtDum

; 1066 :             xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 1067 :             fprintf(ctxt->output, "node is NULL\n");

	push	OFFSET ??_C@_0O@IPKFPFDL@node?5is?5NULL?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN3@xmlCtxtDum:

; 1068 :         }
; 1069 :         return;

	jmp	SHORT $LN1@xmlCtxtDum
$LN2@xmlCtxtDum:

; 1070 :     }
; 1071 :     xmlCtxtDumpOneNode(ctxt, node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpOneNode
	add	esp, 8

; 1072 :     if ((node->type != XML_NAMESPACE_DECL) &&
; 1073 :         (node->children != NULL) && (node->type != XML_ENTITY_REF_NODE)) {

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN1@xmlCtxtDum
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN1@xmlCtxtDum
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 5
	je	SHORT $LN1@xmlCtxtDum

; 1074 :         ctxt->depth++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+108], ecx

; 1075 :         xmlCtxtDumpNodeList(ctxt, node->children);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpNodeList
	add	esp, 8

; 1076 :         ctxt->depth--;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	sub	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+108], ecx
$LN1@xmlCtxtDum:

; 1077 :     }
; 1078 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpOneNode
_TEXT	SEGMENT
tv73 = -8						; size = 4
_ent$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlCtxtDumpOneNode PROC				; COMDAT

; 880  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 881  :     if (node == NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN4@xmlCtxtDum

; 882  :         if (!ctxt->check) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN5@xmlCtxtDum

; 883  :             xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 884  :             fprintf(ctxt->output, "node is NULL\n");

	push	OFFSET ??_C@_0O@IPKFPFDL@node?5is?5NULL?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN5@xmlCtxtDum:

; 885  :         }
; 886  :         return;

	jmp	$LN1@xmlCtxtDum
$LN4@xmlCtxtDum:

; 887  :     }
; 888  :     ctxt->node = node;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+116], edx

; 889  : 
; 890  :     switch (node->type) {

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	sub	edx, 1
	mov	DWORD PTR tv73[ebp], edx
	cmp	DWORD PTR tv73[ebp], 19			; 00000013H
	ja	$LN48@xmlCtxtDum
	mov	eax, DWORD PTR tv73[ebp]
	jmp	DWORD PTR $LN60@xmlCtxtDum[eax*4]
$LN6@xmlCtxtDum:

; 891  :         case XML_ELEMENT_NODE:
; 892  :             if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	$LN7@xmlCtxtDum

; 893  :                 xmlCtxtDumpSpaces(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 894  :                 fprintf(ctxt->output, "ELEMENT ");

	push	OFFSET ??_C@_08EDNNGDCO@ELEMENT?5@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 895  :                 if ((node->ns != NULL) && (node->ns->prefix != NULL)) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN8@xmlCtxtDum
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN8@xmlCtxtDum

; 896  :                     xmlCtxtDumpString(ctxt, node->ns->prefix);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpString
	add	esp, 8

; 897  :                     fprintf(ctxt->output, ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN8@xmlCtxtDum:

; 898  :                 }
; 899  :                 xmlCtxtDumpString(ctxt, node->name);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpString
	add	esp, 8

; 900  :                 fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN7@xmlCtxtDum:

; 901  :             }
; 902  :             break;

	jmp	$LN2@xmlCtxtDum
$LN9@xmlCtxtDum:

; 903  :         case XML_ATTRIBUTE_NODE:
; 904  :             if (!ctxt->check)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN10@xmlCtxtDum

; 905  :                 xmlCtxtDumpSpaces(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpSpaces
	add	esp, 4
$LN10@xmlCtxtDum:

; 906  :             fprintf(ctxt->output, "Error, ATTRIBUTE found here\n");

	push	OFFSET ??_C@_0BN@DLOCDHBF@Error?0?5ATTRIBUTE?5found?5here?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 907  :             xmlCtxtGenericNodeCheck(ctxt, node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtGenericNodeCheck
	add	esp, 8

; 908  :             return;

	jmp	$LN1@xmlCtxtDum
$LN11@xmlCtxtDum:

; 909  :         case XML_TEXT_NODE:
; 910  :             if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	$LN12@xmlCtxtDum

; 911  :                 xmlCtxtDumpSpaces(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 912  :                 if (node->name == (const xmlChar *) xmlStringTextNoenc)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+8], OFFSET _xmlStringTextNoenc
	jne	SHORT $LN13@xmlCtxtDum

; 913  :                     fprintf(ctxt->output, "TEXT no enc");

	push	OFFSET ??_C@_0M@IDMICFJC@TEXT?5no?5enc@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN14@xmlCtxtDum
$LN13@xmlCtxtDum:

; 914  :                 else
; 915  :                     fprintf(ctxt->output, "TEXT");

	push	OFFSET ??_C@_04OEPMCOLO@TEXT@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN14@xmlCtxtDum:

; 916  : 		if (ctxt->options & DUMP_TEXT_TYPE) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+136]
	and	eax, 1
	je	SHORT $LN15@xmlCtxtDum

; 917  : 		    if (node->content == (xmlChar *) &(node->properties))

	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+40], ecx
	jne	SHORT $LN17@xmlCtxtDum

; 918  : 			fprintf(ctxt->output, " compact\n");

	push	OFFSET ??_C@_09PKJIJFNN@?5compact?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN18@xmlCtxtDum
$LN17@xmlCtxtDum:

; 919  : 		    else if (xmlDictOwns(ctxt->dict, node->content) == 1)

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	push	edx
	call	_xmlDictOwns
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN19@xmlCtxtDum

; 920  : 			fprintf(ctxt->output, " interned\n");

	push	OFFSET ??_C@_0L@IDACKBMB@?5interned?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN18@xmlCtxtDum
$LN19@xmlCtxtDum:

; 921  : 		    else
; 922  : 			fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN18@xmlCtxtDum:

; 923  : 		} else

	jmp	SHORT $LN12@xmlCtxtDum
$LN15@xmlCtxtDum:

; 924  : 		    fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN12@xmlCtxtDum:

; 925  :             }
; 926  :             break;

	jmp	$LN2@xmlCtxtDum
$LN21@xmlCtxtDum:

; 927  :         case XML_CDATA_SECTION_NODE:
; 928  :             if (!ctxt->check) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN22@xmlCtxtDum

; 929  :                 xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 930  :                 fprintf(ctxt->output, "CDATA_SECTION\n");

	push	OFFSET ??_C@_0P@HFCBAJGN@CDATA_SECTION?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN22@xmlCtxtDum:

; 931  :             }
; 932  :             break;

	jmp	$LN2@xmlCtxtDum
$LN23@xmlCtxtDum:

; 933  :         case XML_ENTITY_REF_NODE:
; 934  :             if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN24@xmlCtxtDum

; 935  :                 xmlCtxtDumpSpaces(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 936  :                 fprintf(ctxt->output, "ENTITY_REF(%s)\n",

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0BA@FMOACEBO@ENTITY_REF?$CI?$CFs?$CJ?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN24@xmlCtxtDum:

; 937  :                         (char *) node->name);
; 938  :             }
; 939  :             break;

	jmp	$LN2@xmlCtxtDum
$LN25@xmlCtxtDum:

; 940  :         case XML_ENTITY_NODE:
; 941  :             if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN26@xmlCtxtDum

; 942  :                 xmlCtxtDumpSpaces(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 943  :                 fprintf(ctxt->output, "ENTITY\n");

	push	OFFSET ??_C@_07PAIFPHKC@ENTITY?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN26@xmlCtxtDum:

; 944  :             }
; 945  :             break;

	jmp	$LN2@xmlCtxtDum
$LN27@xmlCtxtDum:

; 946  :         case XML_PI_NODE:
; 947  :             if (!ctxt->check) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN28@xmlCtxtDum

; 948  :                 xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 949  :                 fprintf(ctxt->output, "PI %s\n", (char *) node->name);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_06JDGENMBJ@PI?5?$CFs?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN28@xmlCtxtDum:

; 950  :             }
; 951  :             break;

	jmp	$LN2@xmlCtxtDum
$LN29@xmlCtxtDum:

; 952  :         case XML_COMMENT_NODE:
; 953  :             if (!ctxt->check) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN30@xmlCtxtDum

; 954  :                 xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 955  :                 fprintf(ctxt->output, "COMMENT\n");

	push	OFFSET ??_C@_08OCMMJPAI@COMMENT?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN30@xmlCtxtDum:

; 956  :             }
; 957  :             break;

	jmp	$LN2@xmlCtxtDum
$LN31@xmlCtxtDum:

; 958  :         case XML_DOCUMENT_NODE:
; 959  :         case XML_HTML_DOCUMENT_NODE:
; 960  :             if (!ctxt->check) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN32@xmlCtxtDum

; 961  :                 xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4
$LN32@xmlCtxtDum:

; 962  :             }
; 963  :             fprintf(ctxt->output, "Error, DOCUMENT found here\n");

	push	OFFSET ??_C@_0BM@DKGLPLJE@Error?0?5DOCUMENT?5found?5here?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 964  :             xmlCtxtGenericNodeCheck(ctxt, node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtGenericNodeCheck
	add	esp, 8

; 965  :             return;

	jmp	$LN1@xmlCtxtDum
$LN33@xmlCtxtDum:

; 966  :         case XML_DOCUMENT_TYPE_NODE:
; 967  :             if (!ctxt->check) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN34@xmlCtxtDum

; 968  :                 xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 969  :                 fprintf(ctxt->output, "DOCUMENT_TYPE\n");

	push	OFFSET ??_C@_0P@EJFIBKNL@DOCUMENT_TYPE?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN34@xmlCtxtDum:

; 970  :             }
; 971  :             break;

	jmp	$LN2@xmlCtxtDum
$LN35@xmlCtxtDum:

; 972  :         case XML_DOCUMENT_FRAG_NODE:
; 973  :             if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN36@xmlCtxtDum

; 974  :                 xmlCtxtDumpSpaces(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 975  :                 fprintf(ctxt->output, "DOCUMENT_FRAG\n");

	push	OFFSET ??_C@_0P@JLLHGMMO@DOCUMENT_FRAG?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN36@xmlCtxtDum:

; 976  :             }
; 977  :             break;

	jmp	$LN2@xmlCtxtDum
$LN37@xmlCtxtDum:

; 978  :         case XML_NOTATION_NODE:
; 979  :             if (!ctxt->check) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN38@xmlCtxtDum

; 980  :                 xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 981  :                 fprintf(ctxt->output, "NOTATION\n");

	push	OFFSET ??_C@_09CPFNJPEP@NOTATION?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN38@xmlCtxtDum:

; 982  :             }
; 983  :             break;

	jmp	$LN2@xmlCtxtDum
$LN39@xmlCtxtDum:

; 984  :         case XML_DTD_NODE:
; 985  :             xmlCtxtDumpDtdNode(ctxt, (xmlDtdPtr) node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpDtdNode
	add	esp, 8

; 986  :             return;

	jmp	$LN1@xmlCtxtDum
$LN40@xmlCtxtDum:

; 987  :         case XML_ELEMENT_DECL:
; 988  :             xmlCtxtDumpElemDecl(ctxt, (xmlElementPtr) node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpElemDecl
	add	esp, 8

; 989  :             return;

	jmp	$LN1@xmlCtxtDum
$LN41@xmlCtxtDum:

; 990  :         case XML_ATTRIBUTE_DECL:
; 991  :             xmlCtxtDumpAttrDecl(ctxt, (xmlAttributePtr) node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpAttrDecl
	add	esp, 8

; 992  :             return;

	jmp	$LN1@xmlCtxtDum
$LN42@xmlCtxtDum:

; 993  :         case XML_ENTITY_DECL:
; 994  :             xmlCtxtDumpEntityDecl(ctxt, (xmlEntityPtr) node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpEntityDecl
	add	esp, 8

; 995  :             return;

	jmp	$LN1@xmlCtxtDum
$LN43@xmlCtxtDum:

; 996  :         case XML_NAMESPACE_DECL:
; 997  :             xmlCtxtDumpNamespace(ctxt, (xmlNsPtr) node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpNamespace
	add	esp, 8

; 998  :             return;

	jmp	$LN1@xmlCtxtDum
$LN44@xmlCtxtDum:

; 999  :         case XML_XINCLUDE_START:
; 1000 :             if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN45@xmlCtxtDum

; 1001 :                 xmlCtxtDumpSpaces(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 1002 :                 fprintf(ctxt->output, "INCLUDE START\n");

	push	OFFSET ??_C@_0P@MIINKGDA@INCLUDE?5START?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN45@xmlCtxtDum:

; 1003 :             }
; 1004 :             return;

	jmp	$LN1@xmlCtxtDum
$LN46@xmlCtxtDum:

; 1005 :         case XML_XINCLUDE_END:
; 1006 :             if (!ctxt->check) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN47@xmlCtxtDum

; 1007 :                 xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 1008 :                 fprintf(ctxt->output, "INCLUDE END\n");

	push	OFFSET ??_C@_0N@DKMEHMHH@INCLUDE?5END?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN47@xmlCtxtDum:

; 1009 :             }
; 1010 :             return;

	jmp	$LN1@xmlCtxtDum
$LN48@xmlCtxtDum:

; 1011 :         default:
; 1012 :             if (!ctxt->check)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN49@xmlCtxtDum

; 1013 :                 xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4
$LN49@xmlCtxtDum:

; 1014 : 	    xmlDebugErr2(ctxt, XML_CHECK_UNKNOWN_NODE,

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_0BG@ILEBNOHM@Unknown?5node?5type?5?$CFd?6@
	push	5011					; 00001393H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr2
	add	esp, 16					; 00000010H

; 1015 : 	                "Unknown node type %d\n", node->type);
; 1016 :             return;

	jmp	$LN1@xmlCtxtDum
$LN2@xmlCtxtDum:

; 1017 :     }
; 1018 :     if (node->doc == NULL) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN50@xmlCtxtDum

; 1019 :         if (!ctxt->check) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN51@xmlCtxtDum

; 1020 :             xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4
$LN51@xmlCtxtDum:

; 1021 :         }
; 1022 :         fprintf(ctxt->output, "PBM: doc == NULL !!!\n");

	push	OFFSET ??_C@_0BG@LCJECPKH@PBM?3?5doc?5?$DN?$DN?5NULL?5?$CB?$CB?$CB?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN50@xmlCtxtDum:

; 1023 :     }
; 1024 :     ctxt->depth++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+108], edx

; 1025 :     if ((node->type == XML_ELEMENT_NODE) && (node->nsDef != NULL))

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN52@xmlCtxtDum
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN52@xmlCtxtDum

; 1026 :         xmlCtxtDumpNamespaceList(ctxt, node->nsDef);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpNamespaceList
	add	esp, 8
$LN52@xmlCtxtDum:

; 1027 :     if ((node->type == XML_ELEMENT_NODE) && (node->properties != NULL))

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN53@xmlCtxtDum
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN53@xmlCtxtDum

; 1028 :         xmlCtxtDumpAttrList(ctxt, node->properties);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpAttrList
	add	esp, 8
$LN53@xmlCtxtDum:

; 1029 :     if (node->type != XML_ENTITY_REF_NODE) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 5
	je	SHORT $LN54@xmlCtxtDum

; 1030 :         if ((node->type != XML_ELEMENT_NODE) && (node->content != NULL)) {

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN56@xmlCtxtDum
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN56@xmlCtxtDum

; 1031 :             if (!ctxt->check) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN56@xmlCtxtDum

; 1032 :                 xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 1033 :                 fprintf(ctxt->output, "content=");

	push	OFFSET ??_C@_08INNCGMHH@content?$DN@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 1034 :                 xmlCtxtDumpString(ctxt, node->content);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpString
	add	esp, 8

; 1035 :                 fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN56@xmlCtxtDum:

; 1036 :             }
; 1037 :         }
; 1038 :     } else {

	jmp	SHORT $LN55@xmlCtxtDum
$LN54@xmlCtxtDum:

; 1039 :         xmlEntityPtr ent;
; 1040 : 
; 1041 :         ent = xmlGetDocEntity(node->doc, node->name);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_xmlGetDocEntity
	add	esp, 8
	mov	DWORD PTR _ent$1[ebp], eax

; 1042 :         if (ent != NULL)

	cmp	DWORD PTR _ent$1[ebp], 0
	je	SHORT $LN55@xmlCtxtDum

; 1043 :             xmlCtxtDumpEntity(ctxt, ent);

	mov	eax, DWORD PTR _ent$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpEntity
	add	esp, 8
$LN55@xmlCtxtDum:

; 1044 :     }
; 1045 :     ctxt->depth--;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+108]
	sub	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+108], eax

; 1046 : 
; 1047 :     /*
; 1048 :      * Do a bit of checking
; 1049 :      */
; 1050 :     xmlCtxtGenericNodeCheck(ctxt, node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtGenericNodeCheck
	add	esp, 8
$LN1@xmlCtxtDum:

; 1051 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN60@xmlCtxtDum:
	DD	$LN6@xmlCtxtDum
	DD	$LN9@xmlCtxtDum
	DD	$LN11@xmlCtxtDum
	DD	$LN21@xmlCtxtDum
	DD	$LN23@xmlCtxtDum
	DD	$LN25@xmlCtxtDum
	DD	$LN27@xmlCtxtDum
	DD	$LN29@xmlCtxtDum
	DD	$LN31@xmlCtxtDum
	DD	$LN33@xmlCtxtDum
	DD	$LN35@xmlCtxtDum
	DD	$LN37@xmlCtxtDum
	DD	$LN31@xmlCtxtDum
	DD	$LN39@xmlCtxtDum
	DD	$LN40@xmlCtxtDum
	DD	$LN41@xmlCtxtDum
	DD	$LN42@xmlCtxtDum
	DD	$LN43@xmlCtxtDum
	DD	$LN44@xmlCtxtDum
	DD	$LN46@xmlCtxtDum
_xmlCtxtDumpOneNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpAttrList
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlCtxtDumpAttrList PROC				; COMDAT

; 863  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlCtxtDum:

; 864  :     while (attr != NULL) {

	cmp	DWORD PTR _attr$[ebp], 0
	je	SHORT $LN1@xmlCtxtDum

; 865  :         xmlCtxtDumpAttr(ctxt, attr);

	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpAttr
	add	esp, 8

; 866  :         attr = attr->next;

	mov	edx, DWORD PTR _attr$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _attr$[ebp], eax

; 867  :     }

	jmp	SHORT $LN2@xmlCtxtDum
$LN1@xmlCtxtDum:

; 868  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpAttrList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpAttr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlCtxtDumpAttr PROC					; COMDAT

; 825  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 826  :     xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 827  : 
; 828  :     if (attr == NULL) {

	cmp	DWORD PTR _attr$[ebp], 0
	jne	SHORT $LN2@xmlCtxtDum

; 829  :         if (!ctxt->check)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN3@xmlCtxtDum

; 830  :             fprintf(ctxt->output, "Attr is NULL");

	push	OFFSET ??_C@_0N@KCLOKEKK@Attr?5is?5NULL@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN3@xmlCtxtDum:

; 831  :         return;

	jmp	$LN1@xmlCtxtDum
$LN2@xmlCtxtDum:

; 832  :     }
; 833  :     if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN4@xmlCtxtDum

; 834  :         fprintf(ctxt->output, "ATTRIBUTE ");

	push	OFFSET ??_C@_0L@MPLGGCMF@ATTRIBUTE?5@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 835  : 	xmlCtxtDumpString(ctxt, attr->name);

	mov	ecx, DWORD PTR _attr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpString
	add	esp, 8

; 836  :         fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 837  :         if (attr->children != NULL) {

	mov	eax, DWORD PTR _attr$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN4@xmlCtxtDum

; 838  :             ctxt->depth++;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+108], edx

; 839  :             xmlCtxtDumpNodeList(ctxt, attr->children);

	mov	ecx, DWORD PTR _attr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpNodeList
	add	esp, 8

; 840  :             ctxt->depth--;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	sub	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+108], edx
$LN4@xmlCtxtDum:

; 841  :         }
; 842  :     }
; 843  :     if (attr->name == NULL)

	mov	ecx, DWORD PTR _attr$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN6@xmlCtxtDum

; 844  : 	xmlDebugErr(ctxt, XML_CHECK_NO_NAME,

	push	OFFSET ??_C@_0BG@HFHKPGJL@Attribute?5has?5no?5name@
	push	5015					; 00001397H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN6@xmlCtxtDum:

; 845  : 	            "Attribute has no name");
; 846  : 
; 847  :     /*
; 848  :      * Do a bit of checking
; 849  :      */
; 850  :     xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) attr);

	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtGenericNodeCheck
	add	esp, 8
$LN1@xmlCtxtDum:

; 851  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpAttr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpEntity
_TEXT	SEGMENT
tv74 = -4						; size = 4
_ctxt$ = 8						; size = 4
_ent$ = 12						; size = 4
_xmlCtxtDumpEntity PROC					; COMDAT

; 764  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 765  :     xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 766  : 
; 767  :     if (ent == NULL) {

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN4@xmlCtxtDum

; 768  :         if (!ctxt->check)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN5@xmlCtxtDum

; 769  :             fprintf(ctxt->output, "Entity is NULL\n");

	push	OFFSET ??_C@_0BA@PFFLDDAJ@Entity?5is?5NULL?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN5@xmlCtxtDum:

; 770  :         return;

	jmp	$LN1@xmlCtxtDum
$LN4@xmlCtxtDum:

; 771  :     }
; 772  :     if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	$LN1@xmlCtxtDum

; 773  :         switch (ent->etype) {

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR tv74[ebp], eax
	mov	ecx, DWORD PTR tv74[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv74[ebp], ecx
	cmp	DWORD PTR tv74[ebp], 4
	ja	SHORT $LN12@xmlCtxtDum
	mov	edx, DWORD PTR tv74[ebp]
	jmp	DWORD PTR $LN18@xmlCtxtDum[edx*4]
$LN7@xmlCtxtDum:

; 774  :             case XML_INTERNAL_GENERAL_ENTITY:
; 775  :                 fprintf(ctxt->output, "INTERNAL_GENERAL_ENTITY ");

	push	OFFSET ??_C@_0BJ@MJDLDDEN@INTERNAL_GENERAL_ENTITY?5@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 776  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN8@xmlCtxtDum:

; 777  :             case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 778  :                 fprintf(ctxt->output, "EXTERNAL_GENERAL_PARSED_ENTITY ");

	push	OFFSET ??_C@_0CA@NAIMNBBA@EXTERNAL_GENERAL_PARSED_ENTITY?5@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 779  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN9@xmlCtxtDum:

; 780  :             case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 781  :                 fprintf(ctxt->output, "EXTERNAL_GENERAL_UNPARSED_ENTITY ");

	push	OFFSET ??_C@_0CC@EADOHJCE@EXTERNAL_GENERAL_UNPARSED_ENTIT@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 782  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN10@xmlCtxtDum:

; 783  :             case XML_INTERNAL_PARAMETER_ENTITY:
; 784  :                 fprintf(ctxt->output, "INTERNAL_PARAMETER_ENTITY ");

	push	OFFSET ??_C@_0BL@ECACNHOO@INTERNAL_PARAMETER_ENTITY?5@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 785  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN11@xmlCtxtDum:

; 786  :             case XML_EXTERNAL_PARAMETER_ENTITY:
; 787  :                 fprintf(ctxt->output, "EXTERNAL_PARAMETER_ENTITY ");

	push	OFFSET ??_C@_0BL@HEENOMOI@EXTERNAL_PARAMETER_ENTITY?5@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 788  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN12@xmlCtxtDum:

; 789  :             default:
; 790  :                 fprintf(ctxt->output, "ENTITY_%d ! ", (int) ent->etype);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	push	OFFSET ??_C@_0N@KEBDPOGN@ENTITY_?$CFd?5?$CB?5@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN2@xmlCtxtDum:

; 791  :         }
; 792  :         fprintf(ctxt->output, "%s\n", ent->name);

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 793  :         if (ent->ExternalID) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN13@xmlCtxtDum

; 794  :             xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 795  :             fprintf(ctxt->output, "ExternalID=%s\n",

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	push	OFFSET ??_C@_0P@EALJADBN@ExternalID?$DN?$CFs?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN13@xmlCtxtDum:

; 796  :                     (char *) ent->ExternalID);
; 797  :         }
; 798  :         if (ent->SystemID) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN14@xmlCtxtDum

; 799  :             xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 800  :             fprintf(ctxt->output, "SystemID=%s\n", (char *) ent->SystemID);

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	push	OFFSET ??_C@_0N@BPAPFMFO@SystemID?$DN?$CFs?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN14@xmlCtxtDum:

; 801  :         }
; 802  :         if (ent->URI) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN15@xmlCtxtDum

; 803  :             xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 804  :             fprintf(ctxt->output, "URI=%s\n", (char *) ent->URI);

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	push	OFFSET ??_C@_07HJADGDLG@URI?$DN?$CFs?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN15@xmlCtxtDum:

; 805  :         }
; 806  :         if (ent->content) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN1@xmlCtxtDum

; 807  :             xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 808  :             fprintf(ctxt->output, "content=");

	push	OFFSET ??_C@_08INNCGMHH@content?$DN@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 809  :             xmlCtxtDumpString(ctxt, ent->content);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpString
	add	esp, 8

; 810  :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN1@xmlCtxtDum:

; 811  :         }
; 812  :     }
; 813  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN18@xmlCtxtDum:
	DD	$LN7@xmlCtxtDum
	DD	$LN8@xmlCtxtDum
	DD	$LN9@xmlCtxtDum
	DD	$LN10@xmlCtxtDum
	DD	$LN11@xmlCtxtDum
_xmlCtxtDumpEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpNamespaceList
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlCtxtDumpNamespaceList PROC				; COMDAT

; 755  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlCtxtDum:

; 756  :     while (ns != NULL) {

	cmp	DWORD PTR _ns$[ebp], 0
	je	SHORT $LN1@xmlCtxtDum

; 757  :         xmlCtxtDumpNamespace(ctxt, ns);

	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpNamespace
	add	esp, 8

; 758  :         ns = ns->next;

	mov	edx, DWORD PTR _ns$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _ns$[ebp], eax

; 759  :     }

	jmp	SHORT $LN2@xmlCtxtDum
$LN1@xmlCtxtDum:

; 760  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpNamespaceList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpNamespace
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlCtxtDumpNamespace PROC				; COMDAT

; 718  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 719  :     xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 720  : 
; 721  :     if (ns == NULL) {

	cmp	DWORD PTR _ns$[ebp], 0
	jne	SHORT $LN2@xmlCtxtDum

; 722  :         if (!ctxt->check)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN3@xmlCtxtDum

; 723  :             fprintf(ctxt->output, "namespace node is NULL\n");

	push	OFFSET ??_C@_0BI@HODGPHLJ@namespace?5node?5is?5NULL?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN3@xmlCtxtDum:

; 724  :         return;

	jmp	$LN1@xmlCtxtDum
$LN2@xmlCtxtDum:

; 725  :     }
; 726  :     if (ns->type != XML_NAMESPACE_DECL) {

	mov	ecx, DWORD PTR _ns$[ebp]
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	je	SHORT $LN4@xmlCtxtDum

; 727  : 	xmlDebugErr(ctxt, XML_CHECK_NOT_NS_DECL,

	push	OFFSET ??_C@_0CE@MGJPGGJB@Node?5is?5not?5a?5namespace?5declara@
	push	5027					; 000013a3H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 728  : 	            "Node is not a namespace declaration");
; 729  :         return;

	jmp	$LN1@xmlCtxtDum
$LN4@xmlCtxtDum:

; 730  :     }
; 731  :     if (ns->href == NULL) {

	mov	eax, DWORD PTR _ns$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN5@xmlCtxtDum

; 732  :         if (ns->prefix != NULL)

	mov	ecx, DWORD PTR _ns$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN7@xmlCtxtDum

; 733  : 	    xmlDebugErr3(ctxt, XML_CHECK_NO_HREF,

	mov	edx, DWORD PTR _ns$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET ??_C@_0CD@FKAEBHOG@Incomplete?5namespace?5?$CFs?5href?$DNNU@
	push	5028					; 000013a4H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
	jmp	SHORT $LN8@xmlCtxtDum
$LN7@xmlCtxtDum:

; 734  :                     "Incomplete namespace %s href=NULL\n",
; 735  :                     (char *) ns->prefix);
; 736  :         else
; 737  : 	    xmlDebugErr(ctxt, XML_CHECK_NO_HREF,

	push	OFFSET ??_C@_0CI@MFMJLJFK@Incomplete?5default?5namespace?5hr@
	push	5028					; 000013a4H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN8@xmlCtxtDum:

; 738  :                     "Incomplete default namespace href=NULL\n");
; 739  :     } else {

	jmp	SHORT $LN1@xmlCtxtDum
$LN5@xmlCtxtDum:

; 740  :         if (!ctxt->check) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN1@xmlCtxtDum

; 741  :             if (ns->prefix != NULL)

	mov	ecx, DWORD PTR _ns$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN10@xmlCtxtDum

; 742  :                 fprintf(ctxt->output, "namespace %s href=",

	mov	edx, DWORD PTR _ns$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET ??_C@_0BD@IHBOEJJJ@namespace?5?$CFs?5href?$DN@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN11@xmlCtxtDum
$LN10@xmlCtxtDum:

; 743  :                         (char *) ns->prefix);
; 744  :             else
; 745  :                 fprintf(ctxt->output, "default namespace href=");

	push	OFFSET ??_C@_0BI@BIAGHAFN@default?5namespace?5href?$DN@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN11@xmlCtxtDum:

; 746  : 
; 747  :             xmlCtxtDumpString(ctxt, ns->href);

	mov	edx, DWORD PTR _ns$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpString
	add	esp, 8

; 748  :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN1@xmlCtxtDum:

; 749  :         }
; 750  :     }
; 751  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpNamespace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpEntityDecl
_TEXT	SEGMENT
tv95 = -4						; size = 4
_ctxt$ = 8						; size = 4
_ent$ = 12						; size = 4
_xmlCtxtDumpEntityDecl PROC				; COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 646  :     xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 647  : 
; 648  :     if (ent == NULL) {

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN4@xmlCtxtDum

; 649  :         if (!ctxt->check)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN5@xmlCtxtDum

; 650  :             fprintf(ctxt->output, "Entity declaration is NULL\n");

	push	OFFSET ??_C@_0BM@BBOCCNBN@Entity?5declaration?5is?5NULL?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN5@xmlCtxtDum:

; 651  :         return;

	jmp	$LN1@xmlCtxtDum
$LN4@xmlCtxtDum:

; 652  :     }
; 653  :     if (ent->type != XML_ENTITY_DECL) {

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+4], 17			; 00000011H
	je	SHORT $LN6@xmlCtxtDum

; 654  : 	xmlDebugErr(ctxt, XML_CHECK_NOT_ENTITY_DECL,

	push	OFFSET ??_C@_0CC@CMGFHOFN@Node?5is?5not?5an?5entity?5declarati@
	push	5026					; 000013a2H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 655  : 	            "Node is not an entity declaration");
; 656  :         return;

	jmp	$LN1@xmlCtxtDum
$LN6@xmlCtxtDum:

; 657  :     }
; 658  :     if (ent->name != NULL) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN7@xmlCtxtDum

; 659  :         if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN9@xmlCtxtDum

; 660  :             fprintf(ctxt->output, "ENTITYDECL(");

	push	OFFSET ??_C@_0M@KEJNLLDB@ENTITYDECL?$CI@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 661  :             xmlCtxtDumpString(ctxt, ent->name);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpString
	add	esp, 8

; 662  :             fprintf(ctxt->output, ")");

	push	OFFSET ??_C@_01PKGAHCOL@?$CJ@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN9@xmlCtxtDum:

; 663  :         }
; 664  :     } else

	jmp	SHORT $LN8@xmlCtxtDum
$LN7@xmlCtxtDum:

; 665  : 	xmlDebugErr(ctxt, XML_CHECK_NO_NAME,

	push	OFFSET ??_C@_0BP@DPAEJKOA@Entity?5declaration?5has?5no?5name@
	push	5015					; 00001397H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN8@xmlCtxtDum:

; 666  : 	            "Entity declaration has no name");
; 667  :     if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	$LN10@xmlCtxtDum

; 668  :         switch (ent->etype) {

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR tv95[ebp], eax
	mov	ecx, DWORD PTR tv95[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv95[ebp], ecx
	cmp	DWORD PTR tv95[ebp], 5
	ja	$LN2@xmlCtxtDum
	mov	edx, DWORD PTR tv95[ebp]
	jmp	DWORD PTR $LN22@xmlCtxtDum[edx*4]
$LN11@xmlCtxtDum:

; 669  :             case XML_INTERNAL_GENERAL_ENTITY:
; 670  :                 fprintf(ctxt->output, ", internal\n");

	push	OFFSET ??_C@_0M@PBKIGNE@?0?5internal?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 671  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN12@xmlCtxtDum:

; 672  :             case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 673  :                 fprintf(ctxt->output, ", external parsed\n");

	push	OFFSET ??_C@_0BD@BCOHBEKD@?0?5external?5parsed?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 674  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN13@xmlCtxtDum:

; 675  :             case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 676  :                 fprintf(ctxt->output, ", unparsed\n");

	push	OFFSET ??_C@_0M@FLIMFIIH@?0?5unparsed?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 677  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN14@xmlCtxtDum:

; 678  :             case XML_INTERNAL_PARAMETER_ENTITY:
; 679  :                 fprintf(ctxt->output, ", parameter\n");

	push	OFFSET ??_C@_0N@NMAFEAAG@?0?5parameter?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 680  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN15@xmlCtxtDum:

; 681  :             case XML_EXTERNAL_PARAMETER_ENTITY:
; 682  :                 fprintf(ctxt->output, ", external parameter\n");

	push	OFFSET ??_C@_0BG@OKFDOFBK@?0?5external?5parameter?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 683  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN16@xmlCtxtDum:

; 684  :             case XML_INTERNAL_PREDEFINED_ENTITY:
; 685  :                 fprintf(ctxt->output, ", predefined\n");

	push	OFFSET ??_C@_0O@OLDJNJL@?0?5predefined?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN2@xmlCtxtDum:

; 686  :                 break;
; 687  :         }
; 688  :         if (ent->ExternalID) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN17@xmlCtxtDum

; 689  :             xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 690  :             fprintf(ctxt->output, " ExternalID=%s\n",

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	push	OFFSET ??_C@_0BA@GMOODANC@?5ExternalID?$DN?$CFs?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN17@xmlCtxtDum:

; 691  :                     (char *) ent->ExternalID);
; 692  :         }
; 693  :         if (ent->SystemID) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN18@xmlCtxtDum

; 694  :             xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 695  :             fprintf(ctxt->output, " SystemID=%s\n",

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	push	OFFSET ??_C@_0O@MKEBLMD@?5SystemID?$DN?$CFs?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN18@xmlCtxtDum:

; 696  :                     (char *) ent->SystemID);
; 697  :         }
; 698  :         if (ent->URI != NULL) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN19@xmlCtxtDum

; 699  :             xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 700  :             fprintf(ctxt->output, " URI=%s\n", (char *) ent->URI);

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	push	OFFSET ??_C@_08HINJCKNC@?5URI?$DN?$CFs?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN19@xmlCtxtDum:

; 701  :         }
; 702  :         if (ent->content) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN10@xmlCtxtDum

; 703  :             xmlCtxtDumpSpaces(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 704  :             fprintf(ctxt->output, " content=");

	push	OFFSET ??_C@_09MHAMBDHP@?5content?$DN@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 705  :             xmlCtxtDumpString(ctxt, ent->content);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpString
	add	esp, 8

; 706  :             fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN10@xmlCtxtDum:

; 707  :         }
; 708  :     }
; 709  : 
; 710  :     /*
; 711  :      * Do a bit of checking
; 712  :      */
; 713  :     xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) ent);

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtGenericNodeCheck
	add	esp, 8
$LN1@xmlCtxtDum:

; 714  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@xmlCtxtDum:
	DD	$LN11@xmlCtxtDum
	DD	$LN12@xmlCtxtDum
	DD	$LN13@xmlCtxtDum
	DD	$LN14@xmlCtxtDum
	DD	$LN15@xmlCtxtDum
	DD	$LN16@xmlCtxtDum
_xmlCtxtDumpEntityDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpElemDecl
_TEXT	SEGMENT
tv95 = -5016						; size = 4
_buf$1 = -5008						; size = 5001
_ctxt$ = 8						; size = 4
_elem$ = 12						; size = 4
_xmlCtxtDumpElemDecl PROC				; COMDAT

; 586  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5016				; 00001398H
	call	__chkstk
	push	edi
	lea	edi, DWORD PTR [ebp-5016]
	mov	ecx, 1254				; 000004e6H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 587  :     xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 588  : 
; 589  :     if (elem == NULL) {

	cmp	DWORD PTR _elem$[ebp], 0
	jne	SHORT $LN4@xmlCtxtDum

; 590  :         if (!ctxt->check)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN5@xmlCtxtDum

; 591  :             fprintf(ctxt->output, "Element declaration is NULL\n");

	push	OFFSET ??_C@_0BN@LDLGNJBO@Element?5declaration?5is?5NULL?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN5@xmlCtxtDum:

; 592  :         return;

	jmp	$LN1@xmlCtxtDum
$LN4@xmlCtxtDum:

; 593  :     }
; 594  :     if (elem->type != XML_ELEMENT_DECL) {

	mov	ecx, DWORD PTR _elem$[ebp]
	cmp	DWORD PTR [ecx+4], 15			; 0000000fH
	je	SHORT $LN6@xmlCtxtDum

; 595  : 	xmlDebugErr(ctxt, XML_CHECK_NOT_ELEM_DECL,

	push	OFFSET ??_C@_0CD@MEOODKKF@Node?5is?5not?5an?5element?5declarat@
	push	5025					; 000013a1H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 596  : 	            "Node is not an element declaration");
; 597  :         return;

	jmp	$LN1@xmlCtxtDum
$LN6@xmlCtxtDum:

; 598  :     }
; 599  :     if (elem->name != NULL) {

	mov	eax, DWORD PTR _elem$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN7@xmlCtxtDum

; 600  :         if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN9@xmlCtxtDum

; 601  :             fprintf(ctxt->output, "ELEMDECL(");

	push	OFFSET ??_C@_09LBEHMBNA@ELEMDECL?$CI@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 602  :             xmlCtxtDumpString(ctxt, elem->name);

	mov	ecx, DWORD PTR _elem$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpString
	add	esp, 8

; 603  :             fprintf(ctxt->output, ")");

	push	OFFSET ??_C@_01PKGAHCOL@?$CJ@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN9@xmlCtxtDum:

; 604  :         }
; 605  :     } else

	jmp	SHORT $LN8@xmlCtxtDum
$LN7@xmlCtxtDum:

; 606  : 	xmlDebugErr(ctxt, XML_CHECK_NO_NAME,

	push	OFFSET ??_C@_0CA@CBJEJFEP@Element?5declaration?5has?5no?5name@
	push	5015					; 00001397H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN8@xmlCtxtDum:

; 607  : 	            "Element declaration has no name");
; 608  :     if (!ctxt->check) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	$LN10@xmlCtxtDum

; 609  :         switch (elem->etype) {

	mov	edx, DWORD PTR _elem$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR tv95[ebp], eax
	cmp	DWORD PTR tv95[ebp], 4
	ja	SHORT $LN2@xmlCtxtDum
	mov	ecx, DWORD PTR tv95[ebp]
	jmp	DWORD PTR $LN21@xmlCtxtDum[ecx*4]
$LN11@xmlCtxtDum:

; 610  :             case XML_ELEMENT_TYPE_UNDEFINED:
; 611  :                 fprintf(ctxt->output, ", UNDEFINED");

	push	OFFSET ??_C@_0M@PIGJBKAD@?0?5UNDEFINED@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 612  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN12@xmlCtxtDum:

; 613  :             case XML_ELEMENT_TYPE_EMPTY:
; 614  :                 fprintf(ctxt->output, ", EMPTY");

	push	OFFSET ??_C@_07MPIOAGOH@?0?5EMPTY@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 615  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN13@xmlCtxtDum:

; 616  :             case XML_ELEMENT_TYPE_ANY:
; 617  :                 fprintf(ctxt->output, ", ANY");

	push	OFFSET ??_C@_05MNEHMNJK@?0?5ANY@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 618  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN14@xmlCtxtDum:

; 619  :             case XML_ELEMENT_TYPE_MIXED:
; 620  :                 fprintf(ctxt->output, ", MIXED ");

	push	OFFSET ??_C@_08MPHAJKBG@?0?5MIXED?5@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 621  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN15@xmlCtxtDum:

; 622  :             case XML_ELEMENT_TYPE_ELEMENT:
; 623  :                 fprintf(ctxt->output, ", MIXED ");

	push	OFFSET ??_C@_08MPHAJKBG@?0?5MIXED?5@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN2@xmlCtxtDum:

; 624  :                 break;
; 625  :         }
; 626  :         if ((elem->type != XML_ELEMENT_NODE) && (elem->content != NULL)) {

	mov	eax, DWORD PTR _elem$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN16@xmlCtxtDum
	mov	ecx, DWORD PTR _elem$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN16@xmlCtxtDum

; 627  :             char buf[5001];
; 628  : 
; 629  :             buf[0] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _buf$1[ebp+eax], 0

; 630  :             xmlSnprintfElementContent(buf, 5000, elem->content, 1);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	push	5000					; 00001388H
	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	call	_xmlSnprintfElementContent
	add	esp, 16					; 00000010H

; 631  :             buf[5000] = 0;

	mov	ecx, 1
	imul	edx, ecx, 5000
	mov	BYTE PTR _buf$1[ebp+edx], 0

; 632  :             fprintf(ctxt->output, "%s", buf);

	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN16@xmlCtxtDum:

; 633  :         }
; 634  :         fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN10@xmlCtxtDum:

; 635  :     }
; 636  : 
; 637  :     /*
; 638  :      * Do a bit of checking
; 639  :      */
; 640  :     xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) elem);

	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtGenericNodeCheck
	add	esp, 8
$LN1@xmlCtxtDum:

; 641  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@xmlCtxtDum
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 5016				; 00001398H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@xmlCtxtDum:
	DD	1
	DD	$LN19@xmlCtxtDum
$LN19@xmlCtxtDum:
	DD	-5008					; ffffec70H
	DD	5001					; 00001389H
	DD	$LN18@xmlCtxtDum
$LN18@xmlCtxtDum:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN21@xmlCtxtDum:
	DD	$LN11@xmlCtxtDum
	DD	$LN12@xmlCtxtDum
	DD	$LN13@xmlCtxtDum
	DD	$LN14@xmlCtxtDum
	DD	$LN15@xmlCtxtDum
_xmlCtxtDumpElemDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpAttrDecl
_TEXT	SEGMENT
tv194 = -16						; size = 4
tv135 = -12						; size = 4
_cur$1 = -8						; size = 4
_indx$2 = -4						; size = 4
_ctxt$ = 8						; size = 4
_attr$ = 12						; size = 4
_xmlCtxtDumpAttrDecl PROC				; COMDAT

; 481  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 482  :     xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 483  : 
; 484  :     if (attr == NULL) {

	cmp	DWORD PTR _attr$[ebp], 0
	jne	SHORT $LN9@xmlCtxtDum

; 485  :         if (!ctxt->check)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN10@xmlCtxtDum

; 486  :             fprintf(ctxt->output, "Attribute declaration is NULL\n");

	push	OFFSET ??_C@_0BP@BAGDAOMH@Attribute?5declaration?5is?5NULL?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN10@xmlCtxtDum:

; 487  :         return;

	jmp	$LN1@xmlCtxtDum
$LN9@xmlCtxtDum:

; 488  :     }
; 489  :     if (attr->type != XML_ATTRIBUTE_DECL) {

	mov	ecx, DWORD PTR _attr$[ebp]
	cmp	DWORD PTR [ecx+4], 16			; 00000010H
	je	SHORT $LN11@xmlCtxtDum

; 490  : 	xmlDebugErr(ctxt, XML_CHECK_NOT_ATTR_DECL,

	push	OFFSET ??_C@_0CF@DOMFFPAF@Node?5is?5not?5an?5attribute?5declar@
	push	5024					; 000013a0H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 491  : 	            "Node is not an attribute declaration");
; 492  :         return;

	jmp	$LN1@xmlCtxtDum
$LN11@xmlCtxtDum:

; 493  :     }
; 494  :     if (attr->name != NULL) {

	mov	eax, DWORD PTR _attr$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN12@xmlCtxtDum

; 495  :         if (!ctxt->check)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN14@xmlCtxtDum

; 496  :             fprintf(ctxt->output, "ATTRDECL(%s)", (char *) attr->name);

	mov	edx, DWORD PTR _attr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_0N@EBLNCBKJ@ATTRDECL?$CI?$CFs?$CJ@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN14@xmlCtxtDum:

; 497  :     } else

	jmp	SHORT $LN13@xmlCtxtDum
$LN12@xmlCtxtDum:

; 498  : 	xmlDebugErr(ctxt, XML_CHECK_NO_NAME,

	push	OFFSET ??_C@_0CH@PBLLGJEB@Node?5attribute?5declaration?5has?5@
	push	5015					; 00001397H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN13@xmlCtxtDum:

; 499  : 	            "Node attribute declaration has no name");
; 500  :     if (attr->elem != NULL) {

	mov	ecx, DWORD PTR _attr$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	je	SHORT $LN15@xmlCtxtDum

; 501  :         if (!ctxt->check)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	SHORT $LN17@xmlCtxtDum

; 502  :             fprintf(ctxt->output, " for %s", (char *) attr->elem);

	mov	eax, DWORD PTR _attr$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	push	OFFSET ??_C@_07GLNLDEDP@?5for?5?$CFs@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN17@xmlCtxtDum:

; 503  :     } else

	jmp	SHORT $LN16@xmlCtxtDum
$LN15@xmlCtxtDum:

; 504  : 	xmlDebugErr(ctxt, XML_CHECK_NO_ELEM,

	push	OFFSET ??_C@_0CP@BPDBFHFF@Node?5attribute?5declaration?5has?5@
	push	5016					; 00001398H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN16@xmlCtxtDum:

; 505  : 	            "Node attribute declaration has no element name");
; 506  :     if (!ctxt->check) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+124], 0
	jne	$LN18@xmlCtxtDum

; 507  :         switch (attr->atype) {

	mov	eax, DWORD PTR _attr$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR tv135[ebp], ecx
	mov	edx, DWORD PTR tv135[ebp]
	sub	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	cmp	DWORD PTR tv135[ebp], 9
	ja	$LN2@xmlCtxtDum
	mov	eax, DWORD PTR tv135[ebp]
	jmp	DWORD PTR $LN41@xmlCtxtDum[eax*4]
$LN19@xmlCtxtDum:

; 508  :             case XML_ATTRIBUTE_CDATA:
; 509  :                 fprintf(ctxt->output, " CDATA");

	push	OFFSET ??_C@_06CIOOFICG@?5CDATA@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 510  :                 break;

	jmp	$LN2@xmlCtxtDum
$LN20@xmlCtxtDum:

; 511  :             case XML_ATTRIBUTE_ID:
; 512  :                 fprintf(ctxt->output, " ID");

	push	OFFSET ??_C@_03JFNHLDJD@?5ID@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 513  :                 break;

	jmp	$LN2@xmlCtxtDum
$LN21@xmlCtxtDum:

; 514  :             case XML_ATTRIBUTE_IDREF:
; 515  :                 fprintf(ctxt->output, " IDREF");

	push	OFFSET ??_C@_06JJHMNMLB@?5IDREF@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 516  :                 break;

	jmp	$LN2@xmlCtxtDum
$LN22@xmlCtxtDum:

; 517  :             case XML_ATTRIBUTE_IDREFS:
; 518  :                 fprintf(ctxt->output, " IDREFS");

	push	OFFSET ??_C@_07CNGJPBFB@?5IDREFS@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 519  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN23@xmlCtxtDum:

; 520  :             case XML_ATTRIBUTE_ENTITY:
; 521  :                 fprintf(ctxt->output, " ENTITY");

	push	OFFSET ??_C@_07GLIJGNMP@?5ENTITY@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 522  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN24@xmlCtxtDum:

; 523  :             case XML_ATTRIBUTE_ENTITIES:
; 524  :                 fprintf(ctxt->output, " ENTITIES");

	push	OFFSET ??_C@_09MILPKLMO@?5ENTITIES@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 525  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN25@xmlCtxtDum:

; 526  :             case XML_ATTRIBUTE_NMTOKEN:
; 527  :                 fprintf(ctxt->output, " NMTOKEN");

	push	OFFSET ??_C@_08JLMONKHB@?5NMTOKEN@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 528  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN26@xmlCtxtDum:

; 529  :             case XML_ATTRIBUTE_NMTOKENS:
; 530  :                 fprintf(ctxt->output, " NMTOKENS");

	push	OFFSET ??_C@_09LGAPIBOH@?5NMTOKENS@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 531  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN27@xmlCtxtDum:

; 532  :             case XML_ATTRIBUTE_ENUMERATION:
; 533  :                 fprintf(ctxt->output, " ENUMERATION");

	push	OFFSET ??_C@_0N@DAGLJCMJ@?5ENUMERATION@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 534  :                 break;

	jmp	SHORT $LN2@xmlCtxtDum
$LN28@xmlCtxtDum:

; 535  :             case XML_ATTRIBUTE_NOTATION:
; 536  :                 fprintf(ctxt->output, " NOTATION ");

	push	OFFSET ??_C@_0L@EOKHAFCK@?5NOTATION?5@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN2@xmlCtxtDum:

; 537  :                 break;
; 538  :         }
; 539  :         if (attr->tree != NULL) {

	mov	eax, DWORD PTR _attr$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$LN29@xmlCtxtDum

; 540  :             int indx;
; 541  :             xmlEnumerationPtr cur = attr->tree;

	mov	ecx, DWORD PTR _attr$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR _cur$1[ebp], edx

; 542  : 
; 543  :             for (indx = 0; indx < 5; indx++) {

	mov	DWORD PTR _indx$2[ebp], 0
	jmp	SHORT $LN6@xmlCtxtDum
$LN4@xmlCtxtDum:
	mov	eax, DWORD PTR _indx$2[ebp]
	add	eax, 1
	mov	DWORD PTR _indx$2[ebp], eax
$LN6@xmlCtxtDum:
	cmp	DWORD PTR _indx$2[ebp], 5
	jge	SHORT $LN5@xmlCtxtDum

; 544  :                 if (indx != 0)

	cmp	DWORD PTR _indx$2[ebp], 0
	je	SHORT $LN30@xmlCtxtDum

; 545  :                     fprintf(ctxt->output, "|%s", (char *) cur->name);

	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET ??_C@_03MFMGJBPJ@?$HM?$CFs@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN31@xmlCtxtDum
$LN30@xmlCtxtDum:

; 546  :                 else
; 547  :                     fprintf(ctxt->output, " (%s", (char *) cur->name);

	mov	edx, DWORD PTR _cur$1[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_04KHAOAOAJ@?5?$CI?$CFs@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN31@xmlCtxtDum:

; 548  :                 cur = cur->next;

	mov	eax, DWORD PTR _cur$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$1[ebp], ecx

; 549  :                 if (cur == NULL)

	cmp	DWORD PTR _cur$1[ebp], 0
	jne	SHORT $LN32@xmlCtxtDum

; 550  :                     break;

	jmp	SHORT $LN5@xmlCtxtDum
$LN32@xmlCtxtDum:

; 551  :             }

	jmp	SHORT $LN4@xmlCtxtDum
$LN5@xmlCtxtDum:

; 552  :             if (cur == NULL)

	cmp	DWORD PTR _cur$1[ebp], 0
	jne	SHORT $LN33@xmlCtxtDum

; 553  :                 fprintf(ctxt->output, ")");

	push	OFFSET ??_C@_01PKGAHCOL@?$CJ@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN29@xmlCtxtDum
$LN33@xmlCtxtDum:

; 554  :             else
; 555  :                 fprintf(ctxt->output, "...)");

	push	OFFSET ??_C@_04HBFELFIL@?4?4?4?$CJ@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN29@xmlCtxtDum:

; 556  :         }
; 557  :         switch (attr->def) {

	mov	eax, DWORD PTR _attr$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR tv194[ebp], ecx
	cmp	DWORD PTR tv194[ebp], 2
	je	SHORT $LN36@xmlCtxtDum
	cmp	DWORD PTR tv194[ebp], 3
	je	SHORT $LN37@xmlCtxtDum
	cmp	DWORD PTR tv194[ebp], 4
	je	SHORT $LN38@xmlCtxtDum
	jmp	SHORT $LN7@xmlCtxtDum

; 558  :             case XML_ATTRIBUTE_NONE:
; 559  :                 break;

	jmp	SHORT $LN7@xmlCtxtDum
$LN36@xmlCtxtDum:

; 560  :             case XML_ATTRIBUTE_REQUIRED:
; 561  :                 fprintf(ctxt->output, " REQUIRED");

	push	OFFSET ??_C@_09GBLDHCFM@?5REQUIRED@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8

; 562  :                 break;

	jmp	SHORT $LN7@xmlCtxtDum
$LN37@xmlCtxtDum:

; 563  :             case XML_ATTRIBUTE_IMPLIED:
; 564  :                 fprintf(ctxt->output, " IMPLIED");

	push	OFFSET ??_C@_08BNNMMLKP@?5IMPLIED@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 565  :                 break;

	jmp	SHORT $LN7@xmlCtxtDum
$LN38@xmlCtxtDum:

; 566  :             case XML_ATTRIBUTE_FIXED:
; 567  :                 fprintf(ctxt->output, " FIXED");

	push	OFFSET ??_C@_06MNDBCIDD@?5FIXED@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN7@xmlCtxtDum:

; 568  :                 break;
; 569  :         }
; 570  :         if (attr->defaultValue != NULL) {

	mov	edx, DWORD PTR _attr$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN39@xmlCtxtDum

; 571  :             fprintf(ctxt->output, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8

; 572  :             xmlCtxtDumpString(ctxt, attr->defaultValue);

	mov	edx, DWORD PTR _attr$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpString
	add	esp, 8

; 573  :             fprintf(ctxt->output, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN39@xmlCtxtDum:

; 574  :         }
; 575  :         fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8
$LN18@xmlCtxtDum:

; 576  :     }
; 577  : 
; 578  :     /*
; 579  :      * Do a bit of checking
; 580  :      */
; 581  :     xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) attr);

	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtGenericNodeCheck
	add	esp, 8
$LN1@xmlCtxtDum:

; 582  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN41@xmlCtxtDum:
	DD	$LN19@xmlCtxtDum
	DD	$LN20@xmlCtxtDum
	DD	$LN21@xmlCtxtDum
	DD	$LN22@xmlCtxtDum
	DD	$LN23@xmlCtxtDum
	DD	$LN24@xmlCtxtDum
	DD	$LN25@xmlCtxtDum
	DD	$LN26@xmlCtxtDum
	DD	$LN27@xmlCtxtDum
	DD	$LN28@xmlCtxtDum
_xmlCtxtDumpAttrDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpDtdNode
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_dtd$ = 12						; size = 4
_xmlCtxtDumpDtdNode PROC				; COMDAT

; 448  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 449  :     xmlCtxtDumpSpaces(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpSpaces
	add	esp, 4

; 450  : 
; 451  :     if (dtd == NULL) {

	cmp	DWORD PTR _dtd$[ebp], 0
	jne	SHORT $LN2@xmlCtxtDum

; 452  :         if (!ctxt->check)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	jne	SHORT $LN3@xmlCtxtDum

; 453  :             fprintf(ctxt->output, "DTD node is NULL\n");

	push	OFFSET ??_C@_0BC@MDLFLLHC@DTD?5node?5is?5NULL?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN3@xmlCtxtDum:

; 454  :         return;

	jmp	$LN1@xmlCtxtDum
$LN2@xmlCtxtDum:

; 455  :     }
; 456  : 
; 457  :     if (dtd->type != XML_DTD_NODE) {

	mov	ecx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [ecx+4], 14			; 0000000eH
	je	SHORT $LN4@xmlCtxtDum

; 458  : 	xmlDebugErr(ctxt, XML_CHECK_NOT_DTD,

	push	OFFSET ??_C@_0BC@MBEMJEOJ@Node?5is?5not?5a?5DTD@
	push	5022					; 0000139eH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 459  : 	            "Node is not a DTD");
; 460  :         return;

	jmp	$LN1@xmlCtxtDum
$LN4@xmlCtxtDum:

; 461  :     }
; 462  :     if (!ctxt->check) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	$LN5@xmlCtxtDum

; 463  :         if (dtd->name != NULL)

	mov	ecx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN6@xmlCtxtDum

; 464  :             fprintf(ctxt->output, "DTD(%s)", (char *) dtd->name);

	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_07PFBLHE@DTD?$CI?$CFs?$CJ@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@xmlCtxtDum
$LN6@xmlCtxtDum:

; 465  :         else
; 466  :             fprintf(ctxt->output, "DTD");

	push	OFFSET ??_C@_03DFGNODOE@DTD@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN7@xmlCtxtDum:

; 467  :         if (dtd->ExternalID != NULL)

	mov	edx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN8@xmlCtxtDum

; 468  :             fprintf(ctxt->output, ", PUBLIC %s", (char *) dtd->ExternalID);

	mov	eax, DWORD PTR _dtd$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	push	OFFSET ??_C@_0M@NLONAAOP@?0?5PUBLIC?5?$CFs@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN8@xmlCtxtDum:

; 469  :         if (dtd->SystemID != NULL)

	mov	ecx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	je	SHORT $LN9@xmlCtxtDum

; 470  :             fprintf(ctxt->output, ", SYSTEM %s", (char *) dtd->SystemID);

	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	push	OFFSET ??_C@_0M@PKDMNFPO@?0?5SYSTEM?5?$CFs@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN9@xmlCtxtDum:

; 471  :         fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN5@xmlCtxtDum:

; 472  :     }
; 473  :     /*
; 474  :      * Do a bit of checking
; 475  :      */
; 476  :     xmlCtxtGenericNodeCheck(ctxt, (xmlNodePtr) dtd);

	mov	edx, DWORD PTR _dtd$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtGenericNodeCheck
	add	esp, 8
$LN1@xmlCtxtDum:

; 477  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpDtdNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpString
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlCtxtDumpString PROC					; COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 424  :     int i;
; 425  : 
; 426  :     if (ctxt->check) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN5@xmlCtxtDum

; 427  :         return;

	jmp	$LN1@xmlCtxtDum
$LN5@xmlCtxtDum:

; 428  :     }
; 429  :     /* TODO: check UTF8 content of the string */
; 430  :     if (str == NULL) {

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN6@xmlCtxtDum

; 431  :         fprintf(ctxt->output, "(NULL)");

	push	OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fprintf
	add	esp, 8

; 432  :         return;

	jmp	$LN1@xmlCtxtDum
$LN6@xmlCtxtDum:

; 433  :     }
; 434  :     for (i = 0; i < 40; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlCtxtDum
$LN2@xmlCtxtDum:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlCtxtDum:
	cmp	DWORD PTR _i$[ebp], 40			; 00000028H
	jge	$LN3@xmlCtxtDum

; 435  :         if (str[i] == 0)

	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN7@xmlCtxtDum

; 436  :             return;

	jmp	$LN1@xmlCtxtDum
	jmp	$LN8@xmlCtxtDum
$LN7@xmlCtxtDum:

; 437  :         else if (IS_BLANK_CH(str[i]))

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN11@xmlCtxtDum
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN12@xmlCtxtDum
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN11@xmlCtxtDum
$LN12@xmlCtxtDum:
	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN9@xmlCtxtDum
$LN11@xmlCtxtDum:

; 438  :             fputc(' ', ctxt->output);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	32					; 00000020H
	call	DWORD PTR __imp__fputc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN8@xmlCtxtDum
$LN9@xmlCtxtDum:

; 439  :         else if (str[i] >= 0x80)

	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 128				; 00000080H
	jl	SHORT $LN13@xmlCtxtDum

; 440  :             fprintf(ctxt->output, "#%X", str[i]);

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	push	OFFSET ??_C@_03CANIHDGE@?$CD?$CFX@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@xmlCtxtDum
$LN13@xmlCtxtDum:

; 441  :         else
; 442  :             fputc(str[i], ctxt->output);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__fputc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlCtxtDum:
	jmp	$LN2@xmlCtxtDum
$LN3@xmlCtxtDum:

; 443  :     fprintf(ctxt->output, "...");

	push	OFFSET ??_C@_03KHICJKCI@?4?4?4@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fprintf
	add	esp, 8
$LN1@xmlCtxtDum:

; 444  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtDumpString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtGenericNodeCheck
_TEXT	SEGMENT
tv228 = -16						; size = 4
_ns$1 = -12						; size = 4
_dict$ = -8						; size = 4
_doc$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlCtxtGenericNodeCheck PROC				; COMDAT

; 275  : xmlCtxtGenericNodeCheck(xmlDebugCtxtPtr ctxt, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 276  :     xmlDocPtr doc;
; 277  :     xmlDictPtr dict;
; 278  : 
; 279  :     doc = node->doc;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _doc$[ebp], ecx

; 280  : 
; 281  :     if (node->parent == NULL)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN6@xmlCtxtGen

; 282  :         xmlDebugErr(ctxt, XML_CHECK_NO_PARENT,

	push	OFFSET ??_C@_0BE@EPLMDKLB@Node?5has?5no?5parent?6@
	push	5013					; 00001395H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN6@xmlCtxtGen:

; 283  : 	            "Node has no parent\n");
; 284  :     if (node->doc == NULL) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN7@xmlCtxtGen

; 285  :         xmlDebugErr(ctxt, XML_CHECK_NO_DOC,

	push	OFFSET ??_C@_0BB@MOKKDMAC@Node?5has?5no?5doc?6@
	push	5014					; 00001396H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 286  : 	            "Node has no doc\n");
; 287  :         dict = NULL;

	mov	DWORD PTR _dict$[ebp], 0

; 288  :     } else {

	jmp	SHORT $LN8@xmlCtxtGen
$LN7@xmlCtxtGen:

; 289  : 	dict = doc->dict;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _dict$[ebp], ecx

; 290  : 	if ((dict == NULL) && (ctxt->nodict == 0)) {

	cmp	DWORD PTR _dict$[ebp], 0
	jne	SHORT $LN9@xmlCtxtGen
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+132], 0
	jne	SHORT $LN9@xmlCtxtGen

; 291  : #if 0
; 292  :             /* desactivated right now as it raises too many errors */
; 293  : 	    if (doc->type == XML_DOCUMENT_NODE)
; 294  : 		xmlDebugErr(ctxt, XML_CHECK_NO_DICT,
; 295  : 			    "Document has no dictionary\n");
; 296  : #endif
; 297  : 	    ctxt->nodict = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+132], 1
$LN9@xmlCtxtGen:

; 298  : 	}
; 299  : 	if (ctxt->doc == NULL)

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+112], 0
	jne	SHORT $LN10@xmlCtxtGen

; 300  : 	    ctxt->doc = doc;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [edx+112], eax
$LN10@xmlCtxtGen:

; 301  : 
; 302  : 	if (ctxt->dict == NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+120], 0
	jne	SHORT $LN8@xmlCtxtGen

; 303  : 	    ctxt->dict = dict;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [edx+120], eax
$LN8@xmlCtxtGen:

; 304  : 	}
; 305  :     }
; 306  :     if ((node->parent != NULL) && (node->doc != node->parent->doc) &&

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN12@xmlCtxtGen
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	cmp	edx, DWORD PTR [eax+32]
	je	SHORT $LN12@xmlCtxtGen
	push	OFFSET ??_C@_0L@OLLEMIAI@pseudoroot@
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlCtxtGen

; 307  :         (!xmlStrEqual(node->name, BAD_CAST "pseudoroot")))
; 308  :         xmlDebugErr(ctxt, XML_CHECK_WRONG_DOC,

	push	OFFSET ??_C@_0CE@LOLNJJIM@Node?5doc?5differs?5from?5parent?8s?5@
	push	5017					; 00001399H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN12@xmlCtxtGen:

; 309  : 	            "Node doc differs from parent's one\n");
; 310  :     if (node->prev == NULL) {

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN13@xmlCtxtGen

; 311  :         if (node->type == XML_ATTRIBUTE_NODE) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 2
	jne	SHORT $LN15@xmlCtxtGen

; 312  : 	    if ((node->parent != NULL) &&

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN17@xmlCtxtGen
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _node$[ebp]
	cmp	edx, DWORD PTR [ecx+44]
	je	SHORT $LN17@xmlCtxtGen

; 313  : 	        (node != (xmlNodePtr) node->parent->properties))
; 314  : 		xmlDebugErr(ctxt, XML_CHECK_NO_PREV,

	push	OFFSET ??_C@_0CN@CJJLPFI@Attr?5has?5no?5prev?5and?5not?5first?5@
	push	5018					; 0000139aH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN17@xmlCtxtGen:

; 315  :                     "Attr has no prev and not first of attr list\n");
; 316  : 
; 317  :         } else if ((node->parent != NULL) && (node->parent->children != node))

	jmp	SHORT $LN16@xmlCtxtGen
$LN15@xmlCtxtGen:
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN16@xmlCtxtGen
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _node$[ebp]
	je	SHORT $LN16@xmlCtxtGen

; 318  : 	    xmlDebugErr(ctxt, XML_CHECK_NO_PREV,

	push	OFFSET ??_C@_0CP@FIFBDLN@Node?5has?5no?5prev?5and?5not?5first?5@
	push	5018					; 0000139aH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN16@xmlCtxtGen:

; 319  :                     "Node has no prev and not first of parent list\n");
; 320  :     } else {

	jmp	SHORT $LN14@xmlCtxtGen
$LN13@xmlCtxtGen:

; 321  :         if (node->prev->next != node)

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR _node$[ebp]
	je	SHORT $LN14@xmlCtxtGen

; 322  : 	    xmlDebugErr(ctxt, XML_CHECK_WRONG_PREV,

	push	OFFSET ??_C@_0CD@LGMLKLGH@Node?5prev?9?$DOnext?5?3?5back?5link?5wro@
	push	5019					; 0000139bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN14@xmlCtxtGen:

; 323  :                         "Node prev->next : back link wrong\n");
; 324  :     }
; 325  :     if (node->next == NULL) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN20@xmlCtxtGen

; 326  : 	if ((node->parent != NULL) && (node->type != XML_ATTRIBUTE_NODE) &&
; 327  : 	    (node->parent->last != node) &&

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN22@xmlCtxtGen
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 2
	je	SHORT $LN22@xmlCtxtGen
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _node$[ebp]
	je	SHORT $LN22@xmlCtxtGen
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN22@xmlCtxtGen

; 328  : 	    (node->parent->type == XML_ELEMENT_NODE))
; 329  : 	    xmlDebugErr(ctxt, XML_CHECK_NO_NEXT,

	push	OFFSET ??_C@_0CO@INOGIHKC@Node?5has?5no?5next?5and?5not?5last?5o@
	push	5020					; 0000139cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN22@xmlCtxtGen:

; 330  :                     "Node has no next and not last of parent list\n");
; 331  :     } else {

	jmp	SHORT $LN21@xmlCtxtGen
$LN20@xmlCtxtGen:

; 332  :         if (node->next->prev != node)

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+28]
	cmp	eax, DWORD PTR _node$[ebp]
	je	SHORT $LN23@xmlCtxtGen

; 333  : 	    xmlDebugErr(ctxt, XML_CHECK_WRONG_NEXT,

	push	OFFSET ??_C@_0CG@PBIAHHPM@Node?5next?9?$DOprev?5?3?5forward?5link?5@
	push	5021					; 0000139dH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN23@xmlCtxtGen:

; 334  :                     "Node next->prev : forward link wrong\n");
; 335  :         if (node->next->parent != node->parent)

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+20]
	je	SHORT $LN21@xmlCtxtGen

; 336  : 	    xmlDebugErr(ctxt, XML_CHECK_WRONG_PARENT,

	push	OFFSET ??_C@_0CG@PBIAHHPM@Node?5next?9?$DOprev?5?3?5forward?5link?5@
	push	5029					; 000013a5H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
$LN21@xmlCtxtGen:

; 337  :                     "Node next->prev : forward link wrong\n");
; 338  :     }
; 339  :     if (node->type == XML_ELEMENT_NODE) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN25@xmlCtxtGen

; 340  :         xmlNsPtr ns;
; 341  : 
; 342  : 	ns = node->nsDef;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _ns$1[ebp], eax
$LN2@xmlCtxtGen:

; 343  : 	while (ns != NULL) {

	cmp	DWORD PTR _ns$1[ebp], 0
	je	SHORT $LN3@xmlCtxtGen

; 344  : 	    xmlCtxtNsCheckScope(ctxt, node, ns);

	mov	ecx, DWORD PTR _ns$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtNsCheckScope
	add	esp, 12					; 0000000cH

; 345  : 	    ns = ns->next;

	mov	ecx, DWORD PTR _ns$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ns$1[ebp], edx

; 346  : 	}

	jmp	SHORT $LN2@xmlCtxtGen
$LN3@xmlCtxtGen:

; 347  : 	if (node->ns != NULL)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN27@xmlCtxtGen

; 348  : 	    xmlCtxtNsCheckScope(ctxt, node, node->ns);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtNsCheckScope
	add	esp, 12					; 0000000cH
$LN27@xmlCtxtGen:

; 349  :     } else if (node->type == XML_ATTRIBUTE_NODE) {

	jmp	SHORT $LN26@xmlCtxtGen
$LN25@xmlCtxtGen:
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 2
	jne	SHORT $LN26@xmlCtxtGen

; 350  : 	if (node->ns != NULL)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN26@xmlCtxtGen

; 351  : 	    xmlCtxtNsCheckScope(ctxt, node, node->ns);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtNsCheckScope
	add	esp, 12					; 0000000cH
$LN26@xmlCtxtGen:

; 352  :     }
; 353  : 
; 354  :     if ((node->type != XML_ELEMENT_NODE) &&
; 355  : 	(node->type != XML_ATTRIBUTE_NODE) &&
; 356  : 	(node->type != XML_ELEMENT_DECL) &&
; 357  : 	(node->type != XML_ATTRIBUTE_DECL) &&
; 358  : 	(node->type != XML_DTD_NODE) &&
; 359  : 	(node->type != XML_HTML_DOCUMENT_NODE) &&

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	SHORT $LN30@xmlCtxtGen
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 2
	je	SHORT $LN30@xmlCtxtGen
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 15			; 0000000fH
	je	SHORT $LN30@xmlCtxtGen
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 16			; 00000010H
	je	SHORT $LN30@xmlCtxtGen
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 14			; 0000000eH
	je	SHORT $LN30@xmlCtxtGen
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	je	SHORT $LN30@xmlCtxtGen
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 9
	je	SHORT $LN30@xmlCtxtGen

; 360  : 	(node->type != XML_DOCUMENT_NODE)) {
; 361  : 	if (node->content != NULL)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN30@xmlCtxtGen

; 362  : 	    xmlCtxtCheckString(ctxt, (const xmlChar *) node->content);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtCheckString
	add	esp, 8
$LN30@xmlCtxtGen:

; 363  :     }
; 364  :     switch (node->type) {

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv228[ebp], edx
	mov	eax, DWORD PTR tv228[ebp]
	sub	eax, 1
	mov	DWORD PTR tv228[ebp], eax
	cmp	DWORD PTR tv228[ebp], 7
	ja	$LN1@xmlCtxtGen
	mov	ecx, DWORD PTR tv228[ebp]
	jmp	DWORD PTR $LN44@xmlCtxtGen[ecx*4]
$LN32@xmlCtxtGen:

; 365  :         case XML_ELEMENT_NODE:
; 366  :         case XML_ATTRIBUTE_NODE:
; 367  : 	    xmlCtxtCheckName(ctxt, node->name);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtCheckName
	add	esp, 8

; 368  : 	    break;

	jmp	$LN1@xmlCtxtGen
$LN33@xmlCtxtGen:

; 369  :         case XML_TEXT_NODE:
; 370  : 	    if ((node->name == xmlStringText) ||

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+8], OFFSET _xmlStringText
	je	SHORT $LN35@xmlCtxtGen
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+8], OFFSET _xmlStringTextNoenc
	jne	SHORT $LN34@xmlCtxtGen
$LN35@xmlCtxtGen:

; 371  : 	        (node->name == xmlStringTextNoenc))
; 372  : 		break;

	jmp	$LN1@xmlCtxtGen
$LN34@xmlCtxtGen:

; 373  : 	    /* some case of entity substitution can lead to this */
; 374  : 	    if ((ctxt->dict != NULL) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+120], 0
	je	SHORT $LN36@xmlCtxtGen
	push	7
	push	OFFSET ??_C@_07DALNPEGO@nbktext@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+120]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+8], eax
	jne	SHORT $LN36@xmlCtxtGen

; 375  : 	        (node->name == xmlDictLookup(ctxt->dict, BAD_CAST "nbktext",
; 376  : 		                             7)))
; 377  : 		break;

	jmp	$LN1@xmlCtxtGen
$LN36@xmlCtxtGen:

; 378  : 
; 379  : 	    xmlDebugErr3(ctxt, XML_CHECK_WRONG_NAME,

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_0BO@PNOOIGPO@Text?5node?5has?5wrong?5name?5?8?$CFs?8@
	push	5036					; 000013acH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H

; 380  : 			 "Text node has wrong name '%s'",
; 381  : 			 (const char *) node->name);
; 382  : 	    break;

	jmp	SHORT $LN1@xmlCtxtGen
$LN37@xmlCtxtGen:

; 383  :         case XML_COMMENT_NODE:
; 384  : 	    if (node->name == xmlStringComment)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+8], OFFSET _xmlStringComment
	jne	SHORT $LN38@xmlCtxtGen

; 385  : 		break;

	jmp	SHORT $LN1@xmlCtxtGen
$LN38@xmlCtxtGen:

; 386  : 	    xmlDebugErr3(ctxt, XML_CHECK_WRONG_NAME,

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0CB@NIALDOAB@Comment?5node?5has?5wrong?5name?5?8?$CFs@
	push	5036					; 000013acH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H

; 387  : 			 "Comment node has wrong name '%s'",
; 388  : 			 (const char *) node->name);
; 389  : 	    break;

	jmp	SHORT $LN1@xmlCtxtGen
$LN39@xmlCtxtGen:

; 390  :         case XML_PI_NODE:
; 391  : 	    xmlCtxtCheckName(ctxt, node->name);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtCheckName
	add	esp, 8

; 392  : 	    break;

	jmp	SHORT $LN1@xmlCtxtGen
$LN40@xmlCtxtGen:

; 393  :         case XML_CDATA_SECTION_NODE:
; 394  : 	    if (node->name == NULL)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN41@xmlCtxtGen

; 395  : 		break;

	jmp	SHORT $LN1@xmlCtxtGen
$LN41@xmlCtxtGen:

; 396  : 	    xmlDebugErr3(ctxt, XML_CHECK_NAME_NOT_NULL,

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_0CF@EPPJHKJE@CData?5section?5has?5non?5NULL?5name@
	push	5037					; 000013adH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
$LN1@xmlCtxtGen:

; 397  : 			 "CData section has non NULL name '%s'",
; 398  : 			 (const char *) node->name);
; 399  : 	    break;
; 400  :         case XML_ENTITY_REF_NODE:
; 401  :         case XML_ENTITY_NODE:
; 402  :         case XML_DOCUMENT_TYPE_NODE:
; 403  :         case XML_DOCUMENT_FRAG_NODE:
; 404  :         case XML_NOTATION_NODE:
; 405  :         case XML_DTD_NODE:
; 406  :         case XML_ELEMENT_DECL:
; 407  :         case XML_ATTRIBUTE_DECL:
; 408  :         case XML_ENTITY_DECL:
; 409  :         case XML_NAMESPACE_DECL:
; 410  :         case XML_XINCLUDE_START:
; 411  :         case XML_XINCLUDE_END:
; 412  : #ifdef LIBXML_DOCB_ENABLED
; 413  :         case XML_DOCB_DOCUMENT_NODE:
; 414  : #endif
; 415  :         case XML_DOCUMENT_NODE:
; 416  :         case XML_HTML_DOCUMENT_NODE:
; 417  : 	    break;
; 418  :     }
; 419  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN44@xmlCtxtGen:
	DD	$LN32@xmlCtxtGen
	DD	$LN32@xmlCtxtGen
	DD	$LN33@xmlCtxtGen
	DD	$LN40@xmlCtxtGen
	DD	$LN1@xmlCtxtGen
	DD	$LN1@xmlCtxtGen
	DD	$LN39@xmlCtxtGen
	DD	$LN37@xmlCtxtGen
_xmlCtxtGenericNodeCheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtCheckName
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlCtxtCheckName PROC					; COMDAT

; 251  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 252  :     if (ctxt->check) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	$LN1@xmlCtxtChe

; 253  : 	if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN3@xmlCtxtChe

; 254  : 	    xmlDebugErr(ctxt, XML_CHECK_NO_NAME, "Name is NULL");

	push	OFFSET ??_C@_0N@BLMILKM@Name?5is?5NULL@
	push	5015					; 00001397H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH

; 255  : 	    return;

	jmp	SHORT $LN1@xmlCtxtChe
$LN3@xmlCtxtChe:

; 256  : 	}
; 257  : #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
; 258  :         if (xmlValidateName(name, 0)) {

	push	0
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlValidateName
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@xmlCtxtChe

; 259  : 	    xmlDebugErr3(ctxt, XML_CHECK_NOT_NCNAME,

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@DKJDBHCK@Name?5is?5not?5an?5NCName?5?8?$CFs?8@
	push	5034					; 000013aaH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
$LN4@xmlCtxtChe:

; 260  : 			 "Name is not an NCName '%s'", (const char *) name);
; 261  : 	}
; 262  : #endif
; 263  : 	if ((ctxt->dict != NULL) &&
; 264  : 	    (!xmlDictOwns(ctxt->dict, name)) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+120], 0
	je	SHORT $LN1@xmlCtxtChe
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	push	edx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@xmlCtxtChe
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+112], 0
	je	SHORT $LN6@xmlCtxtChe
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+88]
	and	eax, 4608				; 00001200H
	jne	SHORT $LN1@xmlCtxtChe
$LN6@xmlCtxtChe:

; 265  :             ((ctxt->doc == NULL) ||
; 266  :              ((ctxt->doc->parseFlags & (XML_PARSE_SAX1 | XML_PARSE_NODICT)) == 0))) {
; 267  : 	    xmlDebugErr3(ctxt, XML_CHECK_OUTSIDE_DICT,

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CO@NDFCBACJ@Name?5is?5not?5from?5the?5document?5d@
	push	5035					; 000013abH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
$LN1@xmlCtxtChe:

; 268  : 			 "Name is not from the document dictionary '%s'",
; 269  : 			 (const char *) name);
; 270  : 	}
; 271  :     }
; 272  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtCheckName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtCheckString
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlCtxtCheckString PROC				; COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 232  :     if (str == NULL) return;

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@xmlCtxtChe
	jmp	SHORT $LN1@xmlCtxtChe
$LN2@xmlCtxtChe:

; 233  :     if (ctxt->check) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN1@xmlCtxtChe

; 234  :         if (!xmlCheckUTF8(str)) {

	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_xmlCheckUTF8
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@xmlCtxtChe

; 235  : 	    xmlDebugErr3(ctxt, XML_CHECK_NOT_UTF8,

	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	push	OFFSET ??_C@_0BH@GLDOBOAB@String?5is?5not?5UTF?98?5?$CFs@
	push	5032					; 000013a8H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
$LN1@xmlCtxtChe:

; 236  : 			 "String is not UTF-8 %s", (const char *) str);
; 237  : 	}
; 238  :     }
; 239  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtCheckString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtNsCheckScope
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_ns$ = 16						; size = 4
_xmlCtxtNsCheckScope PROC				; COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 199  :     int ret;
; 200  : 
; 201  :     ret = xmlNsCheckScope(node, ns);

	mov	eax, DWORD PTR _ns$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_xmlNsCheckScope
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 202  :     if (ret == -2) {

	cmp	DWORD PTR _ret$[ebp], -2		; fffffffeH
	jne	SHORT $LN2@xmlCtxtNsC

; 203  :         if (ns->prefix == NULL)

	mov	edx, DWORD PTR _ns$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN3@xmlCtxtNsC

; 204  : 	    xmlDebugErr(ctxt, XML_CHECK_NS_SCOPE,

	push	OFFSET ??_C@_0CN@CCCBCKMJ@Reference?5to?5default?5namespace?5@
	push	5030					; 000013a6H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@xmlCtxtNsC
$LN3@xmlCtxtNsC:

; 205  : 			"Reference to default namespace not in scope\n");
; 206  : 	else
; 207  : 	    xmlDebugErr3(ctxt, XML_CHECK_NS_SCOPE,

	mov	ecx, DWORD PTR _ns$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	OFFSET ??_C@_0CK@KJADECB@Reference?5to?5namespace?5?8?$CFs?8?5not@
	push	5030					; 000013a6H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
$LN2@xmlCtxtNsC:

; 208  : 			 "Reference to namespace '%s' not in scope\n",
; 209  : 			 (char *) ns->prefix);
; 210  :     }
; 211  :     if (ret == -3) {

	cmp	DWORD PTR _ret$[ebp], -3		; fffffffdH
	jne	SHORT $LN1@xmlCtxtNsC

; 212  :         if (ns->prefix == NULL)

	mov	ecx, DWORD PTR _ns$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN6@xmlCtxtNsC

; 213  : 	    xmlDebugErr(ctxt, XML_CHECK_NS_ANCESTOR,

	push	OFFSET ??_C@_0DA@PAHGLCCL@Reference?5to?5default?5namespace?5@
	push	5031					; 000013a7H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@xmlCtxtNsC
$LN6@xmlCtxtNsC:

; 214  : 			"Reference to default namespace not on ancestor\n");
; 215  : 	else
; 216  : 	    xmlDebugErr3(ctxt, XML_CHECK_NS_ANCESTOR,

	mov	eax, DWORD PTR _ns$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET ??_C@_0CN@DPKAIPNO@Reference?5to?5namespace?5?8?$CFs?8?5not@
	push	5031					; 000013a7H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlDebugErr3
	add	esp, 16					; 00000010H
$LN1@xmlCtxtNsC:

; 217  : 			 "Reference to namespace '%s' not on ancestor\n",
; 218  : 			 (char *) ns->prefix);
; 219  :     }
; 220  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtNsCheckScope ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugErr3
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_extra$ = 20						; size = 4
_xmlDebugErr3 PROC					; COMDAT

; 179  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 180  :     ctxt->errors++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 181  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	mov	edx, DWORD PTR _error$[ebp]
	push	edx
	push	24					; 00000018H
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 182  : 		    NULL, ctxt->node, XML_FROM_CHECK,
; 183  : 		    error, XML_ERR_ERROR, NULL, 0,
; 184  : 		    NULL, NULL, NULL, 0, 0,
; 185  : 		    msg, extra);
; 186  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDebugErr3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugErr2
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_extra$ = 20						; size = 4
_xmlDebugErr2 PROC					; COMDAT

; 169  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 170  :     ctxt->errors++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 171  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	mov	edx, DWORD PTR _error$[ebp]
	push	edx
	push	24					; 00000018H
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 172  : 		    NULL, ctxt->node, XML_FROM_CHECK,
; 173  : 		    error, XML_ERR_ERROR, NULL, 0,
; 174  : 		    NULL, NULL, NULL, 0, 0,
; 175  : 		    msg, extra);
; 176  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDebugErr2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_xmlDebugErr PROC					; COMDAT

; 159  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 160  :     ctxt->errors++;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 161  :     __xmlRaiseError(NULL, NULL, NULL,

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	2
	mov	ecx, DWORD PTR _error$[ebp]
	push	ecx
	push	24					; 00000018H
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+116]
	push	eax
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 162  : 		    NULL, ctxt->node, XML_FROM_CHECK,
; 163  : 		    error, XML_ERR_ERROR, NULL, 0,
; 164  : 		    NULL, NULL, NULL, 0, 0,
; 165  : 		    "%s", msg);
; 166  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDebugErr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpSpaces
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlCtxtDumpSpaces PROC					; COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 140  :     if (ctxt->check)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN2@xmlCtxtDum

; 141  :         return;

	jmp	SHORT $LN1@xmlCtxtDum
$LN2@xmlCtxtDum:

; 142  :     if ((ctxt->output != NULL) && (ctxt->depth > 0)) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@xmlCtxtDum
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+108], 0
	jle	SHORT $LN1@xmlCtxtDum

; 143  :         if (ctxt->depth < 50)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+108], 50			; 00000032H
	jge	SHORT $LN4@xmlCtxtDum

; 144  :             fprintf(ctxt->output, "%s", &ctxt->shift[100 - 2 * ctxt->depth]);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	shl	edx, 1
	mov	eax, 100				; 00000064H
	sub	eax, edx
	mov	ecx, DWORD PTR _ctxt$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@xmlCtxtDum
$LN4@xmlCtxtDum:

; 145  :         else
; 146  :             fprintf(ctxt->output, "%s", ctxt->shift);

	mov	edx, DWORD PTR _ctxt$[ebp]
	add	edx, 4
	push	edx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN1@xmlCtxtDum:

; 147  :     }
; 148  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpSpaces ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlNsCheckScope
_TEXT	SEGMENT
_oldNs$1 = -8						; size = 4
_cur$ = -4						; size = 4
_node$ = 8						; size = 4
_ns$ = 12						; size = 4
_xmlNsCheckScope PROC					; COMDAT

; 94   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 95   :     xmlNsPtr cur;
; 96   : 
; 97   :     if ((node == NULL) || (ns == NULL))

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN7@xmlNsCheck
	cmp	DWORD PTR _ns$[ebp], 0
	jne	SHORT $LN6@xmlNsCheck
$LN7@xmlNsCheck:

; 98   :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlNsCheck
$LN6@xmlNsCheck:

; 99   : 
; 100  :     if ((node->type != XML_ELEMENT_NODE) &&
; 101  : 	(node->type != XML_ATTRIBUTE_NODE) &&
; 102  : 	(node->type != XML_DOCUMENT_NODE) &&
; 103  : 	(node->type != XML_TEXT_NODE) &&
; 104  : 	(node->type != XML_HTML_DOCUMENT_NODE) &&

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN2@xmlNsCheck
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 2
	je	SHORT $LN2@xmlNsCheck
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 9
	je	SHORT $LN2@xmlNsCheck
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 3
	je	SHORT $LN2@xmlNsCheck
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	je	SHORT $LN2@xmlNsCheck
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 19			; 00000013H
	je	SHORT $LN2@xmlNsCheck

; 105  : 	(node->type != XML_XINCLUDE_START))
; 106  : 	return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@xmlNsCheck
$LN2@xmlNsCheck:

; 107  : 
; 108  :     while ((node != NULL) &&

	cmp	DWORD PTR _node$[ebp], 0
	je	$LN3@xmlNsCheck
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN9@xmlNsCheck
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 2
	je	SHORT $LN9@xmlNsCheck
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 3
	je	SHORT $LN9@xmlNsCheck
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 19			; 00000013H
	jne	SHORT $LN3@xmlNsCheck
$LN9@xmlNsCheck:

; 109  :            ((node->type == XML_ELEMENT_NODE) ||
; 110  :             (node->type == XML_ATTRIBUTE_NODE) ||
; 111  :             (node->type == XML_TEXT_NODE) ||
; 112  : 	    (node->type == XML_XINCLUDE_START))) {
; 113  : 	if ((node->type == XML_ELEMENT_NODE) ||

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	je	SHORT $LN11@xmlNsCheck
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 19			; 00000013H
	jne	SHORT $LN10@xmlNsCheck
$LN11@xmlNsCheck:

; 114  : 	    (node->type == XML_XINCLUDE_START)) {
; 115  : 	    cur = node->nsDef;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@xmlNsCheck:

; 116  : 	    while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN10@xmlNsCheck

; 117  : 	        if (cur == ns)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	edx, DWORD PTR _ns$[ebp]
	jne	SHORT $LN12@xmlNsCheck

; 118  : 		    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlNsCheck
$LN12@xmlNsCheck:

; 119  : 		if (xmlStrEqual(cur->prefix, ns->prefix))

	mov	eax, DWORD PTR _ns$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@xmlNsCheck

; 120  : 		    return(-2);

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@xmlNsCheck
$LN13@xmlNsCheck:

; 121  : 		cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx

; 122  : 	    }

	jmp	SHORT $LN4@xmlNsCheck
$LN10@xmlNsCheck:

; 123  : 	}
; 124  : 	node = node->parent;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _node$[ebp], ecx

; 125  :     }

	jmp	$LN2@xmlNsCheck
$LN3@xmlNsCheck:

; 126  :     /* the xml namespace may be declared on the document node */
; 127  :     if ((node != NULL) &&

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN14@xmlNsCheck
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 9
	je	SHORT $LN15@xmlNsCheck
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN14@xmlNsCheck
$LN15@xmlNsCheck:

; 128  :         ((node->type == XML_DOCUMENT_NODE) ||
; 129  : 	 (node->type == XML_HTML_DOCUMENT_NODE))) {
; 130  : 	 xmlNsPtr oldNs = ((xmlDocPtr) node)->oldNs;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR _oldNs$1[ebp], edx

; 131  : 	 if (oldNs == ns)

	mov	eax, DWORD PTR _oldNs$1[ebp]
	cmp	eax, DWORD PTR _ns$[ebp]
	jne	SHORT $LN14@xmlNsCheck

; 132  : 	     return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlNsCheck
$LN14@xmlNsCheck:

; 133  :     }
; 134  :     return(-3);

	mov	eax, -3					; fffffffdH
$LN1@xmlNsCheck:

; 135  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNsCheckScope ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpCleanCtxt
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_xmlCtxtDumpCleanCtxt PROC				; COMDAT

; 77   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 78   :  /* remove the ATTRIBUTE_UNUSED when this is added */
; 79   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpCleanCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpInitCtxt
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlCtxtDumpInitCtxt PROC				; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 59   :     int i;
; 60   : 
; 61   :     ctxt->depth = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+108], 0

; 62   :     ctxt->check = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 63   :     ctxt->errors = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+128], 0

; 64   :     ctxt->output = stdout;

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax

; 65   :     ctxt->doc = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+112], 0

; 66   :     ctxt->node = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+116], 0

; 67   :     ctxt->dict = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+120], 0

; 68   :     ctxt->nodict = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+132], 0

; 69   :     ctxt->options = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+136], 0

; 70   :     for (i = 0; i < 100; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlCtxtDum
$LN2@xmlCtxtDum:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlCtxtDum:
	cmp	DWORD PTR _i$[ebp], 100			; 00000064H
	jge	SHORT $LN3@xmlCtxtDum

; 71   :         ctxt->shift[i] = ' ';

	mov	edx, DWORD PTR _ctxt$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx+4], 32			; 00000020H
	jmp	SHORT $LN2@xmlCtxtDum
$LN3@xmlCtxtDum:

; 72   :     ctxt->shift[100] = 0;

	mov	eax, 1
	imul	ecx, eax, 100
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	BYTE PTR [edx+ecx+4], 0

; 73   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCtxtDumpInitCtxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlCtxtDumpNodeList
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlCtxtDumpNodeList PROC				; COMDAT

; 1090 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xmlCtxtDum:

; 1091 :     while (node != NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN1@xmlCtxtDum

; 1092 :         xmlCtxtDumpNode(ctxt, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpNode
	add	esp, 8

; 1093 :         node = node->next;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _node$[ebp], eax

; 1094 :     }

	jmp	SHORT $LN2@xmlCtxtDum
$LN1@xmlCtxtDum:

; 1095 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCtxtDumpNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShell
_TEXT	SEGMENT
tv1030 = -2640						; size = 4
tv1007 = -2636						; size = 4
tv2345 = -2632						; size = 4
tv2340 = -2626						; size = 1
tv2333 = -2625						; size = 1
tv2328 = -2624						; size = 4
tv2330 = -2620						; size = 4
tv916 = -2616						; size = 4
tv900 = -2612						; size = 4
tv2211 = -2605						; size = 1
tv2208 = -2604						; size = 4
tv2205 = -2600						; size = 4
tv887 = -2596						; size = 4
tv2193 = -2592						; size = 4
tv2188 = -2586						; size = 1
tv2181 = -2585						; size = 1
tv2176 = -2584						; size = 4
tv2178 = -2580						; size = 4
tv809 = -2576						; size = 4
tv783 = -2572						; size = 4
tv2068 = -2568						; size = 4
tv2063 = -2562						; size = 1
tv2056 = -2561						; size = 1
tv2051 = -2560						; size = 4
tv2053 = -2556						; size = 4
tv702 = -2552						; size = 4
tv674 = -2548						; size = 4
tv672 = -2544						; size = 4
tv1942 = -2540						; size = 4
tv1937 = -2534						; size = 1
tv1930 = -2533						; size = 1
tv1925 = -2532						; size = 4
tv1927 = -2528						; size = 4
tv635 = -2524						; size = 4
tv1921 = -2520						; size = 4
tv1916 = -2514						; size = 1
tv1909 = -2513						; size = 1
tv1904 = -2512						; size = 4
tv1906 = -2508						; size = 4
tv630 = -2504						; size = 4
tv1900 = -2500						; size = 4
tv1895 = -2494						; size = 1
tv1888 = -2493						; size = 1
tv1883 = -2492						; size = 4
tv1885 = -2488						; size = 4
tv620 = -2484						; size = 4
tv1875 = -2480						; size = 4
tv1870 = -2474						; size = 1
tv1863 = -2473						; size = 1
tv1858 = -2472						; size = 4
tv1860 = -2468						; size = 4
tv595 = -2464						; size = 4
tv1836 = -2460						; size = 4
tv1831 = -2454						; size = 1
tv1824 = -2453						; size = 1
tv1819 = -2452						; size = 4
tv1821 = -2448						; size = 4
tv583 = -2444						; size = 4
tv1810 = -2440						; size = 4
tv1805 = -2434						; size = 1
tv1798 = -2433						; size = 1
tv1793 = -2432						; size = 4
tv1795 = -2428						; size = 4
tv566 = -2424						; size = 4
tv1780 = -2420						; size = 4
tv1775 = -2414						; size = 1
tv1768 = -2413						; size = 1
tv1763 = -2412						; size = 4
tv1765 = -2408						; size = 4
tv556 = -2404						; size = 4
tv1755 = -2400						; size = 4
tv1750 = -2394						; size = 1
tv1743 = -2393						; size = 1
tv1738 = -2392						; size = 4
tv1740 = -2388						; size = 4
tv546 = -2384						; size = 4
tv1731 = -2380						; size = 4
tv1726 = -2374						; size = 1
tv1719 = -2373						; size = 1
tv1714 = -2372						; size = 4
tv1716 = -2368						; size = 4
tv474 = -2364						; size = 4
tv451 = -2360						; size = 4
tv1613 = -2356						; size = 4
tv1608 = -2350						; size = 1
tv1601 = -2349						; size = 1
tv1596 = -2348						; size = 4
tv1598 = -2344						; size = 4
tv435 = -2340						; size = 4
tv1584 = -2336						; size = 4
tv1579 = -2330						; size = 1
tv1572 = -2329						; size = 1
tv1567 = -2328						; size = 4
tv1569 = -2324						; size = 4
tv417 = -2320						; size = 4
tv1555 = -2316						; size = 4
tv1550 = -2310						; size = 1
tv1543 = -2309						; size = 1
tv1538 = -2308						; size = 4
tv1540 = -2304						; size = 4
tv407 = -2300						; size = 4
tv1530 = -2296						; size = 4
tv1525 = -2290						; size = 1
tv1518 = -2289						; size = 1
tv1513 = -2288						; size = 4
tv1515 = -2284						; size = 4
tv389 = -2280						; size = 4
tv1498 = -2276						; size = 4
tv1493 = -2270						; size = 1
tv1486 = -2269						; size = 1
tv1481 = -2268						; size = 4
tv1483 = -2264						; size = 4
tv380 = -2260						; size = 4
tv1475 = -2256						; size = 4
tv1470 = -2250						; size = 1
tv1463 = -2249						; size = 1
tv1458 = -2248						; size = 4
tv1460 = -2244						; size = 4
tv371 = -2240						; size = 4
tv1452 = -2236						; size = 4
tv1447 = -2230						; size = 1
tv1440 = -2229						; size = 1
tv1435 = -2228						; size = 4
tv1437 = -2224						; size = 4
tv362 = -2220						; size = 4
tv1429 = -2216						; size = 4
tv1424 = -2210						; size = 1
tv1417 = -2209						; size = 1
tv1412 = -2208						; size = 4
tv1414 = -2204						; size = 4
tv353 = -2200						; size = 4
tv1406 = -2196						; size = 4
tv1401 = -2190						; size = 1
tv1394 = -2189						; size = 1
tv1389 = -2188						; size = 4
tv1391 = -2184						; size = 4
tv238 = -2180						; size = 4
tv1333 = -2176						; size = 4
tv1328 = -2170						; size = 1
tv1321 = -2169						; size = 1
tv1316 = -2168						; size = 4
tv1318 = -2164						; size = 4
tv233 = -2160						; size = 4
tv1312 = -2156						; size = 4
tv1307 = -2150						; size = 1
tv1300 = -2149						; size = 1
tv1295 = -2148						; size = 4
tv1297 = -2144						; size = 4
tv228 = -2140						; size = 4
tv1291 = -2136						; size = 4
tv1286 = -2130						; size = 1
tv1279 = -2129						; size = 1
tv1274 = -2128						; size = 4
tv1276 = -2124						; size = 4
tv223 = -2120						; size = 4
tv1270 = -2116						; size = 4
tv1265 = -2110						; size = 1
tv1258 = -2109						; size = 1
tv1253 = -2108						; size = 4
tv1255 = -2104						; size = 4
_indx$1 = -2100						; size = 4
_l$2 = -2096						; size = 4
_indx$3 = -2092						; size = 4
_dir$4 = -2084						; size = 500
_indx$5 = -1580						; size = 4
_dir$6 = -1576						; size = 4
_root$7 = -1572						; size = 4
_indx$8 = -1568						; size = 4
_dir$9 = -1560						; size = 500
_len$10 = -1052						; size = 4
_list$ = -1044						; size = 4
_ctxt$ = -1040						; size = 4
_i$ = -1036						; size = 4
_arg$ = -1028						; size = 400
_command$ = -620					; size = 100
_cur$ = -516						; size = 4
_cmdline$ = -512					; size = 4
_prompt$ = -504						; size = 500
_doc$ = 8						; size = 4
_filename$ = 12						; size = 4
_input$ = 16						; size = 4
_output$ = 20						; size = 4
_xmlShell PROC						; COMDAT

; 2810 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2640				; 00000a50H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2640]
	mov	ecx, 660				; 00000294H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2811 :     char prompt[500] = "/ > ";

	mov	eax, DWORD PTR ??_C@_04GBAPPDDB@?1?5?$DO?5@
	mov	DWORD PTR _prompt$[ebp], eax
	mov	cl, BYTE PTR ??_C@_04GBAPPDDB@?1?5?$DO?5@+4
	mov	BYTE PTR _prompt$[ebp+4], cl
	push	495					; 000001efH
	push	0
	lea	edx, DWORD PTR _prompt$[ebp+5]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 2812 :     char *cmdline = NULL, *cur;

	mov	DWORD PTR _cmdline$[ebp], 0

; 2813 :     char command[100];
; 2814 :     char arg[400];
; 2815 :     int i;
; 2816 :     xmlShellCtxtPtr ctxt;
; 2817 :     xmlXPathObjectPtr list;
; 2818 : 
; 2819 :     if (doc == NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN34@xmlShell

; 2820 :         return;

	jmp	$LN1@xmlShell
$LN34@xmlShell:

; 2821 :     if (filename == NULL)

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN35@xmlShell

; 2822 :         return;

	jmp	$LN1@xmlShell
$LN35@xmlShell:

; 2823 :     if (input == NULL)

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN36@xmlShell

; 2824 :         return;

	jmp	$LN1@xmlShell
$LN36@xmlShell:

; 2825 :     if (output == NULL)

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN37@xmlShell

; 2826 :         output = stdout;

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _output$[ebp], eax
$LN37@xmlShell:

; 2827 :     ctxt = (xmlShellCtxtPtr) xmlMalloc(sizeof(xmlShellCtxt));

	mov	esi, esp
	push	28					; 0000001cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ctxt$[ebp], eax

; 2828 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN38@xmlShell

; 2829 :         return;

	jmp	$LN1@xmlShell
$LN38@xmlShell:

; 2830 :     ctxt->loaded = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+16], 0

; 2831 :     ctxt->doc = doc;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 2832 :     ctxt->input = input;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2833 :     ctxt->output = output;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _output$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2834 :     ctxt->filename = (char *) xmlStrdup((xmlChar *) filename);

	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], eax

; 2835 :     ctxt->node = (xmlNodePtr) ctxt->doc;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 2836 : 
; 2837 : #ifdef LIBXML_XPATH_ENABLED
; 2838 :     ctxt->pctxt = xmlXPathNewContext(ctxt->doc);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlXPathNewContext
	add	esp, 4
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+12], eax

; 2839 :     if (ctxt->pctxt == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN2@xmlShell

; 2840 :         xmlFree(ctxt);

	mov	esi, esp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2841 :         return;

	jmp	$LN1@xmlShell
$LN2@xmlShell:

; 2842 :     }
; 2843 : #endif /* LIBXML_XPATH_ENABLED */
; 2844 :     while (1) {

	mov	edx, 1
	test	edx, edx
	je	$LN3@xmlShell

; 2845 :         if (ctxt->node == (xmlNodePtr) ctxt->doc)

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN40@xmlShell

; 2846 :             snprintf(prompt, sizeof(prompt), "%s > ", "/");

	push	OFFSET ??_C@_01KMDKNFGN@?1@
	push	OFFSET ??_C@_05LMGNBDMA@?$CFs?5?$DO?5@
	push	500					; 000001f4H
	lea	eax, DWORD PTR _prompt$[ebp]
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
	jmp	$LN41@xmlShell
$LN40@xmlShell:

; 2847 :         else if ((ctxt->node != NULL) && (ctxt->node->name) &&
; 2848 :                  (ctxt->node->ns) && (ctxt->node->ns->prefix))

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN42@xmlShell
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN42@xmlShell
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN42@xmlShell
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN42@xmlShell

; 2849 :             snprintf(prompt, sizeof(prompt), "%s:%s > ",

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET ??_C@_08NAMANEO@?$CFs?3?$CFs?5?$DO?5@
	push	500					; 000001f4H
	lea	ecx, DWORD PTR _prompt$[ebp]
	push	ecx
	call	_snprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN41@xmlShell
$LN42@xmlShell:

; 2850 :                      (ctxt->node->ns->prefix), ctxt->node->name);
; 2851 :         else if ((ctxt->node != NULL) && (ctxt->node->name))

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN44@xmlShell
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN44@xmlShell

; 2852 :             snprintf(prompt, sizeof(prompt), "%s > ", ctxt->node->name);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_05LMGNBDMA@?$CFs?5?$DO?5@
	push	500					; 000001f4H
	lea	edx, DWORD PTR _prompt$[ebp]
	push	edx
	call	_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN41@xmlShell
$LN44@xmlShell:

; 2853 :         else
; 2854 :             snprintf(prompt, sizeof(prompt), "? > ");

	push	OFFSET ??_C@_04BOPGELD@?$DP?5?$DO?5@
	push	500					; 000001f4H
	lea	eax, DWORD PTR _prompt$[ebp]
	push	eax
	call	_snprintf
	add	esp, 12					; 0000000cH
$LN41@xmlShell:

; 2855 :         prompt[sizeof(prompt) - 1] = 0;

	mov	ecx, 1
	imul	edx, ecx, 499
	mov	BYTE PTR _prompt$[ebp+edx], 0

; 2856 : 
; 2857 :         /*
; 2858 :          * Get a new command line
; 2859 :          */
; 2860 :         cmdline = ctxt->input(prompt);

	mov	esi, esp
	lea	eax, DWORD PTR _prompt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cmdline$[ebp], eax

; 2861 :         if (cmdline == NULL)

	cmp	DWORD PTR _cmdline$[ebp], 0
	jne	SHORT $LN46@xmlShell

; 2862 :             break;

	jmp	$LN3@xmlShell
$LN46@xmlShell:

; 2863 : 
; 2864 :         /*
; 2865 :          * Parse the command itself
; 2866 :          */
; 2867 :         cur = cmdline;

	mov	eax, DWORD PTR _cmdline$[ebp]
	mov	DWORD PTR _cur$[ebp], eax
$LN4@xmlShell:

; 2868 :         while ((*cur == ' ') || (*cur == '\t'))

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN47@xmlShell
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jne	SHORT $LN5@xmlShell
$LN47@xmlShell:

; 2869 :             cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN4@xmlShell
$LN5@xmlShell:

; 2870 :         i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN6@xmlShell:

; 2871 :         while ((*cur != ' ') && (*cur != '\t') &&
; 2872 :                (*cur != '\n') && (*cur != '\r')) {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN7@xmlShell
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	je	SHORT $LN7@xmlShell
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN7@xmlShell
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN7@xmlShell

; 2873 :             if (*cur == 0)

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN48@xmlShell

; 2874 :                 break;

	jmp	SHORT $LN7@xmlShell
$LN48@xmlShell:

; 2875 :             command[i++] = *cur++;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _command$[ebp+ecx], al
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 2876 :         }

	jmp	SHORT $LN6@xmlShell
$LN7@xmlShell:

; 2877 :         command[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _command$[ebp+eax], 0

; 2878 :         if (i == 0)

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN8@xmlShell

; 2879 :             continue;

	jmp	$LN2@xmlShell
$LN8@xmlShell:

; 2880 : 
; 2881 :         /*
; 2882 :          * Parse the argument
; 2883 :          */
; 2884 :         while ((*cur == ' ') || (*cur == '\t'))

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN50@xmlShell
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jne	SHORT $LN9@xmlShell
$LN50@xmlShell:

; 2885 :             cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN8@xmlShell
$LN9@xmlShell:

; 2886 :         i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN10@xmlShell:

; 2887 :         while ((*cur != '\n') && (*cur != '\r') && (*cur != 0)) {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN11@xmlShell
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN11@xmlShell
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN11@xmlShell

; 2888 :             if (*cur == 0)

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN51@xmlShell

; 2889 :                 break;

	jmp	SHORT $LN11@xmlShell
$LN51@xmlShell:

; 2890 :             arg[i++] = *cur++;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _arg$[ebp+edx], cl
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 2891 :         }

	jmp	SHORT $LN10@xmlShell
$LN11@xmlShell:

; 2892 :         arg[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _arg$[ebp+ecx], 0

; 2893 : 
; 2894 :         /*
; 2895 :          * start interpreting the command
; 2896 :          */
; 2897 :         if (!strcmp(command, "exit"))

	mov	DWORD PTR tv1255[ebp], OFFSET ??_C@_04MKNBDEPB@exit@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1253[ebp], edx
$LL199@xmlShell:
	mov	eax, DWORD PTR tv1253[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1258[ebp], cl
	mov	edx, DWORD PTR tv1255[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN200@xmlShell
	cmp	BYTE PTR tv1258[ebp], 0
	je	SHORT $LN201@xmlShell
	mov	eax, DWORD PTR tv1253[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1265[ebp], cl
	mov	edx, DWORD PTR tv1255[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN200@xmlShell
	add	DWORD PTR tv1253[ebp], 2
	add	DWORD PTR tv1255[ebp], 2
	cmp	BYTE PTR tv1265[ebp], 0
	jne	SHORT $LL199@xmlShell
$LN201@xmlShell:
	mov	DWORD PTR tv1270[ebp], 0
	jmp	SHORT $LN202@xmlShell
$LN200@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1270[ebp], eax
$LN202@xmlShell:
	mov	ecx, DWORD PTR tv1270[ebp]
	mov	DWORD PTR tv223[ebp], ecx
	cmp	DWORD PTR tv223[ebp], 0
	jne	SHORT $LN52@xmlShell

; 2898 :             break;

	jmp	$LN3@xmlShell
$LN52@xmlShell:

; 2899 :         if (!strcmp(command, "quit"))

	mov	DWORD PTR tv1276[ebp], OFFSET ??_C@_04KNNLNNGO@quit@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1274[ebp], edx
$LL203@xmlShell:
	mov	eax, DWORD PTR tv1274[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1279[ebp], cl
	mov	edx, DWORD PTR tv1276[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN204@xmlShell
	cmp	BYTE PTR tv1279[ebp], 0
	je	SHORT $LN205@xmlShell
	mov	eax, DWORD PTR tv1274[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1286[ebp], cl
	mov	edx, DWORD PTR tv1276[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN204@xmlShell
	add	DWORD PTR tv1274[ebp], 2
	add	DWORD PTR tv1276[ebp], 2
	cmp	BYTE PTR tv1286[ebp], 0
	jne	SHORT $LL203@xmlShell
$LN205@xmlShell:
	mov	DWORD PTR tv1291[ebp], 0
	jmp	SHORT $LN206@xmlShell
$LN204@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1291[ebp], eax
$LN206@xmlShell:
	mov	ecx, DWORD PTR tv1291[ebp]
	mov	DWORD PTR tv228[ebp], ecx
	cmp	DWORD PTR tv228[ebp], 0
	jne	SHORT $LN53@xmlShell

; 2900 :             break;

	jmp	$LN3@xmlShell
$LN53@xmlShell:

; 2901 :         if (!strcmp(command, "bye"))

	mov	DWORD PTR tv1297[ebp], OFFSET ??_C@_03MDONDFG@bye@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1295[ebp], edx
$LL207@xmlShell:
	mov	eax, DWORD PTR tv1295[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1300[ebp], cl
	mov	edx, DWORD PTR tv1297[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN208@xmlShell
	cmp	BYTE PTR tv1300[ebp], 0
	je	SHORT $LN209@xmlShell
	mov	eax, DWORD PTR tv1295[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1307[ebp], cl
	mov	edx, DWORD PTR tv1297[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN208@xmlShell
	add	DWORD PTR tv1295[ebp], 2
	add	DWORD PTR tv1297[ebp], 2
	cmp	BYTE PTR tv1307[ebp], 0
	jne	SHORT $LL207@xmlShell
$LN209@xmlShell:
	mov	DWORD PTR tv1312[ebp], 0
	jmp	SHORT $LN210@xmlShell
$LN208@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1312[ebp], eax
$LN210@xmlShell:
	mov	ecx, DWORD PTR tv1312[ebp]
	mov	DWORD PTR tv233[ebp], ecx
	cmp	DWORD PTR tv233[ebp], 0
	jne	SHORT $LN54@xmlShell

; 2902 :             break;

	jmp	$LN3@xmlShell
$LN54@xmlShell:

; 2903 : 		if (!strcmp(command, "help")) {

	mov	DWORD PTR tv1318[ebp], OFFSET ??_C@_04PCJFHION@help@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1316[ebp], edx
$LL211@xmlShell:
	mov	eax, DWORD PTR tv1316[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1321[ebp], cl
	mov	edx, DWORD PTR tv1318[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN212@xmlShell
	cmp	BYTE PTR tv1321[ebp], 0
	je	SHORT $LN213@xmlShell
	mov	eax, DWORD PTR tv1316[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1328[ebp], cl
	mov	edx, DWORD PTR tv1318[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN212@xmlShell
	add	DWORD PTR tv1316[ebp], 2
	add	DWORD PTR tv1318[ebp], 2
	cmp	BYTE PTR tv1328[ebp], 0
	jne	SHORT $LL211@xmlShell
$LN213@xmlShell:
	mov	DWORD PTR tv1333[ebp], 0
	jmp	SHORT $LN214@xmlShell
$LN212@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1333[ebp], eax
$LN214@xmlShell:
	mov	ecx, DWORD PTR tv1333[ebp]
	mov	DWORD PTR tv238[ebp], ecx
	cmp	DWORD PTR tv238[ebp], 0
	jne	$LN55@xmlShell

; 2904 : 		  fprintf(ctxt->output, "\tbase         display XML base of the node\n");

	push	OFFSET ??_C@_0CM@NDCHEKFM@?7base?5?5?5?5?5?5?5?5?5display?5XML?5base?5@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8

; 2905 : 		  fprintf(ctxt->output, "\tsetbase URI  change the XML base of the node\n");

	push	OFFSET ??_C@_0CP@IHKKPKPH@?7setbase?5URI?5?5change?5the?5XML?5ba@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 8

; 2906 : 		  fprintf(ctxt->output, "\tbye          leave shell\n");

	push	OFFSET ??_C@_0BL@PONCJHLM@?7bye?5?5?5?5?5?5?5?5?5?5leave?5shell?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2907 : 		  fprintf(ctxt->output, "\tcat [node]   display node or current node\n");

	push	OFFSET ??_C@_0CM@PEHFLABL@?7cat?5?$FLnode?$FN?5?5?5display?5node?5or?5c@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8

; 2908 : 		  fprintf(ctxt->output, "\tcd [path]    change directory to path or to root\n");

	push	OFFSET ??_C@_0DD@INLKBBOJ@?7cd?5?$FLpath?$FN?5?5?5?5change?5directory?5@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 8

; 2909 : 		  fprintf(ctxt->output, "\tdir [path]   dumps informations about the node (namespace, attributes, content)\n");

	push	OFFSET ??_C@_0FC@CJOILHDF@?7dir?5?$FLpath?$FN?5?5?5dumps?5information@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2910 : 		  fprintf(ctxt->output, "\tdu [path]    show the structure of the subtree under path or the current node\n");

	push	OFFSET ??_C@_0FA@JDAPDGGD@?7du?5?$FLpath?$FN?5?5?5?5show?5the?5structur@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8

; 2911 : 		  fprintf(ctxt->output, "\texit         leave shell\n");

	push	OFFSET ??_C@_0BL@DMHFOAJK@?7exit?5?5?5?5?5?5?5?5?5leave?5shell?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 8

; 2912 : 		  fprintf(ctxt->output, "\thelp         display this help\n");

	push	OFFSET ??_C@_0CB@KJCEEKOD@?7help?5?5?5?5?5?5?5?5?5display?5this?5help@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2913 : 		  fprintf(ctxt->output, "\tfree         display memory usage\n");

	push	OFFSET ??_C@_0CE@EBLDPJOB@?7free?5?5?5?5?5?5?5?5?5display?5memory?5us@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8

; 2914 : 		  fprintf(ctxt->output, "\tload [name]  load a new document with name\n");

	push	OFFSET ??_C@_0CN@FDDLIHG@?7load?5?$FLname?$FN?5?5load?5a?5new?5docume@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 8

; 2915 : 		  fprintf(ctxt->output, "\tls [path]    list contents of path or the current directory\n");

	push	OFFSET ??_C@_0DO@BNGPDHN@?7ls?5?$FLpath?$FN?5?5?5?5list?5contents?5of?5@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2916 : 		  fprintf(ctxt->output, "\tset xml_fragment replace the current node content with the fragment parsed in context\n");

	push	OFFSET ??_C@_0FI@EINANLEN@?7set?5xml_fragment?5replace?5the?5c@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8

; 2917 : #ifdef LIBXML_XPATH_ENABLED
; 2918 : 		  fprintf(ctxt->output, "\txpath expr   evaluate the XPath expression in that context and print the result\n");

	push	OFFSET ??_C@_0FC@MFFCIEFJ@?7xpath?5expr?5?5?5evaluate?5the?5XPat@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 8

; 2919 : 		  fprintf(ctxt->output, "\tsetns nsreg  register a namespace to a prefix in the XPath evaluation context\n");

	push	OFFSET ??_C@_0FA@BEOPGMKK@?7setns?5nsreg?5?5register?5a?5namesp@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2920 : 		  fprintf(ctxt->output, "\t             format for nsreg is: prefix=[nsuri] (i.e. prefix= unsets a prefix)\n");

	push	OFFSET ??_C@_0FC@FBKBHIJ@?7?5?5?5?5?5?5?5?5?5?5?5?5?5format?5for?5nsreg?5@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8

; 2921 : 		  fprintf(ctxt->output, "\tsetrootns    register all namespace found on the root element\n");

	push	OFFSET ??_C@_0EA@FAEACHOL@?7setrootns?5?5?5?5register?5all?5name@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 8

; 2922 : 		  fprintf(ctxt->output, "\t             the default namespace if any uses 'defaultns' prefix\n");

	push	OFFSET ??_C@_0EE@CPGFHAIM@?7?5?5?5?5?5?5?5?5?5?5?5?5?5the?5default?5names@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2923 : #endif /* LIBXML_XPATH_ENABLED */
; 2924 : 		  fprintf(ctxt->output, "\tpwd          display current working directory\n");

	push	OFFSET ??_C@_0DB@GHFOJJKM@?7pwd?5?5?5?5?5?5?5?5?5?5display?5current?5w@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8

; 2925 : 		  fprintf(ctxt->output, "\twhereis      display absolute path of [path] or current working directory\n");

	push	OFFSET ??_C@_0EM@EFGOHPBI@?7whereis?5?5?5?5?5?5display?5absolute?5@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 8

; 2926 : 		  fprintf(ctxt->output, "\tquit         leave shell\n");

	push	OFFSET ??_C@_0BL@MOIOGEHO@?7quit?5?5?5?5?5?5?5?5?5leave?5shell?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2927 : #ifdef LIBXML_OUTPUT_ENABLED
; 2928 : 		  fprintf(ctxt->output, "\tsave [name]  save this document to name or the original name\n");

	push	OFFSET ??_C@_0DP@KEMKGHON@?7save?5?$FLname?$FN?5?5save?5this?5documen@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8

; 2929 : 		  fprintf(ctxt->output, "\twrite [name] write the current node to the filename\n");

	push	OFFSET ??_C@_0DG@GCDJELAH@?7write?5?$FLname?$FN?5write?5the?5current@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 8

; 2930 : #endif /* LIBXML_OUTPUT_ENABLED */
; 2931 : #ifdef LIBXML_VALID_ENABLED
; 2932 : 		  fprintf(ctxt->output, "\tvalidate     check the document for errors\n");

	push	OFFSET ??_C@_0CN@LCGGCNEC@?7validate?5?5?5?5?5check?5the?5documen@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2933 : #endif /* LIBXML_VALID_ENABLED */
; 2934 : #ifdef LIBXML_SCHEMAS_ENABLED
; 2935 : 		  fprintf(ctxt->output, "\trelaxng rng  validate the document against the Relax-NG schemas\n");

	push	OFFSET ??_C@_0EC@OAJIGDJF@?7relaxng?5rng?5?5validate?5the?5docu@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8

; 2936 : #endif
; 2937 : 		  fprintf(ctxt->output, "\tgrep string  search for a string in the subtree\n");

	push	OFFSET ??_C@_0DC@LPOKEKPE@?7grep?5string?5?5search?5for?5a?5stri@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 8
	jmp	$LN56@xmlShell
$LN55@xmlShell:

; 2938 : #ifdef LIBXML_VALID_ENABLED
; 2939 :         } else if (!strcmp(command, "validate")) {

	mov	DWORD PTR tv1391[ebp], OFFSET ??_C@_08EBLJJHKN@validate@
	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1389[ebp], eax
$LL215@xmlShell:
	mov	ecx, DWORD PTR tv1389[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1394[ebp], dl
	mov	eax, DWORD PTR tv1391[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN216@xmlShell
	cmp	BYTE PTR tv1394[ebp], 0
	je	SHORT $LN217@xmlShell
	mov	ecx, DWORD PTR tv1389[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1401[ebp], dl
	mov	eax, DWORD PTR tv1391[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN216@xmlShell
	add	DWORD PTR tv1389[ebp], 2
	add	DWORD PTR tv1391[ebp], 2
	cmp	BYTE PTR tv1401[ebp], 0
	jne	SHORT $LL215@xmlShell
$LN217@xmlShell:
	mov	DWORD PTR tv1406[ebp], 0
	jmp	SHORT $LN218@xmlShell
$LN216@xmlShell:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1406[ebp], ecx
$LN218@xmlShell:
	mov	edx, DWORD PTR tv1406[ebp]
	mov	DWORD PTR tv353[ebp], edx
	cmp	DWORD PTR tv353[ebp], 0
	jne	SHORT $LN57@xmlShell

; 2940 :             xmlShellValidate(ctxt, arg, NULL, NULL);

	push	0
	push	0
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlShellValidate
	add	esp, 16					; 00000010H
	jmp	$LN56@xmlShell
$LN57@xmlShell:

; 2941 : #endif /* LIBXML_VALID_ENABLED */
; 2942 :         } else if (!strcmp(command, "load")) {

	mov	DWORD PTR tv1414[ebp], OFFSET ??_C@_04EONOHKEP@load@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1412[ebp], edx
$LL219@xmlShell:
	mov	eax, DWORD PTR tv1412[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1417[ebp], cl
	mov	edx, DWORD PTR tv1414[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN220@xmlShell
	cmp	BYTE PTR tv1417[ebp], 0
	je	SHORT $LN221@xmlShell
	mov	eax, DWORD PTR tv1412[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1424[ebp], cl
	mov	edx, DWORD PTR tv1414[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN220@xmlShell
	add	DWORD PTR tv1412[ebp], 2
	add	DWORD PTR tv1414[ebp], 2
	cmp	BYTE PTR tv1424[ebp], 0
	jne	SHORT $LL219@xmlShell
$LN221@xmlShell:
	mov	DWORD PTR tv1429[ebp], 0
	jmp	SHORT $LN222@xmlShell
$LN220@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1429[ebp], eax
$LN222@xmlShell:
	mov	ecx, DWORD PTR tv1429[ebp]
	mov	DWORD PTR tv362[ebp], ecx
	cmp	DWORD PTR tv362[ebp], 0
	jne	SHORT $LN59@xmlShell

; 2943 :             xmlShellLoad(ctxt, arg, NULL, NULL);

	push	0
	push	0
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlShellLoad
	add	esp, 16					; 00000010H
	jmp	$LN56@xmlShell
$LN59@xmlShell:

; 2944 : #ifdef LIBXML_SCHEMAS_ENABLED
; 2945 :         } else if (!strcmp(command, "relaxng")) {

	mov	DWORD PTR tv1437[ebp], OFFSET ??_C@_07LADMNHNM@relaxng@
	lea	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1435[ebp], ecx
$LL223@xmlShell:
	mov	edx, DWORD PTR tv1435[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1440[ebp], al
	mov	ecx, DWORD PTR tv1437[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN224@xmlShell
	cmp	BYTE PTR tv1440[ebp], 0
	je	SHORT $LN225@xmlShell
	mov	edx, DWORD PTR tv1435[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1447[ebp], al
	mov	ecx, DWORD PTR tv1437[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN224@xmlShell
	add	DWORD PTR tv1435[ebp], 2
	add	DWORD PTR tv1437[ebp], 2
	cmp	BYTE PTR tv1447[ebp], 0
	jne	SHORT $LL223@xmlShell
$LN225@xmlShell:
	mov	DWORD PTR tv1452[ebp], 0
	jmp	SHORT $LN226@xmlShell
$LN224@xmlShell:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1452[ebp], edx
$LN226@xmlShell:
	mov	eax, DWORD PTR tv1452[ebp]
	mov	DWORD PTR tv371[ebp], eax
	cmp	DWORD PTR tv371[ebp], 0
	jne	SHORT $LN61@xmlShell

; 2946 :             xmlShellRNGValidate(ctxt, arg, NULL, NULL);

	push	0
	push	0
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlShellRNGValidate
	add	esp, 16					; 00000010H
	jmp	$LN56@xmlShell
$LN61@xmlShell:

; 2947 : #endif
; 2948 : #ifdef LIBXML_OUTPUT_ENABLED
; 2949 :         } else if (!strcmp(command, "save")) {

	mov	DWORD PTR tv1460[ebp], OFFSET ??_C@_04EMMDIJJL@save@
	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1458[ebp], eax
$LL227@xmlShell:
	mov	ecx, DWORD PTR tv1458[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1463[ebp], dl
	mov	eax, DWORD PTR tv1460[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN228@xmlShell
	cmp	BYTE PTR tv1463[ebp], 0
	je	SHORT $LN229@xmlShell
	mov	ecx, DWORD PTR tv1458[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1470[ebp], dl
	mov	eax, DWORD PTR tv1460[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN228@xmlShell
	add	DWORD PTR tv1458[ebp], 2
	add	DWORD PTR tv1460[ebp], 2
	cmp	BYTE PTR tv1470[ebp], 0
	jne	SHORT $LL227@xmlShell
$LN229@xmlShell:
	mov	DWORD PTR tv1475[ebp], 0
	jmp	SHORT $LN230@xmlShell
$LN228@xmlShell:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1475[ebp], ecx
$LN230@xmlShell:
	mov	edx, DWORD PTR tv1475[ebp]
	mov	DWORD PTR tv380[ebp], edx
	cmp	DWORD PTR tv380[ebp], 0
	jne	SHORT $LN63@xmlShell

; 2950 :             xmlShellSave(ctxt, arg, NULL, NULL);

	push	0
	push	0
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlShellSave
	add	esp, 16					; 00000010H
	jmp	$LN56@xmlShell
$LN63@xmlShell:

; 2951 :         } else if (!strcmp(command, "write")) {

	mov	DWORD PTR tv1483[ebp], OFFSET ??_C@_05NGFEDHGN@write@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1481[ebp], edx
$LL231@xmlShell:
	mov	eax, DWORD PTR tv1481[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1486[ebp], cl
	mov	edx, DWORD PTR tv1483[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN232@xmlShell
	cmp	BYTE PTR tv1486[ebp], 0
	je	SHORT $LN233@xmlShell
	mov	eax, DWORD PTR tv1481[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1493[ebp], cl
	mov	edx, DWORD PTR tv1483[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN232@xmlShell
	add	DWORD PTR tv1481[ebp], 2
	add	DWORD PTR tv1483[ebp], 2
	cmp	BYTE PTR tv1493[ebp], 0
	jne	SHORT $LL231@xmlShell
$LN233@xmlShell:
	mov	DWORD PTR tv1498[ebp], 0
	jmp	SHORT $LN234@xmlShell
$LN232@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1498[ebp], eax
$LN234@xmlShell:
	mov	ecx, DWORD PTR tv1498[ebp]
	mov	DWORD PTR tv389[ebp], ecx
	cmp	DWORD PTR tv389[ebp], 0
	jne	SHORT $LN65@xmlShell

; 2952 : 	    if (arg[0] == 0)

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _arg$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN67@xmlShell

; 2953 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CM@DPLMFOBB@Write?5command?5requires?5a?5filena@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN68@xmlShell
$LN67@xmlShell:

; 2954 :                         "Write command requires a filename argument\n");
; 2955 : 	    else
; 2956 : 		xmlShellWrite(ctxt, arg, ctxt->node, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlShellWrite
	add	esp, 16					; 00000010H
$LN68@xmlShell:

; 2957 : #endif /* LIBXML_OUTPUT_ENABLED */
; 2958 :         } else if (!strcmp(command, "grep")) {

	jmp	$LN56@xmlShell
$LN65@xmlShell:
	mov	DWORD PTR tv1515[ebp], OFFSET ??_C@_04LCNKLLJF@grep@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1513[ebp], edx
$LL235@xmlShell:
	mov	eax, DWORD PTR tv1513[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1518[ebp], cl
	mov	edx, DWORD PTR tv1515[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN236@xmlShell
	cmp	BYTE PTR tv1518[ebp], 0
	je	SHORT $LN237@xmlShell
	mov	eax, DWORD PTR tv1513[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1525[ebp], cl
	mov	edx, DWORD PTR tv1515[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN236@xmlShell
	add	DWORD PTR tv1513[ebp], 2
	add	DWORD PTR tv1515[ebp], 2
	cmp	BYTE PTR tv1525[ebp], 0
	jne	SHORT $LL235@xmlShell
$LN237@xmlShell:
	mov	DWORD PTR tv1530[ebp], 0
	jmp	SHORT $LN238@xmlShell
$LN236@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1530[ebp], eax
$LN238@xmlShell:
	mov	ecx, DWORD PTR tv1530[ebp]
	mov	DWORD PTR tv407[ebp], ecx
	cmp	DWORD PTR tv407[ebp], 0
	jne	SHORT $LN69@xmlShell

; 2959 :             xmlShellGrep(ctxt, arg, ctxt->node, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlShellGrep
	add	esp, 16					; 00000010H
	jmp	$LN56@xmlShell
$LN69@xmlShell:

; 2960 :         } else if (!strcmp(command, "free")) {

	mov	DWORD PTR tv1540[ebp], OFFSET ??_C@_04LIAPHEDB@free@
	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1538[ebp], eax
$LL239@xmlShell:
	mov	ecx, DWORD PTR tv1538[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1543[ebp], dl
	mov	eax, DWORD PTR tv1540[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN240@xmlShell
	cmp	BYTE PTR tv1543[ebp], 0
	je	SHORT $LN241@xmlShell
	mov	ecx, DWORD PTR tv1538[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1550[ebp], dl
	mov	eax, DWORD PTR tv1540[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN240@xmlShell
	add	DWORD PTR tv1538[ebp], 2
	add	DWORD PTR tv1540[ebp], 2
	cmp	BYTE PTR tv1550[ebp], 0
	jne	SHORT $LL239@xmlShell
$LN241@xmlShell:
	mov	DWORD PTR tv1555[ebp], 0
	jmp	SHORT $LN242@xmlShell
$LN240@xmlShell:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1555[ebp], ecx
$LN242@xmlShell:
	mov	edx, DWORD PTR tv1555[ebp]
	mov	DWORD PTR tv417[ebp], edx
	cmp	DWORD PTR tv417[ebp], 0
	jne	SHORT $LN71@xmlShell

; 2961 :             if (arg[0] == 0) {

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _arg$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN73@xmlShell

; 2962 :                 xmlMemShow(ctxt->output, 0);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_xmlMemShow
	add	esp, 8

; 2963 :             } else {

	jmp	SHORT $LN74@xmlShell
$LN73@xmlShell:

; 2964 :                 int len = 0;

	mov	DWORD PTR _len$10[ebp], 0

; 2965 : 
; 2966 :                 sscanf(arg, "%d", &len);

	lea	edx, DWORD PTR _len$10[ebp]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH

; 2967 :                 xmlMemShow(ctxt->output, len);

	mov	ecx, DWORD PTR _len$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlMemShow
	add	esp, 8
$LN74@xmlShell:

; 2968 :             }

	jmp	$LN56@xmlShell
$LN71@xmlShell:

; 2969 :         } else if (!strcmp(command, "pwd")) {

	mov	DWORD PTR tv1569[ebp], OFFSET ??_C@_03OFKLFAAJ@pwd@
	lea	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1567[ebp], ecx
$LL243@xmlShell:
	mov	edx, DWORD PTR tv1567[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1572[ebp], al
	mov	ecx, DWORD PTR tv1569[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN244@xmlShell
	cmp	BYTE PTR tv1572[ebp], 0
	je	SHORT $LN245@xmlShell
	mov	edx, DWORD PTR tv1567[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1579[ebp], al
	mov	ecx, DWORD PTR tv1569[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN244@xmlShell
	add	DWORD PTR tv1567[ebp], 2
	add	DWORD PTR tv1569[ebp], 2
	cmp	BYTE PTR tv1579[ebp], 0
	jne	SHORT $LL243@xmlShell
$LN245@xmlShell:
	mov	DWORD PTR tv1584[ebp], 0
	jmp	SHORT $LN246@xmlShell
$LN244@xmlShell:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1584[ebp], edx
$LN246@xmlShell:
	mov	eax, DWORD PTR tv1584[ebp]
	mov	DWORD PTR tv435[ebp], eax
	cmp	DWORD PTR tv435[ebp], 0
	jne	SHORT $LN75@xmlShell

; 2970 :             char dir[500];
; 2971 : 
; 2972 :             if (!xmlShellPwd(ctxt, dir, ctxt->node, NULL))

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR _dir$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlShellPwd
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN77@xmlShell

; 2973 :                 fprintf(ctxt->output, "%s\n", dir);

	lea	edx, DWORD PTR _dir$9[ebp]
	push	edx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN77@xmlShell:

; 2974 :         } else if (!strcmp(command, "du")) {

	jmp	$LN56@xmlShell
$LN75@xmlShell:
	mov	DWORD PTR tv1598[ebp], OFFSET ??_C@_02BNCIMIKC@du@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1596[ebp], edx
$LL247@xmlShell:
	mov	eax, DWORD PTR tv1596[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1601[ebp], cl
	mov	edx, DWORD PTR tv1598[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN248@xmlShell
	cmp	BYTE PTR tv1601[ebp], 0
	je	SHORT $LN249@xmlShell
	mov	eax, DWORD PTR tv1596[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1608[ebp], cl
	mov	edx, DWORD PTR tv1598[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN248@xmlShell
	add	DWORD PTR tv1596[ebp], 2
	add	DWORD PTR tv1598[ebp], 2
	cmp	BYTE PTR tv1608[ebp], 0
	jne	SHORT $LL247@xmlShell
$LN249@xmlShell:
	mov	DWORD PTR tv1613[ebp], 0
	jmp	SHORT $LN250@xmlShell
$LN248@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1613[ebp], eax
$LN250@xmlShell:
	mov	ecx, DWORD PTR tv1613[ebp]
	mov	DWORD PTR tv451[ebp], ecx
	cmp	DWORD PTR tv451[ebp], 0
	jne	$LN78@xmlShell

; 2975 :             if (arg[0] == 0) {

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _arg$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN80@xmlShell

; 2976 :                 xmlShellDu(ctxt, NULL, ctxt->node, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlShellDu
	add	esp, 16					; 00000010H

; 2977 :             } else {

	jmp	$LN81@xmlShell
$LN80@xmlShell:

; 2978 :                 ctxt->pctxt->node = ctxt->node;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx

; 2979 : #ifdef LIBXML_XPATH_ENABLED
; 2980 :                 ctxt->pctxt->node = ctxt->node;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+4], eax

; 2981 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_xmlXPathEval
	add	esp, 8
	mov	DWORD PTR _list$[ebp], eax

; 2982 : #else
; 2983 :                 list = NULL;
; 2984 : #endif /* LIBXML_XPATH_ENABLED */
; 2985 :                 if (list != NULL) {

	cmp	DWORD PTR _list$[ebp], 0
	je	$LN82@xmlShell

; 2986 :                     switch (list->type) {

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv474[ebp], edx
	cmp	DWORD PTR tv474[ebp], 9
	ja	$LN12@xmlShell
	mov	eax, DWORD PTR tv474[ebp]
	jmp	DWORD PTR $LN308@xmlShell[eax*4]
$LN84@xmlShell:

; 2987 :                         case XPATH_UNDEFINED:
; 2988 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2989 :                                             "%s: no such node\n", arg);
; 2990 :                             break;

	jmp	$LN12@xmlShell
$LN85@xmlShell:

; 2991 :                         case XPATH_NODESET:{
; 2992 :                             int indx;
; 2993 : 
; 2994 :                             if (list->nodesetval == NULL)

	mov	ecx, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN86@xmlShell

; 2995 :                                 break;

	jmp	$LN12@xmlShell
$LN86@xmlShell:

; 2996 : 
; 2997 :                             for (indx = 0;

	mov	DWORD PTR _indx$8[ebp], 0
	jmp	SHORT $LN16@xmlShell
$LN14@xmlShell:

; 2999 :                                  indx++)

	mov	edx, DWORD PTR _indx$8[ebp]
	add	edx, 1
	mov	DWORD PTR _indx$8[ebp], edx
$LN16@xmlShell:

; 2998 :                                  indx < list->nodesetval->nodeNr;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _indx$8[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN15@xmlShell

; 3000 :                                 xmlShellDu(ctxt, NULL,

	push	0
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _indx$8[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlShellDu
	add	esp, 16					; 00000010H
	jmp	SHORT $LN14@xmlShell
$LN15@xmlShell:

; 3001 :                                            list->nodesetval->
; 3002 :                                            nodeTab[indx], NULL);
; 3003 :                             break;

	jmp	$LN12@xmlShell
$LN87@xmlShell:

; 3004 :                         }
; 3005 :                         case XPATH_BOOLEAN:
; 3006 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3007 :                                             "%s is a Boolean\n", arg);
; 3008 :                             break;

	jmp	$LN12@xmlShell
$LN88@xmlShell:

; 3009 :                         case XPATH_NUMBER:
; 3010 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3011 :                                             "%s is a number\n", arg);
; 3012 :                             break;

	jmp	$LN12@xmlShell
$LN89@xmlShell:

; 3013 :                         case XPATH_STRING:
; 3014 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3015 :                                             "%s is a string\n", arg);
; 3016 :                             break;

	jmp	$LN12@xmlShell
$LN90@xmlShell:

; 3017 :                         case XPATH_POINT:
; 3018 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3019 :                                             "%s is a point\n", arg);
; 3020 :                             break;

	jmp	$LN12@xmlShell
$LN91@xmlShell:

; 3021 :                         case XPATH_RANGE:
; 3022 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3023 :                                             "%s is a range\n", arg);
; 3024 :                             break;

	jmp	SHORT $LN12@xmlShell
$LN92@xmlShell:

; 3025 :                         case XPATH_LOCATIONSET:
; 3026 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3027 :                                             "%s is a range\n", arg);
; 3028 :                             break;

	jmp	SHORT $LN12@xmlShell
$LN93@xmlShell:

; 3029 :                         case XPATH_USERS:
; 3030 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3031 :                                             "%s is user-defined\n", arg);
; 3032 :                             break;

	jmp	SHORT $LN12@xmlShell
$LN94@xmlShell:

; 3033 :                         case XPATH_XSLT_TREE:
; 3034 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlShell:

; 3035 :                                             "%s is an XSLT value tree\n",
; 3036 :                                             arg);
; 3037 :                             break;
; 3038 :                     }
; 3039 : #ifdef LIBXML_XPATH_ENABLED
; 3040 :                     xmlXPathFreeObject(list);

	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 3041 : #endif
; 3042 :                 } else {

	jmp	SHORT $LN83@xmlShell
$LN82@xmlShell:

; 3043 :                     xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN83@xmlShell:

; 3044 :                                     "%s: no such node\n", arg);
; 3045 :                 }
; 3046 :                 ctxt->pctxt->node = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+4], 0
$LN81@xmlShell:

; 3047 :             }

	jmp	$LN56@xmlShell
$LN78@xmlShell:

; 3048 :         } else if (!strcmp(command, "base")) {

	mov	DWORD PTR tv1716[ebp], OFFSET ??_C@_04BHIIPFEC@base@
	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1714[ebp], eax
$LL251@xmlShell:
	mov	ecx, DWORD PTR tv1714[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1719[ebp], dl
	mov	eax, DWORD PTR tv1716[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN252@xmlShell
	cmp	BYTE PTR tv1719[ebp], 0
	je	SHORT $LN253@xmlShell
	mov	ecx, DWORD PTR tv1714[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1726[ebp], dl
	mov	eax, DWORD PTR tv1716[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN252@xmlShell
	add	DWORD PTR tv1714[ebp], 2
	add	DWORD PTR tv1716[ebp], 2
	cmp	BYTE PTR tv1726[ebp], 0
	jne	SHORT $LL251@xmlShell
$LN253@xmlShell:
	mov	DWORD PTR tv1731[ebp], 0
	jmp	SHORT $LN254@xmlShell
$LN252@xmlShell:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1731[ebp], ecx
$LN254@xmlShell:
	mov	edx, DWORD PTR tv1731[ebp]
	mov	DWORD PTR tv546[ebp], edx
	cmp	DWORD PTR tv546[ebp], 0
	jne	SHORT $LN95@xmlShell

; 3049 :             xmlShellBase(ctxt, NULL, ctxt->node, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlShellBase
	add	esp, 16					; 00000010H
	jmp	$LN56@xmlShell
$LN95@xmlShell:

; 3050 :         } else if (!strcmp(command, "set")) {

	mov	DWORD PTR tv1740[ebp], OFFSET ??_C@_03KCHOJKKI@set@
	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1738[ebp], eax
$LL255@xmlShell:
	mov	ecx, DWORD PTR tv1738[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1743[ebp], dl
	mov	eax, DWORD PTR tv1740[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN256@xmlShell
	cmp	BYTE PTR tv1743[ebp], 0
	je	SHORT $LN257@xmlShell
	mov	ecx, DWORD PTR tv1738[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1750[ebp], dl
	mov	eax, DWORD PTR tv1740[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN256@xmlShell
	add	DWORD PTR tv1738[ebp], 2
	add	DWORD PTR tv1740[ebp], 2
	cmp	BYTE PTR tv1750[ebp], 0
	jne	SHORT $LL255@xmlShell
$LN257@xmlShell:
	mov	DWORD PTR tv1755[ebp], 0
	jmp	SHORT $LN258@xmlShell
$LN256@xmlShell:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1755[ebp], ecx
$LN258@xmlShell:
	mov	edx, DWORD PTR tv1755[ebp]
	mov	DWORD PTR tv556[ebp], edx
	cmp	DWORD PTR tv556[ebp], 0
	jne	SHORT $LN97@xmlShell

; 3051 : 	    xmlShellSetContent(ctxt, arg, ctxt->node, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlShellSetContent
	add	esp, 16					; 00000010H
	jmp	$LN56@xmlShell
$LN97@xmlShell:

; 3052 : #ifdef LIBXML_XPATH_ENABLED
; 3053 :         } else if (!strcmp(command, "setns")) {

	mov	DWORD PTR tv1765[ebp], OFFSET ??_C@_05DAFPCCNK@setns@
	lea	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1763[ebp], ecx
$LL259@xmlShell:
	mov	edx, DWORD PTR tv1763[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1768[ebp], al
	mov	ecx, DWORD PTR tv1765[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN260@xmlShell
	cmp	BYTE PTR tv1768[ebp], 0
	je	SHORT $LN261@xmlShell
	mov	edx, DWORD PTR tv1763[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1775[ebp], al
	mov	ecx, DWORD PTR tv1765[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN260@xmlShell
	add	DWORD PTR tv1763[ebp], 2
	add	DWORD PTR tv1765[ebp], 2
	cmp	BYTE PTR tv1775[ebp], 0
	jne	SHORT $LL259@xmlShell
$LN261@xmlShell:
	mov	DWORD PTR tv1780[ebp], 0
	jmp	SHORT $LN262@xmlShell
$LN260@xmlShell:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1780[ebp], edx
$LN262@xmlShell:
	mov	eax, DWORD PTR tv1780[ebp]
	mov	DWORD PTR tv566[ebp], eax
	cmp	DWORD PTR tv566[ebp], 0
	jne	SHORT $LN99@xmlShell

; 3054 :             if (arg[0] == 0) {

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _arg$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN101@xmlShell

; 3055 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0CA@IOLKGPPF@setns?3?5prefix?$DN?$FLnsuri?$FN?5required?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3056 : 				"setns: prefix=[nsuri] required\n");
; 3057 :             } else {

	jmp	SHORT $LN102@xmlShell
$LN101@xmlShell:

; 3058 :                 xmlShellRegisterNamespace(ctxt, arg, NULL, NULL);

	push	0
	push	0
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlShellRegisterNamespace
	add	esp, 16					; 00000010H
$LN102@xmlShell:

; 3059 :             }

	jmp	$LN56@xmlShell
$LN99@xmlShell:

; 3060 :         } else if (!strcmp(command, "setrootns")) {

	mov	DWORD PTR tv1795[ebp], OFFSET ??_C@_09ENEJFFG@setrootns@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1793[ebp], edx
$LL263@xmlShell:
	mov	eax, DWORD PTR tv1793[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1798[ebp], cl
	mov	edx, DWORD PTR tv1795[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN264@xmlShell
	cmp	BYTE PTR tv1798[ebp], 0
	je	SHORT $LN265@xmlShell
	mov	eax, DWORD PTR tv1793[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1805[ebp], cl
	mov	edx, DWORD PTR tv1795[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN264@xmlShell
	add	DWORD PTR tv1793[ebp], 2
	add	DWORD PTR tv1795[ebp], 2
	cmp	BYTE PTR tv1805[ebp], 0
	jne	SHORT $LL263@xmlShell
$LN265@xmlShell:
	mov	DWORD PTR tv1810[ebp], 0
	jmp	SHORT $LN266@xmlShell
$LN264@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1810[ebp], eax
$LN266@xmlShell:
	mov	ecx, DWORD PTR tv1810[ebp]
	mov	DWORD PTR tv583[ebp], ecx
	cmp	DWORD PTR tv583[ebp], 0
	jne	SHORT $LN103@xmlShell

; 3061 : 	    xmlNodePtr root;
; 3062 : 
; 3063 : 	    root = xmlDocGetRootElement(ctxt->doc);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$7[ebp], eax

; 3064 : 	    xmlShellRegisterRootNamespaces(ctxt, NULL, root, NULL);

	push	0
	mov	ecx, DWORD PTR _root$7[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlShellRegisterRootNamespaces
	add	esp, 16					; 00000010H
	jmp	$LN56@xmlShell
$LN103@xmlShell:

; 3065 :         } else if (!strcmp(command, "xpath")) {

	mov	DWORD PTR tv1821[ebp], OFFSET ??_C@_05CNNIIAHK@xpath@
	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1819[ebp], eax
$LL267@xmlShell:
	mov	ecx, DWORD PTR tv1819[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1824[ebp], dl
	mov	eax, DWORD PTR tv1821[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN268@xmlShell
	cmp	BYTE PTR tv1824[ebp], 0
	je	SHORT $LN269@xmlShell
	mov	ecx, DWORD PTR tv1819[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1831[ebp], dl
	mov	eax, DWORD PTR tv1821[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN268@xmlShell
	add	DWORD PTR tv1819[ebp], 2
	add	DWORD PTR tv1821[ebp], 2
	cmp	BYTE PTR tv1831[ebp], 0
	jne	SHORT $LL267@xmlShell
$LN269@xmlShell:
	mov	DWORD PTR tv1836[ebp], 0
	jmp	SHORT $LN270@xmlShell
$LN268@xmlShell:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1836[ebp], ecx
$LN270@xmlShell:
	mov	edx, DWORD PTR tv1836[ebp]
	mov	DWORD PTR tv595[ebp], edx
	cmp	DWORD PTR tv595[ebp], 0
	jne	$LN105@xmlShell

; 3066 :             if (arg[0] == 0) {

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _arg$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN107@xmlShell

; 3067 : 		xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0BM@BHIKJLIK@xpath?3?5expression?5required?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3068 : 				"xpath: expression required\n");
; 3069 : 	    } else {

	jmp	SHORT $LN108@xmlShell
$LN107@xmlShell:

; 3070 :                 ctxt->pctxt->node = ctxt->node;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx

; 3071 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	call	_xmlXPathEval
	add	esp, 8
	mov	DWORD PTR _list$[ebp], eax

; 3072 : 		xmlXPathDebugDumpObject(ctxt->output, list, 0);

	push	0
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_xmlXPathDebugDumpObject
	add	esp, 12					; 0000000cH

; 3073 : 		xmlXPathFreeObject(list);

	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4
$LN108@xmlShell:

; 3074 : 	    }

	jmp	$LN56@xmlShell
$LN105@xmlShell:

; 3075 : #endif /* LIBXML_XPATH_ENABLED */
; 3076 : #ifdef LIBXML_TREE_ENABLED
; 3077 :         } else if (!strcmp(command, "setbase")) {

	mov	DWORD PTR tv1860[ebp], OFFSET ??_C@_07NPGKGHNA@setbase@
	lea	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1858[ebp], ecx
$LL271@xmlShell:
	mov	edx, DWORD PTR tv1858[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1863[ebp], al
	mov	ecx, DWORD PTR tv1860[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN272@xmlShell
	cmp	BYTE PTR tv1863[ebp], 0
	je	SHORT $LN273@xmlShell
	mov	edx, DWORD PTR tv1858[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1870[ebp], al
	mov	ecx, DWORD PTR tv1860[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN272@xmlShell
	add	DWORD PTR tv1858[ebp], 2
	add	DWORD PTR tv1860[ebp], 2
	cmp	BYTE PTR tv1870[ebp], 0
	jne	SHORT $LL271@xmlShell
$LN273@xmlShell:
	mov	DWORD PTR tv1875[ebp], 0
	jmp	SHORT $LN274@xmlShell
$LN272@xmlShell:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1875[ebp], edx
$LN274@xmlShell:
	mov	eax, DWORD PTR tv1875[ebp]
	mov	DWORD PTR tv620[ebp], eax
	cmp	DWORD PTR tv620[ebp], 0
	jne	SHORT $LN109@xmlShell

; 3078 :             xmlShellSetBase(ctxt, arg, ctxt->node, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlShellSetBase
	add	esp, 16					; 00000010H
	jmp	$LN56@xmlShell
$LN109@xmlShell:

; 3079 : #endif
; 3080 :         } else if ((!strcmp(command, "ls")) || (!strcmp(command, "dir"))) {

	mov	DWORD PTR tv1885[ebp], OFFSET ??_C@_02EFGBDOJM@ls@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1883[ebp], edx
$LL275@xmlShell:
	mov	eax, DWORD PTR tv1883[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1888[ebp], cl
	mov	edx, DWORD PTR tv1885[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN276@xmlShell
	cmp	BYTE PTR tv1888[ebp], 0
	je	SHORT $LN277@xmlShell
	mov	eax, DWORD PTR tv1883[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1895[ebp], cl
	mov	edx, DWORD PTR tv1885[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN276@xmlShell
	add	DWORD PTR tv1883[ebp], 2
	add	DWORD PTR tv1885[ebp], 2
	cmp	BYTE PTR tv1895[ebp], 0
	jne	SHORT $LL275@xmlShell
$LN277@xmlShell:
	mov	DWORD PTR tv1900[ebp], 0
	jmp	SHORT $LN278@xmlShell
$LN276@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1900[ebp], eax
$LN278@xmlShell:
	mov	ecx, DWORD PTR tv1900[ebp]
	mov	DWORD PTR tv630[ebp], ecx
	cmp	DWORD PTR tv630[ebp], 0
	je	$LN113@xmlShell
	mov	DWORD PTR tv1906[ebp], OFFSET ??_C@_03DAPAKLGM@dir@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1904[ebp], edx
$LL279@xmlShell:
	mov	eax, DWORD PTR tv1904[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1909[ebp], cl
	mov	edx, DWORD PTR tv1906[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN280@xmlShell
	cmp	BYTE PTR tv1909[ebp], 0
	je	SHORT $LN281@xmlShell
	mov	eax, DWORD PTR tv1904[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1916[ebp], cl
	mov	edx, DWORD PTR tv1906[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN280@xmlShell
	add	DWORD PTR tv1904[ebp], 2
	add	DWORD PTR tv1906[ebp], 2
	cmp	BYTE PTR tv1916[ebp], 0
	jne	SHORT $LL279@xmlShell
$LN281@xmlShell:
	mov	DWORD PTR tv1921[ebp], 0
	jmp	SHORT $LN282@xmlShell
$LN280@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1921[ebp], eax
$LN282@xmlShell:
	mov	ecx, DWORD PTR tv1921[ebp]
	mov	DWORD PTR tv635[ebp], ecx
	cmp	DWORD PTR tv635[ebp], 0
	jne	$LN111@xmlShell
$LN113@xmlShell:

; 3081 :             int dir = (!strcmp(command, "dir"));

	mov	DWORD PTR tv1927[ebp], OFFSET ??_C@_03DAPAKLGM@dir@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv1925[ebp], edx
$LL283@xmlShell:
	mov	eax, DWORD PTR tv1925[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1930[ebp], cl
	mov	edx, DWORD PTR tv1927[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN284@xmlShell
	cmp	BYTE PTR tv1930[ebp], 0
	je	SHORT $LN285@xmlShell
	mov	eax, DWORD PTR tv1925[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1937[ebp], cl
	mov	edx, DWORD PTR tv1927[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN284@xmlShell
	add	DWORD PTR tv1925[ebp], 2
	add	DWORD PTR tv1927[ebp], 2
	cmp	BYTE PTR tv1937[ebp], 0
	jne	SHORT $LL283@xmlShell
$LN285@xmlShell:
	mov	DWORD PTR tv1942[ebp], 0
	jmp	SHORT $LN286@xmlShell
$LN284@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1942[ebp], eax
$LN286@xmlShell:
	mov	ecx, DWORD PTR tv1942[ebp]
	mov	DWORD PTR tv672[ebp], ecx
	cmp	DWORD PTR tv672[ebp], 0
	jne	SHORT $LN196@xmlShell
	mov	DWORD PTR tv674[ebp], 1
	jmp	SHORT $LN197@xmlShell
$LN196@xmlShell:
	mov	DWORD PTR tv674[ebp], 0
$LN197@xmlShell:
	mov	edx, DWORD PTR tv674[ebp]
	mov	DWORD PTR _dir$6[ebp], edx

; 3082 : 
; 3083 :             if (arg[0] == 0) {

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _arg$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN114@xmlShell

; 3084 :                 if (dir)

	cmp	DWORD PTR _dir$6[ebp], 0
	je	SHORT $LN116@xmlShell

; 3085 :                     xmlShellDir(ctxt, NULL, ctxt->node, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlShellDir
	add	esp, 16					; 00000010H
	jmp	SHORT $LN117@xmlShell
$LN116@xmlShell:

; 3086 :                 else
; 3087 :                     xmlShellList(ctxt, NULL, ctxt->node, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlShellList
	add	esp, 16					; 00000010H
$LN117@xmlShell:

; 3088 :             } else {

	jmp	$LN115@xmlShell
$LN114@xmlShell:

; 3089 :                 ctxt->pctxt->node = ctxt->node;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+4], eax

; 3090 : #ifdef LIBXML_XPATH_ENABLED
; 3091 :                 ctxt->pctxt->node = ctxt->node;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+4], ecx

; 3092 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	call	_xmlXPathEval
	add	esp, 8
	mov	DWORD PTR _list$[ebp], eax

; 3093 : #else
; 3094 :                 list = NULL;
; 3095 : #endif /* LIBXML_XPATH_ENABLED */
; 3096 :                 if (list != NULL) {

	cmp	DWORD PTR _list$[ebp], 0
	je	$LN118@xmlShell

; 3097 :                     switch (list->type) {

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv702[ebp], eax
	cmp	DWORD PTR tv702[ebp], 9
	ja	$LN17@xmlShell
	mov	ecx, DWORD PTR tv702[ebp]
	jmp	DWORD PTR $LN309@xmlShell[ecx*4]
$LN120@xmlShell:

; 3098 :                         case XPATH_UNDEFINED:
; 3099 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3100 :                                             "%s: no such node\n", arg);
; 3101 :                             break;

	jmp	$LN17@xmlShell
$LN121@xmlShell:

; 3102 :                         case XPATH_NODESET:{
; 3103 :                                 int indx;
; 3104 : 
; 3105 : 				if (list->nodesetval == NULL)

	mov	edx, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN122@xmlShell

; 3106 : 				    break;

	jmp	$LN17@xmlShell
$LN122@xmlShell:

; 3107 : 
; 3108 :                                 for (indx = 0;

	mov	DWORD PTR _indx$5[ebp], 0
	jmp	SHORT $LN21@xmlShell
$LN19@xmlShell:

; 3110 :                                      indx++) {

	mov	eax, DWORD PTR _indx$5[ebp]
	add	eax, 1
	mov	DWORD PTR _indx$5[ebp], eax
$LN21@xmlShell:

; 3109 :                                      indx < list->nodesetval->nodeNr;

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _indx$5[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN20@xmlShell

; 3111 :                                     if (dir)

	cmp	DWORD PTR _dir$6[ebp], 0
	je	SHORT $LN123@xmlShell

; 3112 :                                         xmlShellDir(ctxt, NULL,

	push	0
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _indx$5[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlShellDir
	add	esp, 16					; 00000010H
	jmp	SHORT $LN124@xmlShell
$LN123@xmlShell:

; 3113 :                                                     list->nodesetval->
; 3114 :                                                     nodeTab[indx], NULL);
; 3115 :                                     else
; 3116 :                                         xmlShellList(ctxt, NULL,

	push	0
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _indx$5[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlShellList
	add	esp, 16					; 00000010H
$LN124@xmlShell:

; 3117 :                                                      list->nodesetval->
; 3118 :                                                      nodeTab[indx], NULL);
; 3119 :                                 }

	jmp	$LN19@xmlShell
$LN20@xmlShell:

; 3120 :                                 break;

	jmp	$LN17@xmlShell
$LN125@xmlShell:

; 3121 :                             }
; 3122 :                         case XPATH_BOOLEAN:
; 3123 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3124 :                                             "%s is a Boolean\n", arg);
; 3125 :                             break;

	jmp	$LN17@xmlShell
$LN126@xmlShell:

; 3126 :                         case XPATH_NUMBER:
; 3127 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3128 :                                             "%s is a number\n", arg);
; 3129 :                             break;

	jmp	$LN17@xmlShell
$LN127@xmlShell:

; 3130 :                         case XPATH_STRING:
; 3131 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3132 :                                             "%s is a string\n", arg);
; 3133 :                             break;

	jmp	$LN17@xmlShell
$LN128@xmlShell:

; 3134 :                         case XPATH_POINT:
; 3135 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3136 :                                             "%s is a point\n", arg);
; 3137 :                             break;

	jmp	$LN17@xmlShell
$LN129@xmlShell:

; 3138 :                         case XPATH_RANGE:
; 3139 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3140 :                                             "%s is a range\n", arg);
; 3141 :                             break;

	jmp	SHORT $LN17@xmlShell
$LN130@xmlShell:

; 3142 :                         case XPATH_LOCATIONSET:
; 3143 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3144 :                                             "%s is a range\n", arg);
; 3145 :                             break;

	jmp	SHORT $LN17@xmlShell
$LN131@xmlShell:

; 3146 :                         case XPATH_USERS:
; 3147 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3148 :                                             "%s is user-defined\n", arg);
; 3149 :                             break;

	jmp	SHORT $LN17@xmlShell
$LN132@xmlShell:

; 3150 :                         case XPATH_XSLT_TREE:
; 3151 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@xmlShell:

; 3152 :                                             "%s is an XSLT value tree\n",
; 3153 :                                             arg);
; 3154 :                             break;
; 3155 :                     }
; 3156 : #ifdef LIBXML_XPATH_ENABLED
; 3157 :                     xmlXPathFreeObject(list);

	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 3158 : #endif
; 3159 :                 } else {

	jmp	SHORT $LN119@xmlShell
$LN118@xmlShell:

; 3160 :                     xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN119@xmlShell:

; 3161 :                                     "%s: no such node\n", arg);
; 3162 :                 }
; 3163 :                 ctxt->pctxt->node = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+4], 0
$LN115@xmlShell:

; 3164 :             }

	jmp	$LN56@xmlShell
$LN111@xmlShell:

; 3165 :         } else if (!strcmp(command, "whereis")) {

	mov	DWORD PTR tv2053[ebp], OFFSET ??_C@_07BANGEKHA@whereis@
	lea	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv2051[ebp], ecx
$LL287@xmlShell:
	mov	edx, DWORD PTR tv2051[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv2056[ebp], al
	mov	ecx, DWORD PTR tv2053[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN288@xmlShell
	cmp	BYTE PTR tv2056[ebp], 0
	je	SHORT $LN289@xmlShell
	mov	edx, DWORD PTR tv2051[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv2063[ebp], al
	mov	ecx, DWORD PTR tv2053[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN288@xmlShell
	add	DWORD PTR tv2051[ebp], 2
	add	DWORD PTR tv2053[ebp], 2
	cmp	BYTE PTR tv2063[ebp], 0
	jne	SHORT $LL287@xmlShell
$LN289@xmlShell:
	mov	DWORD PTR tv2068[ebp], 0
	jmp	SHORT $LN290@xmlShell
$LN288@xmlShell:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv2068[ebp], edx
$LN290@xmlShell:
	mov	eax, DWORD PTR tv2068[ebp]
	mov	DWORD PTR tv783[ebp], eax
	cmp	DWORD PTR tv783[ebp], 0
	jne	$LN133@xmlShell

; 3166 :             char dir[500];
; 3167 : 
; 3168 :             if (arg[0] == 0) {

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _arg$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN135@xmlShell

; 3169 :                 if (!xmlShellPwd(ctxt, dir, ctxt->node, NULL))

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR _dir$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlShellPwd
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN137@xmlShell

; 3170 :                     fprintf(ctxt->output, "%s\n", dir);

	lea	edx, DWORD PTR _dir$4[ebp]
	push	edx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN137@xmlShell:

; 3171 :             } else {

	jmp	$LN136@xmlShell
$LN135@xmlShell:

; 3172 :                 ctxt->pctxt->node = ctxt->node;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx

; 3173 : #ifdef LIBXML_XPATH_ENABLED
; 3174 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	call	_xmlXPathEval
	add	esp, 8
	mov	DWORD PTR _list$[ebp], eax

; 3175 : #else
; 3176 :                 list = NULL;
; 3177 : #endif /* LIBXML_XPATH_ENABLED */
; 3178 :                 if (list != NULL) {

	cmp	DWORD PTR _list$[ebp], 0
	je	$LN138@xmlShell

; 3179 :                     switch (list->type) {

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv809[ebp], ecx
	cmp	DWORD PTR tv809[ebp], 9
	ja	$LN22@xmlShell
	mov	edx, DWORD PTR tv809[ebp]
	jmp	DWORD PTR $LN310@xmlShell[edx*4]
$LN140@xmlShell:

; 3180 :                         case XPATH_UNDEFINED:
; 3181 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3182 :                                             "%s: no such node\n", arg);
; 3183 :                             break;

	jmp	$LN22@xmlShell
$LN141@xmlShell:

; 3184 :                         case XPATH_NODESET:{
; 3185 :                                 int indx;
; 3186 : 
; 3187 : 				if (list->nodesetval == NULL)

	mov	eax, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN142@xmlShell

; 3188 : 				    break;

	jmp	$LN22@xmlShell
$LN142@xmlShell:

; 3189 : 
; 3190 :                                 for (indx = 0;

	mov	DWORD PTR _indx$3[ebp], 0
	jmp	SHORT $LN26@xmlShell
$LN24@xmlShell:

; 3192 :                                      indx++) {

	mov	ecx, DWORD PTR _indx$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _indx$3[ebp], ecx
$LN26@xmlShell:

; 3191 :                                      indx < list->nodesetval->nodeNr;

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _indx$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN25@xmlShell

; 3193 :                                     if (!xmlShellPwd(ctxt, dir, list->nodesetval->

	push	0
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _indx$3[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	lea	ecx, DWORD PTR _dir$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlShellPwd
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN143@xmlShell

; 3194 :                                                      nodeTab[indx], NULL))
; 3195 :                                         fprintf(ctxt->output, "%s\n", dir);

	lea	eax, DWORD PTR _dir$4[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN143@xmlShell:

; 3196 :                                 }

	jmp	SHORT $LN24@xmlShell
$LN25@xmlShell:

; 3197 :                                 break;

	jmp	$LN22@xmlShell
$LN144@xmlShell:

; 3198 :                             }
; 3199 :                         case XPATH_BOOLEAN:
; 3200 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3201 :                                             "%s is a Boolean\n", arg);
; 3202 :                             break;

	jmp	$LN22@xmlShell
$LN145@xmlShell:

; 3203 :                         case XPATH_NUMBER:
; 3204 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3205 :                                             "%s is a number\n", arg);
; 3206 :                             break;

	jmp	$LN22@xmlShell
$LN146@xmlShell:

; 3207 :                         case XPATH_STRING:
; 3208 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3209 :                                             "%s is a string\n", arg);
; 3210 :                             break;

	jmp	$LN22@xmlShell
$LN147@xmlShell:

; 3211 :                         case XPATH_POINT:
; 3212 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3213 :                                             "%s is a point\n", arg);
; 3214 :                             break;

	jmp	$LN22@xmlShell
$LN148@xmlShell:

; 3215 :                         case XPATH_RANGE:
; 3216 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3217 :                                             "%s is a range\n", arg);
; 3218 :                             break;

	jmp	SHORT $LN22@xmlShell
$LN149@xmlShell:

; 3219 :                         case XPATH_LOCATIONSET:
; 3220 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3221 :                                             "%s is a range\n", arg);
; 3222 :                             break;

	jmp	SHORT $LN22@xmlShell
$LN150@xmlShell:

; 3223 :                         case XPATH_USERS:
; 3224 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3225 :                                             "%s is user-defined\n", arg);
; 3226 :                             break;

	jmp	SHORT $LN22@xmlShell
$LN151@xmlShell:

; 3227 :                         case XPATH_XSLT_TREE:
; 3228 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@xmlShell:

; 3229 :                                             "%s is an XSLT value tree\n",
; 3230 :                                             arg);
; 3231 :                             break;
; 3232 :                     }
; 3233 : #ifdef LIBXML_XPATH_ENABLED
; 3234 :                     xmlXPathFreeObject(list);

	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 3235 : #endif
; 3236 :                 } else {

	jmp	SHORT $LN139@xmlShell
$LN138@xmlShell:

; 3237 :                     xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN139@xmlShell:

; 3238 :                                     "%s: no such node\n", arg);
; 3239 :                 }
; 3240 :                 ctxt->pctxt->node = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+4], 0
$LN136@xmlShell:

; 3241 :             }

	jmp	$LN56@xmlShell
$LN133@xmlShell:

; 3242 :         } else if (!strcmp(command, "cd")) {

	mov	DWORD PTR tv2178[ebp], OFFSET ??_C@_02ELLOPNDH@cd@
	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv2176[ebp], eax
$LL291@xmlShell:
	mov	ecx, DWORD PTR tv2176[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv2181[ebp], dl
	mov	eax, DWORD PTR tv2178[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN292@xmlShell
	cmp	BYTE PTR tv2181[ebp], 0
	je	SHORT $LN293@xmlShell
	mov	ecx, DWORD PTR tv2176[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv2188[ebp], dl
	mov	eax, DWORD PTR tv2178[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN292@xmlShell
	add	DWORD PTR tv2176[ebp], 2
	add	DWORD PTR tv2178[ebp], 2
	cmp	BYTE PTR tv2188[ebp], 0
	jne	SHORT $LL291@xmlShell
$LN293@xmlShell:
	mov	DWORD PTR tv2193[ebp], 0
	jmp	SHORT $LN294@xmlShell
$LN292@xmlShell:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv2193[ebp], ecx
$LN294@xmlShell:
	mov	edx, DWORD PTR tv2193[ebp]
	mov	DWORD PTR tv887[ebp], edx
	cmp	DWORD PTR tv887[ebp], 0
	jne	$LN152@xmlShell

; 3243 :             if (arg[0] == 0) {

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _arg$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN154@xmlShell

; 3244 :                 ctxt->node = (xmlNodePtr) ctxt->doc;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 3245 :             } else {

	jmp	$LN155@xmlShell
$LN154@xmlShell:

; 3246 : #ifdef LIBXML_XPATH_ENABLED
; 3247 :                 int l;
; 3248 : 
; 3249 :                 ctxt->pctxt->node = ctxt->node;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+4], eax

; 3250 : 		l = strlen(arg);

	lea	ecx, DWORD PTR _arg$[ebp]
	mov	DWORD PTR tv2205[ebp], ecx
	mov	edx, DWORD PTR tv2205[ebp]
	add	edx, 1
	mov	DWORD PTR tv2208[ebp], edx
$LL295@xmlShell:
	mov	eax, DWORD PTR tv2205[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv2211[ebp], cl
	add	DWORD PTR tv2205[ebp], 1
	cmp	BYTE PTR tv2211[ebp], 0
	jne	SHORT $LL295@xmlShell
	mov	edx, DWORD PTR tv2205[ebp]
	sub	edx, DWORD PTR tv2208[ebp]
	mov	DWORD PTR tv900[ebp], edx
	mov	eax, DWORD PTR tv900[ebp]
	mov	DWORD PTR _l$2[ebp], eax

; 3251 : 		if ((l >= 2) && (arg[l - 1] == '/'))

	cmp	DWORD PTR _l$2[ebp], 2
	jl	SHORT $LN156@xmlShell
	mov	ecx, DWORD PTR _l$2[ebp]
	movsx	edx, BYTE PTR _arg$[ebp+ecx-1]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN156@xmlShell

; 3252 : 		    arg[l - 1] = 0;

	mov	eax, DWORD PTR _l$2[ebp]
	mov	BYTE PTR _arg$[ebp+eax-1], 0
$LN156@xmlShell:

; 3253 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_xmlXPathEval
	add	esp, 8
	mov	DWORD PTR _list$[ebp], eax

; 3254 : #else
; 3255 :                 list = NULL;
; 3256 : #endif /* LIBXML_XPATH_ENABLED */
; 3257 :                 if (list != NULL) {

	cmp	DWORD PTR _list$[ebp], 0
	je	$LN157@xmlShell

; 3258 :                     switch (list->type) {

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv916[ebp], edx
	cmp	DWORD PTR tv916[ebp], 9
	ja	$LN27@xmlShell
	mov	eax, DWORD PTR tv916[ebp]
	jmp	DWORD PTR $LN311@xmlShell[eax*4]
$LN159@xmlShell:

; 3259 :                         case XPATH_UNDEFINED:
; 3260 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3261 :                                             "%s: no such node\n", arg);
; 3262 :                             break;

	jmp	$LN27@xmlShell
$LN160@xmlShell:

; 3263 :                         case XPATH_NODESET:
; 3264 :                             if (list->nodesetval != NULL) {

	mov	ecx, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	$LN161@xmlShell

; 3265 : 				if (list->nodesetval->nodeNr == 1) {

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN163@xmlShell

; 3266 : 				    ctxt->node = list->nodesetval->nodeTab[0];

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+8], ecx

; 3267 : 				    if ((ctxt->node != NULL) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN165@xmlShell
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	jne	SHORT $LN165@xmlShell

; 3268 : 				        (ctxt->node->type ==
; 3269 : 					 XML_NAMESPACE_DECL)) {
; 3270 : 					xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0BI@IHADHLCC@cannot?5cd?5to?5namespace?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3271 : 						    "cannot cd to namespace\n");
; 3272 : 					ctxt->node = NULL;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN165@xmlShell:

; 3273 : 				    }
; 3274 : 				} else

	jmp	SHORT $LN164@xmlShell
$LN163@xmlShell:

; 3275 : 				    xmlGenericError(xmlGenericErrorContext,

	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@LLGICLLC@?$CFs?5is?5a?5?$CFd?5Node?5Set?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN164@xmlShell:

; 3276 : 						    "%s is a %d Node Set\n",
; 3277 : 						    arg,
; 3278 : 						    list->nodesetval->nodeNr);
; 3279 :                             } else

	jmp	SHORT $LN162@xmlShell
$LN161@xmlShell:

; 3280 :                                 xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BJ@MNAPMPFB@?$CFs?5is?5an?5empty?5Node?5Set?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN162@xmlShell:

; 3281 :                                                 "%s is an empty Node Set\n",
; 3282 :                                                 arg);
; 3283 :                             break;

	jmp	$LN27@xmlShell
$LN166@xmlShell:

; 3284 :                         case XPATH_BOOLEAN:
; 3285 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3286 :                                             "%s is a Boolean\n", arg);
; 3287 :                             break;

	jmp	$LN27@xmlShell
$LN167@xmlShell:

; 3288 :                         case XPATH_NUMBER:
; 3289 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3290 :                                             "%s is a number\n", arg);
; 3291 :                             break;

	jmp	$LN27@xmlShell
$LN168@xmlShell:

; 3292 :                         case XPATH_STRING:
; 3293 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3294 :                                             "%s is a string\n", arg);
; 3295 :                             break;

	jmp	$LN27@xmlShell
$LN169@xmlShell:

; 3296 :                         case XPATH_POINT:
; 3297 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3298 :                                             "%s is a point\n", arg);
; 3299 :                             break;

	jmp	$LN27@xmlShell
$LN170@xmlShell:

; 3300 :                         case XPATH_RANGE:
; 3301 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3302 :                                             "%s is a range\n", arg);
; 3303 :                             break;

	jmp	SHORT $LN27@xmlShell
$LN171@xmlShell:

; 3304 :                         case XPATH_LOCATIONSET:
; 3305 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3306 :                                             "%s is a range\n", arg);
; 3307 :                             break;

	jmp	SHORT $LN27@xmlShell
$LN172@xmlShell:

; 3308 :                         case XPATH_USERS:
; 3309 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3310 :                                             "%s is user-defined\n", arg);
; 3311 :                             break;

	jmp	SHORT $LN27@xmlShell
$LN173@xmlShell:

; 3312 :                         case XPATH_XSLT_TREE:
; 3313 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN27@xmlShell:

; 3314 :                                             "%s is an XSLT value tree\n",
; 3315 :                                             arg);
; 3316 :                             break;
; 3317 :                     }
; 3318 : #ifdef LIBXML_XPATH_ENABLED
; 3319 :                     xmlXPathFreeObject(list);

	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 3320 : #endif
; 3321 :                 } else {

	jmp	SHORT $LN158@xmlShell
$LN157@xmlShell:

; 3322 :                     xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN158@xmlShell:

; 3323 :                                     "%s: no such node\n", arg);
; 3324 :                 }
; 3325 :                 ctxt->pctxt->node = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+4], 0
$LN155@xmlShell:

; 3326 :             }

	jmp	$LN56@xmlShell
$LN152@xmlShell:

; 3327 : #ifdef LIBXML_OUTPUT_ENABLED
; 3328 :         } else if (!strcmp(command, "cat")) {

	mov	DWORD PTR tv2330[ebp], OFFSET ??_C@_03PFGOGFOL@cat@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv2328[ebp], edx
$LL296@xmlShell:
	mov	eax, DWORD PTR tv2328[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv2333[ebp], cl
	mov	edx, DWORD PTR tv2330[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN297@xmlShell
	cmp	BYTE PTR tv2333[ebp], 0
	je	SHORT $LN298@xmlShell
	mov	eax, DWORD PTR tv2328[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv2340[ebp], cl
	mov	edx, DWORD PTR tv2330[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN297@xmlShell
	add	DWORD PTR tv2328[ebp], 2
	add	DWORD PTR tv2330[ebp], 2
	cmp	BYTE PTR tv2340[ebp], 0
	jne	SHORT $LL296@xmlShell
$LN298@xmlShell:
	mov	DWORD PTR tv2345[ebp], 0
	jmp	SHORT $LN299@xmlShell
$LN297@xmlShell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv2345[ebp], eax
$LN299@xmlShell:
	mov	ecx, DWORD PTR tv2345[ebp]
	mov	DWORD PTR tv1007[ebp], ecx
	cmp	DWORD PTR tv1007[ebp], 0
	jne	$LN174@xmlShell

; 3329 :             if (arg[0] == 0) {

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _arg$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN176@xmlShell

; 3330 :                 xmlShellCat(ctxt, NULL, ctxt->node, NULL);

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlShellCat
	add	esp, 16					; 00000010H

; 3331 :             } else {

	jmp	$LN177@xmlShell
$LN176@xmlShell:

; 3332 :                 ctxt->pctxt->node = ctxt->node;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx

; 3333 : #ifdef LIBXML_XPATH_ENABLED
; 3334 :                 ctxt->pctxt->node = ctxt->node;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+4], eax

; 3335 :                 list = xmlXPathEval((xmlChar *) arg, ctxt->pctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_xmlXPathEval
	add	esp, 8
	mov	DWORD PTR _list$[ebp], eax

; 3336 : #else
; 3337 :                 list = NULL;
; 3338 : #endif /* LIBXML_XPATH_ENABLED */
; 3339 :                 if (list != NULL) {

	cmp	DWORD PTR _list$[ebp], 0
	je	$LN178@xmlShell

; 3340 :                     switch (list->type) {

	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv1030[ebp], edx
	cmp	DWORD PTR tv1030[ebp], 9
	ja	$LN29@xmlShell
	mov	eax, DWORD PTR tv1030[ebp]
	jmp	DWORD PTR $LN312@xmlShell[eax*4]
$LN180@xmlShell:

; 3341 :                         case XPATH_UNDEFINED:
; 3342 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3343 :                                             "%s: no such node\n", arg);
; 3344 :                             break;

	jmp	$LN29@xmlShell
$LN181@xmlShell:

; 3345 :                         case XPATH_NODESET:{
; 3346 :                                 int indx;
; 3347 : 
; 3348 : 				if (list->nodesetval == NULL)

	mov	ecx, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN182@xmlShell

; 3349 : 				    break;

	jmp	$LN29@xmlShell
$LN182@xmlShell:

; 3350 : 
; 3351 :                                 for (indx = 0;

	mov	DWORD PTR _indx$1[ebp], 0
	jmp	SHORT $LN33@xmlShell
$LN31@xmlShell:

; 3353 :                                      indx++) {

	mov	edx, DWORD PTR _indx$1[ebp]
	add	edx, 1
	mov	DWORD PTR _indx$1[ebp], edx
$LN33@xmlShell:

; 3352 :                                      indx < list->nodesetval->nodeNr;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _indx$1[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN32@xmlShell

; 3354 :                                     if (i > 0)

	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN183@xmlShell

; 3355 :                                         fprintf(ctxt->output, " -------\n");

	push	OFFSET ??_C@_09PGMOGJPB@?5?9?9?9?9?9?9?9?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN183@xmlShell:

; 3356 :                                     xmlShellCat(ctxt, NULL,

	push	0
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _indx$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlShellCat
	add	esp, 16					; 00000010H

; 3357 :                                                 list->nodesetval->
; 3358 :                                                 nodeTab[indx], NULL);
; 3359 :                                 }

	jmp	SHORT $LN31@xmlShell
$LN32@xmlShell:

; 3360 :                                 break;

	jmp	$LN29@xmlShell
$LN184@xmlShell:

; 3361 :                             }
; 3362 :                         case XPATH_BOOLEAN:
; 3363 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3364 :                                             "%s is a Boolean\n", arg);
; 3365 :                             break;

	jmp	$LN29@xmlShell
$LN185@xmlShell:

; 3366 :                         case XPATH_NUMBER:
; 3367 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3368 :                                             "%s is a number\n", arg);
; 3369 :                             break;

	jmp	$LN29@xmlShell
$LN186@xmlShell:

; 3370 :                         case XPATH_STRING:
; 3371 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3372 :                                             "%s is a string\n", arg);
; 3373 :                             break;

	jmp	$LN29@xmlShell
$LN187@xmlShell:

; 3374 :                         case XPATH_POINT:
; 3375 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3376 :                                             "%s is a point\n", arg);
; 3377 :                             break;

	jmp	$LN29@xmlShell
$LN188@xmlShell:

; 3378 :                         case XPATH_RANGE:
; 3379 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3380 :                                             "%s is a range\n", arg);
; 3381 :                             break;

	jmp	SHORT $LN29@xmlShell
$LN189@xmlShell:

; 3382 :                         case XPATH_LOCATIONSET:
; 3383 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3384 :                                             "%s is a range\n", arg);
; 3385 :                             break;

	jmp	SHORT $LN29@xmlShell
$LN190@xmlShell:

; 3386 :                         case XPATH_USERS:
; 3387 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3388 :                                             "%s is user-defined\n", arg);
; 3389 :                             break;

	jmp	SHORT $LN29@xmlShell
$LN191@xmlShell:

; 3390 :                         case XPATH_XSLT_TREE:
; 3391 :                             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _arg$[ebp]
	push	edx
	push	OFFSET ??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN29@xmlShell:

; 3392 :                                             "%s is an XSLT value tree\n",
; 3393 :                                             arg);
; 3394 :                             break;
; 3395 :                     }
; 3396 : #ifdef LIBXML_XPATH_ENABLED
; 3397 :                     xmlXPathFreeObject(list);

	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 3398 : #endif
; 3399 :                 } else {

	jmp	SHORT $LN179@xmlShell
$LN178@xmlShell:

; 3400 :                     xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN179@xmlShell:

; 3401 :                                     "%s: no such node\n", arg);
; 3402 :                 }
; 3403 :                 ctxt->pctxt->node = NULL;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+4], 0
$LN177@xmlShell:

; 3404 :             }
; 3405 : #endif /* LIBXML_OUTPUT_ENABLED */
; 3406 :         } else {

	jmp	SHORT $LN56@xmlShell
$LN174@xmlShell:

; 3407 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	lea	edx, DWORD PTR _command$[ebp]
	push	edx
	push	OFFSET ??_C@_0BE@LMHBCIGK@Unknown?5command?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN56@xmlShell:

; 3408 :                             "Unknown command %s\n", command);
; 3409 :         }
; 3410 :         free(cmdline);          /* not xmlFree here ! */

	mov	esi, esp
	mov	edx, DWORD PTR _cmdline$[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3411 : 	cmdline = NULL;

	mov	DWORD PTR _cmdline$[ebp], 0

; 3412 :     }

	jmp	$LN2@xmlShell
$LN3@xmlShell:

; 3413 : #ifdef LIBXML_XPATH_ENABLED
; 3414 :     xmlXPathFreeContext(ctxt->pctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlXPathFreeContext
	add	esp, 4

; 3415 : #endif /* LIBXML_XPATH_ENABLED */
; 3416 :     if (ctxt->loaded) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN192@xmlShell

; 3417 :         xmlFreeDoc(ctxt->doc);

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4
$LN192@xmlShell:

; 3418 :     }
; 3419 :     if (ctxt->filename != NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN193@xmlShell

; 3420 :         xmlFree(ctxt->filename);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN193@xmlShell:

; 3421 :     xmlFree(ctxt);

	mov	esi, esp
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3422 :     if (cmdline != NULL)

	cmp	DWORD PTR _cmdline$[ebp], 0
	je	SHORT $LN1@xmlShell

; 3423 :         free(cmdline);          /* not xmlFree here ! */

	mov	esi, esp
	mov	eax, DWORD PTR _cmdline$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlShell:

; 3424 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN307@xmlShell
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 2640				; 00000a50H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN307@xmlShell:
	DD	6
	DD	$LN306@xmlShell
$LN306@xmlShell:
	DD	-504					; fffffe08H
	DD	500					; 000001f4H
	DD	$LN300@xmlShell
	DD	-620					; fffffd94H
	DD	100					; 00000064H
	DD	$LN301@xmlShell
	DD	-1028					; fffffbfcH
	DD	400					; 00000190H
	DD	$LN302@xmlShell
	DD	-1052					; fffffbe4H
	DD	4
	DD	$LN303@xmlShell
	DD	-1560					; fffff9e8H
	DD	500					; 000001f4H
	DD	$LN304@xmlShell
	DD	-2084					; fffff7dcH
	DD	500					; 000001f4H
	DD	$LN305@xmlShell
$LN305@xmlShell:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	0
$LN304@xmlShell:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	0
$LN303@xmlShell:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN302@xmlShell:
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	0
$LN301@xmlShell:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN300@xmlShell:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	0
	npad	1
$LN308@xmlShell:
	DD	$LN84@xmlShell
	DD	$LN85@xmlShell
	DD	$LN87@xmlShell
	DD	$LN88@xmlShell
	DD	$LN89@xmlShell
	DD	$LN90@xmlShell
	DD	$LN91@xmlShell
	DD	$LN92@xmlShell
	DD	$LN93@xmlShell
	DD	$LN94@xmlShell
$LN309@xmlShell:
	DD	$LN120@xmlShell
	DD	$LN121@xmlShell
	DD	$LN125@xmlShell
	DD	$LN126@xmlShell
	DD	$LN127@xmlShell
	DD	$LN128@xmlShell
	DD	$LN129@xmlShell
	DD	$LN130@xmlShell
	DD	$LN131@xmlShell
	DD	$LN132@xmlShell
$LN310@xmlShell:
	DD	$LN140@xmlShell
	DD	$LN141@xmlShell
	DD	$LN144@xmlShell
	DD	$LN145@xmlShell
	DD	$LN146@xmlShell
	DD	$LN147@xmlShell
	DD	$LN148@xmlShell
	DD	$LN149@xmlShell
	DD	$LN150@xmlShell
	DD	$LN151@xmlShell
$LN311@xmlShell:
	DD	$LN159@xmlShell
	DD	$LN160@xmlShell
	DD	$LN166@xmlShell
	DD	$LN167@xmlShell
	DD	$LN168@xmlShell
	DD	$LN169@xmlShell
	DD	$LN170@xmlShell
	DD	$LN171@xmlShell
	DD	$LN172@xmlShell
	DD	$LN173@xmlShell
$LN312@xmlShell:
	DD	$LN180@xmlShell
	DD	$LN181@xmlShell
	DD	$LN184@xmlShell
	DD	$LN185@xmlShell
	DD	$LN186@xmlShell
	DD	$LN187@xmlShell
	DD	$LN188@xmlShell
	DD	$LN189@xmlShell
	DD	$LN190@xmlShell
	DD	$LN191@xmlShell
_xmlShell ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPwd
_TEXT	SEGMENT
_path$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_buffer$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellPwd PROC					; COMDAT

; 2771 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2772 :     xmlChar *path;
; 2773 : 
; 2774 :     if ((node == NULL) || (buffer == NULL))

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN3@xmlShellPw
	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN2@xmlShellPw
$LN3@xmlShellPw:

; 2775 :         return (-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlShellPw
$LN2@xmlShellPw:

; 2776 : 
; 2777 :     path = xmlGetNodePath(node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	_xmlGetNodePath
	add	esp, 4
	mov	DWORD PTR _path$[ebp], eax

; 2778 :     if (path == NULL)

	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN4@xmlShellPw

; 2779 : 	return (-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlShellPw
$LN4@xmlShellPw:

; 2780 : 
; 2781 :     /*
; 2782 :      * This test prevents buffer overflow, because this routine
; 2783 :      * is only called by xmlShell, in which the second argument is
; 2784 :      * 500 chars long.
; 2785 :      * It is a dirty hack before a cleaner solution is found.
; 2786 :      * Documentation should mention that the second argument must
; 2787 :      * be at least 500 chars long, and could be stripped if too long.
; 2788 :      */
; 2789 :     snprintf(buffer, 499, "%s", path);

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	499					; 000001f3H
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_snprintf
	add	esp, 16					; 00000010H

; 2790 :     buffer[499] = '0';

	mov	eax, 1
	imul	ecx, eax, 499
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	BYTE PTR [edx+ecx], 48			; 00000030H

; 2791 :     xmlFree(path);

	mov	esi, esp
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2792 : 
; 2793 :     return (0);

	xor	eax, eax
$LN1@xmlShellPw:

; 2794 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellPwd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellDu
_TEXT	SEGMENT
_i$ = -12						; size = 4
_indent$ = -8						; size = 4
_node$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_tree$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellDu PROC					; COMDAT

; 2687 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2688 :     xmlNodePtr node;
; 2689 :     int indent = 0, i;

	mov	DWORD PTR _indent$[ebp], 0

; 2690 : 
; 2691 :     if (!ctxt)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN9@xmlShellDu

; 2692 : 	return (-1);

	or	eax, -1
	jmp	$LN1@xmlShellDu
$LN9@xmlShellDu:

; 2693 : 
; 2694 :     if (tree == NULL)

	cmp	DWORD PTR _tree$[ebp], 0
	jne	SHORT $LN10@xmlShellDu

; 2695 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlShellDu
$LN10@xmlShellDu:

; 2696 :     node = tree;

	mov	eax, DWORD PTR _tree$[ebp]
	mov	DWORD PTR _node$[ebp], eax
$LN2@xmlShellDu:

; 2697 :     while (node != NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	je	$LN3@xmlShellDu

; 2698 :         if ((node->type == XML_DOCUMENT_NODE) ||

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 9
	je	SHORT $LN13@xmlShellDu
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 13			; 0000000dH
	jne	SHORT $LN11@xmlShellDu
$LN13@xmlShellDu:

; 2699 :             (node->type == XML_HTML_DOCUMENT_NODE)) {
; 2700 :             fprintf(ctxt->output, "/\n");

	push	OFFSET ??_C@_02MJEAMPLK@?1?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	$LN12@xmlShellDu
$LN11@xmlShellDu:

; 2701 :         } else if (node->type == XML_ELEMENT_NODE) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN12@xmlShellDu

; 2702 :             for (i = 0; i < indent; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@xmlShellDu
$LN4@xmlShellDu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@xmlShellDu:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _indent$[ebp]
	jge	SHORT $LN5@xmlShellDu

; 2703 :                 fprintf(ctxt->output, "  ");

	push	OFFSET ??_C@_02KNHHEEKP@?5?5@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN4@xmlShellDu
$LN5@xmlShellDu:

; 2704 :             if ((node->ns) && (node->ns->prefix))

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN16@xmlShellDu
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN16@xmlShellDu

; 2705 :                 fprintf(ctxt->output, "%s:", node->ns->prefix);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET ??_C@_03DKEJHHJP@?$CFs?3@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN16@xmlShellDu:

; 2706 :             fprintf(ctxt->output, "%s\n", node->name);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN12@xmlShellDu:

; 2707 :         } else {
; 2708 :         }
; 2709 : 
; 2710 :         /*
; 2711 :          * Browse the full subtree, deep first
; 2712 :          */
; 2713 : 
; 2714 :         if ((node->type == XML_DOCUMENT_NODE) ||

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 9
	je	SHORT $LN19@xmlShellDu
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 13			; 0000000dH
	jne	SHORT $LN17@xmlShellDu
$LN19@xmlShellDu:

; 2715 :             (node->type == XML_HTML_DOCUMENT_NODE)) {
; 2716 :             node = ((xmlDocPtr) node)->children;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _node$[ebp], ecx

; 2717 :         } else if ((node->children != NULL)

	jmp	$LN18@xmlShellDu
$LN17@xmlShellDu:

; 2718 :                    && (node->type != XML_ENTITY_REF_NODE)) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN20@xmlShellDu
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 5
	je	SHORT $LN20@xmlShellDu

; 2719 :             /* deep first */
; 2720 :             node = node->children;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _node$[ebp], edx

; 2721 :             indent++;

	mov	eax, DWORD PTR _indent$[ebp]
	add	eax, 1
	mov	DWORD PTR _indent$[ebp], eax
	jmp	$LN18@xmlShellDu
$LN20@xmlShellDu:

; 2722 :         } else if ((node != tree) && (node->next != NULL)) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	ecx, DWORD PTR _tree$[ebp]
	je	SHORT $LN22@xmlShellDu
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN22@xmlShellDu

; 2723 :             /* then siblings */
; 2724 :             node = node->next;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _node$[ebp], ecx
	jmp	$LN18@xmlShellDu
$LN22@xmlShellDu:

; 2725 :         } else if (node != tree) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	edx, DWORD PTR _tree$[ebp]
	je	SHORT $LN24@xmlShellDu
$LN7@xmlShellDu:

; 2726 :             /* go up to parents->next if needed */
; 2727 :             while (node != tree) {

	mov	eax, DWORD PTR _node$[ebp]
	cmp	eax, DWORD PTR _tree$[ebp]
	je	SHORT $LN8@xmlShellDu

; 2728 :                 if (node->parent != NULL) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN26@xmlShellDu

; 2729 :                     node = node->parent;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _node$[ebp], eax

; 2730 :                     indent--;

	mov	ecx, DWORD PTR _indent$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _indent$[ebp], ecx
$LN26@xmlShellDu:

; 2731 :                 }
; 2732 :                 if ((node != tree) && (node->next != NULL)) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	edx, DWORD PTR _tree$[ebp]
	je	SHORT $LN27@xmlShellDu
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN27@xmlShellDu

; 2733 :                     node = node->next;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _node$[ebp], edx

; 2734 :                     break;

	jmp	SHORT $LN8@xmlShellDu
$LN27@xmlShellDu:

; 2735 :                 }
; 2736 :                 if (node->parent == NULL) {

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN28@xmlShellDu

; 2737 :                     node = NULL;

	mov	DWORD PTR _node$[ebp], 0

; 2738 :                     break;

	jmp	SHORT $LN8@xmlShellDu
$LN28@xmlShellDu:

; 2739 :                 }
; 2740 :                 if (node == tree) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	ecx, DWORD PTR _tree$[ebp]
	jne	SHORT $LN29@xmlShellDu

; 2741 :                     node = NULL;

	mov	DWORD PTR _node$[ebp], 0

; 2742 :                     break;

	jmp	SHORT $LN8@xmlShellDu
$LN29@xmlShellDu:

; 2743 :                 }
; 2744 :             }

	jmp	SHORT $LN7@xmlShellDu
$LN8@xmlShellDu:

; 2745 :             /* exit condition */
; 2746 :             if (node == tree)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	edx, DWORD PTR _tree$[ebp]
	jne	SHORT $LN30@xmlShellDu

; 2747 :                 node = NULL;

	mov	DWORD PTR _node$[ebp], 0
$LN30@xmlShellDu:

; 2748 :         } else

	jmp	SHORT $LN18@xmlShellDu
$LN24@xmlShellDu:

; 2749 :             node = NULL;

	mov	DWORD PTR _node$[ebp], 0
$LN18@xmlShellDu:

; 2750 :     }

	jmp	$LN2@xmlShellDu
$LN3@xmlShellDu:

; 2751 :     return (0);

	xor	eax, eax
$LN1@xmlShellDu:

; 2752 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellDu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellValidate
_TEXT	SEGMENT
_subset$1 = -80						; size = 4
_res$ = -76						; size = 4
_vctxt$ = -68						; size = 64
_ctxt$ = 8						; size = 4
_dtd$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellValidate PROC					; COMDAT

; 2645 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2646 :     xmlValidCtxt vctxt;
; 2647 :     int res = -1;

	mov	DWORD PTR _res$[ebp], -1

; 2648 : 
; 2649 :     if ((ctxt == NULL) || (ctxt->doc == NULL)) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlShellVa
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN2@xmlShellVa
$LN3@xmlShellVa:
	or	eax, -1
	jmp	$LN1@xmlShellVa
$LN2@xmlShellVa:

; 2650 :     vctxt.userData = stderr;

	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _vctxt$[ebp], eax

; 2651 :     vctxt.error = (xmlValidityErrorFunc) fprintf;

	mov	DWORD PTR _vctxt$[ebp+4], OFFSET _fprintf

; 2652 :     vctxt.warning = (xmlValidityWarningFunc) fprintf;

	mov	DWORD PTR _vctxt$[ebp+8], OFFSET _fprintf

; 2653 : 
; 2654 :     if ((dtd == NULL) || (dtd[0] == 0)) {

	cmp	DWORD PTR _dtd$[ebp], 0
	je	SHORT $LN6@xmlShellVa
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _dtd$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN4@xmlShellVa
$LN6@xmlShellVa:

; 2655 :         res = xmlValidateDocument(&vctxt, ctxt->doc);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR _vctxt$[ebp]
	push	ecx
	call	_xmlValidateDocument
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 2656 :     } else {

	jmp	SHORT $LN5@xmlShellVa
$LN4@xmlShellVa:

; 2657 :         xmlDtdPtr subset;
; 2658 : 
; 2659 :         subset = xmlParseDTD(NULL, (xmlChar *) dtd);

	mov	edx, DWORD PTR _dtd$[ebp]
	push	edx
	push	0
	call	_xmlParseDTD
	add	esp, 8
	mov	DWORD PTR _subset$1[ebp], eax

; 2660 :         if (subset != NULL) {

	cmp	DWORD PTR _subset$1[ebp], 0
	je	SHORT $LN5@xmlShellVa

; 2661 :             res = xmlValidateDtd(&vctxt, ctxt->doc, subset);

	mov	eax, DWORD PTR _subset$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR _vctxt$[ebp]
	push	eax
	call	_xmlValidateDtd
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$[ebp], eax

; 2662 : 
; 2663 :             xmlFreeDtd(subset);

	mov	ecx, DWORD PTR _subset$1[ebp]
	push	ecx
	call	_xmlFreeDtd
	add	esp, 4
$LN5@xmlShellVa:

; 2664 :         }
; 2665 :     }
; 2666 :     return (res);

	mov	eax, DWORD PTR _res$[ebp]
$LN1@xmlShellVa:

; 2667 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@xmlShellVa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN11@xmlShellVa:
	DD	1
	DD	$LN10@xmlShellVa
$LN10@xmlShellVa:
	DD	-68					; ffffffbcH
	DD	64					; 00000040H
	DD	$LN9@xmlShellVa
$LN9@xmlShellVa:
	DB	118					; 00000076H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlShellValidate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellSave
_TEXT	SEGMENT
tv76 = -4						; size = 4
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellSave PROC					; COMDAT

; 2583 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2584 :     if ((ctxt == NULL) || (ctxt->doc == NULL))

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN5@xmlShellSa
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN4@xmlShellSa
$LN5@xmlShellSa:

; 2585 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlShellSa
$LN4@xmlShellSa:

; 2586 :     if ((filename == NULL) || (filename[0] == 0))

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN7@xmlShellSa
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN6@xmlShellSa
$LN7@xmlShellSa:

; 2587 :         filename = ctxt->filename;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _filename$[ebp], eax
$LN6@xmlShellSa:

; 2588 :     if (filename == NULL)

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN8@xmlShellSa

; 2589 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlShellSa
$LN8@xmlShellSa:

; 2590 : #ifdef W_OK
; 2591 :     if (access((char *) filename, W_OK)) {
; 2592 :         xmlGenericError(xmlGenericErrorContext,
; 2593 :                         "Cannot save to %s\n", filename);
; 2594 :         return (-1);
; 2595 :     }
; 2596 : #endif
; 2597 :     switch (ctxt->doc->type) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv76[ebp], eax
	cmp	DWORD PTR tv76[ebp], 9
	je	SHORT $LN9@xmlShellSa
	cmp	DWORD PTR tv76[ebp], 13			; 0000000dH
	je	SHORT $LN11@xmlShellSa
	jmp	SHORT $LN13@xmlShellSa
$LN9@xmlShellSa:

; 2598 :         case XML_DOCUMENT_NODE:
; 2599 :             if (xmlSaveFile((char *) filename, ctxt->doc) < 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_xmlSaveFile
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN10@xmlShellSa

; 2600 :                 xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@HDDIGIBB@Failed?5to?5save?5to?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlShellSa:

; 2601 :                                 "Failed to save to %s\n", filename);
; 2602 :             }
; 2603 :             break;

	jmp	SHORT $LN2@xmlShellSa
$LN11@xmlShellSa:

; 2604 :         case XML_HTML_DOCUMENT_NODE:
; 2605 : #ifdef LIBXML_HTML_ENABLED
; 2606 :             if (htmlSaveFile((char *) filename, ctxt->doc) < 0) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_htmlSaveFile
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN12@xmlShellSa

; 2607 :                 xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@HDDIGIBB@Failed?5to?5save?5to?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlShellSa:

; 2608 :                                 "Failed to save to %s\n", filename);
; 2609 :             }
; 2610 : #else
; 2611 :             if (xmlSaveFile((char *) filename, ctxt->doc) < 0) {
; 2612 :                 xmlGenericError(xmlGenericErrorContext,
; 2613 :                                 "Failed to save to %s\n", filename);
; 2614 :             }
; 2615 : #endif /* LIBXML_HTML_ENABLED */
; 2616 :             break;

	jmp	SHORT $LN2@xmlShellSa
$LN13@xmlShellSa:

; 2617 :         default:
; 2618 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	push	OFFSET ??_C@_0DL@KLJNMADF@To?5save?5to?5subparts?5of?5a?5docume@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2619 : 	    "To save to subparts of a document use the 'write' command\n");
; 2620 :             return (-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlShellSa
$LN2@xmlShellSa:

; 2621 : 
; 2622 :     }
; 2623 :     return (0);

	xor	eax, eax
$LN1@xmlShellSa:

; 2624 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellSave ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellWrite
_TEXT	SEGMENT
tv71 = -8						; size = 4
_f$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellWrite PROC					; COMDAT

; 2515 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2516 :     if (node == NULL)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN4@xmlShellWr

; 2517 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlShellWr
$LN4@xmlShellWr:

; 2518 :     if ((filename == NULL) || (filename[0] == 0)) {

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN6@xmlShellWr
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN5@xmlShellWr
$LN6@xmlShellWr:

; 2519 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlShellWr
$LN5@xmlShellWr:

; 2520 :     }
; 2521 : #ifdef W_OK
; 2522 :     if (access((char *) filename, W_OK)) {
; 2523 :         xmlGenericError(xmlGenericErrorContext,
; 2524 :                         "Cannot write to %s\n", filename);
; 2525 :         return (-1);
; 2526 :     }
; 2527 : #endif
; 2528 :     switch (node->type) {

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv71[ebp], edx
	cmp	DWORD PTR tv71[ebp], 9
	je	SHORT $LN7@xmlShellWr
	cmp	DWORD PTR tv71[ebp], 13			; 0000000dH
	je	SHORT $LN9@xmlShellWr
	jmp	$LN11@xmlShellWr
$LN7@xmlShellWr:

; 2529 :         case XML_DOCUMENT_NODE:
; 2530 :             if (xmlSaveFile((char *) filename, ctxt->doc) < -1) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_xmlSaveFile
	add	esp, 8
	cmp	eax, -1
	jge	SHORT $LN8@xmlShellWr

; 2531 :                 xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@HNGJDIHJ@Failed?5to?5write?5to?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2532 :                                 "Failed to write to %s\n", filename);
; 2533 :                 return (-1);

	or	eax, -1
	jmp	$LN1@xmlShellWr
$LN8@xmlShellWr:

; 2534 :             }
; 2535 :             break;

	jmp	$LN2@xmlShellWr
$LN9@xmlShellWr:

; 2536 :         case XML_HTML_DOCUMENT_NODE:
; 2537 : #ifdef LIBXML_HTML_ENABLED
; 2538 :             if (htmlSaveFile((char *) filename, ctxt->doc) < 0) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_htmlSaveFile
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN10@xmlShellWr

; 2539 :                 xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@HNGJDIHJ@Failed?5to?5write?5to?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2540 :                                 "Failed to write to %s\n", filename);
; 2541 :                 return (-1);

	or	eax, -1
	jmp	$LN1@xmlShellWr
$LN10@xmlShellWr:

; 2542 :             }
; 2543 : #else
; 2544 :             if (xmlSaveFile((char *) filename, ctxt->doc) < -1) {
; 2545 :                 xmlGenericError(xmlGenericErrorContext,
; 2546 :                                 "Failed to write to %s\n", filename);
; 2547 :                 return (-1);
; 2548 :             }
; 2549 : #endif /* LIBXML_HTML_ENABLED */
; 2550 :             break;

	jmp	SHORT $LN2@xmlShellWr
$LN11@xmlShellWr:

; 2551 :         default:{
; 2552 :                 FILE *f;
; 2553 : 
; 2554 :                 f = fopen((char *) filename, "w");

	mov	esi, esp
	push	OFFSET ??_C@_01NOFIACDB@w@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _f$1[ebp], eax

; 2555 :                 if (f == NULL) {

	cmp	DWORD PTR _f$1[ebp], 0
	jne	SHORT $LN12@xmlShellWr

; 2556 :                     xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@HNGJDIHJ@Failed?5to?5write?5to?5?$CFs?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2557 :                                     "Failed to write to %s\n", filename);
; 2558 :                     return (-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlShellWr
$LN12@xmlShellWr:

; 2559 :                 }
; 2560 :                 xmlElemDump(f, ctxt->doc, node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _f$1[ebp]
	push	ecx
	call	_xmlElemDump
	add	esp, 12					; 0000000cH

; 2561 :                 fclose(f);

	mov	esi, esp
	mov	edx, DWORD PTR _f$1[ebp]
	push	edx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@xmlShellWr:

; 2562 :             }
; 2563 :     }
; 2564 :     return (0);

	xor	eax, eax
$LN1@xmlShellWr:

; 2565 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellCat
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellCat PROC					; COMDAT

; 2414 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2415 :     if (!ctxt)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlShellCa

; 2416 :         return (0);

	xor	eax, eax
	jmp	$LN1@xmlShellCa
$LN2@xmlShellCa:

; 2417 :     if (node == NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN3@xmlShellCa

; 2418 : 	fprintf(ctxt->output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2419 : 	return (0);

	xor	eax, eax
	jmp	$LN1@xmlShellCa
$LN3@xmlShellCa:

; 2420 :     }
; 2421 :     if (ctxt->doc->type == XML_HTML_DOCUMENT_NODE) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN4@xmlShellCa

; 2422 : #ifdef LIBXML_HTML_ENABLED
; 2423 :         if (node->type == XML_HTML_DOCUMENT_NODE)

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	jne	SHORT $LN6@xmlShellCa

; 2424 :             htmlDocDump(ctxt->output, (htmlDocPtr) node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_htmlDocDump
	add	esp, 8
	jmp	SHORT $LN7@xmlShellCa
$LN6@xmlShellCa:

; 2425 :         else
; 2426 :             htmlNodeDumpFile(ctxt->output, ctxt->doc, node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_htmlNodeDumpFile
	add	esp, 12					; 0000000cH
$LN7@xmlShellCa:

; 2427 : #else
; 2428 :         if (node->type == XML_DOCUMENT_NODE)
; 2429 :             xmlDocDump(ctxt->output, (xmlDocPtr) node);
; 2430 :         else
; 2431 :             xmlElemDump(ctxt->output, ctxt->doc, node);
; 2432 : #endif /* LIBXML_HTML_ENABLED */
; 2433 :     } else {

	jmp	SHORT $LN5@xmlShellCa
$LN4@xmlShellCa:

; 2434 :         if (node->type == XML_DOCUMENT_NODE)

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 9
	jne	SHORT $LN8@xmlShellCa

; 2435 :             xmlDocDump(ctxt->output, (xmlDocPtr) node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_xmlDocDump
	add	esp, 8
	jmp	SHORT $LN5@xmlShellCa
$LN8@xmlShellCa:

; 2436 :         else
; 2437 :             xmlElemDump(ctxt->output, ctxt->doc, node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlElemDump
	add	esp, 12					; 0000000cH
$LN5@xmlShellCa:

; 2438 :     }
; 2439 :     fprintf(ctxt->output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fprintf
	add	esp, 8

; 2440 :     return (0);

	xor	eax, eax
$LN1@xmlShellCa:

; 2441 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlShellCat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPrintNode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_xmlShellPrintNode PROC					; COMDAT

; 1920 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1921 :     xmlShellPrintNodeCtxt(NULL, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	push	0
	call	_xmlShellPrintNodeCtxt
	add	esp, 8

; 1922 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlShellPrintNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellLoad
_TEXT	SEGMENT
tv71 = -12						; size = 4
_html$ = -8						; size = 4
_doc$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_filename$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellLoad PROC					; COMDAT

; 2460 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2461 :     xmlDocPtr doc;
; 2462 :     int html = 0;

	mov	DWORD PTR _html$[ebp], 0

; 2463 : 
; 2464 :     if ((ctxt == NULL) || (filename == NULL)) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN3@xmlShellLo
	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN2@xmlShellLo
$LN3@xmlShellLo:
	or	eax, -1
	jmp	$LN1@xmlShellLo
$LN2@xmlShellLo:

; 2465 :     if (ctxt->doc != NULL)

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@xmlShellLo

; 2466 :         html = (ctxt->doc->type == XML_HTML_DOCUMENT_NODE);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+4], 13			; 0000000dH
	jne	SHORT $LN11@xmlShellLo
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN12@xmlShellLo
$LN11@xmlShellLo:
	mov	DWORD PTR tv71[ebp], 0
$LN12@xmlShellLo:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _html$[ebp], eax
$LN4@xmlShellLo:

; 2467 : 
; 2468 :     if (html) {

	cmp	DWORD PTR _html$[ebp], 0
	je	SHORT $LN5@xmlShellLo

; 2469 : #ifdef LIBXML_HTML_ENABLED
; 2470 :         doc = htmlParseFile(filename, NULL);

	push	0
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_htmlParseFile
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 2471 : #else
; 2472 :         fprintf(ctxt->output, "HTML support not compiled in\n");
; 2473 :         doc = NULL;
; 2474 : #endif /* LIBXML_HTML_ENABLED */
; 2475 :     } else {

	jmp	SHORT $LN6@xmlShellLo
$LN5@xmlShellLo:

; 2476 :         doc = xmlReadFile(filename,NULL,0);

	push	0
	push	0
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_xmlReadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _doc$[ebp], eax
$LN6@xmlShellLo:

; 2477 :     }
; 2478 :     if (doc != NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	je	$LN7@xmlShellLo

; 2479 :         if (ctxt->loaded == 1) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 1
	jne	SHORT $LN9@xmlShellLo

; 2480 :             xmlFreeDoc(ctxt->doc);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4
$LN9@xmlShellLo:

; 2481 :         }
; 2482 :         ctxt->loaded = 1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+16], 1

; 2483 : #ifdef LIBXML_XPATH_ENABLED
; 2484 :         xmlXPathFreeContext(ctxt->pctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_xmlXPathFreeContext
	add	esp, 4

; 2485 : #endif /* LIBXML_XPATH_ENABLED */
; 2486 :         xmlFree(ctxt->filename);

	mov	esi, esp
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2487 :         ctxt->doc = doc;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [edx+4], eax

; 2488 :         ctxt->node = (xmlNodePtr) doc;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 2489 : #ifdef LIBXML_XPATH_ENABLED
; 2490 :         ctxt->pctxt = xmlXPathNewContext(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlXPathNewContext
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 2491 : #endif /* LIBXML_XPATH_ENABLED */
; 2492 :         ctxt->filename = (char *) xmlCanonicPath((xmlChar *) filename);

	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_xmlCanonicPath
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax

; 2493 :     } else

	jmp	SHORT $LN8@xmlShellLo
$LN7@xmlShellLo:

; 2494 :         return (-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlShellLo
$LN8@xmlShellLo:

; 2495 :     return (0);

	xor	eax, eax
$LN1@xmlShellLo:

; 2496 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellLoad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellDir
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellDir PROC					; COMDAT

; 2279 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2280 :     if (!ctxt)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlShellDi

; 2281 :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlShellDi
$LN2@xmlShellDi:

; 2282 :     if (node == NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN3@xmlShellDi

; 2283 : 	fprintf(ctxt->output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2284 : 	return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlShellDi
$LN3@xmlShellDi:

; 2285 :     }
; 2286 :     if ((node->type == XML_DOCUMENT_NODE) ||

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 9
	je	SHORT $LN6@xmlShellDi
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN4@xmlShellDi
$LN6@xmlShellDi:

; 2287 :         (node->type == XML_HTML_DOCUMENT_NODE)) {
; 2288 :         xmlDebugDumpDocumentHead(ctxt->output, (xmlDocPtr) node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlDebugDumpDocumentHead
	add	esp, 8
	jmp	SHORT $LN5@xmlShellDi
$LN4@xmlShellDi:

; 2289 :     } else if (node->type == XML_ATTRIBUTE_NODE) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 2
	jne	SHORT $LN7@xmlShellDi

; 2290 :         xmlDebugDumpAttr(ctxt->output, (xmlAttrPtr) node, 0);

	push	0
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_xmlDebugDumpAttr
	add	esp, 12					; 0000000cH

; 2291 :     } else {

	jmp	SHORT $LN5@xmlShellDi
$LN7@xmlShellDi:

; 2292 :         xmlDebugDumpOneNode(ctxt->output, node, 0);

	push	0
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_xmlDebugDumpOneNode
	add	esp, 12					; 0000000cH
$LN5@xmlShellDi:

; 2293 :     }
; 2294 :     return (0);

	xor	eax, eax
$LN1@xmlShellDi:

; 2295 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlShellDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellBase
_TEXT	SEGMENT
_base$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellBase PROC					; COMDAT

; 2051 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2052 :     xmlChar *base;
; 2053 :     if (!ctxt)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlShellBa

; 2054 :         return 0;

	xor	eax, eax
	jmp	$LN1@xmlShellBa
$LN2@xmlShellBa:

; 2055 :     if (node == NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN3@xmlShellBa

; 2056 : 	fprintf(ctxt->output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2057 : 	return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlShellBa
$LN3@xmlShellBa:

; 2058 :     }
; 2059 : 
; 2060 :     base = xmlNodeGetBase(node->doc, node);

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_xmlNodeGetBase
	add	esp, 8
	mov	DWORD PTR _base$[ebp], eax

; 2061 : 
; 2062 :     if (base == NULL) {

	cmp	DWORD PTR _base$[ebp], 0
	jne	SHORT $LN4@xmlShellBa

; 2063 :         fprintf(ctxt->output, " No base found !!!\n");

	push	OFFSET ??_C@_0BE@GMLBNCCG@?5No?5base?5found?5?$CB?$CB?$CB?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 8

; 2064 :     } else {

	jmp	SHORT $LN5@xmlShellBa
$LN4@xmlShellBa:

; 2065 :         fprintf(ctxt->output, "%s\n", base);

	mov	ecx, DWORD PTR _base$[ebp]
	push	ecx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 2066 :         xmlFree(base);

	mov	esi, esp
	mov	ecx, DWORD PTR _base$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlShellBa:

; 2067 :     }
; 2068 :     return (0);

	xor	eax, eax
$LN1@xmlShellBa:

; 2069 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellBase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellList
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_arg$ = 12						; size = 4
_node$ = 16						; size = 4
_node2$ = 20						; size = 4
_xmlShellList PROC					; COMDAT

; 2008 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 2009 :     xmlNodePtr cur;
; 2010 :     if (!ctxt)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN4@xmlShellLi

; 2011 :         return (0);

	xor	eax, eax
	jmp	$LN1@xmlShellLi
$LN4@xmlShellLi:

; 2012 :     if (node == NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN5@xmlShellLi

; 2013 : 	fprintf(ctxt->output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fprintf
	add	esp, 8

; 2014 : 	return (0);

	xor	eax, eax
	jmp	$LN1@xmlShellLi
$LN5@xmlShellLi:

; 2015 :     }
; 2016 :     if ((node->type == XML_DOCUMENT_NODE) ||

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 9
	je	SHORT $LN8@xmlShellLi
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN6@xmlShellLi
$LN8@xmlShellLi:

; 2017 :         (node->type == XML_HTML_DOCUMENT_NODE)) {
; 2018 :         cur = ((xmlDocPtr) node)->children;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN2@xmlShellLi
$LN6@xmlShellLi:

; 2019 :     } else if (node->type == XML_NAMESPACE_DECL) {

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN9@xmlShellLi

; 2020 :         xmlLsOneNode(ctxt->output, node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlLsOneNode
	add	esp, 8

; 2021 :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlShellLi
	jmp	SHORT $LN2@xmlShellLi
$LN9@xmlShellLi:

; 2022 :     } else if (node->children != NULL) {

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN11@xmlShellLi

; 2023 :         cur = node->children;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax

; 2024 :     } else {

	jmp	SHORT $LN2@xmlShellLi
$LN11@xmlShellLi:

; 2025 :         xmlLsOneNode(ctxt->output, node);

	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlLsOneNode
	add	esp, 8

; 2026 :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlShellLi
$LN2@xmlShellLi:

; 2027 :     }
; 2028 :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@xmlShellLi

; 2029 :         xmlLsOneNode(ctxt->output, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlLsOneNode
	add	esp, 8

; 2030 :         cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 2031 :     }

	jmp	SHORT $LN2@xmlShellLi
$LN3@xmlShellLi:

; 2032 :     return (0);

	xor	eax, eax
$LN1@xmlShellLi:

; 2033 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlShellList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPrintXPathResult
_TEXT	SEGMENT
_list$ = 8						; size = 4
_xmlShellPrintXPathResult PROC				; COMDAT

; 1988 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1989 :     xmlShellPrintXPathResultCtxt(NULL, list);

	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	push	0
	call	_xmlShellPrintXPathResultCtxt
	add	esp, 8

; 1990 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlShellPrintXPathResult ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlShellPrintXPathError
_TEXT	SEGMENT
tv65 = -8						; size = 4
_default_arg$ = -4					; size = 4
_errorType$ = 8						; size = 4
_arg$ = 12						; size = 4
_xmlShellPrintXPathError PROC				; COMDAT

; 1829 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1830 :     const char *default_arg = "Result";

	mov	DWORD PTR _default_arg$[ebp], OFFSET ??_C@_06GGONACPB@Result@

; 1831 : 
; 1832 :     if (!arg)

	cmp	DWORD PTR _arg$[ebp], 0
	jne	SHORT $LN4@xmlShellPr

; 1833 :         arg = default_arg;

	mov	eax, DWORD PTR _default_arg$[ebp]
	mov	DWORD PTR _arg$[ebp], eax
$LN4@xmlShellPr:

; 1834 : 
; 1835 :     switch (errorType) {

	mov	ecx, DWORD PTR _errorType$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 9
	ja	$LN1@xmlShellPr
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN15@xmlShellPr[edx*4]
$LN5@xmlShellPr:

; 1836 :         case XPATH_UNDEFINED:
; 1837 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@BKDKPJIH@?$CFs?3?5no?5such?5node?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1838 :                             "%s: no such node\n", arg);
; 1839 :             break;

	jmp	$LN1@xmlShellPr
$LN6@xmlShellPr:

; 1840 : 
; 1841 :         case XPATH_BOOLEAN:
; 1842 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@OAHMBEPC@?$CFs?5is?5a?5Boolean?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1843 :                             "%s is a Boolean\n", arg);
; 1844 :             break;

	jmp	$LN1@xmlShellPr
$LN7@xmlShellPr:

; 1845 :         case XPATH_NUMBER:
; 1846 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@MJFGBNGN@?$CFs?5is?5a?5number?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1847 :                             "%s is a number\n", arg);
; 1848 :             break;

	jmp	$LN1@xmlShellPr
$LN8@xmlShellPr:

; 1849 :         case XPATH_STRING:
; 1850 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@MACDFFOG@?$CFs?5is?5a?5string?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1851 :                             "%s is a string\n", arg);
; 1852 :             break;

	jmp	$LN1@xmlShellPr
$LN9@xmlShellPr:

; 1853 :         case XPATH_POINT:
; 1854 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@GKBAOHMC@?$CFs?5is?5a?5point?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1855 :                             "%s is a point\n", arg);
; 1856 :             break;

	jmp	$LN1@xmlShellPr
$LN10@xmlShellPr:

; 1857 :         case XPATH_RANGE:
; 1858 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1859 :                             "%s is a range\n", arg);
; 1860 :             break;

	jmp	SHORT $LN1@xmlShellPr
$LN11@xmlShellPr:

; 1861 :         case XPATH_LOCATIONSET:
; 1862 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@BFEJMNEG@?$CFs?5is?5a?5range?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1863 :                             "%s is a range\n", arg);
; 1864 :             break;

	jmp	SHORT $LN1@xmlShellPr
$LN12@xmlShellPr:

; 1865 :         case XPATH_USERS:
; 1866 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@CPIGDIBG@?$CFs?5is?5user?9defined?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1867 :                             "%s is user-defined\n", arg);
; 1868 :             break;

	jmp	SHORT $LN1@xmlShellPr
$LN13@xmlShellPr:

; 1869 :         case XPATH_XSLT_TREE:
; 1870 :             xmlGenericError(xmlGenericErrorContext,

	mov	esi, esp
	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@CDFINLLJ@?$CFs?5is?5an?5XSLT?5value?5tree?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlShellPr:

; 1871 :                             "%s is an XSLT value tree\n", arg);
; 1872 :             break;
; 1873 :     }
; 1874 : #if 0
; 1875 :     xmlGenericError(xmlGenericErrorContext,
; 1876 :                     "Try casting the result string function (xpath builtin)\n",
; 1877 :                     arg);
; 1878 : #endif
; 1879 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@xmlShellPr:
	DD	$LN5@xmlShellPr
	DD	$LN1@xmlShellPr
	DD	$LN6@xmlShellPr
	DD	$LN7@xmlShellPr
	DD	$LN8@xmlShellPr
	DD	$LN9@xmlShellPr
	DD	$LN10@xmlShellPr
	DD	$LN11@xmlShellPr
	DD	$LN12@xmlShellPr
	DD	$LN13@xmlShellPr
_xmlShellPrintXPathError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlBoolToText
_TEXT	SEGMENT
_boolval$ = 8						; size = 4
_xmlBoolToText PROC					; COMDAT

; 1797 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1798 :     if (boolval)

	cmp	DWORD PTR _boolval$[ebp], 0
	je	SHORT $LN2@xmlBoolToT

; 1799 :         return("True");

	mov	eax, OFFSET ??_C@_04HPMIDMKH@True@
	jmp	SHORT $LN1@xmlBoolToT
	jmp	SHORT $LN1@xmlBoolToT
$LN2@xmlBoolToT:

; 1800 :     else
; 1801 :         return("False");

	mov	eax, OFFSET ??_C@_05MKDOIIA@False@
$LN1@xmlBoolToT:

; 1802 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlBoolToText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlLsCountNode
_TEXT	SEGMENT
tv66 = -12						; size = 4
_list$ = -8						; size = 4
_ret$ = -4						; size = 4
_node$ = 8						; size = 4
_xmlLsCountNode PROC					; COMDAT

; 1605 : xmlLsCountNode(xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1606 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1607 :     xmlNodePtr list = NULL;

	mov	DWORD PTR _list$[ebp], 0

; 1608 : 
; 1609 :     if (node == NULL)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN7@xmlLsCount

; 1610 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlLsCount
$LN7@xmlLsCount:

; 1611 : 
; 1612 :     switch (node->type) {

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR tv66[ebp]
	sub	edx, 1
	mov	DWORD PTR tv66[ebp], edx
	cmp	DWORD PTR tv66[ebp], 20			; 00000014H
	ja	SHORT $LN2@xmlLsCount
	mov	eax, DWORD PTR tv66[ebp]
	movzx	ecx, BYTE PTR $LN15@xmlLsCount[eax]
	jmp	DWORD PTR $LN16@xmlLsCount[ecx*4]
$LN8@xmlLsCount:

; 1613 : 	case XML_ELEMENT_NODE:
; 1614 : 	    list = node->children;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _list$[ebp], eax

; 1615 : 	    break;

	jmp	SHORT $LN2@xmlLsCount
$LN9@xmlLsCount:

; 1616 : 	case XML_DOCUMENT_NODE:
; 1617 : 	case XML_HTML_DOCUMENT_NODE:
; 1618 : #ifdef LIBXML_DOCB_ENABLED
; 1619 : 	case XML_DOCB_DOCUMENT_NODE:
; 1620 : #endif
; 1621 : 	    list = ((xmlDocPtr) node)->children;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _list$[ebp], edx

; 1622 : 	    break;

	jmp	SHORT $LN2@xmlLsCount
$LN10@xmlLsCount:

; 1623 : 	case XML_ATTRIBUTE_NODE:
; 1624 : 	    list = ((xmlAttrPtr) node)->children;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _list$[ebp], ecx

; 1625 : 	    break;

	jmp	SHORT $LN2@xmlLsCount
$LN11@xmlLsCount:

; 1626 : 	case XML_TEXT_NODE:
; 1627 : 	case XML_CDATA_SECTION_NODE:
; 1628 : 	case XML_PI_NODE:
; 1629 : 	case XML_COMMENT_NODE:
; 1630 : 	    if (node->content != NULL) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN12@xmlLsCount

; 1631 : 		ret = xmlStrlen(node->content);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN12@xmlLsCount:

; 1632 :             }
; 1633 : 	    break;

	jmp	SHORT $LN2@xmlLsCount
$LN13@xmlLsCount:

; 1634 : 	case XML_ENTITY_REF_NODE:
; 1635 : 	case XML_DOCUMENT_TYPE_NODE:
; 1636 : 	case XML_ENTITY_NODE:
; 1637 : 	case XML_DOCUMENT_FRAG_NODE:
; 1638 : 	case XML_NOTATION_NODE:
; 1639 : 	case XML_DTD_NODE:
; 1640 :         case XML_ELEMENT_DECL:
; 1641 :         case XML_ATTRIBUTE_DECL:
; 1642 :         case XML_ENTITY_DECL:
; 1643 : 	case XML_NAMESPACE_DECL:
; 1644 : 	case XML_XINCLUDE_START:
; 1645 : 	case XML_XINCLUDE_END:
; 1646 : 	    ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN2@xmlLsCount:

; 1647 : 	    break;
; 1648 :     }
; 1649 :     for (;list != NULL;ret++)

	jmp	SHORT $LN6@xmlLsCount
$LN4@xmlLsCount:
	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, 1
	mov	DWORD PTR _ret$[ebp], edx
$LN6@xmlLsCount:
	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN5@xmlLsCount

; 1650 :         list = list->next;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _list$[ebp], ecx
	jmp	SHORT $LN4@xmlLsCount
$LN5@xmlLsCount:

; 1651 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlLsCount:

; 1652 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN16@xmlLsCount:
	DD	$LN8@xmlLsCount
	DD	$LN10@xmlLsCount
	DD	$LN11@xmlLsCount
	DD	$LN13@xmlLsCount
	DD	$LN9@xmlLsCount
$LN15@xmlLsCount:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	3
	DB	3
	DB	2
	DB	2
	DB	4
	DB	3
	DB	3
	DB	3
	DB	4
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	4
_xmlLsCountNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlLsOneNode
_TEXT	SEGMENT
tv154 = -12						; size = 4
tv69 = -8						; size = 4
_ns$1 = -4						; size = 4
_output$ = 8						; size = 4
_node$ = 12						; size = 4
_xmlLsOneNode PROC					; COMDAT

; 1662 : xmlLsOneNode(FILE *output, xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1663 :     if (output == NULL) return;

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN6@xmlLsOneNo
	jmp	$LN1@xmlLsOneNo
$LN6@xmlLsOneNo:

; 1664 :     if (node == NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN7@xmlLsOneNo

; 1665 : 	fprintf(output, "NULL\n");

	push	OFFSET ??_C@_05NJDBAOFA@NULL?6@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1666 : 	return;

	jmp	$LN1@xmlLsOneNo
$LN7@xmlLsOneNo:

; 1667 :     }
; 1668 :     switch (node->type) {

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR tv69[ebp]
	sub	eax, 1
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 17			; 00000011H
	ja	$LN22@xmlLsOneNo
	mov	ecx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN54@xmlLsOneNo[ecx*4]
$LN8@xmlLsOneNo:

; 1669 : 	case XML_ELEMENT_NODE:
; 1670 : 	    fprintf(output, "-");

	push	OFFSET ??_C@_01JOAMLHOP@?9@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8

; 1671 : 	    break;

	jmp	$LN2@xmlLsOneNo
$LN9@xmlLsOneNo:

; 1672 : 	case XML_ATTRIBUTE_NODE:
; 1673 : 	    fprintf(output, "a");

	push	OFFSET ??_C@_01MCMALHOG@a@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1674 : 	    break;

	jmp	$LN2@xmlLsOneNo
$LN10@xmlLsOneNo:

; 1675 : 	case XML_TEXT_NODE:
; 1676 : 	    fprintf(output, "t");

	push	OFFSET ??_C@_01PFHFFBPC@t@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8

; 1677 : 	    break;

	jmp	$LN2@xmlLsOneNo
$LN11@xmlLsOneNo:

; 1678 : 	case XML_CDATA_SECTION_NODE:
; 1679 : 	    fprintf(output, "C");

	push	OFFSET ??_C@_01GFHCPBMG@C@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8

; 1680 : 	    break;

	jmp	$LN2@xmlLsOneNo
$LN12@xmlLsOneNo:

; 1681 : 	case XML_ENTITY_REF_NODE:
; 1682 : 	    fprintf(output, "e");

	push	OFFSET ??_C@_01KGKMHCOC@e@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1683 : 	    break;

	jmp	$LN2@xmlLsOneNo
$LN13@xmlLsOneNo:

; 1684 : 	case XML_ENTITY_NODE:
; 1685 : 	    fprintf(output, "E");

	push	OFFSET ??_C@_01DDCIFGEA@E@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8

; 1686 : 	    break;

	jmp	$LN2@xmlLsOneNo
$LN14@xmlLsOneNo:

; 1687 : 	case XML_PI_NODE:
; 1688 : 	    fprintf(output, "p");

	push	OFFSET ??_C@_01JBBJJEPG@p@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8

; 1689 : 	    break;

	jmp	$LN2@xmlLsOneNo
$LN15@xmlLsOneNo:

; 1690 : 	case XML_COMMENT_NODE:
; 1691 : 	    fprintf(output, "c");

	push	OFFSET ??_C@_01PAPGNFGE@c@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1692 : 	    break;

	jmp	$LN2@xmlLsOneNo
$LN16@xmlLsOneNo:

; 1693 : 	case XML_DOCUMENT_NODE:
; 1694 : 	    fprintf(output, "d");

	push	OFFSET ??_C@_01LPLHEDKD@d@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8

; 1695 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN17@xmlLsOneNo:

; 1696 : 	case XML_HTML_DOCUMENT_NODE:
; 1697 : 	    fprintf(output, "h");

	push	OFFSET ??_C@_01BDACAMKP@h@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8

; 1698 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN18@xmlLsOneNo:

; 1699 : 	case XML_DOCUMENT_TYPE_NODE:
; 1700 : 	    fprintf(output, "T");

	push	OFFSET ??_C@_01GAPBHFFA@T@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1701 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN19@xmlLsOneNo:

; 1702 : 	case XML_DOCUMENT_FRAG_NODE:
; 1703 : 	    fprintf(output, "F");

	push	OFFSET ??_C@_01BIAFAFID@F@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8

; 1704 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN20@xmlLsOneNo:

; 1705 : 	case XML_NOTATION_NODE:
; 1706 : 	    fprintf(output, "N");

	push	OFFSET ??_C@_01NANMIPIL@N@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8

; 1707 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN21@xmlLsOneNo:

; 1708 : 	case XML_NAMESPACE_DECL:
; 1709 : 	    fprintf(output, "n");

	push	OFFSET ??_C@_01EFFIKLCJ@n@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1710 : 	    break;

	jmp	SHORT $LN2@xmlLsOneNo
$LN22@xmlLsOneNo:

; 1711 : 	default:
; 1712 : 	    fprintf(output, "?");

	push	OFFSET ??_C@_01OGPIMHDM@?$DP@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
$LN2@xmlLsOneNo:

; 1713 :     }
; 1714 :     if (node->type != XML_NAMESPACE_DECL) {

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+4], 18			; 00000012H
	je	SHORT $LN23@xmlLsOneNo

; 1715 : 	if (node->properties != NULL)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN24@xmlLsOneNo

; 1716 : 	    fprintf(output, "a");

	push	OFFSET ??_C@_01MCMALHOG@a@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN25@xmlLsOneNo
$LN24@xmlLsOneNo:

; 1717 : 	else
; 1718 : 	    fprintf(output, "-");

	push	OFFSET ??_C@_01JOAMLHOP@?9@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
$LN25@xmlLsOneNo:

; 1719 : 	if (node->nsDef != NULL)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN26@xmlLsOneNo

; 1720 : 	    fprintf(output, "n");

	push	OFFSET ??_C@_01EFFIKLCJ@n@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN23@xmlLsOneNo
$LN26@xmlLsOneNo:

; 1721 : 	else
; 1722 : 	    fprintf(output, "-");

	push	OFFSET ??_C@_01JOAMLHOP@?9@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 8
$LN23@xmlLsOneNo:

; 1723 :     }
; 1724 : 
; 1725 :     fprintf(output, " %8d ", xmlLsCountNode(node));

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	_xmlLsCountNode
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_05KPHFGMAO@?5?$CF8d?5@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1726 : 
; 1727 :     switch (node->type) {

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv154[ebp], eax
	mov	ecx, DWORD PTR tv154[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv154[ebp], ecx
	cmp	DWORD PTR tv154[ebp], 17		; 00000011H
	ja	$LN51@xmlLsOneNo
	mov	edx, DWORD PTR tv154[ebp]
	jmp	DWORD PTR $LN55@xmlLsOneNo[edx*4]
$LN28@xmlLsOneNo:

; 1728 : 	case XML_ELEMENT_NODE:
; 1729 : 	    if (node->name != NULL) {

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN29@xmlLsOneNo

; 1730 :                 if ((node->ns != NULL) && (node->ns->prefix != NULL))

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN30@xmlLsOneNo
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN30@xmlLsOneNo

; 1731 :                     fprintf(output, "%s:", node->ns->prefix);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET ??_C@_03DKEJHHJP@?$CFs?3@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN30@xmlLsOneNo:

; 1732 : 		fprintf(output, "%s", (const char *) node->name);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN29@xmlLsOneNo:

; 1733 :             }
; 1734 : 	    break;

	jmp	$LN4@xmlLsOneNo
$LN31@xmlLsOneNo:

; 1735 : 	case XML_ATTRIBUTE_NODE:
; 1736 : 	    if (node->name != NULL)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN32@xmlLsOneNo

; 1737 : 		fprintf(output, "%s", (const char *) node->name);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN32@xmlLsOneNo:

; 1738 : 	    break;

	jmp	$LN4@xmlLsOneNo
$LN33@xmlLsOneNo:

; 1739 : 	case XML_TEXT_NODE:
; 1740 : 	    if (node->content != NULL) {

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN34@xmlLsOneNo

; 1741 : 		xmlDebugDumpString(output, node->content);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_xmlDebugDumpString
	add	esp, 8
$LN34@xmlLsOneNo:

; 1742 :             }
; 1743 : 	    break;

	jmp	$LN4@xmlLsOneNo
$LN35@xmlLsOneNo:

; 1744 : 	case XML_CDATA_SECTION_NODE:
; 1745 : 	    break;

	jmp	$LN4@xmlLsOneNo
$LN36@xmlLsOneNo:

; 1746 : 	case XML_ENTITY_REF_NODE:
; 1747 : 	    if (node->name != NULL)

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN37@xmlLsOneNo

; 1748 : 		fprintf(output, "%s", (const char *) node->name);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN37@xmlLsOneNo:

; 1749 : 	    break;

	jmp	$LN4@xmlLsOneNo
$LN38@xmlLsOneNo:

; 1750 : 	case XML_ENTITY_NODE:
; 1751 : 	    if (node->name != NULL)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN39@xmlLsOneNo

; 1752 : 		fprintf(output, "%s", (const char *) node->name);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN39@xmlLsOneNo:

; 1753 : 	    break;

	jmp	$LN4@xmlLsOneNo
$LN40@xmlLsOneNo:

; 1754 : 	case XML_PI_NODE:
; 1755 : 	    if (node->name != NULL)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN41@xmlLsOneNo

; 1756 : 		fprintf(output, "%s", (const char *) node->name);

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN41@xmlLsOneNo:

; 1757 : 	    break;

	jmp	SHORT $LN4@xmlLsOneNo
$LN42@xmlLsOneNo:

; 1758 : 	case XML_COMMENT_NODE:
; 1759 : 	    break;

	jmp	SHORT $LN4@xmlLsOneNo
$LN43@xmlLsOneNo:

; 1760 : 	case XML_DOCUMENT_NODE:
; 1761 : 	    break;

	jmp	SHORT $LN4@xmlLsOneNo
$LN44@xmlLsOneNo:

; 1762 : 	case XML_HTML_DOCUMENT_NODE:
; 1763 : 	    break;

	jmp	SHORT $LN4@xmlLsOneNo
$LN45@xmlLsOneNo:

; 1764 : 	case XML_DOCUMENT_TYPE_NODE:
; 1765 : 	    break;

	jmp	SHORT $LN4@xmlLsOneNo
$LN46@xmlLsOneNo:

; 1766 : 	case XML_DOCUMENT_FRAG_NODE:
; 1767 : 	    break;

	jmp	SHORT $LN4@xmlLsOneNo
$LN47@xmlLsOneNo:

; 1768 : 	case XML_NOTATION_NODE:
; 1769 : 	    break;

	jmp	SHORT $LN4@xmlLsOneNo
$LN48@xmlLsOneNo:

; 1770 : 	case XML_NAMESPACE_DECL: {
; 1771 : 	    xmlNsPtr ns = (xmlNsPtr) node;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _ns$1[ebp], ecx

; 1772 : 
; 1773 : 	    if (ns->prefix == NULL)

	mov	edx, DWORD PTR _ns$1[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN49@xmlLsOneNo

; 1774 : 		fprintf(output, "default -> %s", (char *)ns->href);

	mov	eax, DWORD PTR _ns$1[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0O@IMMJOEMC@default?5?9?$DO?5?$CFs@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN50@xmlLsOneNo
$LN49@xmlLsOneNo:

; 1775 : 	    else
; 1776 : 		fprintf(output, "%s -> %s", (char *)ns->prefix,

	mov	eax, DWORD PTR _ns$1[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _ns$1[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET ??_C@_08DHHJCFN@?$CFs?5?9?$DO?5?$CFs@
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_fprintf
	add	esp, 16					; 00000010H
$LN50@xmlLsOneNo:

; 1777 : 			(char *)ns->href);
; 1778 : 	    break;

	jmp	SHORT $LN4@xmlLsOneNo
$LN51@xmlLsOneNo:

; 1779 : 	}
; 1780 : 	default:
; 1781 : 	    if (node->name != NULL)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN4@xmlLsOneNo

; 1782 : 		fprintf(output, "%s", (const char *) node->name);

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN4@xmlLsOneNo:

; 1783 :     }
; 1784 :     fprintf(output, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
$LN1@xmlLsOneNo:

; 1785 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN54@xmlLsOneNo:
	DD	$LN8@xmlLsOneNo
	DD	$LN9@xmlLsOneNo
	DD	$LN10@xmlLsOneNo
	DD	$LN11@xmlLsOneNo
	DD	$LN12@xmlLsOneNo
	DD	$LN13@xmlLsOneNo
	DD	$LN14@xmlLsOneNo
	DD	$LN15@xmlLsOneNo
	DD	$LN16@xmlLsOneNo
	DD	$LN18@xmlLsOneNo
	DD	$LN19@xmlLsOneNo
	DD	$LN20@xmlLsOneNo
	DD	$LN17@xmlLsOneNo
	DD	$LN22@xmlLsOneNo
	DD	$LN22@xmlLsOneNo
	DD	$LN22@xmlLsOneNo
	DD	$LN22@xmlLsOneNo
	DD	$LN21@xmlLsOneNo
$LN55@xmlLsOneNo:
	DD	$LN28@xmlLsOneNo
	DD	$LN31@xmlLsOneNo
	DD	$LN33@xmlLsOneNo
	DD	$LN35@xmlLsOneNo
	DD	$LN36@xmlLsOneNo
	DD	$LN38@xmlLsOneNo
	DD	$LN40@xmlLsOneNo
	DD	$LN42@xmlLsOneNo
	DD	$LN43@xmlLsOneNo
	DD	$LN45@xmlLsOneNo
	DD	$LN46@xmlLsOneNo
	DD	$LN47@xmlLsOneNo
	DD	$LN44@xmlLsOneNo
	DD	$LN51@xmlLsOneNo
	DD	$LN51@xmlLsOneNo
	DD	$LN51@xmlLsOneNo
	DD	$LN51@xmlLsOneNo
	DD	$LN48@xmlLsOneNo
_xmlLsOneNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugCheckDocument
_TEXT	SEGMENT
_ctxt$ = -144						; size = 140
_output$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlDebugCheckDocument PROC				; COMDAT

; 1577 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1578 :     xmlDebugCtxt ctxt;
; 1579 : 
; 1580 :     if (output == NULL)

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN2@xmlDebugCh

; 1581 : 	output = stdout;

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _output$[ebp], eax
$LN2@xmlDebugCh:

; 1582 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt
	add	esp, 4

; 1583 :     ctxt.output = output;

	mov	ecx, DWORD PTR _output$[ebp]
	mov	DWORD PTR _ctxt$[ebp], ecx

; 1584 :     ctxt.check = 1;

	mov	DWORD PTR _ctxt$[ebp+124], 1

; 1585 :     xmlCtxtDumpDocument(&ctxt, doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpDocument
	add	esp, 8

; 1586 :     xmlCtxtDumpCleanCtxt(&ctxt);

	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpCleanCtxt
	add	esp, 4

; 1587 :     return(ctxt.errors);

	mov	eax, DWORD PTR _ctxt$[ebp+128]

; 1588 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@xmlDebugCh
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlDebugCh:
	DD	1
	DD	$LN5@xmlDebugCh
$LN5@xmlDebugCh:
	DD	-144					; ffffff70H
	DD	140					; 0000008cH
	DD	$LN4@xmlDebugCh
$LN4@xmlDebugCh:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDebugCheckDocument ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpEntities
_TEXT	SEGMENT
_ctxt$ = -144						; size = 140
_output$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlDebugDumpEntities PROC				; COMDAT

; 1400 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1401 :     xmlDebugCtxt ctxt;
; 1402 : 
; 1403 :     if (output == NULL) return;

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN2@xmlDebugDu
	jmp	SHORT $LN1@xmlDebugDu
$LN2@xmlDebugDu:

; 1404 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt
	add	esp, 4

; 1405 :     ctxt.output = output;

	mov	ecx, DWORD PTR _output$[ebp]
	mov	DWORD PTR _ctxt$[ebp], ecx

; 1406 :     xmlCtxtDumpEntities(&ctxt, doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpEntities
	add	esp, 8

; 1407 :     xmlCtxtDumpCleanCtxt(&ctxt);

	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpCleanCtxt
	add	esp, 4
$LN1@xmlDebugDu:

; 1408 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@xmlDebugDu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@xmlDebugDu:
	DD	1
	DD	$LN5@xmlDebugDu
$LN5@xmlDebugDu:
	DD	-144					; ffffff70H
	DD	140					; 0000008cH
	DD	$LN4@xmlDebugDu
$LN4@xmlDebugDu:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDebugDumpEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpDTD
_TEXT	SEGMENT
_ctxt$ = -144						; size = 140
_output$ = 8						; size = 4
_dtd$ = 12						; size = 4
_xmlDebugDumpDTD PROC					; COMDAT

; 1547 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1548 :     xmlDebugCtxt ctxt;
; 1549 : 
; 1550 :     if (output == NULL)

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN2@xmlDebugDu

; 1551 : 	output = stdout;

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _output$[ebp], eax
$LN2@xmlDebugDu:

; 1552 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt
	add	esp, 4

; 1553 :     ctxt.options |= DUMP_TEXT_TYPE;

	mov	ecx, DWORD PTR _ctxt$[ebp+136]
	or	ecx, 1
	mov	DWORD PTR _ctxt$[ebp+136], ecx

; 1554 :     ctxt.output = output;

	mov	edx, DWORD PTR _output$[ebp]
	mov	DWORD PTR _ctxt$[ebp], edx

; 1555 :     xmlCtxtDumpDTD(&ctxt, dtd);

	mov	eax, DWORD PTR _dtd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpDTD
	add	esp, 8

; 1556 :     xmlCtxtDumpCleanCtxt(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpCleanCtxt
	add	esp, 4

; 1557 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@xmlDebugDu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@xmlDebugDu:
	DD	1
	DD	$LN5@xmlDebugDu
$LN5@xmlDebugDu:
	DD	-144					; ffffff70H
	DD	140					; 0000008cH
	DD	$LN4@xmlDebugDu
$LN4@xmlDebugDu:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDebugDumpDTD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpDocument
_TEXT	SEGMENT
_ctxt$ = -144						; size = 140
_output$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlDebugDumpDocument PROC				; COMDAT

; 1526 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1527 :     xmlDebugCtxt ctxt;
; 1528 : 
; 1529 :     if (output == NULL)

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN2@xmlDebugDu

; 1530 : 	output = stdout;

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _output$[ebp], eax
$LN2@xmlDebugDu:

; 1531 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt
	add	esp, 4

; 1532 :     ctxt.options |= DUMP_TEXT_TYPE;

	mov	ecx, DWORD PTR _ctxt$[ebp+136]
	or	ecx, 1
	mov	DWORD PTR _ctxt$[ebp+136], ecx

; 1533 :     ctxt.output = output;

	mov	edx, DWORD PTR _output$[ebp]
	mov	DWORD PTR _ctxt$[ebp], edx

; 1534 :     xmlCtxtDumpDocument(&ctxt, doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpDocument
	add	esp, 8

; 1535 :     xmlCtxtDumpCleanCtxt(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpCleanCtxt
	add	esp, 4

; 1536 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@xmlDebugDu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@xmlDebugDu:
	DD	1
	DD	$LN5@xmlDebugDu
$LN5@xmlDebugDu:
	DD	-144					; ffffff70H
	DD	140					; 0000008cH
	DD	$LN4@xmlDebugDu
$LN4@xmlDebugDu:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDebugDumpDocument ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpDocumentHead
_TEXT	SEGMENT
_ctxt$ = -144						; size = 140
_output$ = 8						; size = 4
_doc$ = 12						; size = 4
_xmlDebugDumpDocumentHead PROC				; COMDAT

; 1505 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1506 :     xmlDebugCtxt ctxt;
; 1507 : 
; 1508 :     if (output == NULL)

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN2@xmlDebugDu

; 1509 : 	output = stdout;

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _output$[ebp], eax
$LN2@xmlDebugDu:

; 1510 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt
	add	esp, 4

; 1511 :     ctxt.options |= DUMP_TEXT_TYPE;

	mov	ecx, DWORD PTR _ctxt$[ebp+136]
	or	ecx, 1
	mov	DWORD PTR _ctxt$[ebp+136], ecx

; 1512 :     ctxt.output = output;

	mov	edx, DWORD PTR _output$[ebp]
	mov	DWORD PTR _ctxt$[ebp], edx

; 1513 :     xmlCtxtDumpDocumentHead(&ctxt, doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpDocumentHead
	add	esp, 8

; 1514 :     xmlCtxtDumpCleanCtxt(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpCleanCtxt
	add	esp, 4

; 1515 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@xmlDebugDu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@xmlDebugDu:
	DD	1
	DD	$LN5@xmlDebugDu
$LN5@xmlDebugDu:
	DD	-144					; ffffff70H
	DD	140					; 0000008cH
	DD	$LN4@xmlDebugDu
$LN4@xmlDebugDu:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDebugDumpDocumentHead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpNodeList
_TEXT	SEGMENT
_ctxt$ = -144						; size = 140
_output$ = 8						; size = 4
_node$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlDebugDumpNodeList PROC				; COMDAT

; 1484 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1485 :     xmlDebugCtxt ctxt;
; 1486 : 
; 1487 :     if (output == NULL)

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN2@xmlDebugDu

; 1488 : 	output = stdout;

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _output$[ebp], eax
$LN2@xmlDebugDu:

; 1489 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt
	add	esp, 4

; 1490 :     ctxt.output = output;

	mov	ecx, DWORD PTR _output$[ebp]
	mov	DWORD PTR _ctxt$[ebp], ecx

; 1491 :     ctxt.depth = depth;

	mov	edx, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _ctxt$[ebp+108], edx

; 1492 :     xmlCtxtDumpNodeList(&ctxt, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpNodeList
	add	esp, 8

; 1493 :     xmlCtxtDumpCleanCtxt(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpCleanCtxt
	add	esp, 4

; 1494 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@xmlDebugDu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlDebugDu:
	DD	1
	DD	$LN5@xmlDebugDu
$LN5@xmlDebugDu:
	DD	-144					; ffffff70H
	DD	140					; 0000008cH
	DD	$LN4@xmlDebugDu
$LN4@xmlDebugDu:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDebugDumpNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpNode
_TEXT	SEGMENT
_ctxt$ = -144						; size = 140
_output$ = 8						; size = 4
_node$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlDebugDumpNode PROC					; COMDAT

; 1462 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1463 :     xmlDebugCtxt ctxt;
; 1464 : 
; 1465 :     if (output == NULL)

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN2@xmlDebugDu

; 1466 : 	output = stdout;

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _output$[ebp], eax
$LN2@xmlDebugDu:

; 1467 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt
	add	esp, 4

; 1468 :     ctxt.output = output;

	mov	ecx, DWORD PTR _output$[ebp]
	mov	DWORD PTR _ctxt$[ebp], ecx

; 1469 :     ctxt.depth = depth;

	mov	edx, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _ctxt$[ebp+108], edx

; 1470 :     xmlCtxtDumpNode(&ctxt, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpNode
	add	esp, 8

; 1471 :     xmlCtxtDumpCleanCtxt(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpCleanCtxt
	add	esp, 4

; 1472 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@xmlDebugDu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@xmlDebugDu:
	DD	1
	DD	$LN5@xmlDebugDu
$LN5@xmlDebugDu:
	DD	-144					; ffffff70H
	DD	140					; 0000008cH
	DD	$LN4@xmlDebugDu
$LN4@xmlDebugDu:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDebugDumpNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpOneNode
_TEXT	SEGMENT
_ctxt$ = -144						; size = 140
_output$ = 8						; size = 4
_node$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlDebugDumpOneNode PROC				; COMDAT

; 1441 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1442 :     xmlDebugCtxt ctxt;
; 1443 : 
; 1444 :     if (output == NULL) return;

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN2@xmlDebugDu
	jmp	SHORT $LN1@xmlDebugDu
$LN2@xmlDebugDu:

; 1445 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt
	add	esp, 4

; 1446 :     ctxt.output = output;

	mov	ecx, DWORD PTR _output$[ebp]
	mov	DWORD PTR _ctxt$[ebp], ecx

; 1447 :     ctxt.depth = depth;

	mov	edx, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _ctxt$[ebp+108], edx

; 1448 :     xmlCtxtDumpOneNode(&ctxt, node);

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpOneNode
	add	esp, 8

; 1449 :     xmlCtxtDumpCleanCtxt(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpCleanCtxt
	add	esp, 4
$LN1@xmlDebugDu:

; 1450 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@xmlDebugDu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@xmlDebugDu:
	DD	1
	DD	$LN5@xmlDebugDu
$LN5@xmlDebugDu:
	DD	-144					; ffffff70H
	DD	140					; 0000008cH
	DD	$LN4@xmlDebugDu
$LN4@xmlDebugDu:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDebugDumpOneNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpAttrList
_TEXT	SEGMENT
_ctxt$ = -144						; size = 140
_output$ = 8						; size = 4
_attr$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlDebugDumpAttrList PROC				; COMDAT

; 1420 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1421 :     xmlDebugCtxt ctxt;
; 1422 : 
; 1423 :     if (output == NULL) return;

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN2@xmlDebugDu
	jmp	SHORT $LN1@xmlDebugDu
$LN2@xmlDebugDu:

; 1424 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt
	add	esp, 4

; 1425 :     ctxt.output = output;

	mov	ecx, DWORD PTR _output$[ebp]
	mov	DWORD PTR _ctxt$[ebp], ecx

; 1426 :     ctxt.depth = depth;

	mov	edx, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _ctxt$[ebp+108], edx

; 1427 :     xmlCtxtDumpAttrList(&ctxt, attr);

	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpAttrList
	add	esp, 8

; 1428 :     xmlCtxtDumpCleanCtxt(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpCleanCtxt
	add	esp, 4
$LN1@xmlDebugDu:

; 1429 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@xmlDebugDu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@xmlDebugDu:
	DD	1
	DD	$LN5@xmlDebugDu
$LN5@xmlDebugDu:
	DD	-144					; ffffff70H
	DD	140					; 0000008cH
	DD	$LN4@xmlDebugDu
$LN4@xmlDebugDu:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDebugDumpAttrList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpAttr
_TEXT	SEGMENT
_ctxt$ = -144						; size = 140
_output$ = 8						; size = 4
_attr$ = 12						; size = 4
_depth$ = 16						; size = 4
_xmlDebugDumpAttr PROC					; COMDAT

; 1379 : xmlDebugDumpAttr(FILE *output, xmlAttrPtr attr, int depth) {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1380 :     xmlDebugCtxt ctxt;
; 1381 : 
; 1382 :     if (output == NULL) return;

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN2@xmlDebugDu
	jmp	SHORT $LN1@xmlDebugDu
$LN2@xmlDebugDu:

; 1383 :     xmlCtxtDumpInitCtxt(&ctxt);

	lea	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlCtxtDumpInitCtxt
	add	esp, 4

; 1384 :     ctxt.output = output;

	mov	ecx, DWORD PTR _output$[ebp]
	mov	DWORD PTR _ctxt$[ebp], ecx

; 1385 :     ctxt.depth = depth;

	mov	edx, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _ctxt$[ebp+108], edx

; 1386 :     xmlCtxtDumpAttr(&ctxt, attr);

	mov	eax, DWORD PTR _attr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlCtxtDumpAttr
	add	esp, 8

; 1387 :     xmlCtxtDumpCleanCtxt(&ctxt);

	lea	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlCtxtDumpCleanCtxt
	add	esp, 4
$LN1@xmlDebugDu:

; 1388 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@xmlDebugDu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@xmlDebugDu:
	DD	1
	DD	$LN5@xmlDebugDu
$LN5@xmlDebugDu:
	DD	-144					; ffffff70H
	DD	140					; 0000008cH
	DD	$LN4@xmlDebugDu
$LN4@xmlDebugDu:
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
_xmlDebugDumpAttr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\debugxml.c
;	COMDAT _xmlDebugDumpString
_TEXT	SEGMENT
_i$ = -4						; size = 4
_output$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlDebugDumpString PROC				; COMDAT

; 1349 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6FBE7998_debugxml@c
	call	@__CheckForDebuggerJustMyCode@4

; 1350 :     int i;
; 1351 : 
; 1352 :     if (output == NULL)

	cmp	DWORD PTR _output$[ebp], 0
	jne	SHORT $LN5@xmlDebugDu

; 1353 : 	output = stdout;

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _output$[ebp], eax
$LN5@xmlDebugDu:

; 1354 :     if (str == NULL) {

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN6@xmlDebugDu

; 1355 :         fprintf(output, "(NULL)");

	push	OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8

; 1356 :         return;

	jmp	$LN1@xmlDebugDu
$LN6@xmlDebugDu:

; 1357 :     }
; 1358 :     for (i = 0; i < 40; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlDebugDu
$LN2@xmlDebugDu:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlDebugDu:
	cmp	DWORD PTR _i$[ebp], 40			; 00000028H
	jge	$LN3@xmlDebugDu

; 1359 :         if (str[i] == 0)

	mov	edx, DWORD PTR _str$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN7@xmlDebugDu

; 1360 :             return;

	jmp	$LN1@xmlDebugDu
	jmp	$LN8@xmlDebugDu
$LN7@xmlDebugDu:

; 1361 :         else if (IS_BLANK_CH(str[i]))

	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN11@xmlDebugDu
	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN12@xmlDebugDu
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN11@xmlDebugDu
$LN12@xmlDebugDu:
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN9@xmlDebugDu
$LN11@xmlDebugDu:

; 1362 :             fputc(' ', output);

	mov	esi, esp
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	push	32					; 00000020H
	call	DWORD PTR __imp__fputc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN8@xmlDebugDu
$LN9@xmlDebugDu:

; 1363 :         else if (str[i] >= 0x80)

	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 128				; 00000080H
	jl	SHORT $LN13@xmlDebugDu

; 1364 :             fprintf(output, "#%X", str[i]);

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	push	OFFSET ??_C@_03CANIHDGE@?$CD?$CFX@
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@xmlDebugDu
$LN13@xmlDebugDu:

; 1365 :         else
; 1366 :             fputc(str[i], output);

	mov	esi, esp
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__fputc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlDebugDu:
	jmp	$LN2@xmlDebugDu
$LN3@xmlDebugDu:

; 1367 :     fprintf(output, "...");

	push	OFFSET ??_C@_03KHICJKCI@?4?4?4@
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_fprintf
	add	esp, 8
$LN1@xmlDebugDu:

; 1368 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDebugDumpString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2270 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 2271 :         int _Result;
; 2272 :         va_list _ArgList;
; 2273 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 2176 :         return __stdio_common_vsscanf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_scanf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 2275 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 2276 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2277 :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Stream$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 96   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 97   :         static unsigned __int64 _OptionsStorage;
; 98   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 99   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
