; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\uri.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__0B912F28_uri@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_snprintf
PUBLIC	_xmlCreateURI
PUBLIC	_xmlBuildURI
PUBLIC	_xmlBuildRelativeURI
PUBLIC	_xmlParseURI
PUBLIC	_xmlParseURIRaw
PUBLIC	_xmlParseURIReference
PUBLIC	_xmlSaveUri
PUBLIC	_xmlPrintURI
PUBLIC	_xmlURIEscapeStr
PUBLIC	_xmlURIUnescapeString
PUBLIC	_xmlNormalizeURIPath
PUBLIC	_xmlURIEscape
PUBLIC	_xmlFreeURI
PUBLIC	_xmlCanonicPath
PUBLIC	_xmlPathToURI
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ ; `string'
PUBLIC	??_C@_0BI@NJMLMHOE@creating?5URI?5structure?6@	; `string'
PUBLIC	??_C@_0CJ@PJGKIFED@reaching?5arbitrary?5MAX_URI_LENG@ ; `string'
PUBLIC	??_C@_0M@NFLMPNMP@saving?5URI?6@		; `string'
PUBLIC	??_C@_03HODKBCIO@?3?$CFd@			; `string'
PUBLIC	??_C@_04DAMGJPCA@file@				; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BG@GBNFHGHH@unescaping?5URI?5value?6@	; `string'
PUBLIC	??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@	; `string'
PUBLIC	??_C@_03JCBKNEED@?$CL?9?4@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_05GFBJJGAL@?1?$DP?$DL?3?$EA@		; `string'
PUBLIC	??_C@_02CBLDBPFN@?1?1@				; `string'
PUBLIC	??_C@_07LHGLKCBA@?$DL?3?$CG?$DN?$CL$?0@		; `string'
PUBLIC	??_C@_01EOFPKCAF@?$EA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_0L@JBEGPNBA@?3?$EA?$CG?$DN?$CL$?0?1?$DP?$DL@ ; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP@				; `string'
PUBLIC	??_C@_0L@LPCDADNI@?$DL?1?$DP?3?$EA?$CG?$DN?$CL?0$@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_01IPJKGB@?$CD@				; `string'
PUBLIC	??_C@_0BM@EJBDEPKK@resolving?5URI?5against?5base?6@ ; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_02CAHBHFGK@?4?1@				; `string'
PUBLIC	??_C@_07OJONJGHF@?1?$DL?$CG?$DN?$CL$?0@		; `string'
PUBLIC	??_C@_0BH@KBJNOCC@building?5relative?5URI?6@	; `string'
PUBLIC	??_C@_03GACAABJG@?3?1?1@			; `string'
PUBLIC	??_C@_09MLNEJDDK@?3?1?$DP_?4?$CD?$CG?$DL?$DN@	; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrstr:PROC
EXTRN	_xmlStrcmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlStrcat:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_09MLNEJDDK@?3?1?$DP_?4?$CD?$CG?$DL?$DN@
CONST	SEGMENT
??_C@_09MLNEJDDK@?3?1?$DP_?4?$CD?$CG?$DL?$DN@ DB ':/?_.#&;=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GACAABJG@?3?1?1@
CONST	SEGMENT
??_C@_03GACAABJG@?3?1?1@ DB '://', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KBJNOCC@building?5relative?5URI?6@
CONST	SEGMENT
??_C@_0BH@KBJNOCC@building?5relative?5URI?6@ DB 'building relative URI', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07OJONJGHF@?1?$DL?$CG?$DN?$CL$?0@
CONST	SEGMENT
??_C@_07OJONJGHF@?1?$DL?$CG?$DN?$CL$?0@ DB '/;&=+$,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02CAHBHFGK@?4?1@
CONST	SEGMENT
??_C@_02CAHBHFGK@?4?1@ DB './', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EJBDEPKK@resolving?5URI?5against?5base?6@
CONST	SEGMENT
??_C@_0BM@EJBDEPKK@resolving?5URI?5against?5base?6@ DB 'resolving URI aga'
	DB	'inst base', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IPJKGB@?$CD@
CONST	SEGMENT
??_C@_01IPJKGB@?$CD@ DB '#', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LPCDADNI@?$DL?1?$DP?3?$EA?$CG?$DN?$CL?0$@
CONST	SEGMENT
??_C@_0L@LPCDADNI@?$DL?1?$DP?3?$EA?$CG?$DN?$CL?0$@ DB ';/?:@&=+,$', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JBEGPNBA@?3?$EA?$CG?$DN?$CL$?0?1?$DP?$DL@
CONST	SEGMENT
??_C@_0L@JBEGPNBA@?3?$EA?$CG?$DN?$CL$?0?1?$DP?$DL@ DB ':@&=+$,/?;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EOFPKCAF@?$EA@
CONST	SEGMENT
??_C@_01EOFPKCAF@?$EA@ DB '@', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LHGLKCBA@?$DL?3?$CG?$DN?$CL$?0@
CONST	SEGMENT
??_C@_07LHGLKCBA@?$DL?3?$CG?$DN?$CL$?0@ DB ';:&=+$,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02CBLDBPFN@?1?1@
CONST	SEGMENT
??_C@_02CBLDBPFN@?1?1@ DB '//', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFBJJGAL@?1?$DP?$DL?3?$EA@
CONST	SEGMENT
??_C@_05GFBJJGAL@?1?$DP?$DL?3?$EA@ DB '/?;:@', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JCBKNEED@?$CL?9?4@
CONST	SEGMENT
??_C@_03JCBKNEED@?$CL?9?4@ DB '+-.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
CONST	SEGMENT
??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@ DB 'escaping URI value', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GBNFHGHH@unescaping?5URI?5value?6@
CONST	SEGMENT
??_C@_0BG@GBNFHGHH@unescaping?5URI?5value?6@ DB 'unescaping URI value', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DAMGJPCA@file@
CONST	SEGMENT
??_C@_04DAMGJPCA@file@ DB 'file', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HODKBCIO@?3?$CFd@
CONST	SEGMENT
??_C@_03HODKBCIO@?3?$CFd@ DB ':%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NFLMPNMP@saving?5URI?6@
CONST	SEGMENT
??_C@_0M@NFLMPNMP@saving?5URI?6@ DB 'saving URI', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PJGKIFED@reaching?5arbitrary?5MAX_URI_LENG@
CONST	SEGMENT
??_C@_0CJ@PJGKIFED@reaching?5arbitrary?5MAX_URI_LENG@ DB 'reaching arbitr'
	DB	'ary MAX_URI_LENGTH limit', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NJMLMHOE@creating?5URI?5structure?6@
CONST	SEGMENT
??_C@_0BI@NJMLMHOE@creating?5URI?5structure?6@ DB 'creating URI structure'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
CONST	SEGMENT
??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@ DB 'Memory allocation fa'
	DB	'iled', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _is_hex
_TEXT	SEGMENT
_c$ = 8							; size = 1
_is_hex	PROC						; COMDAT

; 1589 : static int is_hex(char c) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1590 :     if (((c >= '0') && (c <= '9')) ||
; 1591 :         ((c >= 'a') && (c <= 'f')) ||

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN4@is_hex
	movsx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 57					; 00000039H
	jle	SHORT $LN3@is_hex
$LN4@is_hex:
	movsx	edx, BYTE PTR _c$[ebp]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN5@is_hex
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 102				; 00000066H
	jle	SHORT $LN3@is_hex
$LN5@is_hex:
	movsx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN2@is_hex
	movsx	edx, BYTE PTR _c$[ebp]
	cmp	edx, 70					; 00000046H
	jg	SHORT $LN2@is_hex
$LN3@is_hex:

; 1592 :         ((c >= 'A') && (c <= 'F')))
; 1593 : 	return(1);

	mov	eax, 1
	jmp	SHORT $LN1@is_hex
$LN2@is_hex:

; 1594 :     return(0);

	xor	eax, eax
$LN1@is_hex:

; 1595 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_is_hex	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlSaveUriRealloc
_TEXT	SEGMENT
_tmp$ = -8						; size = 4
_temp$ = -4						; size = 4
_ret$ = 8						; size = 4
_max$ = 12						; size = 4
_xmlSaveUriRealloc PROC					; COMDAT

; 1031 : xmlSaveUriRealloc(xmlChar *ret, int *max) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1032 :     xmlChar *temp;
; 1033 :     int tmp;
; 1034 : 
; 1035 :     if (*max > MAX_URI_LENGTH) {

	mov	eax, DWORD PTR _max$[ebp]
	cmp	DWORD PTR [eax], 1048576		; 00100000H
	jle	SHORT $LN2@xmlSaveUri

; 1036 :         xmlURIErrMemory("reaching arbitrary MAX_URI_LENGTH limit\n");

	push	OFFSET ??_C@_0CJ@PJGKIFED@reaching?5arbitrary?5MAX_URI_LENG@
	call	_xmlURIErrMemory
	add	esp, 4

; 1037 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSaveUri
$LN2@xmlSaveUri:

; 1038 :     }
; 1039 :     tmp = *max * 2;

	mov	ecx, DWORD PTR _max$[ebp]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx

; 1040 :     temp = (xmlChar *) xmlRealloc(ret, (tmp + 1));

	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 1
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _temp$[ebp], eax

; 1041 :     if (temp == NULL) {

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN3@xmlSaveUri

; 1042 :         xmlURIErrMemory("saving URI\n");

	push	OFFSET ??_C@_0M@NFLMPNMP@saving?5URI?6@
	call	_xmlURIErrMemory
	add	esp, 4

; 1043 :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlSaveUri
$LN3@xmlSaveUri:

; 1044 :     }
; 1045 :     *max = tmp;

	mov	edx, DWORD PTR _max$[ebp]
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [edx], eax

; 1046 :     return(temp);

	mov	eax, DWORD PTR _temp$[ebp]
$LN1@xmlSaveUri:

; 1047 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlSaveUriRealloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986URIReference
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986URIReference PROC				; COMDAT

; 898  : xmlParse3986URIReference(xmlURIPtr uri, const char *str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 899  :     int ret;
; 900  : 
; 901  :     if (str == NULL)

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@xmlParse39

; 902  : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlParse39
$LN2@xmlParse39:

; 903  :     xmlCleanURI(uri);

	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlCleanURI
	add	esp, 4

; 904  : 
; 905  :     /*
; 906  :      * Try first to parse absolute refs, then fallback to relative if
; 907  :      * it fails.
; 908  :      */
; 909  :     ret = xmlParse3986URI(uri, str);

	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlParse3986URI
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 910  :     if (ret != 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN3@xmlParse39

; 911  : 	xmlCleanURI(uri);

	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlCleanURI
	add	esp, 4

; 912  :         ret = xmlParse3986RelativeRef(uri, str);

	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlParse3986RelativeRef
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 913  : 	if (ret != 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN3@xmlParse39

; 914  : 	    xmlCleanURI(uri);

	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlCleanURI
	add	esp, 4

; 915  : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParse39
$LN3@xmlParse39:

; 916  : 	}
; 917  :     }
; 918  :     return(0);

	xor	eax, eax
$LN1@xmlParse39:

; 919  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986URIReference ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986URI
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986URI PROC					; COMDAT

; 857  : xmlParse3986URI(xmlURIPtr uri, const char *str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 858  :     int ret;
; 859  : 
; 860  :     ret = xmlParse3986Scheme(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlParse3986Scheme
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 861  :     if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN2@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN2@xmlParse39:

; 862  :     if (*str != ':') {

	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN3@xmlParse39

; 863  : 	return(1);

	mov	eax, 1
	jmp	$LN1@xmlParse39
$LN3@xmlParse39:

; 864  :     }
; 865  :     str++;

	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str$[ebp], ecx

; 866  :     ret = xmlParse3986HierPart(uri, &str);

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlParse3986HierPart
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 867  :     if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN4@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN4@xmlParse39:

; 868  :     if (*str == '?') {

	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN5@xmlParse39

; 869  : 	str++;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax

; 870  : 	ret = xmlParse3986Query(uri, &str);

	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlParse3986Query
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 871  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN5@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParse39
$LN5@xmlParse39:

; 872  :     }
; 873  :     if (*str == '#') {

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 35					; 00000023H
	jne	SHORT $LN7@xmlParse39

; 874  : 	str++;

	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx

; 875  : 	ret = xmlParse3986Fragment(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlParse3986Fragment
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 876  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN7@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParse39
$LN7@xmlParse39:

; 877  :     }
; 878  :     if (*str != 0) {

	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN9@xmlParse39

; 879  : 	xmlCleanURI(uri);

	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlCleanURI
	add	esp, 4

; 880  : 	return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlParse39
$LN9@xmlParse39:

; 881  :     }
; 882  :     return(0);

	xor	eax, eax
$LN1@xmlParse39:

; 883  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986URI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986RelativeRef
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986RelativeRef PROC				; COMDAT

; 803  : xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 804  :     int ret;
; 805  : 
; 806  :     if ((*str == '/') && (*(str + 1) == '/')) {

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN2@xmlParse39
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN2@xmlParse39

; 807  :         str += 2;

	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 2
	mov	DWORD PTR _str$[ebp], ecx

; 808  : 	ret = xmlParse3986Authority(uri, &str);

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlParse3986Authority
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 809  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN4@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN4@xmlParse39:

; 810  : 	ret = xmlParse3986PathAbEmpty(uri, &str);

	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlParse3986PathAbEmpty
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 811  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN5@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN5@xmlParse39:

; 812  :     } else if (*str == '/') {

	jmp	$LN3@xmlParse39
$LN2@xmlParse39:
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN6@xmlParse39

; 813  : 	ret = xmlParse3986PathAbsolute(uri, &str);

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlParse3986PathAbsolute
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 814  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN8@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN8@xmlParse39:

; 815  :     } else if (ISA_PCHAR(str)) {

	jmp	$LN3@xmlParse39
$LN6@xmlParse39:
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN12@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 122				; 0000007aH
	jle	$LN11@xmlParse39
$LN12@xmlParse39:
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN13@xmlParse39
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 90					; 0000005aH
	jle	$LN11@xmlParse39
$LN13@xmlParse39:
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN14@xmlParse39
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jle	$LN11@xmlParse39
$LN14@xmlParse39:
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	je	$LN11@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	$LN11@xmlParse39
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	je	$LN11@xmlParse39
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 126				; 0000007eH
	je	$LN11@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	jne	$LN15@xmlParse39
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN17@xmlParse39
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN16@xmlParse39
$LN17@xmlParse39:
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN18@xmlParse39
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 102				; 00000066H
	jle	SHORT $LN16@xmlParse39
$LN18@xmlParse39:
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN15@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 70					; 00000046H
	jg	SHORT $LN15@xmlParse39
$LN16@xmlParse39:
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN19@xmlParse39
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 57					; 00000039H
	jle	$LN11@xmlParse39
$LN19@xmlParse39:
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN20@xmlParse39
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 102				; 00000066H
	jle	$LN11@xmlParse39
$LN20@xmlParse39:
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN15@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 70					; 00000046H
	jle	$LN11@xmlParse39
$LN15@xmlParse39:
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 33					; 00000021H
	je	$LN11@xmlParse39
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 36					; 00000024H
	je	SHORT $LN11@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 38					; 00000026H
	je	SHORT $LN11@xmlParse39
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN11@xmlParse39
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	je	SHORT $LN11@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	je	SHORT $LN11@xmlParse39
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN11@xmlParse39
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $LN11@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	je	SHORT $LN11@xmlParse39
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN11@xmlParse39
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 39					; 00000027H
	je	SHORT $LN11@xmlParse39
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	je	SHORT $LN11@xmlParse39
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN9@xmlParse39
$LN11@xmlParse39:

; 816  :         ret = xmlParse3986PathNoScheme(uri, &str);

	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlParse3986PathNoScheme
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 817  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN22@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN22@xmlParse39:

; 818  :     } else {

	jmp	SHORT $LN3@xmlParse39
$LN9@xmlParse39:

; 819  : 	/* path-empty is effectively empty */
; 820  : 	if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN3@xmlParse39

; 821  : 	    if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN24@xmlParse39
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN24@xmlParse39:

; 822  : 	    uri->path = NULL;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [eax+24], 0
$LN3@xmlParse39:

; 823  : 	}
; 824  :     }
; 825  : 
; 826  :     if (*str == '?') {

	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN25@xmlParse39

; 827  : 	str++;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax

; 828  : 	ret = xmlParse3986Query(uri, &str);

	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlParse3986Query
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 829  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN25@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParse39
$LN25@xmlParse39:

; 830  :     }
; 831  :     if (*str == '#') {

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 35					; 00000023H
	jne	SHORT $LN27@xmlParse39

; 832  : 	str++;

	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx

; 833  : 	ret = xmlParse3986Fragment(uri, &str);

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlParse3986Fragment
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 834  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN27@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParse39
$LN27@xmlParse39:

; 835  :     }
; 836  :     if (*str != 0) {

	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN29@xmlParse39

; 837  : 	xmlCleanURI(uri);

	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlCleanURI
	add	esp, 4

; 838  : 	return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlParse39
$LN29@xmlParse39:

; 839  :     }
; 840  :     return(0);

	xor	eax, eax
$LN1@xmlParse39:

; 841  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986RelativeRef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986HierPart
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_cur$ = -8						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986HierPart PROC				; COMDAT

; 753  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 754  :     const char *cur;
; 755  :     int ret;
; 756  : 
; 757  :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 758  : 
; 759  :     if ((*cur == '/') && (*(cur + 1) == '/')) {

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN2@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN2@xmlParse39

; 760  :         cur += 2;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 2
	mov	DWORD PTR _cur$[ebp], eax

; 761  : 	ret = xmlParse3986Authority(uri, &cur);

	lea	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlParse3986Authority
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 762  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN4@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN4@xmlParse39:

; 763  : 	if (uri->server == NULL)

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN5@xmlParse39

; 764  : 	    uri->port = -1;

	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+20], -1
$LN5@xmlParse39:

; 765  : 	ret = xmlParse3986PathAbEmpty(uri, &cur);

	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlParse3986PathAbEmpty
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 766  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN6@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN6@xmlParse39:

; 767  : 	*str = cur;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 768  : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlParse39
	jmp	$LN3@xmlParse39
$LN2@xmlParse39:

; 769  :     } else if (*cur == '/') {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN7@xmlParse39

; 770  :         ret = xmlParse3986PathAbsolute(uri, &cur);

	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlParse3986PathAbsolute
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 771  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN9@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN9@xmlParse39:

; 772  :     } else if (ISA_PCHAR(cur)) {

	jmp	$LN3@xmlParse39
$LN7@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN13@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 122				; 0000007aH
	jle	$LN12@xmlParse39
$LN13@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN14@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 90					; 0000005aH
	jle	$LN12@xmlParse39
$LN14@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN15@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jle	$LN12@xmlParse39
$LN15@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	je	$LN12@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	$LN12@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	je	$LN12@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 126				; 0000007eH
	je	$LN12@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	jne	$LN16@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN18@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN17@xmlParse39
$LN18@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN19@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 102				; 00000066H
	jle	SHORT $LN17@xmlParse39
$LN19@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 70					; 00000046H
	jg	SHORT $LN16@xmlParse39
$LN17@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN20@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 57					; 00000039H
	jle	$LN12@xmlParse39
$LN20@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN21@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 102				; 00000066H
	jle	$LN12@xmlParse39
$LN21@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 70					; 00000046H
	jle	$LN12@xmlParse39
$LN16@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 33					; 00000021H
	je	$LN12@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 36					; 00000024H
	je	SHORT $LN12@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 38					; 00000026H
	je	SHORT $LN12@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN12@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	je	SHORT $LN12@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	je	SHORT $LN12@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN12@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $LN12@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	je	SHORT $LN12@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN12@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 39					; 00000027H
	je	SHORT $LN12@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	je	SHORT $LN12@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN10@xmlParse39
$LN12@xmlParse39:

; 773  :         ret = xmlParse3986PathRootless(uri, &cur);

	lea	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlParse3986PathRootless
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 774  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN23@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParse39
$LN23@xmlParse39:

; 775  :     } else {

	jmp	SHORT $LN3@xmlParse39
$LN10@xmlParse39:

; 776  : 	/* path-empty is effectively empty */
; 777  : 	if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN3@xmlParse39

; 778  : 	    if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN25@xmlParse39
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN25@xmlParse39:

; 779  : 	    uri->path = NULL;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [eax+24], 0
$LN3@xmlParse39:

; 780  : 	}
; 781  :     }
; 782  :     *str = cur;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 783  :     return (0);

	xor	eax, eax
$LN1@xmlParse39:

; 784  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@xmlParse39
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@xmlParse39:
	DD	1
	DD	$LN28@xmlParse39
$LN28@xmlParse39:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN27@xmlParse39
$LN27@xmlParse39:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
_xmlParse3986HierPart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986PathNoScheme
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_cur$ = -8						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986PathNoScheme PROC				; COMDAT

; 708  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 709  :     const char *cur;
; 710  :     int ret;
; 711  : 
; 712  :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 713  : 
; 714  :     ret = xmlParse3986Segment(&cur, ':', 0);

	push	0
	push	58					; 0000003aH
	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 715  :     if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN2@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN2@xmlParse39:

; 716  :     while (*cur == '/') {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN3@xmlParse39

; 717  :         cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 718  : 	ret = xmlParse3986Segment(&cur, 0, 1);

	push	1
	push	0
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 719  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN5@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN5@xmlParse39:

; 720  :     }

	jmp	SHORT $LN2@xmlParse39
$LN3@xmlParse39:

; 721  :     if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	$LN6@xmlParse39

; 722  : 	if (uri->path != NULL) xmlFree(uri->path);

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN7@xmlParse39
	mov	esi, esp
	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlParse39:

; 723  :         if (cur != *str) {

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN8@xmlParse39

; 724  :             if (uri->cleanup & 2)

	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 2
	je	SHORT $LN10@xmlParse39

; 725  :                 uri->path = STRNDUP(*str, cur - *str);

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+24], eax
	jmp	SHORT $LN11@xmlParse39
$LN10@xmlParse39:

; 726  :             else
; 727  :                 uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN11@xmlParse39:

; 728  :         } else {

	jmp	SHORT $LN6@xmlParse39
$LN8@xmlParse39:

; 729  :             uri->path = NULL;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+24], 0
$LN6@xmlParse39:

; 730  :         }
; 731  :     }
; 732  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 733  :     return (0);

	xor	eax, eax
$LN1@xmlParse39:

; 734  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@xmlParse39
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@xmlParse39:
	DD	1
	DD	$LN14@xmlParse39
$LN14@xmlParse39:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN13@xmlParse39
$LN13@xmlParse39:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
_xmlParse3986PathNoScheme ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986PathRootless
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_cur$ = -8						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986PathRootless PROC				; COMDAT

; 666  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 667  :     const char *cur;
; 668  :     int ret;
; 669  : 
; 670  :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 671  : 
; 672  :     ret = xmlParse3986Segment(&cur, 0, 0);

	push	0
	push	0
	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 673  :     if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN2@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN2@xmlParse39:

; 674  :     while (*cur == '/') {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN3@xmlParse39

; 675  :         cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 676  : 	ret = xmlParse3986Segment(&cur, 0, 1);

	push	1
	push	0
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 677  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN5@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN5@xmlParse39:

; 678  :     }

	jmp	SHORT $LN2@xmlParse39
$LN3@xmlParse39:

; 679  :     if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	$LN6@xmlParse39

; 680  : 	if (uri->path != NULL) xmlFree(uri->path);

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN7@xmlParse39
	mov	esi, esp
	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlParse39:

; 681  :         if (cur != *str) {

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN8@xmlParse39

; 682  :             if (uri->cleanup & 2)

	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 2
	je	SHORT $LN10@xmlParse39

; 683  :                 uri->path = STRNDUP(*str, cur - *str);

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+24], eax
	jmp	SHORT $LN11@xmlParse39
$LN10@xmlParse39:

; 684  :             else
; 685  :                 uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN11@xmlParse39:

; 686  :         } else {

	jmp	SHORT $LN6@xmlParse39
$LN8@xmlParse39:

; 687  :             uri->path = NULL;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+24], 0
$LN6@xmlParse39:

; 688  :         }
; 689  :     }
; 690  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 691  :     return (0);

	xor	eax, eax
$LN1@xmlParse39:

; 692  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@xmlParse39
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@xmlParse39:
	DD	1
	DD	$LN14@xmlParse39
$LN14@xmlParse39:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN13@xmlParse39
$LN13@xmlParse39:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
_xmlParse3986PathRootless ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986PathAbsolute
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_cur$ = -8						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986PathAbsolute PROC				; COMDAT

; 620  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 621  :     const char *cur;
; 622  :     int ret;
; 623  : 
; 624  :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 625  : 
; 626  :     if (*cur != '/')

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN4@xmlParse39

; 627  :         return(1);

	mov	eax, 1
	jmp	$LN1@xmlParse39
$LN4@xmlParse39:

; 628  :     cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 629  :     ret = xmlParse3986Segment(&cur, 0, 0);

	push	0
	push	0
	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 630  :     if (ret == 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN5@xmlParse39
$LN2@xmlParse39:

; 631  : 	while (*cur == '/') {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN5@xmlParse39

; 632  : 	    cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 633  : 	    ret = xmlParse3986Segment(&cur, 0, 1);

	push	1
	push	0
	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 634  : 	    if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN6@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN6@xmlParse39:

; 635  : 	}

	jmp	SHORT $LN2@xmlParse39
$LN5@xmlParse39:

; 636  :     }
; 637  :     if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	$LN7@xmlParse39

; 638  : 	if (uri->path != NULL) xmlFree(uri->path);

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN8@xmlParse39
	mov	esi, esp
	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlParse39:

; 639  :         if (cur != *str) {

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN9@xmlParse39

; 640  :             if (uri->cleanup & 2)

	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 2
	je	SHORT $LN11@xmlParse39

; 641  :                 uri->path = STRNDUP(*str, cur - *str);

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+24], eax
	jmp	SHORT $LN12@xmlParse39
$LN11@xmlParse39:

; 642  :             else
; 643  :                 uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN12@xmlParse39:

; 644  :         } else {

	jmp	SHORT $LN7@xmlParse39
$LN9@xmlParse39:

; 645  :             uri->path = NULL;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+24], 0
$LN7@xmlParse39:

; 646  :         }
; 647  :     }
; 648  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 649  :     return (0);

	xor	eax, eax
$LN1@xmlParse39:

; 650  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@xmlParse39
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN16@xmlParse39:
	DD	1
	DD	$LN15@xmlParse39
$LN15@xmlParse39:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN14@xmlParse39
$LN14@xmlParse39:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
_xmlParse3986PathAbsolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986PathAbEmpty
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_cur$ = -8						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986PathAbEmpty PROC				; COMDAT

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 581  :     const char *cur;
; 582  :     int ret;
; 583  : 
; 584  :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx
$LN2@xmlParse39:

; 585  : 
; 586  :     while (*cur == '/') {

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN3@xmlParse39

; 587  :         cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 588  : 	ret = xmlParse3986Segment(&cur, 0, 1);

	push	1
	push	0
	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlParse3986Segment
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 589  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN4@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlParse39
$LN4@xmlParse39:

; 590  :     }

	jmp	SHORT $LN2@xmlParse39
$LN3@xmlParse39:

; 591  :     if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	$LN5@xmlParse39

; 592  : 	if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN6@xmlParse39
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlParse39:

; 593  :         if (*str != cur) {

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _cur$[ebp]
	je	SHORT $LN7@xmlParse39

; 594  :             if (uri->cleanup & 2)

	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 2
	je	SHORT $LN9@xmlParse39

; 595  :                 uri->path = STRNDUP(*str, cur - *str);

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	sub	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+24], eax
	jmp	SHORT $LN10@xmlParse39
$LN9@xmlParse39:

; 596  :             else
; 597  :                 uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN10@xmlParse39:

; 598  :         } else {

	jmp	SHORT $LN5@xmlParse39
$LN7@xmlParse39:

; 599  :             uri->path = NULL;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+24], 0
$LN5@xmlParse39:

; 600  :         }
; 601  :     }
; 602  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 603  :     return (0);

	xor	eax, eax
$LN1@xmlParse39:

; 604  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@xmlParse39
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN14@xmlParse39:
	DD	1
	DD	$LN13@xmlParse39
$LN13@xmlParse39:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN12@xmlParse39
$LN12@xmlParse39:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
_xmlParse3986PathAbEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Segment
_TEXT	SEGMENT
tv272 = -8						; size = 4
_cur$ = -4						; size = 4
_str$ = 8						; size = 4
_forbid$ = 12						; size = 1
_empty$ = 16						; size = 4
_xmlParse3986Segment PROC				; COMDAT

; 551  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 552  :     const char *cur;
; 553  : 
; 554  :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 555  :     if (!ISA_PCHAR(cur)) {

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jle	$LN2@xmlParse39
$LN5@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN6@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	jle	$LN2@xmlParse39
$LN6@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN7@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	$LN2@xmlParse39
$LN7@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	$LN2@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	je	$LN2@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	je	$LN2@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 126				; 0000007eH
	je	$LN2@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	$LN8@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN10@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN9@xmlParse39
$LN10@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN11@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 102				; 00000066H
	jle	SHORT $LN9@xmlParse39
$LN11@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN8@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 70					; 00000046H
	jg	SHORT $LN8@xmlParse39
$LN9@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN12@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 57					; 00000039H
	jle	$LN2@xmlParse39
$LN12@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN13@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 102				; 00000066H
	jle	$LN2@xmlParse39
$LN13@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN8@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 70					; 00000046H
	jle	$LN2@xmlParse39
$LN8@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	je	$LN2@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 36					; 00000024H
	je	$LN2@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 38					; 00000026H
	je	$LN2@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	je	SHORT $LN2@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN2@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	je	SHORT $LN2@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN2@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN2@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN2@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $LN2@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN2@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN2@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 64					; 00000040H
	je	SHORT $LN2@xmlParse39

; 556  :         if (empty)

	cmp	DWORD PTR _empty$[ebp], 0
	je	SHORT $LN15@xmlParse39

; 557  : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlParse39
$LN15@xmlParse39:

; 558  : 	return(1);

	mov	eax, 1
	jmp	$LN1@xmlParse39
$LN2@xmlParse39:

; 559  :     }
; 560  :     while (ISA_PCHAR(cur) && (*cur != forbid))

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN17@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jle	$LN16@xmlParse39
$LN17@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN18@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	jle	$LN16@xmlParse39
$LN18@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN19@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	$LN16@xmlParse39
$LN19@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	$LN16@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	je	$LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	je	$LN16@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 126				; 0000007eH
	je	$LN16@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	$LN20@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN22@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN21@xmlParse39
$LN22@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN23@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 102				; 00000066H
	jle	SHORT $LN21@xmlParse39
$LN23@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN20@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 70					; 00000046H
	jg	SHORT $LN20@xmlParse39
$LN21@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN24@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 57					; 00000039H
	jle	$LN16@xmlParse39
$LN24@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN25@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 102				; 00000066H
	jle	$LN16@xmlParse39
$LN25@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN20@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 70					; 00000046H
	jle	$LN16@xmlParse39
$LN20@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	je	$LN16@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN16@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 38					; 00000026H
	je	SHORT $LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	je	SHORT $LN16@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN16@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	je	SHORT $LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN16@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN16@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $LN16@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN16@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 64					; 00000040H
	jne	SHORT $LN3@xmlParse39
$LN16@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _forbid$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@xmlParse39

; 561  :         NEXT(cur);

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN28@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 3
	mov	DWORD PTR _cur$[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv272[ebp], edx
	jmp	SHORT $LN29@xmlParse39
$LN28@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv272[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
$LN29@xmlParse39:
	jmp	$LN2@xmlParse39
$LN3@xmlParse39:

; 562  :     *str = cur;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 563  :     return (0);

	xor	eax, eax
$LN1@xmlParse39:

; 564  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986Segment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Authority
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_cur$ = -8						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Authority PROC				; COMDAT

; 509  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 510  :     const char *cur;
; 511  :     int ret;
; 512  : 
; 513  :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 514  :     /*
; 515  :      * try to parse an userinfo and check for the trailing @
; 516  :      */
; 517  :     ret = xmlParse3986Userinfo(uri, &cur);

	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlParse3986Userinfo
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 518  :     if ((ret != 0) || (*cur != '@'))

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN4@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 64					; 00000040H
	je	SHORT $LN2@xmlParse39
$LN4@xmlParse39:

; 519  :         cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN3@xmlParse39
$LN2@xmlParse39:

; 520  :     else
; 521  :         cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
$LN3@xmlParse39:

; 522  :     ret = xmlParse3986Host(uri, &cur);

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlParse3986Host
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 523  :     if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN5@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParse39
$LN5@xmlParse39:

; 524  :     if (*cur == ':') {

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN6@xmlParse39

; 525  :         cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 526  :         ret = xmlParse3986Port(uri, &cur);

	lea	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlParse3986Port
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 527  : 	if (ret != 0) return(ret);

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN6@xmlParse39
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlParse39
$LN6@xmlParse39:

; 528  :     }
; 529  :     *str = cur;

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 530  :     return(0);

	xor	eax, eax
$LN1@xmlParse39:

; 531  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@xmlParse39
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@xmlParse39:
	DD	1
	DD	$LN10@xmlParse39
$LN10@xmlParse39:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN9@xmlParse39
$LN9@xmlParse39:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
_xmlParse3986Authority ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Host
_TEXT	SEGMENT
tv214 = -20						; size = 4
_host$ = -16						; size = 4
_cur$ = -8						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Host PROC					; COMDAT

; 433  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 434  :     const char *cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 435  :     const char *host;
; 436  : 
; 437  :     host = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _host$[ebp], edx

; 438  :     /*
; 439  :      * IPv6 and future adressing scheme are enclosed between brackets
; 440  :      */
; 441  :     if (*cur == '[') {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 91					; 0000005bH
	jne	SHORT $LN6@xmlParse39

; 442  :         cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
$LN2@xmlParse39:

; 443  : 	while ((*cur != ']') && (*cur != 0))

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	je	SHORT $LN3@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@xmlParse39

; 444  : 	    cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN2@xmlParse39
$LN3@xmlParse39:

; 445  : 	if (*cur != ']')

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN7@xmlParse39

; 446  : 	    return(1);

	mov	eax, 1
	jmp	$LN1@xmlParse39
$LN7@xmlParse39:

; 447  : 	cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 448  : 	goto found;

	jmp	$found$41
$LN6@xmlParse39:

; 449  :     }
; 450  :     /*
; 451  :      * try to parse an IPv4
; 452  :      */
; 453  :     if (ISA_DIGIT(cur)) {

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	$LN4@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jg	$LN4@xmlParse39

; 454  :         if (xmlParse3986DecOctet(&cur) != 0)

	lea	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlParse3986DecOctet
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@xmlParse39

; 455  : 	    goto not_ipv4;

	jmp	SHORT $not_ipv4$42
$LN9@xmlParse39:

; 456  : 	if (*cur != '.')

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	je	SHORT $LN10@xmlParse39

; 457  : 	    goto not_ipv4;

	jmp	SHORT $not_ipv4$42
$LN10@xmlParse39:

; 458  : 	cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 459  :         if (xmlParse3986DecOctet(&cur) != 0)

	lea	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlParse3986DecOctet
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@xmlParse39

; 460  : 	    goto not_ipv4;

	jmp	SHORT $not_ipv4$42
$LN11@xmlParse39:

; 461  : 	if (*cur != '.')

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN12@xmlParse39

; 462  : 	    goto not_ipv4;

	jmp	SHORT $not_ipv4$42
$LN12@xmlParse39:

; 463  :         if (xmlParse3986DecOctet(&cur) != 0)

	lea	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlParse3986DecOctet
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@xmlParse39

; 464  : 	    goto not_ipv4;

	jmp	SHORT $not_ipv4$42
$LN13@xmlParse39:

; 465  : 	if (*cur != '.')

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN14@xmlParse39

; 466  : 	    goto not_ipv4;

	jmp	SHORT $not_ipv4$42
$LN14@xmlParse39:

; 467  :         if (xmlParse3986DecOctet(&cur) != 0)

	lea	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlParse3986DecOctet
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@xmlParse39

; 468  : 	    goto not_ipv4;

	jmp	SHORT $not_ipv4$42
$LN15@xmlParse39:

; 469  : 	goto found;

	jmp	$found$41
$not_ipv4$42:

; 470  : not_ipv4:
; 471  :         cur = *str;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _cur$[ebp], eax
$LN4@xmlParse39:

; 472  :     }
; 473  :     /*
; 474  :      * then this should be a hostname which can be empty
; 475  :      */
; 476  :     while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN17@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 122				; 0000007aH
	jle	$LN16@xmlParse39
$LN17@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN18@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 90					; 0000005aH
	jle	$LN16@xmlParse39
$LN18@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN19@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jle	$LN16@xmlParse39
$LN19@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	je	$LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	$LN16@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	je	$LN16@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 126				; 0000007eH
	je	$LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	jne	$LN20@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN22@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN21@xmlParse39
$LN22@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN23@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 102				; 00000066H
	jle	SHORT $LN21@xmlParse39
$LN23@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN20@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 70					; 00000046H
	jg	SHORT $LN20@xmlParse39
$LN21@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN24@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 57					; 00000039H
	jle	$LN16@xmlParse39
$LN24@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN25@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 102				; 00000066H
	jle	$LN16@xmlParse39
$LN25@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN20@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 70					; 00000046H
	jle	SHORT $LN16@xmlParse39
$LN20@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 33					; 00000021H
	je	SHORT $LN16@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 36					; 00000024H
	je	SHORT $LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 38					; 00000026H
	je	SHORT $LN16@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN16@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	je	SHORT $LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	je	SHORT $LN16@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN16@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $LN16@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	je	SHORT $LN16@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN16@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 39					; 00000027H
	jne	SHORT $found$41
$LN16@xmlParse39:

; 477  :         NEXT(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	jne	SHORT $LN36@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 3
	mov	DWORD PTR _cur$[ebp], edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv214[ebp], eax
	jmp	SHORT $LN37@xmlParse39
$LN36@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv214[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
$LN37@xmlParse39:
	jmp	$LN4@xmlParse39
$found$41:

; 478  : found:
; 479  :     if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	$LN28@xmlParse39

; 480  : 	if (uri->authority != NULL) xmlFree(uri->authority);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN29@xmlParse39
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN29@xmlParse39:

; 481  : 	uri->authority = NULL;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [eax+8], 0

; 482  : 	if (uri->server != NULL) xmlFree(uri->server);

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN30@xmlParse39
	mov	esi, esp
	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN30@xmlParse39:

; 483  : 	if (cur != host) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, DWORD PTR _host$[ebp]
	je	SHORT $LN31@xmlParse39

; 484  : 	    if (uri->cleanup & 2)

	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 2
	je	SHORT $LN33@xmlParse39

; 485  : 		uri->server = STRNDUP(host, cur - host);

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR _host$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host$[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN34@xmlParse39
$LN33@xmlParse39:

; 486  : 	    else
; 487  : 		uri->server = xmlURIUnescapeString(host, cur - host, NULL);

	push	0
	mov	edx, DWORD PTR _cur$[ebp]
	sub	edx, DWORD PTR _host$[ebp]
	push	edx
	mov	eax, DWORD PTR _host$[ebp]
	push	eax
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN34@xmlParse39:

; 488  : 	} else

	jmp	SHORT $LN28@xmlParse39
$LN31@xmlParse39:

; 489  : 	    uri->server = NULL;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+12], 0
$LN28@xmlParse39:

; 490  :     }
; 491  :     *str = cur;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 492  :     return(0);

	xor	eax, eax
$LN1@xmlParse39:

; 493  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN40@xmlParse39
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN40@xmlParse39:
	DD	1
	DD	$LN39@xmlParse39
$LN39@xmlParse39:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN38@xmlParse39
$LN38@xmlParse39:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
_xmlParse3986Host ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986DecOctet
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_str$ = 8						; size = 4
_xmlParse3986DecOctet PROC				; COMDAT

; 394  : xmlParse3986DecOctet(const char **str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 395  :     const char *cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 396  : 
; 397  :     if (!(ISA_DIGIT(cur)))

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN2@xmlParse39
$LN3@xmlParse39:

; 398  :         return(1);

	mov	eax, 1
	jmp	$LN1@xmlParse39
$LN2@xmlParse39:

; 399  :     if (!ISA_DIGIT(cur+1))

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN6@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN4@xmlParse39
$LN6@xmlParse39:

; 400  : 	cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	$LN5@xmlParse39
$LN4@xmlParse39:

; 401  :     else if ((*cur != '0') && (ISA_DIGIT(cur + 1)) && (!ISA_DIGIT(cur+2)))

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	je	SHORT $LN7@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN7@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN7@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN9@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN7@xmlParse39
$LN9@xmlParse39:

; 402  : 	cur += 2;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 2
	mov	DWORD PTR _cur$[ebp], eax
	jmp	$LN5@xmlParse39
$LN7@xmlParse39:

; 403  :     else if ((*cur == '1') && (ISA_DIGIT(cur + 1)) && (ISA_DIGIT(cur + 2)))

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 49					; 00000031H
	jne	SHORT $LN10@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN10@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN10@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN10@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN10@xmlParse39

; 404  : 	cur += 3;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 3
	mov	DWORD PTR _cur$[ebp], edx
	jmp	$LN5@xmlParse39
$LN10@xmlParse39:

; 405  :     else if ((*cur == '2') && (*(cur + 1) >= '0') &&
; 406  : 	     (*(cur + 1) <= '4') && (ISA_DIGIT(cur + 2)))

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 50					; 00000032H
	jne	SHORT $LN12@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN12@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 52					; 00000034H
	jg	SHORT $LN12@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN12@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN12@xmlParse39

; 407  : 	cur += 3;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 3
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN5@xmlParse39
$LN12@xmlParse39:

; 408  :     else if ((*cur == '2') && (*(cur + 1) == '5') &&
; 409  : 	     (*(cur + 2) >= '0') && (*(cur + 1) <= '5'))

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 50					; 00000032H
	jne	SHORT $LN14@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 53					; 00000035H
	jne	SHORT $LN14@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN14@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 53					; 00000035H
	jg	SHORT $LN14@xmlParse39

; 410  : 	cur += 3;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 3
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN5@xmlParse39
$LN14@xmlParse39:

; 411  :     else
; 412  :         return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlParse39
$LN5@xmlParse39:

; 413  :     *str = cur;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 414  :     return(0);

	xor	eax, eax
$LN1@xmlParse39:

; 415  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986DecOctet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Userinfo
_TEXT	SEGMENT
tv182 = -8						; size = 4
_cur$ = -4						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Userinfo PROC				; COMDAT

; 358  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 359  :     const char *cur;
; 360  : 
; 361  :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx
$LN2@xmlParse39:

; 362  :     while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
; 363  :            ISA_SUB_DELIM(cur) || (*cur == ':'))

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jle	$LN4@xmlParse39
$LN5@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN6@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	jle	$LN4@xmlParse39
$LN6@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN7@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	$LN4@xmlParse39
$LN7@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	$LN4@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	je	$LN4@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	je	$LN4@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 126				; 0000007eH
	je	$LN4@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	$LN8@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN10@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN9@xmlParse39
$LN10@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN11@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 102				; 00000066H
	jle	SHORT $LN9@xmlParse39
$LN11@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN8@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 70					; 00000046H
	jg	SHORT $LN8@xmlParse39
$LN9@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN12@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 57					; 00000039H
	jle	$LN4@xmlParse39
$LN12@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN13@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 102				; 00000066H
	jle	$LN4@xmlParse39
$LN13@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN8@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 70					; 00000046H
	jle	$LN4@xmlParse39
$LN8@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	je	SHORT $LN4@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN4@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 38					; 00000026H
	je	SHORT $LN4@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	je	SHORT $LN4@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN4@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	je	SHORT $LN4@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN4@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN4@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN4@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $LN4@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN4@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	jne	SHORT $LN3@xmlParse39
$LN4@xmlParse39:

; 364  : 	NEXT(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	jne	SHORT $LN21@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 3
	mov	DWORD PTR _cur$[ebp], edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv182[ebp], eax
	jmp	SHORT $LN22@xmlParse39
$LN21@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
$LN22@xmlParse39:
	jmp	$LN2@xmlParse39
$LN3@xmlParse39:

; 365  :     if (*cur == '@') {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 64					; 00000040H
	jne	SHORT $LN15@xmlParse39

; 366  : 	if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN16@xmlParse39

; 367  : 	    if (uri->user != NULL) xmlFree(uri->user);

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN17@xmlParse39
	mov	esi, esp
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@xmlParse39:

; 368  : 	    if (uri->cleanup & 2)

	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 2
	je	SHORT $LN18@xmlParse39

; 369  : 		uri->user = STRNDUP(*str, cur - *str);

	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	sub	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	SHORT $LN16@xmlParse39
$LN18@xmlParse39:

; 370  : 	    else
; 371  : 		uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN16@xmlParse39:

; 372  : 	}
; 373  : 	*str = cur;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 374  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParse39
$LN15@xmlParse39:

; 375  :     }
; 376  :     return(1);

	mov	eax, 1
$LN1@xmlParse39:

; 377  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986Userinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Port
_TEXT	SEGMENT
_port$ = -8						; size = 4
_cur$ = -4						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Port PROC					; COMDAT

; 326  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 327  :     const char *cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 328  :     unsigned port = 0; /* unsigned for defined overflow behavior */

	mov	DWORD PTR _port$[ebp], 0

; 329  : 
; 330  :     if (ISA_DIGIT(cur)) {

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN4@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN4@xmlParse39
$LN2@xmlParse39:

; 331  : 	while (ISA_DIGIT(cur)) {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN3@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@xmlParse39

; 332  : 	    port = port * 10 + (*cur - '0');

	imul	ecx, DWORD PTR _port$[ebp], 10
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	DWORD PTR _port$[ebp], ecx

; 333  : 
; 334  : 	    cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 335  : 	}

	jmp	SHORT $LN2@xmlParse39
$LN3@xmlParse39:

; 336  : 	if (uri != NULL)

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN5@xmlParse39

; 337  : 	    uri->port = port & INT_MAX; /* port value modulo INT_MAX+1 */

	mov	eax, DWORD PTR _port$[ebp]
	and	eax, 2147483647				; 7fffffffH
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN5@xmlParse39:

; 338  : 	*str = cur;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 339  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParse39
$LN4@xmlParse39:

; 340  :     }
; 341  :     return(1);

	mov	eax, 1
$LN1@xmlParse39:

; 342  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986Port ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Query
_TEXT	SEGMENT
tv209 = -8						; size = 4
_cur$ = -4						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Query PROC					; COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 283  :     const char *cur;
; 284  : 
; 285  :     if (str == NULL)

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN4@xmlParse39

; 286  :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlParse39
$LN4@xmlParse39:

; 287  : 
; 288  :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx
$LN2@xmlParse39:

; 289  : 
; 290  :     while ((ISA_PCHAR(cur)) || (*cur == '/') || (*cur == '?') ||

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN6@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jle	$LN5@xmlParse39
$LN6@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN7@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	jle	$LN5@xmlParse39
$LN7@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN8@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	$LN5@xmlParse39
$LN8@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	je	$LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 126				; 0000007eH
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	$LN9@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN11@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN10@xmlParse39
$LN11@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN12@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 102				; 00000066H
	jle	SHORT $LN10@xmlParse39
$LN12@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN9@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 70					; 00000046H
	jg	SHORT $LN9@xmlParse39
$LN10@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN13@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 57					; 00000039H
	jle	$LN5@xmlParse39
$LN13@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN14@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 102				; 00000066H
	jle	$LN5@xmlParse39
$LN14@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN9@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 70					; 00000046H
	jle	$LN5@xmlParse39
$LN9@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 36					; 00000024H
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 38					; 00000026H
	je	$LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 41					; 00000029H
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	je	$LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	$LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	$LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 64					; 00000040H
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 63					; 0000003fH
	je	SHORT $LN5@xmlParse39
	cmp	DWORD PTR _uri$[ebp], 0
	je	$LN3@xmlParse39
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	je	$LN3@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 125				; 0000007dH
	je	SHORT $LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 124				; 0000007cH
	je	SHORT $LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 94					; 0000005eH
	je	SHORT $LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 91					; 0000005bH
	je	SHORT $LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 96					; 00000060H
	jne	SHORT $LN3@xmlParse39
$LN5@xmlParse39:

; 291  :            ((uri != NULL) && (uri->cleanup & 1) && (IS_UNWISE(cur))))
; 292  :         NEXT(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	jne	SHORT $LN23@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 3
	mov	DWORD PTR _cur$[ebp], edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv209[ebp], eax
	jmp	SHORT $LN24@xmlParse39
$LN23@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv209[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
$LN24@xmlParse39:
	jmp	$LN2@xmlParse39
$LN3@xmlParse39:

; 293  :     if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	$LN17@xmlParse39

; 294  :         if (uri->query != NULL)

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN18@xmlParse39

; 295  :             xmlFree(uri->query);

	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@xmlParse39:

; 296  : 	if (uri->cleanup & 2)

	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 2
	je	SHORT $LN19@xmlParse39

; 297  : 	    uri->query = STRNDUP(*str, cur - *str);

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN20@xmlParse39
$LN19@xmlParse39:

; 298  : 	else
; 299  : 	    uri->query = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+28], eax
$LN20@xmlParse39:

; 300  : 
; 301  : 	/* Save the raw bytes of the query as well.
; 302  : 	 * See: http://mail.gnome.org/archives/xml/2007-April/thread.html#00114
; 303  : 	 */
; 304  : 	if (uri->query_raw != NULL)

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN21@xmlParse39

; 305  : 	    xmlFree (uri->query_raw);

	mov	esi, esp
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN21@xmlParse39:

; 306  : 	uri->query_raw = STRNDUP (*str, cur - *str);

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+40], eax
$LN17@xmlParse39:

; 307  :     }
; 308  :     *str = cur;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 309  :     return (0);

	xor	eax, eax
$LN1@xmlParse39:

; 310  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986Query ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Fragment
_TEXT	SEGMENT
tv213 = -8						; size = 4
_cur$ = -4						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Fragment PROC				; COMDAT

; 245  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 246  :     const char *cur;
; 247  : 
; 248  :     if (str == NULL)

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN4@xmlParse39

; 249  :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlParse39
$LN4@xmlParse39:

; 250  : 
; 251  :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx
$LN2@xmlParse39:

; 252  : 
; 253  :     while ((ISA_PCHAR(cur)) || (*cur == '/') || (*cur == '?') ||
; 254  :            (*cur == '[') || (*cur == ']') ||

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN6@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jle	$LN5@xmlParse39
$LN6@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN7@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	jle	$LN5@xmlParse39
$LN7@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN8@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	$LN5@xmlParse39
$LN8@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	je	$LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 126				; 0000007eH
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	$LN9@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN11@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN10@xmlParse39
$LN11@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN12@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 102				; 00000066H
	jle	SHORT $LN10@xmlParse39
$LN12@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN9@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 70					; 00000046H
	jg	SHORT $LN9@xmlParse39
$LN10@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN13@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 57					; 00000039H
	jle	$LN5@xmlParse39
$LN13@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN14@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 102				; 00000066H
	jle	$LN5@xmlParse39
$LN14@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN9@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 70					; 00000046H
	jle	$LN5@xmlParse39
$LN9@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 36					; 00000024H
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 38					; 00000026H
	je	$LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 41					; 00000029H
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	je	$LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	$LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	$LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 64					; 00000040H
	je	$LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	je	$LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 63					; 0000003fH
	je	$LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 91					; 0000005bH
	je	SHORT $LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN5@xmlParse39
	cmp	DWORD PTR _uri$[ebp], 0
	je	$LN3@xmlParse39
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 1
	je	$LN3@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 124				; 0000007cH
	je	SHORT $LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 94					; 0000005eH
	je	SHORT $LN5@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 91					; 0000005bH
	je	SHORT $LN5@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	je	SHORT $LN5@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 96					; 00000060H
	jne	SHORT $LN3@xmlParse39
$LN5@xmlParse39:

; 255  :            ((uri != NULL) && (uri->cleanup & 1) && (IS_UNWISE(cur))))
; 256  :         NEXT(cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	SHORT $LN22@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 3
	mov	DWORD PTR _cur$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv213[ebp], ecx
	jmp	SHORT $LN23@xmlParse39
$LN22@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR tv213[ebp], edx
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
$LN23@xmlParse39:
	jmp	$LN2@xmlParse39
$LN3@xmlParse39:

; 257  :     if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN17@xmlParse39

; 258  :         if (uri->fragment != NULL)

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN18@xmlParse39

; 259  :             xmlFree(uri->fragment);

	mov	esi, esp
	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@xmlParse39:

; 260  : 	if (uri->cleanup & 2)

	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 2
	je	SHORT $LN19@xmlParse39

; 261  : 	    uri->fragment = STRNDUP(*str, cur - *str);

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+32], eax
	jmp	SHORT $LN17@xmlParse39
$LN19@xmlParse39:

; 262  : 	else
; 263  : 	    uri->fragment = xmlURIUnescapeString(*str, cur - *str, NULL);

	push	0
	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	sub	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlURIUnescapeString
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+32], eax
$LN17@xmlParse39:

; 264  :     }
; 265  :     *str = cur;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 266  :     return (0);

	xor	eax, eax
$LN1@xmlParse39:

; 267  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986Fragment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParse3986Scheme
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParse3986Scheme PROC				; COMDAT

; 208  : xmlParse3986Scheme(xmlURIPtr uri, const char **str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 209  :     const char *cur;
; 210  : 
; 211  :     if (str == NULL)

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN4@xmlParse39

; 212  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlParse39
$LN4@xmlParse39:

; 213  : 
; 214  :     cur = *str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 215  :     if (!ISA_ALPHA(cur))

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN6@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jle	SHORT $LN5@xmlParse39
$LN6@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN7@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	jle	SHORT $LN5@xmlParse39
$LN7@xmlParse39:

; 216  : 	return(2);

	mov	eax, 2
	jmp	$LN1@xmlParse39
$LN5@xmlParse39:

; 217  :     cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
$LN2@xmlParse39:

; 218  :     while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
; 219  :            (*cur == '+') || (*cur == '-') || (*cur == '.')) cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN9@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jle	SHORT $LN8@xmlParse39
$LN9@xmlParse39:
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN10@xmlParse39
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	jle	SHORT $LN8@xmlParse39
$LN10@xmlParse39:
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN11@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	SHORT $LN8@xmlParse39
$LN11@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN8@xmlParse39
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN8@xmlParse39
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	jne	SHORT $LN3@xmlParse39
$LN8@xmlParse39:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN2@xmlParse39
$LN3@xmlParse39:

; 220  :     if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN12@xmlParse39

; 221  : 	if (uri->scheme != NULL) xmlFree(uri->scheme);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN13@xmlParse39
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlParse39:

; 222  : 	uri->scheme = STRNDUP(*str, cur - *str);

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx], eax
$LN12@xmlParse39:

; 223  :     }
; 224  :     *str = cur;

	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 225  :     return(0);

	xor	eax, eax
$LN1@xmlParse39:

; 226  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParse3986Scheme ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlCleanURI
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_xmlCleanURI PROC					; COMDAT

; 1349 : xmlCleanURI(xmlURIPtr uri) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1350 :     if (uri == NULL) return;

	cmp	DWORD PTR _uri$[ebp], 0
	jne	SHORT $LN2@xmlCleanUR
	jmp	$LN1@xmlCleanUR
$LN2@xmlCleanUR:

; 1351 : 
; 1352 :     if (uri->scheme != NULL) xmlFree(uri->scheme);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlCleanUR
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlCleanUR:

; 1353 :     uri->scheme = NULL;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [eax], 0

; 1354 :     if (uri->server != NULL) xmlFree(uri->server);

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN4@xmlCleanUR
	mov	esi, esp
	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlCleanUR:

; 1355 :     uri->server = NULL;

	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1356 :     if (uri->user != NULL) xmlFree(uri->user);

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN5@xmlCleanUR
	mov	esi, esp
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlCleanUR:

; 1357 :     uri->user = NULL;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1358 :     if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN6@xmlCleanUR
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlCleanUR:

; 1359 :     uri->path = NULL;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [eax+24], 0

; 1360 :     if (uri->fragment != NULL) xmlFree(uri->fragment);

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN7@xmlCleanUR
	mov	esi, esp
	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlCleanUR:

; 1361 :     uri->fragment = NULL;

	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 1362 :     if (uri->opaque != NULL) xmlFree(uri->opaque);

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN8@xmlCleanUR
	mov	esi, esp
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlCleanUR:

; 1363 :     uri->opaque = NULL;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+4], 0

; 1364 :     if (uri->authority != NULL) xmlFree(uri->authority);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN9@xmlCleanUR
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlCleanUR:

; 1365 :     uri->authority = NULL;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1366 :     if (uri->query != NULL) xmlFree(uri->query);

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN10@xmlCleanUR
	mov	esi, esp
	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlCleanUR:

; 1367 :     uri->query = NULL;

	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 1368 :     if (uri->query_raw != NULL) xmlFree(uri->query_raw);

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN11@xmlCleanUR
	mov	esi, esp
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlCleanUR:

; 1369 :     uri->query_raw = NULL;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+40], 0
$LN1@xmlCleanUR:

; 1370 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCleanURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlURIErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlURIErrMemory PROC					; COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 38   :     if (extra)

	cmp	DWORD PTR _extra$[ebp], 0
	je	SHORT $LN2@xmlURIErrM

; 39   :         __xmlRaiseError(NULL, NULL, NULL,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _extra$[ebp]
	push	ecx
	push	0
	push	0
	push	3
	push	2
	push	30					; 0000001eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
	jmp	SHORT $LN1@xmlURIErrM
$LN2@xmlURIErrM:

; 40   :                         NULL, NULL, XML_FROM_URI,
; 41   :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
; 42   :                         extra, NULL, NULL, 0, 0,
; 43   :                         "Memory allocation failed : %s\n", extra);
; 44   :     else
; 45   :         __xmlRaiseError(NULL, NULL, NULL,

	push	OFFSET ??_C@_0BK@GDFDKGPJ@Memory?5allocation?5failed?6@
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	3
	push	2
	push	30					; 0000001eH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 64					; 00000040H
$LN1@xmlURIErrM:

; 46   :                         NULL, NULL, XML_FROM_URI,
; 47   :                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
; 48   :                         NULL, NULL, NULL, 0, 0,
; 49   :                         "Memory allocation failed\n");
; 50   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlURIErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlPathToURI
_TEXT	SEGMENT
_cal$ = -64						; size = 4
_ret$ = -60						; size = 4
_temp$ = -52						; size = 44
_uri$ = -4						; size = 4
_path$ = 8						; size = 4
_xmlPathToURI PROC					; COMDAT

; 2512 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 2513 :     xmlURIPtr uri;
; 2514 :     xmlURI temp;
; 2515 :     xmlChar *ret, *cal;
; 2516 : 
; 2517 :     if (path == NULL)

	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN4@xmlPathToU

; 2518 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlPathToU
$LN4@xmlPathToU:

; 2519 : 
; 2520 :     if ((uri = xmlParseURI((const char *) path)) != NULL) {

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$[ebp], eax
	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN5@xmlPathToU

; 2521 : 	xmlFreeURI(uri);

	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlFreeURI
	add	esp, 4

; 2522 : 	return xmlStrdup(path);

	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN1@xmlPathToU
$LN5@xmlPathToU:

; 2523 :     }
; 2524 :     cal = xmlCanonicPath(path);

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_xmlCanonicPath
	add	esp, 4
	mov	DWORD PTR _cal$[ebp], eax

; 2525 :     if (cal == NULL)

	cmp	DWORD PTR _cal$[ebp], 0
	jne	SHORT $LN6@xmlPathToU

; 2526 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlPathToU
$LN6@xmlPathToU:

; 2527 : #if defined(_WIN32) && !defined(__CYGWIN__)
; 2528 :     /* xmlCanonicPath can return an URI on Windows (is that the intended behaviour?)
; 2529 :        If 'cal' is a valid URI allready then we are done here, as continuing would make
; 2530 :        it invalid. */
; 2531 :     if ((uri = xmlParseURI((const char *) cal)) != NULL) {

	mov	ecx, DWORD PTR _cal$[ebp]
	push	ecx
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$[ebp], eax
	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN7@xmlPathToU

; 2532 : 	xmlFreeURI(uri);

	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4

; 2533 : 	return cal;

	mov	eax, DWORD PTR _cal$[ebp]
	jmp	SHORT $LN1@xmlPathToU
$LN7@xmlPathToU:

; 2534 :     }
; 2535 :     /* 'cal' can contain a relative path with backslashes. If that is processed
; 2536 :        by xmlSaveURI, they will be escaped and the external entity loader machinery
; 2537 :        will fail. So convert them to slashes. Misuse 'ret' for walking. */
; 2538 :     ret = cal;

	mov	eax, DWORD PTR _cal$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN2@xmlPathToU:

; 2539 :     while (*ret != '\0') {

	mov	ecx, DWORD PTR _ret$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@xmlPathToU

; 2540 : 	if (*ret == '\\')

	mov	eax, DWORD PTR _ret$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN8@xmlPathToU

; 2541 : 	    *ret = '/';

	mov	edx, DWORD PTR _ret$[ebp]
	mov	BYTE PTR [edx], 47			; 0000002fH
$LN8@xmlPathToU:

; 2542 : 	ret++;

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, 1
	mov	DWORD PTR _ret$[ebp], eax

; 2543 :     }

	jmp	SHORT $LN2@xmlPathToU
$LN3@xmlPathToU:

; 2544 : #endif
; 2545 :     memset(&temp, 0, sizeof(temp));

	push	44					; 0000002cH
	push	0
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2546 :     temp.path = (char *) cal;

	mov	edx, DWORD PTR _cal$[ebp]
	mov	DWORD PTR _temp$[ebp+24], edx

; 2547 :     ret = xmlSaveUri(&temp);

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_xmlSaveUri
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2548 :     xmlFree(cal);

	mov	esi, esp
	mov	ecx, DWORD PTR _cal$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2549 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlPathToU:

; 2550 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@xmlPathToU
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN12@xmlPathToU:
	DD	1
	DD	$LN11@xmlPathToU
$LN11@xmlPathToU:
	DD	-52					; ffffffccH
	DD	44					; 0000002cH
	DD	$LN10@xmlPathToU
$LN10@xmlPathToU:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_xmlPathToURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlCanonicPath
_TEXT	SEGMENT
_escURI$1 = -36						; size = 4
_c$2 = -29						; size = 1
_j$3 = -28						; size = 4
_l$4 = -24						; size = 4
_absuri$ = -20						; size = 4
_ret$ = -16						; size = 4
_uri$ = -12						; size = 4
_p$ = -8						; size = 4
_len$ = -4						; size = 4
_path$ = 8						; size = 4
_xmlCanonicPath PROC					; COMDAT

; 2371 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 2372 : /*
; 2373 :  * For Windows implementations, additional work needs to be done to
; 2374 :  * replace backslashes in pathnames with "forward slashes"
; 2375 :  */
; 2376 : #if defined(_WIN32) && !defined(__CYGWIN__)
; 2377 :     int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 2378 :     char *p = NULL;

	mov	DWORD PTR _p$[ebp], 0

; 2379 : #endif
; 2380 :     xmlURIPtr uri;
; 2381 :     xmlChar *ret;
; 2382 :     const xmlChar *absuri;
; 2383 : 
; 2384 :     if (path == NULL)

	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN7@xmlCanonic

; 2385 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCanonic
$LN7@xmlCanonic:

; 2386 : 
; 2387 : #if defined(_WIN32)
; 2388 :     /*
; 2389 :      * We must not change the backslashes to slashes if the the path
; 2390 :      * starts with \\?\
; 2391 :      * Those paths can be up to 32k characters long.
; 2392 :      * Was added specifically for OpenOffice, those paths can't be converted
; 2393 :      * to URIs anyway.
; 2394 :      */
; 2395 :     if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _path$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN8@xmlCanonic
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _path$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN8@xmlCanonic
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _path$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN8@xmlCanonic
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _path$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN8@xmlCanonic

; 2396 :         (path[3] == '\\') )
; 2397 : 	return xmlStrdup((const xmlChar *) path);

	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN1@xmlCanonic
$LN8@xmlCanonic:

; 2398 : #endif
; 2399 : 
; 2400 : 	/* sanitize filename starting with // so it can be used as URI */
; 2401 :     if ((path[0] == '/') && (path[1] == '/') && (path[2] != '/'))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _path$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN9@xmlCanonic
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _path$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN9@xmlCanonic
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _path$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN9@xmlCanonic

; 2402 :         path++;

	mov	ecx, DWORD PTR _path$[ebp]
	add	ecx, 1
	mov	DWORD PTR _path$[ebp], ecx
$LN9@xmlCanonic:

; 2403 : 
; 2404 :     if ((uri = xmlParseURI((const char *) path)) != NULL) {

	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$[ebp], eax
	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN10@xmlCanonic

; 2405 : 	xmlFreeURI(uri);

	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlFreeURI
	add	esp, 4

; 2406 : 	return xmlStrdup(path);

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN1@xmlCanonic
$LN10@xmlCanonic:

; 2407 :     }
; 2408 : 
; 2409 :     /* Check if this is an "absolute uri" */
; 2410 :     absuri = xmlStrstr(path, BAD_CAST "://");

	push	OFFSET ??_C@_03GACAABJG@?3?1?1@
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _absuri$[ebp], eax

; 2411 :     if (absuri != NULL) {

	cmp	DWORD PTR _absuri$[ebp], 0
	je	$path_processing$31

; 2412 :         int l, j;
; 2413 : 	unsigned char c;
; 2414 : 	xmlChar *escURI;
; 2415 : 
; 2416 :         /*
; 2417 : 	 * this looks like an URI where some parts have not been
; 2418 : 	 * escaped leading to a parsing problem.  Check that the first
; 2419 : 	 * part matches a protocol.
; 2420 : 	 */
; 2421 : 	l = absuri - path;

	mov	eax, DWORD PTR _absuri$[ebp]
	sub	eax, DWORD PTR _path$[ebp]
	mov	DWORD PTR _l$4[ebp], eax

; 2422 : 	/* Bypass if first part (part before the '://') is > 20 chars */
; 2423 : 	if ((l <= 0) || (l > 20))

	cmp	DWORD PTR _l$4[ebp], 0
	jle	SHORT $LN13@xmlCanonic
	cmp	DWORD PTR _l$4[ebp], 20			; 00000014H
	jle	SHORT $LN12@xmlCanonic
$LN13@xmlCanonic:

; 2424 : 	    goto path_processing;

	jmp	$path_processing$31
$LN12@xmlCanonic:

; 2425 : 	/* Bypass if any non-alpha characters are present in first part */
; 2426 : 	for (j = 0;j < l;j++) {

	mov	DWORD PTR _j$3[ebp], 0
	jmp	SHORT $LN4@xmlCanonic
$LN2@xmlCanonic:
	mov	ecx, DWORD PTR _j$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$3[ebp], ecx
$LN4@xmlCanonic:
	mov	edx, DWORD PTR _j$3[ebp]
	cmp	edx, DWORD PTR _l$4[ebp]
	jge	SHORT $LN3@xmlCanonic

; 2427 : 	    c = path[j];

	mov	eax, DWORD PTR _path$[ebp]
	add	eax, DWORD PTR _j$3[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$2[ebp], cl

; 2428 : 	    if (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))))

	movzx	edx, BYTE PTR _c$2[ebp]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN15@xmlCanonic
	movzx	eax, BYTE PTR _c$2[ebp]
	cmp	eax, 122				; 0000007aH
	jle	SHORT $LN14@xmlCanonic
$LN15@xmlCanonic:
	movzx	ecx, BYTE PTR _c$2[ebp]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN16@xmlCanonic
	movzx	edx, BYTE PTR _c$2[ebp]
	cmp	edx, 90					; 0000005aH
	jle	SHORT $LN14@xmlCanonic
$LN16@xmlCanonic:

; 2429 : 	        goto path_processing;

	jmp	SHORT $path_processing$31
$LN14@xmlCanonic:

; 2430 : 	}

	jmp	SHORT $LN2@xmlCanonic
$LN3@xmlCanonic:

; 2431 : 
; 2432 : 	/* Escape all except the characters specified in the supplied path */
; 2433 :         escURI = xmlURIEscapeStr(path, BAD_CAST ":/?_.#&;=");

	push	OFFSET ??_C@_09MLNEJDDK@?3?1?$DP_?4?$CD?$CG?$DL?$DN@
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _escURI$1[ebp], eax

; 2434 : 	if (escURI != NULL) {

	cmp	DWORD PTR _escURI$1[ebp], 0
	je	SHORT $path_processing$31

; 2435 : 	    /* Try parsing the escaped path */
; 2436 : 	    uri = xmlParseURI((const char *) escURI);

	mov	ecx, DWORD PTR _escURI$1[ebp]
	push	ecx
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$[ebp], eax

; 2437 : 	    /* If successful, return the escaped string */
; 2438 : 	    if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN18@xmlCanonic

; 2439 : 	        xmlFreeURI(uri);

	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4

; 2440 : 		return escURI;

	mov	eax, DWORD PTR _escURI$1[ebp]
	jmp	$LN1@xmlCanonic
$LN18@xmlCanonic:

; 2441 : 	    }
; 2442 :             xmlFree(escURI);

	mov	esi, esp
	mov	eax, DWORD PTR _escURI$1[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$path_processing$31:

; 2443 : 	}
; 2444 :     }
; 2445 : 
; 2446 : path_processing:
; 2447 : /* For Windows implementations, replace backslashes with 'forward slashes' */
; 2448 : #if defined(_WIN32) && !defined(__CYGWIN__)
; 2449 :     /*
; 2450 :      * Create a URI structure
; 2451 :      */
; 2452 :     uri = xmlCreateURI();

	call	_xmlCreateURI
	mov	DWORD PTR _uri$[ebp], eax

; 2453 :     if (uri == NULL) {		/* Guard against 'out of memory' */

	cmp	DWORD PTR _uri$[ebp], 0
	jne	SHORT $LN19@xmlCanonic

; 2454 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCanonic
$LN19@xmlCanonic:

; 2455 :     }
; 2456 : 
; 2457 :     len = xmlStrlen(path);

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 2458 :     if ((len > 2) && IS_WINDOWS_PATH(path)) {

	cmp	DWORD PTR _len$[ebp], 2
	jle	$LN20@xmlCanonic
	cmp	DWORD PTR _path$[ebp], 0
	je	$LN20@xmlCanonic
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _path$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN23@xmlCanonic
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _path$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 122				; 0000007aH
	jle	SHORT $LN22@xmlCanonic
$LN23@xmlCanonic:
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _path$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 65					; 00000041H
	jl	$LN20@xmlCanonic
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _path$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 90					; 0000005aH
	jg	$LN20@xmlCanonic
$LN22@xmlCanonic:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _path$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	jne	$LN20@xmlCanonic
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _path$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN24@xmlCanonic
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _path$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 92					; 0000005cH
	jne	$LN20@xmlCanonic
$LN24@xmlCanonic:

; 2459 :         /* make the scheme 'file' */
; 2460 : 	uri->scheme = (char *) xmlStrdup(BAD_CAST "file");

	push	OFFSET ??_C@_04DAMGJPCA@file@
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx], eax

; 2461 : 	/* allocate space for leading '/' + path + string terminator */
; 2462 : 	uri->path = xmlMallocAtomic(len + 2);

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 2
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 2463 : 	if (uri->path == NULL) {

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN25@xmlCanonic

; 2464 : 	    xmlFreeURI(uri);	/* Guard agains 'out of memory' */

	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlFreeURI
	add	esp, 4

; 2465 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCanonic
$LN25@xmlCanonic:

; 2466 : 	}
; 2467 : 	/* Put in leading '/' plus path */
; 2468 : 	uri->path[0] = '/';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	BYTE PTR [edx+ecx], 47			; 0000002fH

; 2469 : 	p = uri->path + 1;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 2470 : 	strncpy(p, (char *) path, len + 1);

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2471 :     } else {

	jmp	SHORT $LN5@xmlCanonic
$LN20@xmlCanonic:

; 2472 : 	uri->path = (char *) xmlStrdup(path);

	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+24], eax

; 2473 : 	if (uri->path == NULL) {

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN26@xmlCanonic

; 2474 : 	    xmlFreeURI(uri);

	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlFreeURI
	add	esp, 4

; 2475 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCanonic
$LN26@xmlCanonic:

; 2476 : 	}
; 2477 : 	p = uri->path;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _p$[ebp], eax
$LN5@xmlCanonic:

; 2478 :     }
; 2479 :     /* Now change all occurences of '\' to '/' */
; 2480 :     while (*p != '\0') {

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN6@xmlCanonic

; 2481 : 	if (*p == '\\')

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN27@xmlCanonic

; 2482 : 	    *p = '/';

	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx], 47			; 0000002fH
$LN27@xmlCanonic:

; 2483 : 	p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 2484 :     }

	jmp	SHORT $LN5@xmlCanonic
$LN6@xmlCanonic:

; 2485 : 
; 2486 :     if (uri->scheme == NULL) {

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN28@xmlCanonic

; 2487 : 	ret = xmlStrdup((const xmlChar *) uri->path);

	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 2488 :     } else {

	jmp	SHORT $LN29@xmlCanonic
$LN28@xmlCanonic:

; 2489 : 	ret = xmlSaveUri(uri);

	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlSaveUri
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax
$LN29@xmlCanonic:

; 2490 :     }
; 2491 : 
; 2492 :     xmlFreeURI(uri);

	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4

; 2493 : #else
; 2494 :     ret = xmlStrdup((const xmlChar *) path);
; 2495 : #endif
; 2496 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCanonic:

; 2497 : }

	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCanonicPath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlFreeURI
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_xmlFreeURI PROC					; COMDAT

; 1379 : xmlFreeURI(xmlURIPtr uri) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1380 :     if (uri == NULL) return;

	cmp	DWORD PTR _uri$[ebp], 0
	jne	SHORT $LN2@xmlFreeURI
	jmp	$LN1@xmlFreeURI
$LN2@xmlFreeURI:

; 1381 : 
; 1382 :     if (uri->scheme != NULL) xmlFree(uri->scheme);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlFreeURI
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xmlFreeURI:

; 1383 :     if (uri->server != NULL) xmlFree(uri->server);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN4@xmlFreeURI
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlFreeURI:

; 1384 :     if (uri->user != NULL) xmlFree(uri->user);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN5@xmlFreeURI
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@xmlFreeURI:

; 1385 :     if (uri->path != NULL) xmlFree(uri->path);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN6@xmlFreeURI
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlFreeURI:

; 1386 :     if (uri->fragment != NULL) xmlFree(uri->fragment);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN7@xmlFreeURI
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlFreeURI:

; 1387 :     if (uri->opaque != NULL) xmlFree(uri->opaque);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN8@xmlFreeURI
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlFreeURI:

; 1388 :     if (uri->authority != NULL) xmlFree(uri->authority);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN9@xmlFreeURI
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlFreeURI:

; 1389 :     if (uri->query != NULL) xmlFree(uri->query);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN10@xmlFreeURI
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlFreeURI:

; 1390 :     if (uri->query_raw != NULL) xmlFree(uri->query_raw);

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN11@xmlFreeURI
	mov	esi, esp
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlFreeURI:

; 1391 :     xmlFree(uri);

	mov	esi, esp
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlFreeURI:

; 1392 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFreeURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlURIEscape
_TEXT	SEGMENT
_port$1 = -32						; size = 10
_ret2$ = -16						; size = 4
_uri$ = -12						; size = 4
_segment$ = -8						; size = 4
_ret$ = -4						; size = 4
_str$ = 8						; size = 4
_xmlURIEscape PROC					; COMDAT

; 1744 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1745 :     xmlChar *ret, *segment = NULL;

	mov	DWORD PTR _segment$[ebp], 0

; 1746 :     xmlURIPtr uri;
; 1747 :     int ret2;
; 1748 : 
; 1749 : #define NULLCHK(p) if(!p) { \
; 1750 :          xmlURIErrMemory("escaping URI value\n"); \
; 1751 :          xmlFreeURI(uri); \
; 1752 :          return NULL; } \
; 1753 : 
; 1754 :     if (str == NULL)

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@xmlURIEsca

; 1755 :         return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN2@xmlURIEsca:

; 1756 : 
; 1757 :     uri = xmlCreateURI();

	call	_xmlCreateURI
	mov	DWORD PTR _uri$[ebp], eax

; 1758 :     if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN3@xmlURIEsca

; 1759 : 	/*
; 1760 : 	 * Allow escaping errors in the unescaped form
; 1761 : 	 */
; 1762 :         uri->cleanup = 1;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [eax+36], 1

; 1763 :         ret2 = xmlParseURIReference(uri, (const char *)str);

	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlParseURIReference
	add	esp, 8
	mov	DWORD PTR _ret2$[ebp], eax

; 1764 :         if (ret2) {

	cmp	DWORD PTR _ret2$[ebp], 0
	je	SHORT $LN3@xmlURIEsca

; 1765 :             xmlFreeURI(uri);

	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlFreeURI
	add	esp, 4

; 1766 :             return (NULL);

	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN3@xmlURIEsca:

; 1767 :         }
; 1768 :     }
; 1769 : 
; 1770 :     if (!uri)

	cmp	DWORD PTR _uri$[ebp], 0
	jne	SHORT $LN5@xmlURIEsca

; 1771 :         return NULL;

	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN5@xmlURIEsca:

; 1772 : 
; 1773 :     ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 1774 : 
; 1775 :     if (uri->scheme) {

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN6@xmlURIEsca

; 1776 :         segment = xmlURIEscapeStr(BAD_CAST uri->scheme, BAD_CAST "+-.");

	push	OFFSET ??_C@_03JCBKNEED@?$CL?9?4@
	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _segment$[ebp], eax

; 1777 :         NULLCHK(segment)

	cmp	DWORD PTR _segment$[ebp], 0
	jne	SHORT $LN7@xmlURIEsca
	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory
	add	esp, 4
	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlFreeURI
	add	esp, 4
	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN7@xmlURIEsca:

; 1778 :         ret = xmlStrcat(ret, segment);

	mov	edx, DWORD PTR _segment$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1779 :         ret = xmlStrcat(ret, BAD_CAST ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1780 :         xmlFree(segment);

	mov	esi, esp
	mov	edx, DWORD PTR _segment$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlURIEsca:

; 1781 :     }
; 1782 : 
; 1783 :     if (uri->authority) {

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN8@xmlURIEsca

; 1784 :         segment =

	push	OFFSET ??_C@_05GFBJJGAL@?1?$DP?$DL?3?$EA@
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _segment$[ebp], eax

; 1785 :             xmlURIEscapeStr(BAD_CAST uri->authority, BAD_CAST "/?;:@");
; 1786 :         NULLCHK(segment)

	cmp	DWORD PTR _segment$[ebp], 0
	jne	SHORT $LN9@xmlURIEsca
	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory
	add	esp, 4
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlFreeURI
	add	esp, 4
	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN9@xmlURIEsca:

; 1787 :         ret = xmlStrcat(ret, BAD_CAST "//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1@
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1788 :         ret = xmlStrcat(ret, segment);

	mov	edx, DWORD PTR _segment$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1789 :         xmlFree(segment);

	mov	esi, esp
	mov	ecx, DWORD PTR _segment$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlURIEsca:

; 1790 :     }
; 1791 : 
; 1792 :     if (uri->user) {

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	$LN10@xmlURIEsca

; 1793 :         segment = xmlURIEscapeStr(BAD_CAST uri->user, BAD_CAST ";:&=+$,");

	push	OFFSET ??_C@_07LHGLKCBA@?$DL?3?$CG?$DN?$CL$?0@
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _segment$[ebp], eax

; 1794 :         NULLCHK(segment)

	cmp	DWORD PTR _segment$[ebp], 0
	jne	SHORT $LN11@xmlURIEsca
	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory
	add	esp, 4
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4
	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN11@xmlURIEsca:

; 1795 : 		ret = xmlStrcat(ret,BAD_CAST "//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1@
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1796 :         ret = xmlStrcat(ret, segment);

	mov	ecx, DWORD PTR _segment$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1797 :         ret = xmlStrcat(ret, BAD_CAST "@");

	push	OFFSET ??_C@_01EOFPKCAF@?$EA@
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1798 :         xmlFree(segment);

	mov	esi, esp
	mov	ecx, DWORD PTR _segment$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlURIEsca:

; 1799 :     }
; 1800 : 
; 1801 :     if (uri->server) {

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$LN12@xmlURIEsca

; 1802 :         segment = xmlURIEscapeStr(BAD_CAST uri->server, BAD_CAST "/?;:@");

	push	OFFSET ??_C@_05GFBJJGAL@?1?$DP?$DL?3?$EA@
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _segment$[ebp], eax

; 1803 :         NULLCHK(segment)

	cmp	DWORD PTR _segment$[ebp], 0
	jne	SHORT $LN13@xmlURIEsca
	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory
	add	esp, 4
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4
	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN13@xmlURIEsca:

; 1804 : 		if (uri->user == NULL)

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN14@xmlURIEsca

; 1805 : 		ret = xmlStrcat(ret, BAD_CAST "//");

	push	OFFSET ??_C@_02CBLDBPFN@?1?1@
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN14@xmlURIEsca:

; 1806 :         ret = xmlStrcat(ret, segment);

	mov	edx, DWORD PTR _segment$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1807 :         xmlFree(segment);

	mov	esi, esp
	mov	ecx, DWORD PTR _segment$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlURIEsca:

; 1808 :     }
; 1809 : 
; 1810 :     if (uri->port) {

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN15@xmlURIEsca

; 1811 :         xmlChar port[10];
; 1812 : 
; 1813 :         snprintf((char *) port, 10, "%d", uri->port);

	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	push	10					; 0000000aH
	lea	edx, DWORD PTR _port$1[ebp]
	push	edx
	call	_snprintf
	add	esp, 16					; 00000010H

; 1814 :         ret = xmlStrcat(ret, BAD_CAST ":");

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1815 :         ret = xmlStrcat(ret, port);

	lea	ecx, DWORD PTR _port$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN15@xmlURIEsca:

; 1816 :     }
; 1817 : 
; 1818 :     if (uri->path) {

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN16@xmlURIEsca

; 1819 :         segment =

	push	OFFSET ??_C@_0L@JBEGPNBA@?3?$EA?$CG?$DN?$CL$?0?1?$DP?$DL@
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _segment$[ebp], eax

; 1820 :             xmlURIEscapeStr(BAD_CAST uri->path, BAD_CAST ":@&=+$,/?;");
; 1821 :         NULLCHK(segment)

	cmp	DWORD PTR _segment$[ebp], 0
	jne	SHORT $LN17@xmlURIEsca
	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory
	add	esp, 4
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlFreeURI
	add	esp, 4
	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN17@xmlURIEsca:

; 1822 :         ret = xmlStrcat(ret, segment);

	mov	ecx, DWORD PTR _segment$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1823 :         xmlFree(segment);

	mov	esi, esp
	mov	eax, DWORD PTR _segment$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlURIEsca:

; 1824 :     }
; 1825 : 
; 1826 :     if (uri->query_raw) {

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN18@xmlURIEsca

; 1827 :         ret = xmlStrcat(ret, BAD_CAST "?");

	push	OFFSET ??_C@_01OGPIMHDM@?$DP@
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1828 :         ret = xmlStrcat(ret, BAD_CAST uri->query_raw);

	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1829 :     }

	jmp	$LN19@xmlURIEsca
$LN18@xmlURIEsca:

; 1830 :     else if (uri->query) {

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN19@xmlURIEsca

; 1831 :         segment =

	push	OFFSET ??_C@_0L@LPCDADNI@?$DL?1?$DP?3?$EA?$CG?$DN?$CL?0$@
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _segment$[ebp], eax

; 1832 :             xmlURIEscapeStr(BAD_CAST uri->query, BAD_CAST ";/?:@&=+,$");
; 1833 :         NULLCHK(segment)

	cmp	DWORD PTR _segment$[ebp], 0
	jne	SHORT $LN21@xmlURIEsca
	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory
	add	esp, 4
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlFreeURI
	add	esp, 4
	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN21@xmlURIEsca:

; 1834 :         ret = xmlStrcat(ret, BAD_CAST "?");

	push	OFFSET ??_C@_01OGPIMHDM@?$DP@
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1835 :         ret = xmlStrcat(ret, segment);

	mov	edx, DWORD PTR _segment$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1836 :         xmlFree(segment);

	mov	esi, esp
	mov	ecx, DWORD PTR _segment$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN19@xmlURIEsca:

; 1837 :     }
; 1838 : 
; 1839 :     if (uri->opaque) {

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN22@xmlURIEsca

; 1840 :         segment = xmlURIEscapeStr(BAD_CAST uri->opaque, BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _segment$[ebp], eax

; 1841 :         NULLCHK(segment)

	cmp	DWORD PTR _segment$[ebp], 0
	jne	SHORT $LN23@xmlURIEsca
	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory
	add	esp, 4
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4
	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN23@xmlURIEsca:

; 1842 :         ret = xmlStrcat(ret, segment);

	mov	eax, DWORD PTR _segment$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1843 :         xmlFree(segment);

	mov	esi, esp
	mov	edx, DWORD PTR _segment$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN22@xmlURIEsca:

; 1844 :     }
; 1845 : 
; 1846 :     if (uri->fragment) {

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN24@xmlURIEsca

; 1847 :         segment = xmlURIEscapeStr(BAD_CAST uri->fragment, BAD_CAST "#");

	push	OFFSET ??_C@_01IPJKGB@?$CD@
	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _segment$[ebp], eax

; 1848 :         NULLCHK(segment)

	cmp	DWORD PTR _segment$[ebp], 0
	jne	SHORT $LN25@xmlURIEsca
	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory
	add	esp, 4
	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlFreeURI
	add	esp, 4
	xor	eax, eax
	jmp	SHORT $LN1@xmlURIEsca
$LN25@xmlURIEsca:

; 1849 :         ret = xmlStrcat(ret, BAD_CAST "#");

	push	OFFSET ??_C@_01IPJKGB@?$CD@
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1850 :         ret = xmlStrcat(ret, segment);

	mov	edx, DWORD PTR _segment$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlStrcat
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1851 :         xmlFree(segment);

	mov	esi, esp
	mov	ecx, DWORD PTR _segment$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN24@xmlURIEsca:

; 1852 :     }
; 1853 : 
; 1854 :     xmlFreeURI(uri);

	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4

; 1855 : #undef NULLCHK
; 1856 : 
; 1857 :     return (ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlURIEsca:

; 1858 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@xmlURIEsca
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN29@xmlURIEsca:
	DD	1
	DD	$LN28@xmlURIEsca
$LN28@xmlURIEsca:
	DD	-32					; ffffffe0H
	DD	10					; 0000000aH
	DD	$LN27@xmlURIEsca
$LN27@xmlURIEsca:
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
_xmlURIEscape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlNormalizeURIPath
_TEXT	SEGMENT
tv225 = -24						; size = 4
tv224 = -20						; size = 4
_tmp$1 = -16						; size = 4
_segp$2 = -12						; size = 4
_out$ = -8						; size = 4
_cur$ = -4						; size = 4
_path$ = 8						; size = 4
_xmlNormalizeURIPath PROC				; COMDAT

; 1412 : xmlNormalizeURIPath(char *path) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1413 :     char *cur, *out;
; 1414 : 
; 1415 :     if (path == NULL)

	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN28@xmlNormali

; 1416 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlNormali
$LN28@xmlNormali:

; 1417 : 
; 1418 :     /* Skip all initial "/" chars.  We want to get to the beginning of the
; 1419 :      * first non-empty segment.
; 1420 :      */
; 1421 :     cur = path;

	mov	eax, DWORD PTR _path$[ebp]
	mov	DWORD PTR _cur$[ebp], eax
$LN2@xmlNormali:

; 1422 :     while (cur[0] == '/')

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN3@xmlNormali

; 1423 :       ++cur;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN2@xmlNormali
$LN3@xmlNormali:

; 1424 :     if (cur[0] == '\0')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN29@xmlNormali

; 1425 :       return(0);

	xor	eax, eax
	jmp	$LN1@xmlNormali
$LN29@xmlNormali:

; 1426 : 
; 1427 :     /* Keep everything we've seen so far.  */
; 1428 :     out = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _out$[ebp], ecx
$LN4@xmlNormali:

; 1429 : 
; 1430 :     /*
; 1431 :      * Analyze each segment in sequence for cases (c) and (d).
; 1432 :      */
; 1433 :     while (cur[0] != '\0') {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	$done_cd$50

; 1434 : 	/*
; 1435 : 	 * c) All occurrences of "./", where "." is a complete path segment,
; 1436 : 	 *    are removed from the buffer string.
; 1437 : 	 */
; 1438 : 	if ((cur[0] == '.') && (cur[1] == '/')) {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN30@xmlNormali
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN30@xmlNormali

; 1439 : 	    cur += 2;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 2
	mov	DWORD PTR _cur$[ebp], ecx
$LN6@xmlNormali:

; 1440 : 	    /* '//' normalization should be done at this point too */
; 1441 : 	    while (cur[0] == '/')

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN7@xmlNormali

; 1442 : 		cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN6@xmlNormali
$LN7@xmlNormali:

; 1443 : 	    continue;

	jmp	SHORT $LN4@xmlNormali
$LN30@xmlNormali:

; 1444 : 	}
; 1445 : 
; 1446 : 	/*
; 1447 : 	 * d) If the buffer string ends with "." as a complete path segment,
; 1448 : 	 *    that "." is removed.
; 1449 : 	 */
; 1450 : 	if ((cur[0] == '.') && (cur[1] == '\0'))

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 46					; 0000002eH
	jne	SHORT $LN8@xmlNormali
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN8@xmlNormali

; 1451 : 	    break;

	jmp	$done_cd$50
$LN8@xmlNormali:

; 1452 : 
; 1453 : 	/* Otherwise keep the segment.  */
; 1454 : 	while (cur[0] != '/') {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN10@xmlNormali

; 1455 :             if (cur[0] == '\0')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN32@xmlNormali

; 1456 :               goto done_cd;

	jmp	$done_cd$50
$LN32@xmlNormali:

; 1457 : 	    (out++)[0] = (cur++)[0];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [eax+ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 1458 : 	}

	jmp	SHORT $LN8@xmlNormali
$LN10@xmlNormali:

; 1459 : 	/* nomalize // */
; 1460 : 	while ((cur[0] == '/') && (cur[1] == '/'))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN11@xmlNormali
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN11@xmlNormali

; 1461 : 	    cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN10@xmlNormali
$LN11@xmlNormali:

; 1462 : 
; 1463 :         (out++)[0] = (cur++)[0];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [eax+ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 1464 :     }

	jmp	$LN4@xmlNormali
$done_cd$50:

; 1465 :  done_cd:
; 1466 :     out[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 1467 : 
; 1468 :     /* Reset to the beginning of the first segment for the next sequence.  */
; 1469 :     cur = path;

	mov	edx, DWORD PTR _path$[ebp]
	mov	DWORD PTR _cur$[ebp], edx
$LN12@xmlNormali:

; 1470 :     while (cur[0] == '/')

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN13@xmlNormali

; 1471 :       ++cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN12@xmlNormali
$LN13@xmlNormali:

; 1472 :     if (cur[0] == '\0')

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN14@xmlNormali

; 1473 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlNormali
$LN14@xmlNormali:

; 1474 : 
; 1475 :     /*
; 1476 :      * Analyze each segment in sequence for cases (e) and (f).
; 1477 :      *
; 1478 :      * e) All occurrences of "<segment>/../", where <segment> is a
; 1479 :      *    complete path segment not equal to "..", are removed from the
; 1480 :      *    buffer string.  Removal of these path segments is performed
; 1481 :      *    iteratively, removing the leftmost matching pattern on each
; 1482 :      *    iteration, until no matching pattern remains.
; 1483 :      *
; 1484 :      * f) If the buffer string ends with "<segment>/..", where <segment>
; 1485 :      *    is a complete path segment not equal to "..", that
; 1486 :      *    "<segment>/.." is removed.
; 1487 :      *
; 1488 :      * To satisfy the "iterative" clause in (e), we need to collapse the
; 1489 :      * string every time we find something that needs to be removed.  Thus,
; 1490 :      * we don't need to keep two pointers into the string: we only need a
; 1491 :      * "current position" pointer.
; 1492 :      */
; 1493 :     while (1) {

	mov	eax, 1
	test	eax, eax
	je	$LN15@xmlNormali

; 1494 :         char *segp, *tmp;
; 1495 : 
; 1496 :         /* At the beginning of each iteration of this loop, "cur" points to
; 1497 :          * the first character of the segment we want to examine.
; 1498 :          */
; 1499 : 
; 1500 :         /* Find the end of the current segment.  */
; 1501 :         segp = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _segp$2[ebp], ecx
$LN16@xmlNormali:

; 1502 :         while ((segp[0] != '/') && (segp[0] != '\0'))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _segp$2[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN17@xmlNormali
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _segp$2[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN17@xmlNormali

; 1503 :           ++segp;

	mov	ecx, DWORD PTR _segp$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _segp$2[ebp], ecx
	jmp	SHORT $LN16@xmlNormali
$LN17@xmlNormali:

; 1504 : 
; 1505 :         /* If this is the last segment, we're done (we need at least two
; 1506 :          * segments to meet the criteria for the (e) and (f) cases).
; 1507 :          */
; 1508 :         if (segp[0] == '\0')

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _segp$2[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN34@xmlNormali

; 1509 :           break;

	jmp	$LN15@xmlNormali
$LN34@xmlNormali:

; 1510 : 
; 1511 :         /* If the first segment is "..", or if the next segment _isn't_ "..",
; 1512 :          * keep this segment and try the next one.
; 1513 :          */
; 1514 :         ++segp;

	mov	eax, DWORD PTR _segp$2[ebp]
	add	eax, 1
	mov	DWORD PTR _segp$2[ebp], eax

; 1515 :         if (((cur[0] == '.') && (cur[1] == '.') && (segp == cur+3))
; 1516 :             || ((segp[0] != '.') || (segp[1] != '.')

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 46					; 0000002eH
	jne	SHORT $LN37@xmlNormali
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 46					; 0000002eH
	jne	SHORT $LN37@xmlNormali
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 3
	cmp	DWORD PTR _segp$2[ebp], edx
	je	SHORT $LN36@xmlNormali
$LN37@xmlNormali:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _segp$2[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN36@xmlNormali
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _segp$2[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN36@xmlNormali
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _segp$2[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN35@xmlNormali
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _segp$2[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN35@xmlNormali
$LN36@xmlNormali:

; 1517 :                 || ((segp[2] != '/') && (segp[2] != '\0')))) {
; 1518 :           cur = segp;

	mov	ecx, DWORD PTR _segp$2[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 1519 :           continue;

	jmp	$LN14@xmlNormali
$LN35@xmlNormali:

; 1520 :         }
; 1521 : 
; 1522 :         /* If we get here, remove this segment and the next one and back up
; 1523 :          * to the previous segment (if there is one), to implement the
; 1524 :          * "iteratively" clause.  It's pretty much impossible to back up
; 1525 :          * while maintaining two pointers into the buffer, so just compact
; 1526 :          * the whole buffer now.
; 1527 :          */
; 1528 : 
; 1529 :         /* If this is the end of the buffer, we're done.  */
; 1530 :         if (segp[2] == '\0') {

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _segp$2[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN39@xmlNormali

; 1531 :           cur[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 1532 :           break;

	jmp	$LN15@xmlNormali
$LN39@xmlNormali:

; 1533 :         }
; 1534 :         /* Valgrind complained, strcpy(cur, segp + 3); */
; 1535 :         /* string will overlap, do not use strcpy */
; 1536 :         tmp = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _tmp$1[ebp], edx

; 1537 :         segp += 3;

	mov	eax, DWORD PTR _segp$2[ebp]
	add	eax, 3
	mov	DWORD PTR _segp$2[ebp], eax
$LN18@xmlNormali:

; 1538 :         while ((*tmp++ = *segp++) != 0)

	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	edx, DWORD PTR _segp$2[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _tmp$1[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv224[ebp], edx
	mov	eax, DWORD PTR _tmp$1[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$1[ebp], eax
	mov	ecx, DWORD PTR _segp$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _segp$2[ebp], ecx
	cmp	DWORD PTR tv224[ebp], 0
	je	SHORT $LN45@xmlNormali
	mov	DWORD PTR tv225[ebp], 1
	jmp	SHORT $LN46@xmlNormali
$LN45@xmlNormali:
	mov	DWORD PTR tv225[ebp], 0
$LN46@xmlNormali:
	cmp	DWORD PTR tv225[ebp], 0
	je	SHORT $LN19@xmlNormali

; 1539 :           ;

	jmp	SHORT $LN18@xmlNormali
$LN19@xmlNormali:

; 1540 : 
; 1541 :         /* If there are no previous segments, then keep going from here.  */
; 1542 :         segp = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _segp$2[ebp], edx
$LN20@xmlNormali:

; 1543 :         while ((segp > path) && ((--segp)[0] == '/'))

	mov	eax, DWORD PTR _segp$2[ebp]
	cmp	eax, DWORD PTR _path$[ebp]
	jbe	SHORT $LN21@xmlNormali
	mov	ecx, DWORD PTR _segp$2[ebp]
	sub	ecx, 1
	mov	DWORD PTR _segp$2[ebp], ecx
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _segp$2[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN21@xmlNormali

; 1544 :           ;

	jmp	SHORT $LN20@xmlNormali
$LN21@xmlNormali:

; 1545 :         if (segp == path)

	mov	eax, DWORD PTR _segp$2[ebp]
	cmp	eax, DWORD PTR _path$[ebp]
	jne	SHORT $LN40@xmlNormali

; 1546 :           continue;

	jmp	$LN14@xmlNormali
$LN40@xmlNormali:

; 1547 : 
; 1548 :         /* "segp" is pointing to the end of a previous segment; find it's
; 1549 :          * start.  We need to back up to the previous segment and start
; 1550 :          * over with that to handle things like "foo/bar/../..".  If we
; 1551 :          * don't do this, then on the first pass we'll remove the "bar/..",
; 1552 :          * but be pointing at the second ".." so we won't realize we can also
; 1553 :          * remove the "foo/..".
; 1554 :          */
; 1555 :         cur = segp;

	mov	ecx, DWORD PTR _segp$2[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
$LN22@xmlNormali:

; 1556 :         while ((cur > path) && (cur[-1] != '/'))

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	edx, DWORD PTR _path$[ebp]
	jbe	SHORT $LN23@xmlNormali
	mov	eax, 1
	imul	ecx, eax, -1
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN23@xmlNormali

; 1557 :           --cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN22@xmlNormali
$LN23@xmlNormali:

; 1558 :     }

	jmp	$LN14@xmlNormali
$LN15@xmlNormali:

; 1559 :     out[0] = '\0';

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 1560 : 
; 1561 :     /*
; 1562 :      * g) If the resulting buffer string still begins with one or more
; 1563 :      *    complete path segments of "..", then the reference is
; 1564 :      *    considered to be in error. Implementations may handle this
; 1565 :      *    error by retaining these components in the resolved path (i.e.,
; 1566 :      *    treating them as part of the final URI), by removing them from
; 1567 :      *    the resolved path (i.e., discarding relative levels above the
; 1568 :      *    root), or by avoiding traversal of the reference.
; 1569 :      *
; 1570 :      * We discard them from the final path.
; 1571 :      */
; 1572 :     if (path[0] == '/') {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _path$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	$LN41@xmlNormali

; 1573 :       cur = path;

	mov	eax, DWORD PTR _path$[ebp]
	mov	DWORD PTR _cur$[ebp], eax
$LN24@xmlNormali:

; 1574 :       while ((cur[0] == '/') && (cur[1] == '.') && (cur[2] == '.')
; 1575 :              && ((cur[3] == '/') || (cur[3] == '\0')))

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN25@xmlNormali
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 46					; 0000002eH
	jne	SHORT $LN25@xmlNormali
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 46					; 0000002eH
	jne	SHORT $LN25@xmlNormali
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN42@xmlNormali
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN25@xmlNormali
$LN42@xmlNormali:

; 1576 : 	cur += 3;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 3
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN24@xmlNormali
$LN25@xmlNormali:

; 1577 : 
; 1578 :       if (cur != path) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	edx, DWORD PTR _path$[ebp]
	je	SHORT $LN41@xmlNormali

; 1579 : 	out = path;

	mov	eax, DWORD PTR _path$[ebp]
	mov	DWORD PTR _out$[ebp], eax
$LN26@xmlNormali:

; 1580 : 	while (cur[0] != '\0')

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN27@xmlNormali

; 1581 :           (out++)[0] = (cur++)[0];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [ecx+edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN26@xmlNormali
$LN27@xmlNormali:

; 1582 : 	out[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN41@xmlNormali:

; 1583 :       }
; 1584 :     }
; 1585 : 
; 1586 :     return(0);

	xor	eax, eax
$LN1@xmlNormali:

; 1587 : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNormalizeURIPath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlURIUnescapeString
_TEXT	SEGMENT
tv68 = -28						; size = 4
tv194 = -21						; size = 1
tv191 = -20						; size = 4
tv188 = -16						; size = 4
_in$ = -12						; size = 4
_out$ = -8						; size = 4
_ret$ = -4						; size = 4
_str$ = 8						; size = 4
_len$ = 12						; size = 4
_target$ = 16						; size = 4
_xmlURIUnescapeString PROC				; COMDAT

; 1612 : xmlURIUnescapeString(const char *str, int len, char *target) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1613 :     char *ret, *out;
; 1614 :     const char *in;
; 1615 : 
; 1616 :     if (str == NULL)

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN4@xmlURIUnes

; 1617 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlURIUnes
$LN4@xmlURIUnes:

; 1618 :     if (len <= 0) len = strlen(str);

	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN5@xmlURIUnes
	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR tv188[ebp], eax
	mov	ecx, DWORD PTR tv188[ebp]
	add	ecx, 1
	mov	DWORD PTR tv191[ebp], ecx
$LL23@xmlURIUnes:
	mov	edx, DWORD PTR tv188[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv194[ebp], al
	add	DWORD PTR tv188[ebp], 1
	cmp	BYTE PTR tv194[ebp], 0
	jne	SHORT $LL23@xmlURIUnes
	mov	ecx, DWORD PTR tv188[ebp]
	sub	ecx, DWORD PTR tv191[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _len$[ebp], edx
$LN5@xmlURIUnes:

; 1619 :     if (len < 0) return(NULL);

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN6@xmlURIUnes
	xor	eax, eax
	jmp	$LN1@xmlURIUnes
$LN6@xmlURIUnes:

; 1620 : 
; 1621 :     if (target == NULL) {

	cmp	DWORD PTR _target$[ebp], 0
	jne	SHORT $LN7@xmlURIUnes

; 1622 : 	ret = (char *) xmlMallocAtomic(len + 1);

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 1623 : 	if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN9@xmlURIUnes

; 1624 :             xmlURIErrMemory("unescaping URI value\n");

	push	OFFSET ??_C@_0BG@GBNFHGHH@unescaping?5URI?5value?6@
	call	_xmlURIErrMemory
	add	esp, 4

; 1625 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlURIUnes
$LN9@xmlURIUnes:

; 1626 : 	}
; 1627 :     } else

	jmp	SHORT $LN8@xmlURIUnes
$LN7@xmlURIUnes:

; 1628 : 	ret = target;

	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
$LN8@xmlURIUnes:

; 1629 :     in = str;

	mov	edx, DWORD PTR _str$[ebp]
	mov	DWORD PTR _in$[ebp], edx

; 1630 :     out = ret;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _out$[ebp], eax
$LN2@xmlURIUnes:

; 1631 :     while(len > 0) {

	cmp	DWORD PTR _len$[ebp], 0
	jle	$LN3@xmlURIUnes

; 1632 : 	if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {

	cmp	DWORD PTR _len$[ebp], 2
	jle	$LN10@xmlURIUnes
	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	$LN10@xmlURIUnes
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	_is_hex
	add	esp, 4
	test	eax, eax
	je	$LN10@xmlURIUnes
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	_is_hex
	add	esp, 4
	test	eax, eax
	je	$LN10@xmlURIUnes

; 1633 : 	    in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 1634 : 	    if ((*in >= '0') && (*in <= '9'))

	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN12@xmlURIUnes
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN12@xmlURIUnes

; 1635 : 	        *out = (*in - '0');

	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN13@xmlURIUnes
$LN12@xmlURIUnes:

; 1636 : 	    else if ((*in >= 'a') && (*in <= 'f'))

	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN14@xmlURIUnes
	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 102				; 00000066H
	jg	SHORT $LN14@xmlURIUnes

; 1637 : 	        *out = (*in - 'a') + 10;

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 87					; 00000057H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN13@xmlURIUnes
$LN14@xmlURIUnes:

; 1638 : 	    else if ((*in >= 'A') && (*in <= 'F'))

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN13@xmlURIUnes
	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 70					; 00000046H
	jg	SHORT $LN13@xmlURIUnes

; 1639 : 	        *out = (*in - 'A') + 10;

	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	edx, 55					; 00000037H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
$LN13@xmlURIUnes:

; 1640 : 	    in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 1641 : 	    if ((*in >= '0') && (*in <= '9'))

	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN17@xmlURIUnes
	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jg	SHORT $LN17@xmlURIUnes

; 1642 : 	        *out = *out * 16 + (*in - '0');

	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax]
	shl	ecx, 4
	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, BYTE PTR [edx]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN18@xmlURIUnes
$LN17@xmlURIUnes:

; 1643 : 	    else if ((*in >= 'a') && (*in <= 'f'))

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN19@xmlURIUnes
	mov	edx, DWORD PTR _in$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 102				; 00000066H
	jg	SHORT $LN19@xmlURIUnes

; 1644 : 	        *out = *out * 16 + (*in - 'a') + 10;

	mov	ecx, DWORD PTR _out$[ebp]
	movsx	edx, BYTE PTR [ecx]
	shl	edx, 4
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	lea	edx, DWORD PTR [edx+ecx-87]
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN18@xmlURIUnes
$LN19@xmlURIUnes:

; 1645 : 	    else if ((*in >= 'A') && (*in <= 'F'))

	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN18@xmlURIUnes
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 70					; 00000046H
	jg	SHORT $LN18@xmlURIUnes

; 1646 : 	        *out = *out * 16 + (*in - 'A') + 10;

	mov	edx, DWORD PTR _out$[ebp]
	movsx	eax, BYTE PTR [edx]
	shl	eax, 4
	mov	ecx, DWORD PTR _in$[ebp]
	movsx	edx, BYTE PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-55]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
$LN18@xmlURIUnes:

; 1647 : 	    in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx

; 1648 : 	    len -= 3;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 3
	mov	DWORD PTR _len$[ebp], eax

; 1649 : 	    out++;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 1650 : 	} else {

	jmp	SHORT $LN11@xmlURIUnes
$LN10@xmlURIUnes:

; 1651 : 	    *out++ = *in++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 1652 : 	    len--;

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
$LN11@xmlURIUnes:

; 1653 : 	}
; 1654 :     }

	jmp	$LN2@xmlURIUnes
$LN3@xmlURIUnes:

; 1655 :     *out = 0;

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 0

; 1656 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlURIUnes:

; 1657 : }

	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlURIUnescapeString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlURIEscapeStr
_TEXT	SEGMENT
_val$1 = -33						; size = 1
_out$ = -32						; size = 4
_len$ = -24						; size = 4
_in$ = -16						; size = 4
_temp$ = -12						; size = 4
_ch$ = -5						; size = 1
_ret$ = -4						; size = 4
_str$ = 8						; size = 4
_list$ = 12						; size = 4
_xmlURIEscapeStr PROC					; COMDAT

; 1670 : xmlURIEscapeStr(const xmlChar *str, const xmlChar *list) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1671 :     xmlChar *ret, ch;
; 1672 :     xmlChar *temp;
; 1673 :     const xmlChar *in;
; 1674 :     int len, out;
; 1675 : 
; 1676 :     if (str == NULL)

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN4@xmlURIEsca

; 1677 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN4@xmlURIEsca:

; 1678 :     if (str[0] == 0)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN5@xmlURIEsca

; 1679 : 	return(xmlStrdup(str));

	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN1@xmlURIEsca
$LN5@xmlURIEsca:

; 1680 :     len = xmlStrlen(str);

	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 1681 :     if (!(len > 0)) return(NULL);

	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN6@xmlURIEsca
	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN6@xmlURIEsca:

; 1682 : 
; 1683 :     len += 20;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _len$[ebp], eax

; 1684 :     ret = (xmlChar *) xmlMallocAtomic(len);

	mov	esi, esp
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 1685 :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN7@xmlURIEsca

; 1686 :         xmlURIErrMemory("escaping URI value\n");

	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory
	add	esp, 4

; 1687 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN7@xmlURIEsca:

; 1688 :     }
; 1689 :     in = (const xmlChar *) str;

	mov	edx, DWORD PTR _str$[ebp]
	mov	DWORD PTR _in$[ebp], edx

; 1690 :     out = 0;

	mov	DWORD PTR _out$[ebp], 0
$LN2@xmlURIEsca:

; 1691 :     while(*in != 0) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@xmlURIEsca

; 1692 : 	if (len - out <= 3) {

	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, DWORD PTR _out$[ebp]
	cmp	edx, 3
	jg	SHORT $LN8@xmlURIEsca

; 1693 :             temp = xmlSaveUriRealloc(ret, &len);

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1694 : 	    if (temp == NULL) {

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN9@xmlURIEsca

; 1695 :                 xmlURIErrMemory("escaping URI value\n");

	push	OFFSET ??_C@_0BE@NGGADEAG@escaping?5URI?5value?6@
	call	_xmlURIErrMemory
	add	esp, 4

; 1696 : 		xmlFree(ret);

	mov	esi, esp
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1697 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlURIEsca
$LN9@xmlURIEsca:

; 1698 : 	    }
; 1699 : 	    ret = temp;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN8@xmlURIEsca:

; 1700 : 	}
; 1701 : 
; 1702 : 	ch = *in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _ch$[ebp], dl

; 1703 : 
; 1704 : 	if ((ch != '@') && (!IS_UNRESERVED(ch)) && (!xmlStrchr(list, ch))) {

	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 64					; 00000040H
	je	$LN10@xmlURIEsca
	movzx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN12@xmlURIEsca
	movzx	edx, BYTE PTR _ch$[ebp]
	cmp	edx, 122				; 0000007aH
	jle	$LN10@xmlURIEsca
$LN12@xmlURIEsca:
	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN13@xmlURIEsca
	movzx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 90					; 0000005aH
	jle	$LN10@xmlURIEsca
$LN13@xmlURIEsca:
	movzx	edx, BYTE PTR _ch$[ebp]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN14@xmlURIEsca
	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 57					; 00000039H
	jle	$LN10@xmlURIEsca
$LN14@xmlURIEsca:
	movzx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 45					; 0000002dH
	je	$LN10@xmlURIEsca
	movzx	edx, BYTE PTR _ch$[ebp]
	cmp	edx, 95					; 0000005fH
	je	$LN10@xmlURIEsca
	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 46					; 0000002eH
	je	$LN10@xmlURIEsca
	movzx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 33					; 00000021H
	je	$LN10@xmlURIEsca
	movzx	edx, BYTE PTR _ch$[ebp]
	cmp	edx, 126				; 0000007eH
	je	$LN10@xmlURIEsca
	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 42					; 0000002aH
	je	$LN10@xmlURIEsca
	movzx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 39					; 00000027H
	je	$LN10@xmlURIEsca
	movzx	edx, BYTE PTR _ch$[ebp]
	cmp	edx, 40					; 00000028H
	je	$LN10@xmlURIEsca
	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 41					; 00000029H
	je	$LN10@xmlURIEsca
	movzx	ecx, BYTE PTR _ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _list$[ebp]
	push	edx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	jne	$LN10@xmlURIEsca

; 1705 : 	    unsigned char val;
; 1706 : 	    ret[out++] = '%';

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 37			; 00000025H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 1707 : 	    val = ch >> 4;

	movzx	edx, BYTE PTR _ch$[ebp]
	sar	edx, 4
	mov	BYTE PTR _val$1[ebp], dl

; 1708 : 	    if (val <= 9)

	movzx	eax, BYTE PTR _val$1[ebp]
	cmp	eax, 9
	jg	SHORT $LN15@xmlURIEsca

; 1709 : 		ret[out++] = '0' + val;

	movzx	ecx, BYTE PTR _val$1[ebp]
	add	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	jmp	SHORT $LN16@xmlURIEsca
$LN15@xmlURIEsca:

; 1710 : 	    else
; 1711 : 		ret[out++] = 'A' + val - 0xA;

	movzx	ecx, BYTE PTR _val$1[ebp]
	add	ecx, 55					; 00000037H
	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
$LN16@xmlURIEsca:

; 1712 : 	    val = ch & 0xF;

	movzx	ecx, BYTE PTR _ch$[ebp]
	and	ecx, 15					; 0000000fH
	mov	BYTE PTR _val$1[ebp], cl

; 1713 : 	    if (val <= 9)

	movzx	edx, BYTE PTR _val$1[ebp]
	cmp	edx, 9
	jg	SHORT $LN17@xmlURIEsca

; 1714 : 		ret[out++] = '0' + val;

	movzx	eax, BYTE PTR _val$1[ebp]
	add	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	jmp	SHORT $LN18@xmlURIEsca
$LN17@xmlURIEsca:

; 1715 : 	    else
; 1716 : 		ret[out++] = 'A' + val - 0xA;

	movzx	eax, BYTE PTR _val$1[ebp]
	add	eax, 55					; 00000037H
	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
$LN18@xmlURIEsca:

; 1717 : 	    in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 1718 : 	} else {

	jmp	SHORT $LN11@xmlURIEsca
$LN10@xmlURIEsca:

; 1719 : 	    ret[out++] = *in++;

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx
$LN11@xmlURIEsca:

; 1720 : 	}
; 1721 : 
; 1722 :     }

	jmp	$LN2@xmlURIEsca
$LN3@xmlURIEsca:

; 1723 :     ret[out] = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 0

; 1724 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlURIEsca:

; 1725 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@xmlURIEsca
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN22@xmlURIEsca:
	DD	1
	DD	$LN21@xmlURIEsca
$LN21@xmlURIEsca:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN20@xmlURIEsca
$LN20@xmlURIEsca:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_xmlURIEscapeStr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlPrintURI
_TEXT	SEGMENT
_out$ = -4						; size = 4
_stream$ = 8						; size = 4
_uri$ = 12						; size = 4
_xmlPrintURI PROC					; COMDAT

; 1332 : xmlPrintURI(FILE *stream, xmlURIPtr uri) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1333 :     xmlChar *out;
; 1334 : 
; 1335 :     out = xmlSaveUri(uri);

	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	call	_xmlSaveUri
	add	esp, 4
	mov	DWORD PTR _out$[ebp], eax

; 1336 :     if (out != NULL) {

	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN1@xmlPrintUR

; 1337 : 	fprintf(stream, "%s", (char *) out);

	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1338 : 	xmlFree(out);

	mov	esi, esp
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlPrintUR:

; 1339 :     }
; 1340 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlPrintURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlSaveUri
_TEXT	SEGMENT
tv803 = -148						; size = 4
tv796 = -144						; size = 4
tv704 = -140						; size = 4
tv697 = -136						; size = 4
tv581 = -132						; size = 4
tv574 = -128						; size = 4
tv442 = -124						; size = 4
tv435 = -120						; size = 4
tv307 = -116						; size = 4
tv300 = -112						; size = 4
tv211 = -108						; size = 4
tv204 = -104						; size = 4
_lo$1 = -100						; size = 4
_hi$2 = -96						; size = 4
_val$3 = -92						; size = 4
_lo$4 = -88						; size = 4
_hi$5 = -84						; size = 4
_val$6 = -80						; size = 4
_lo$7 = -76						; size = 4
_hi$8 = -72						; size = 4
_val$9 = -68						; size = 4
_lo$10 = -64						; size = 4
_hi$11 = -60						; size = 4
_val$12 = -56						; size = 4
_lo$13 = -52						; size = 4
_hi$14 = -48						; size = 4
_val$15 = -44						; size = 4
_lo$16 = -40						; size = 4
_hi$17 = -36						; size = 4
_val$18 = -32						; size = 4
_max$ = -24						; size = 4
_len$ = -16						; size = 4
_p$ = -12						; size = 4
_temp$ = -8						; size = 4
_ret$ = -4						; size = 4
_uri$ = 8						; size = 4
_xmlSaveUri PROC					; COMDAT

; 1058 : xmlSaveUri(xmlURIPtr uri) {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1059 :     xmlChar *ret = NULL;

	mov	DWORD PTR _ret$[ebp], 0

; 1060 :     xmlChar *temp;
; 1061 :     const char *p;
; 1062 :     int len;
; 1063 :     int max;
; 1064 : 
; 1065 :     if (uri == NULL) return(NULL);

	cmp	DWORD PTR _uri$[ebp], 0
	jne	SHORT $LN20@xmlSaveUri
	xor	eax, eax
	jmp	$LN1@xmlSaveUri
$LN20@xmlSaveUri:

; 1066 : 
; 1067 : 
; 1068 :     max = 80;

	mov	DWORD PTR _max$[ebp], 80		; 00000050H

; 1069 :     ret = (xmlChar *) xmlMallocAtomic((max + 1) * sizeof(xmlChar));

	mov	eax, DWORD PTR _max$[ebp]
	add	eax, 1
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 1070 :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN21@xmlSaveUri

; 1071 :         xmlURIErrMemory("saving URI\n");

	push	OFFSET ??_C@_0M@NFLMPNMP@saving?5URI?6@
	call	_xmlURIErrMemory
	add	esp, 4

; 1072 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlSaveUri
$LN21@xmlSaveUri:

; 1073 :     }
; 1074 :     len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 1075 : 
; 1076 :     if (uri->scheme != NULL) {

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$LN22@xmlSaveUri

; 1077 : 	p = uri->scheme;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _p$[ebp], eax
$LN2@xmlSaveUri:

; 1078 : 	while (*p != 0) {

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@xmlSaveUri

; 1079 : 	    if (len >= max) {

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jl	SHORT $LN23@xmlSaveUri

; 1080 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	ecx, DWORD PTR _max$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1081 :                 if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN24@xmlSaveUri
	jmp	$mem_error$156
$LN24@xmlSaveUri:

; 1082 : 		ret = temp;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN23@xmlSaveUri:

; 1083 : 	    }
; 1084 : 	    ret[len++] = *p++;

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 1085 : 	}

	jmp	SHORT $LN2@xmlSaveUri
$LN3@xmlSaveUri:

; 1086 : 	if (len >= max) {

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jl	SHORT $LN25@xmlSaveUri

; 1087 :             temp = xmlSaveUriRealloc(ret, &max);

	lea	ecx, DWORD PTR _max$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1088 :             if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN26@xmlSaveUri
	jmp	$mem_error$156
$LN26@xmlSaveUri:

; 1089 :             ret = temp;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN25@xmlSaveUri:

; 1090 : 	}
; 1091 : 	ret[len++] = ':';

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 58			; 0000003aH
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
$LN22@xmlSaveUri:

; 1092 :     }
; 1093 :     if (uri->opaque != NULL) {

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN27@xmlSaveUri

; 1094 : 	p = uri->opaque;

	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[ebp], edx
$LN4@xmlSaveUri:

; 1095 : 	while (*p != 0) {

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN5@xmlSaveUri

; 1096 : 	    if (len + 3 >= max) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 3
	cmp	edx, DWORD PTR _max$[ebp]
	jl	SHORT $LN29@xmlSaveUri

; 1097 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1098 :                 if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN30@xmlSaveUri
	jmp	$mem_error$156
$LN30@xmlSaveUri:

; 1099 :                 ret = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], edx
$LN29@xmlSaveUri:

; 1100 : 	    }
; 1101 : 	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	je	$LN33@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	je	$LN33@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 63					; 0000003fH
	je	$LN33@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	je	$LN33@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 64					; 00000040H
	je	$LN33@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 38					; 00000026H
	je	$LN33@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	$LN33@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	$LN33@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 36					; 00000024H
	je	$LN33@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	je	$LN33@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 91					; 0000005bH
	je	$LN33@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 93					; 0000005dH
	je	$LN33@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN35@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 122				; 0000007aH
	jle	$LN33@xmlSaveUri
$LN35@xmlSaveUri:
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN36@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	jle	SHORT $LN33@xmlSaveUri
$LN36@xmlSaveUri:
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN37@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN33@xmlSaveUri
$LN37@xmlSaveUri:
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN33@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	je	SHORT $LN33@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	je	SHORT $LN33@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	je	SHORT $LN33@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 126				; 0000007eH
	je	SHORT $LN33@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	je	SHORT $LN33@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	je	SHORT $LN33@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN33@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	jne	SHORT $LN31@xmlSaveUri
$LN33@xmlSaveUri:

; 1102 : 		ret[len++] = *p++;

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	jmp	$LN32@xmlSaveUri
$LN31@xmlSaveUri:

; 1103 : 	    else {
; 1104 : 		int val = *(unsigned char *)p++;

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _val$18[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 1105 : 		int hi = val / 0x10, lo = val % 0x10;

	mov	eax, DWORD PTR _val$18[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR _hi$17[ebp], eax
	mov	edx, DWORD PTR _val$18[ebp]
	and	edx, -2147483633			; 8000000fH
	jns	SHORT $LN150@xmlSaveUri
	dec	edx
	or	edx, -16				; fffffff0H
	inc	edx
$LN150@xmlSaveUri:
	mov	DWORD PTR _lo$16[ebp], edx

; 1106 : 		ret[len++] = '%';

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 37			; 00000025H
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 1107 : 		ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	cmp	DWORD PTR _hi$17[ebp], 9
	jle	SHORT $LN123@xmlSaveUri
	mov	DWORD PTR tv204[ebp], 55		; 00000037H
	jmp	SHORT $LN124@xmlSaveUri
$LN123@xmlSaveUri:
	mov	DWORD PTR tv204[ebp], 48		; 00000030H
$LN124@xmlSaveUri:
	mov	edx, DWORD PTR _hi$17[ebp]
	add	edx, DWORD PTR tv204[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 1108 : 		ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	cmp	DWORD PTR _lo$16[ebp], 9
	jle	SHORT $LN125@xmlSaveUri
	mov	DWORD PTR tv211[ebp], 55		; 00000037H
	jmp	SHORT $LN126@xmlSaveUri
$LN125@xmlSaveUri:
	mov	DWORD PTR tv211[ebp], 48		; 00000030H
$LN126@xmlSaveUri:
	mov	edx, DWORD PTR _lo$16[ebp]
	add	edx, DWORD PTR tv211[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
$LN32@xmlSaveUri:

; 1109 : 	    }
; 1110 : 	}

	jmp	$LN4@xmlSaveUri
$LN5@xmlSaveUri:

; 1111 :     } else {

	jmp	$LN28@xmlSaveUri
$LN27@xmlSaveUri:

; 1112 : 	if ((uri->server != NULL) || (uri->port == -1)) {

	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN41@xmlSaveUri
	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+20], -1
	jne	$LN39@xmlSaveUri
$LN41@xmlSaveUri:

; 1113 : 	    if (len + 3 >= max) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 3
	cmp	ecx, DWORD PTR _max$[ebp]
	jl	SHORT $LN42@xmlSaveUri

; 1114 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	edx, DWORD PTR _max$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1115 :                 if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN43@xmlSaveUri
	jmp	$mem_error$156
$LN43@xmlSaveUri:

; 1116 :                 ret = temp;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
$LN42@xmlSaveUri:

; 1117 : 	    }
; 1118 : 	    ret[len++] = '/';

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 47			; 0000002fH
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 1119 : 	    ret[len++] = '/';

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 47			; 0000002fH
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 1120 : 	    if (uri->user != NULL) {

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN44@xmlSaveUri

; 1121 : 		p = uri->user;

	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _p$[ebp], edx
$LN6@xmlSaveUri:

; 1122 : 		while (*p != 0) {

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN7@xmlSaveUri

; 1123 : 		    if (len + 3 >= max) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 3
	cmp	edx, DWORD PTR _max$[ebp]
	jl	SHORT $LN45@xmlSaveUri

; 1124 :                         temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1125 :                         if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN46@xmlSaveUri
	jmp	$mem_error$156
$LN46@xmlSaveUri:

; 1126 :                         ret = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], edx
$LN45@xmlSaveUri:

; 1127 : 		    }
; 1128 : 		    if ((IS_UNRESERVED(*(p))) ||
; 1129 : 			((*(p) == ';')) || ((*(p) == ':')) ||
; 1130 : 			((*(p) == '&')) || ((*(p) == '=')) ||
; 1131 : 			((*(p) == '+')) || ((*(p) == '$')) ||

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN50@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 122				; 0000007aH
	jle	$LN49@xmlSaveUri
$LN50@xmlSaveUri:
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN51@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	jle	$LN49@xmlSaveUri
$LN51@xmlSaveUri:
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN52@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	$LN49@xmlSaveUri
$LN52@xmlSaveUri:
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	$LN49@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	je	$LN49@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	je	$LN49@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	je	$LN49@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 126				; 0000007eH
	je	SHORT $LN49@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	je	SHORT $LN49@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	je	SHORT $LN49@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN49@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	je	SHORT $LN49@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	je	SHORT $LN49@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN49@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 38					; 00000026H
	je	SHORT $LN49@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $LN49@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN49@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 36					; 00000024H
	je	SHORT $LN49@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	jne	SHORT $LN47@xmlSaveUri
$LN49@xmlSaveUri:

; 1132 : 			((*(p) == ',')))
; 1133 : 			ret[len++] = *p++;

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
	jmp	$LN48@xmlSaveUri
$LN47@xmlSaveUri:

; 1134 : 		    else {
; 1135 : 			int val = *(unsigned char *)p++;

	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _val$15[ebp], edx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 1136 : 			int hi = val / 0x10, lo = val % 0x10;

	mov	eax, DWORD PTR _val$15[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR _hi$14[ebp], eax
	mov	ecx, DWORD PTR _val$15[ebp]
	and	ecx, -2147483633			; 8000000fH
	jns	SHORT $LN151@xmlSaveUri
	dec	ecx
	or	ecx, -16				; fffffff0H
	inc	ecx
$LN151@xmlSaveUri:
	mov	DWORD PTR _lo$13[ebp], ecx

; 1137 : 			ret[len++] = '%';

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 37			; 00000025H
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 1138 : 			ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	cmp	DWORD PTR _hi$14[ebp], 9
	jle	SHORT $LN127@xmlSaveUri
	mov	DWORD PTR tv300[ebp], 55		; 00000037H
	jmp	SHORT $LN128@xmlSaveUri
$LN127@xmlSaveUri:
	mov	DWORD PTR tv300[ebp], 48		; 00000030H
$LN128@xmlSaveUri:
	mov	ecx, DWORD PTR _hi$14[ebp]
	add	ecx, DWORD PTR tv300[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 1139 : 			ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	cmp	DWORD PTR _lo$13[ebp], 9
	jle	SHORT $LN129@xmlSaveUri
	mov	DWORD PTR tv307[ebp], 55		; 00000037H
	jmp	SHORT $LN130@xmlSaveUri
$LN129@xmlSaveUri:
	mov	DWORD PTR tv307[ebp], 48		; 00000030H
$LN130@xmlSaveUri:
	mov	ecx, DWORD PTR _lo$13[ebp]
	add	ecx, DWORD PTR tv307[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
$LN48@xmlSaveUri:

; 1140 : 		    }
; 1141 : 		}

	jmp	$LN6@xmlSaveUri
$LN7@xmlSaveUri:

; 1142 : 		if (len + 3 >= max) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 3
	cmp	ecx, DWORD PTR _max$[ebp]
	jl	SHORT $LN53@xmlSaveUri

; 1143 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	edx, DWORD PTR _max$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1144 :                     if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN54@xmlSaveUri
	jmp	$mem_error$156
$LN54@xmlSaveUri:

; 1145 :                     ret = temp;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
$LN53@xmlSaveUri:

; 1146 : 		}
; 1147 : 		ret[len++] = '@';

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 64			; 00000040H
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
$LN44@xmlSaveUri:

; 1148 : 	    }
; 1149 : 	    if (uri->server != NULL) {

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	$LN55@xmlSaveUri

; 1150 : 		p = uri->server;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _p$[ebp], eax
$LN8@xmlSaveUri:

; 1151 : 		while (*p != 0) {

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN9@xmlSaveUri

; 1152 : 		    if (len >= max) {

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jl	SHORT $LN56@xmlSaveUri

; 1153 : 			temp = xmlSaveUriRealloc(ret, &max);

	lea	ecx, DWORD PTR _max$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1154 : 			if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN57@xmlSaveUri
	jmp	$mem_error$156
$LN57@xmlSaveUri:

; 1155 : 			ret = temp;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN56@xmlSaveUri:

; 1156 : 		    }
; 1157 : 		    ret[len++] = *p++;

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 1158 : 		}

	jmp	SHORT $LN8@xmlSaveUri
$LN9@xmlSaveUri:

; 1159 : 		if (uri->port > 0) {

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jle	SHORT $LN55@xmlSaveUri

; 1160 : 		    if (len + 10 >= max) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 10					; 0000000aH
	cmp	ecx, DWORD PTR _max$[ebp]
	jl	SHORT $LN59@xmlSaveUri

; 1161 : 			temp = xmlSaveUriRealloc(ret, &max);

	lea	edx, DWORD PTR _max$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1162 : 			if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN60@xmlSaveUri
	jmp	$mem_error$156
$LN60@xmlSaveUri:

; 1163 : 			ret = temp;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
$LN59@xmlSaveUri:

; 1164 : 		    }
; 1165 : 		    len += snprintf((char *) &ret[len], max - len, ":%d", uri->port);

	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	OFFSET ??_C@_03HODKBCIO@?3?$CFd@
	mov	ecx, DWORD PTR _max$[ebp]
	sub	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	push	edx
	call	_snprintf
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN55@xmlSaveUri:

; 1166 : 		}
; 1167 : 	    }

	jmp	$LN40@xmlSaveUri
$LN39@xmlSaveUri:

; 1168 : 	} else if (uri->authority != NULL) {

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	$LN61@xmlSaveUri

; 1169 : 	    if (len + 3 >= max) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 3
	cmp	ecx, DWORD PTR _max$[ebp]
	jl	SHORT $LN63@xmlSaveUri

; 1170 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	edx, DWORD PTR _max$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1171 :                 if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN64@xmlSaveUri
	jmp	$mem_error$156
$LN64@xmlSaveUri:

; 1172 :                 ret = temp;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
$LN63@xmlSaveUri:

; 1173 : 	    }
; 1174 : 	    ret[len++] = '/';

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 47			; 0000002fH
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 1175 : 	    ret[len++] = '/';

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 47			; 0000002fH
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 1176 : 	    p = uri->authority;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _p$[ebp], ecx
$LN10@xmlSaveUri:

; 1177 : 	    while (*p != 0) {

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN11@xmlSaveUri

; 1178 : 		if (len + 3 >= max) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 3
	cmp	ecx, DWORD PTR _max$[ebp]
	jl	SHORT $LN65@xmlSaveUri

; 1179 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	edx, DWORD PTR _max$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1180 :                     if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN66@xmlSaveUri
	jmp	$mem_error$156
$LN66@xmlSaveUri:

; 1181 :                     ret = temp;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
$LN65@xmlSaveUri:

; 1182 : 		}
; 1183 : 		if ((IS_UNRESERVED(*(p))) ||
; 1184 :                     ((*(p) == '$')) || ((*(p) == ',')) || ((*(p) == ';')) ||
; 1185 :                     ((*(p) == ':')) || ((*(p) == '@')) || ((*(p) == '&')) ||
; 1186 :                     ((*(p) == '=')) || ((*(p) == '+')))

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN70@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jle	$LN69@xmlSaveUri
$LN70@xmlSaveUri:
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN71@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	jle	$LN69@xmlSaveUri
$LN71@xmlSaveUri:
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN72@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	$LN69@xmlSaveUri
$LN72@xmlSaveUri:
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	$LN69@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 95					; 0000005fH
	je	$LN69@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	$LN69@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 33					; 00000021H
	je	$LN69@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 126				; 0000007eH
	je	$LN69@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	je	SHORT $LN69@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN69@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 40					; 00000028H
	je	SHORT $LN69@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 41					; 00000029H
	je	SHORT $LN69@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN69@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $LN69@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	je	SHORT $LN69@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN69@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 64					; 00000040H
	je	SHORT $LN69@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 38					; 00000026H
	je	SHORT $LN69@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN69@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN67@xmlSaveUri
$LN69@xmlSaveUri:

; 1187 : 		    ret[len++] = *p++;

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	jmp	$LN68@xmlSaveUri
$LN67@xmlSaveUri:

; 1188 : 		else {
; 1189 : 		    int val = *(unsigned char *)p++;

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _val$12[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 1190 : 		    int hi = val / 0x10, lo = val % 0x10;

	mov	eax, DWORD PTR _val$12[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR _hi$11[ebp], eax
	mov	edx, DWORD PTR _val$12[ebp]
	and	edx, -2147483633			; 8000000fH
	jns	SHORT $LN152@xmlSaveUri
	dec	edx
	or	edx, -16				; fffffff0H
	inc	edx
$LN152@xmlSaveUri:
	mov	DWORD PTR _lo$10[ebp], edx

; 1191 : 		    ret[len++] = '%';

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 37			; 00000025H
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 1192 : 		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	cmp	DWORD PTR _hi$11[ebp], 9
	jle	SHORT $LN131@xmlSaveUri
	mov	DWORD PTR tv435[ebp], 55		; 00000037H
	jmp	SHORT $LN132@xmlSaveUri
$LN131@xmlSaveUri:
	mov	DWORD PTR tv435[ebp], 48		; 00000030H
$LN132@xmlSaveUri:
	mov	edx, DWORD PTR _hi$11[ebp]
	add	edx, DWORD PTR tv435[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 1193 : 		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	cmp	DWORD PTR _lo$10[ebp], 9
	jle	SHORT $LN133@xmlSaveUri
	mov	DWORD PTR tv442[ebp], 55		; 00000037H
	jmp	SHORT $LN134@xmlSaveUri
$LN133@xmlSaveUri:
	mov	DWORD PTR tv442[ebp], 48		; 00000030H
$LN134@xmlSaveUri:
	mov	edx, DWORD PTR _lo$10[ebp]
	add	edx, DWORD PTR tv442[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
$LN68@xmlSaveUri:

; 1194 : 		}
; 1195 : 	    }

	jmp	$LN10@xmlSaveUri
$LN11@xmlSaveUri:

; 1196 : 	} else if (uri->scheme != NULL) {

	jmp	SHORT $LN40@xmlSaveUri
$LN61@xmlSaveUri:
	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN40@xmlSaveUri

; 1197 : 	    if (len + 3 >= max) {

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 3
	cmp	eax, DWORD PTR _max$[ebp]
	jl	SHORT $LN40@xmlSaveUri

; 1198 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	ecx, DWORD PTR _max$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1199 :                 if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN75@xmlSaveUri
	jmp	$mem_error$156
$LN75@xmlSaveUri:

; 1200 :                 ret = temp;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN40@xmlSaveUri:

; 1201 : 	    }
; 1202 : 	}
; 1203 : 	if (uri->path != NULL) {

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	$LN76@xmlSaveUri

; 1204 : 	    p = uri->path;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _p$[ebp], eax

; 1205 : 	    /*
; 1206 : 	     * the colon in file:///d: should not be escaped or
; 1207 : 	     * Windows accesses fail later.
; 1208 : 	     */
; 1209 : 	    if ((uri->scheme != NULL) &&
; 1210 : 		(p[0] == '/') &&
; 1211 : 		(((p[1] >= 'a') && (p[1] <= 'z')) ||
; 1212 : 		 ((p[1] >= 'A') && (p[1] <= 'Z'))) &&
; 1213 : 		(p[2] == ':') &&

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$LN12@xmlSaveUri
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	$LN12@xmlSaveUri
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN79@xmlSaveUri
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 122				; 0000007aH
	jle	SHORT $LN78@xmlSaveUri
$LN79@xmlSaveUri:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 65					; 00000041H
	jl	$LN12@xmlSaveUri
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 90					; 0000005aH
	jg	$LN12@xmlSaveUri
$LN78@xmlSaveUri:
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	jne	$LN12@xmlSaveUri
	push	OFFSET ??_C@_04DAMGJPCA@file@
	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN12@xmlSaveUri

; 1214 : 	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
; 1215 : 		if (len + 3 >= max) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 3
	cmp	edx, DWORD PTR _max$[ebp]
	jl	SHORT $LN80@xmlSaveUri

; 1216 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1217 :                     if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN81@xmlSaveUri
	jmp	$mem_error$156
$LN81@xmlSaveUri:

; 1218 :                     ret = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], edx
$LN80@xmlSaveUri:

; 1219 : 		}
; 1220 : 		ret[len++] = *p++;

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 1221 : 		ret[len++] = *p++;

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 1222 : 		ret[len++] = *p++;

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx
$LN12@xmlSaveUri:

; 1223 : 	    }
; 1224 : 	    while (*p != 0) {

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN76@xmlSaveUri

; 1225 : 		if (len + 3 >= max) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 3
	cmp	edx, DWORD PTR _max$[ebp]
	jl	SHORT $LN82@xmlSaveUri

; 1226 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1227 :                     if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN83@xmlSaveUri
	jmp	$mem_error$156
$LN83@xmlSaveUri:

; 1228 :                     ret = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], edx
$LN82@xmlSaveUri:

; 1229 : 		}
; 1230 : 		if ((IS_UNRESERVED(*(p))) || ((*(p) == '/')) ||
; 1231 :                     ((*(p) == ';')) || ((*(p) == '@')) || ((*(p) == '&')) ||
; 1232 : 	            ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) ||

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN87@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 122				; 0000007aH
	jle	$LN86@xmlSaveUri
$LN87@xmlSaveUri:
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN88@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	jle	$LN86@xmlSaveUri
$LN88@xmlSaveUri:
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN89@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	$LN86@xmlSaveUri
$LN89@xmlSaveUri:
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	$LN86@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	je	$LN86@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	je	$LN86@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	je	$LN86@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 126				; 0000007eH
	je	$LN86@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 42					; 0000002aH
	je	SHORT $LN86@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	je	SHORT $LN86@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN86@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	je	SHORT $LN86@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN86@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 59					; 0000003bH
	je	SHORT $LN86@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 64					; 00000040H
	je	SHORT $LN86@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 38					; 00000026H
	je	SHORT $LN86@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN86@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	je	SHORT $LN86@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 36					; 00000024H
	je	SHORT $LN86@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN84@xmlSaveUri
$LN86@xmlSaveUri:

; 1233 : 	            ((*(p) == ',')))
; 1234 : 		    ret[len++] = *p++;

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx
	jmp	$LN85@xmlSaveUri
$LN84@xmlSaveUri:

; 1235 : 		else {
; 1236 : 		    int val = *(unsigned char *)p++;

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _val$9[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 1237 : 		    int hi = val / 0x10, lo = val % 0x10;

	mov	eax, DWORD PTR _val$9[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR _hi$8[ebp], eax
	mov	eax, DWORD PTR _val$9[ebp]
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN153@xmlSaveUri
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN153@xmlSaveUri:
	mov	DWORD PTR _lo$7[ebp], eax

; 1238 : 		    ret[len++] = '%';

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 37			; 00000025H
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 1239 : 		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	cmp	DWORD PTR _hi$8[ebp], 9
	jle	SHORT $LN135@xmlSaveUri
	mov	DWORD PTR tv574[ebp], 55		; 00000037H
	jmp	SHORT $LN136@xmlSaveUri
$LN135@xmlSaveUri:
	mov	DWORD PTR tv574[ebp], 48		; 00000030H
$LN136@xmlSaveUri:
	mov	eax, DWORD PTR _hi$8[ebp]
	add	eax, DWORD PTR tv574[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 1240 : 		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	cmp	DWORD PTR _lo$7[ebp], 9
	jle	SHORT $LN137@xmlSaveUri
	mov	DWORD PTR tv581[ebp], 55		; 00000037H
	jmp	SHORT $LN138@xmlSaveUri
$LN137@xmlSaveUri:
	mov	DWORD PTR tv581[ebp], 48		; 00000030H
$LN138@xmlSaveUri:
	mov	eax, DWORD PTR _lo$7[ebp]
	add	eax, DWORD PTR tv581[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
$LN85@xmlSaveUri:

; 1241 : 		}
; 1242 : 	    }

	jmp	$LN12@xmlSaveUri
$LN76@xmlSaveUri:

; 1243 : 	}
; 1244 : 	if (uri->query_raw != NULL) {

	mov	eax, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	$LN90@xmlSaveUri

; 1245 : 	    if (len + 1 >= max) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	cmp	ecx, DWORD PTR _max$[ebp]
	jl	SHORT $LN92@xmlSaveUri

; 1246 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	edx, DWORD PTR _max$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1247 :                 if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN93@xmlSaveUri
	jmp	$mem_error$156
$LN93@xmlSaveUri:

; 1248 :                 ret = temp;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
$LN92@xmlSaveUri:

; 1249 : 	    }
; 1250 : 	    ret[len++] = '?';

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 63			; 0000003fH
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 1251 : 	    p = uri->query_raw;

	mov	ecx, DWORD PTR _uri$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _p$[ebp], edx
$LN14@xmlSaveUri:

; 1252 : 	    while (*p != 0) {

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN15@xmlSaveUri

; 1253 : 		if (len + 1 >= max) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	cmp	edx, DWORD PTR _max$[ebp]
	jl	SHORT $LN94@xmlSaveUri

; 1254 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1255 :                     if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN95@xmlSaveUri
	jmp	$mem_error$156
$LN95@xmlSaveUri:

; 1256 :                     ret = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], edx
$LN94@xmlSaveUri:

; 1257 : 		}
; 1258 : 		ret[len++] = *p++;

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 1259 : 	    }

	jmp	SHORT $LN14@xmlSaveUri
$LN15@xmlSaveUri:

; 1260 : 	} else if (uri->query != NULL) {

	jmp	$LN28@xmlSaveUri
$LN90@xmlSaveUri:
	mov	edx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	$LN28@xmlSaveUri

; 1261 : 	    if (len + 3 >= max) {

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 3
	cmp	eax, DWORD PTR _max$[ebp]
	jl	SHORT $LN97@xmlSaveUri

; 1262 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	ecx, DWORD PTR _max$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1263 :                 if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN98@xmlSaveUri
	jmp	$mem_error$156
$LN98@xmlSaveUri:

; 1264 :                 ret = temp;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN97@xmlSaveUri:

; 1265 : 	    }
; 1266 : 	    ret[len++] = '?';

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 63			; 0000003fH
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 1267 : 	    p = uri->query;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _p$[ebp], ecx
$LN16@xmlSaveUri:

; 1268 : 	    while (*p != 0) {

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN28@xmlSaveUri

; 1269 : 		if (len + 3 >= max) {

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 3
	cmp	ecx, DWORD PTR _max$[ebp]
	jl	SHORT $LN99@xmlSaveUri

; 1270 :                     temp = xmlSaveUriRealloc(ret, &max);

	lea	edx, DWORD PTR _max$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1271 :                     if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN100@xmlSaveUri
	jmp	$mem_error$156
$LN100@xmlSaveUri:

; 1272 :                     ret = temp;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], ecx
$LN99@xmlSaveUri:

; 1273 : 		}
; 1274 : 		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN104@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jle	$LN103@xmlSaveUri
$LN104@xmlSaveUri:
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN105@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 90					; 0000005aH
	jle	$LN103@xmlSaveUri
$LN105@xmlSaveUri:
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN106@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	$LN103@xmlSaveUri
$LN106@xmlSaveUri:
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	je	$LN103@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 95					; 0000005fH
	je	$LN103@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	$LN103@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 33					; 00000021H
	je	$LN103@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 126				; 0000007eH
	je	$LN103@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	je	$LN103@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	je	$LN103@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 40					; 00000028H
	je	$LN103@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 41					; 00000029H
	je	$LN103@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 59					; 0000003bH
	je	SHORT $LN103@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN103@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 63					; 0000003fH
	je	SHORT $LN103@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN103@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 64					; 00000040H
	je	SHORT $LN103@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 38					; 00000026H
	je	SHORT $LN103@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN103@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	je	SHORT $LN103@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 36					; 00000024H
	je	SHORT $LN103@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN103@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 91					; 0000005bH
	je	SHORT $LN103@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	jne	SHORT $LN101@xmlSaveUri
$LN103@xmlSaveUri:

; 1275 : 		    ret[len++] = *p++;

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
	jmp	$LN102@xmlSaveUri
$LN101@xmlSaveUri:

; 1276 : 		else {
; 1277 : 		    int val = *(unsigned char *)p++;

	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _val$6[ebp], edx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 1278 : 		    int hi = val / 0x10, lo = val % 0x10;

	mov	eax, DWORD PTR _val$6[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR _hi$5[ebp], eax
	mov	ecx, DWORD PTR _val$6[ebp]
	and	ecx, -2147483633			; 8000000fH
	jns	SHORT $LN154@xmlSaveUri
	dec	ecx
	or	ecx, -16				; fffffff0H
	inc	ecx
$LN154@xmlSaveUri:
	mov	DWORD PTR _lo$4[ebp], ecx

; 1279 : 		    ret[len++] = '%';

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 37			; 00000025H
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 1280 : 		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	cmp	DWORD PTR _hi$5[ebp], 9
	jle	SHORT $LN139@xmlSaveUri
	mov	DWORD PTR tv697[ebp], 55		; 00000037H
	jmp	SHORT $LN140@xmlSaveUri
$LN139@xmlSaveUri:
	mov	DWORD PTR tv697[ebp], 48		; 00000030H
$LN140@xmlSaveUri:
	mov	ecx, DWORD PTR _hi$5[ebp]
	add	ecx, DWORD PTR tv697[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 1281 : 		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	cmp	DWORD PTR _lo$4[ebp], 9
	jle	SHORT $LN141@xmlSaveUri
	mov	DWORD PTR tv704[ebp], 55		; 00000037H
	jmp	SHORT $LN142@xmlSaveUri
$LN141@xmlSaveUri:
	mov	DWORD PTR tv704[ebp], 48		; 00000030H
$LN142@xmlSaveUri:
	mov	ecx, DWORD PTR _lo$4[ebp]
	add	ecx, DWORD PTR tv704[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax
$LN102@xmlSaveUri:

; 1282 : 		}
; 1283 : 	    }

	jmp	$LN16@xmlSaveUri
$LN28@xmlSaveUri:

; 1284 : 	}
; 1285 :     }
; 1286 :     if (uri->fragment != NULL) {

	mov	ecx, DWORD PTR _uri$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	$LN108@xmlSaveUri

; 1287 : 	if (len + 3 >= max) {

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 3
	cmp	edx, DWORD PTR _max$[ebp]
	jl	SHORT $LN109@xmlSaveUri

; 1288 :             temp = xmlSaveUriRealloc(ret, &max);

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1289 :             if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN110@xmlSaveUri
	jmp	$mem_error$156
$LN110@xmlSaveUri:

; 1290 :             ret = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], edx
$LN109@xmlSaveUri:

; 1291 : 	}
; 1292 : 	ret[len++] = '#';

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 35			; 00000023H
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 1293 : 	p = uri->fragment;

	mov	edx, DWORD PTR _uri$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _p$[ebp], eax
$LN18@xmlSaveUri:

; 1294 : 	while (*p != 0) {

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN108@xmlSaveUri

; 1295 : 	    if (len + 3 >= max) {

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 3
	cmp	eax, DWORD PTR _max$[ebp]
	jl	SHORT $LN111@xmlSaveUri

; 1296 :                 temp = xmlSaveUriRealloc(ret, &max);

	lea	ecx, DWORD PTR _max$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1297 :                 if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN112@xmlSaveUri
	jmp	$mem_error$156
$LN112@xmlSaveUri:

; 1298 :                 ret = temp;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN111@xmlSaveUri:

; 1299 : 	    }
; 1300 : 	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN116@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 122				; 0000007aH
	jle	$LN115@xmlSaveUri
$LN116@xmlSaveUri:
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN117@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 90					; 0000005aH
	jle	$LN115@xmlSaveUri
$LN117@xmlSaveUri:
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN118@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jle	$LN115@xmlSaveUri
$LN118@xmlSaveUri:
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	je	$LN115@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	je	$LN115@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 46					; 0000002eH
	je	$LN115@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 33					; 00000021H
	je	$LN115@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 126				; 0000007eH
	je	$LN115@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 42					; 0000002aH
	je	$LN115@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 39					; 00000027H
	je	$LN115@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	je	$LN115@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 41					; 00000029H
	je	$LN115@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN115@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN115@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN115@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN115@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 64					; 00000040H
	je	SHORT $LN115@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 38					; 00000026H
	je	SHORT $LN115@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 61					; 0000003dH
	je	SHORT $LN115@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN115@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 36					; 00000024H
	je	SHORT $LN115@xmlSaveUri
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $LN115@xmlSaveUri
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 91					; 0000005bH
	je	SHORT $LN115@xmlSaveUri
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN113@xmlSaveUri
$LN115@xmlSaveUri:

; 1301 : 		ret[len++] = *p++;

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx
	jmp	$LN114@xmlSaveUri
$LN113@xmlSaveUri:

; 1302 : 	    else {
; 1303 : 		int val = *(unsigned char *)p++;

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _val$3[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 1304 : 		int hi = val / 0x10, lo = val % 0x10;

	mov	eax, DWORD PTR _val$3[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR _hi$2[ebp], eax
	mov	eax, DWORD PTR _val$3[ebp]
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN155@xmlSaveUri
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN155@xmlSaveUri:
	mov	DWORD PTR _lo$1[ebp], eax

; 1305 : 		ret[len++] = '%';

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 37			; 00000025H
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 1306 : 		ret[len++] = hi + (hi > 9? 'A'-10 : '0');

	cmp	DWORD PTR _hi$2[ebp], 9
	jle	SHORT $LN143@xmlSaveUri
	mov	DWORD PTR tv796[ebp], 55		; 00000037H
	jmp	SHORT $LN144@xmlSaveUri
$LN143@xmlSaveUri:
	mov	DWORD PTR tv796[ebp], 48		; 00000030H
$LN144@xmlSaveUri:
	mov	eax, DWORD PTR _hi$2[ebp]
	add	eax, DWORD PTR tv796[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx

; 1307 : 		ret[len++] = lo + (lo > 9? 'A'-10 : '0');

	cmp	DWORD PTR _lo$1[ebp], 9
	jle	SHORT $LN145@xmlSaveUri
	mov	DWORD PTR tv803[ebp], 55		; 00000037H
	jmp	SHORT $LN146@xmlSaveUri
$LN145@xmlSaveUri:
	mov	DWORD PTR tv803[ebp], 48		; 00000030H
$LN146@xmlSaveUri:
	mov	eax, DWORD PTR _lo$1[ebp]
	add	eax, DWORD PTR tv803[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
$LN114@xmlSaveUri:

; 1308 : 	    }
; 1309 : 	}

	jmp	$LN18@xmlSaveUri
$LN108@xmlSaveUri:

; 1310 :     }
; 1311 :     if (len >= max) {

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jl	SHORT $LN120@xmlSaveUri

; 1312 :         temp = xmlSaveUriRealloc(ret, &max);

	lea	ecx, DWORD PTR _max$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlSaveUriRealloc
	add	esp, 8
	mov	DWORD PTR _temp$[ebp], eax

; 1313 :         if (temp == NULL) goto mem_error;

	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN121@xmlSaveUri
	jmp	SHORT $mem_error$156
$LN121@xmlSaveUri:

; 1314 :         ret = temp;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN120@xmlSaveUri:

; 1315 :     }
; 1316 :     ret[len] = 0;

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 0

; 1317 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlSaveUri
$mem_error$156:

; 1318 : 
; 1319 : mem_error:
; 1320 :     xmlFree(ret);

	mov	esi, esp
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1321 :     return(NULL);

	xor	eax, eax
$LN1@xmlSaveUri:

; 1322 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN149@xmlSaveUri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN149@xmlSaveUri:
	DD	1
	DD	$LN148@xmlSaveUri
$LN148@xmlSaveUri:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN147@xmlSaveUri
$LN147@xmlSaveUri:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	120					; 00000078H
	DB	0
_xmlSaveUri ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParseURIReference
_TEXT	SEGMENT
_uri$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlParseURIReference PROC				; COMDAT

; 962  : xmlParseURIReference(xmlURIPtr uri, const char *str) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 963  :     return(xmlParse3986URIReference(uri, str));

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlParse3986URIReference
	add	esp, 8

; 964  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlParseURIReference ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParseURIRaw
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_uri$ = -4						; size = 4
_str$ = 8						; size = 4
_raw$ = 12						; size = 4
_xmlParseURIRaw PROC					; COMDAT

; 978  : xmlParseURIRaw(const char *str, int raw) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 979  :     xmlURIPtr uri;
; 980  :     int ret;
; 981  : 
; 982  :     if (str == NULL)

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@xmlParseUR

; 983  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseUR
$LN2@xmlParseUR:

; 984  :     uri = xmlCreateURI();

	call	_xmlCreateURI
	mov	DWORD PTR _uri$[ebp], eax

; 985  :     if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN3@xmlParseUR

; 986  :         if (raw) {

	cmp	DWORD PTR _raw$[ebp], 0
	je	SHORT $LN4@xmlParseUR

; 987  : 	    uri->cleanup |= 2;

	mov	eax, DWORD PTR _uri$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 2
	mov	edx, DWORD PTR _uri$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN4@xmlParseUR:

; 988  : 	}
; 989  : 	ret = xmlParseURIReference(uri, str);

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlParseURIReference
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 990  :         if (ret) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN3@xmlParseUR

; 991  : 	    xmlFreeURI(uri);

	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4

; 992  : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseUR
$LN3@xmlParseUR:

; 993  : 	}
; 994  :     }
; 995  :     return(uri);

	mov	eax, DWORD PTR _uri$[ebp]
$LN1@xmlParseUR:

; 996  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseURIRaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlParseURI
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_uri$ = -4						; size = 4
_str$ = 8						; size = 4
_xmlParseURI PROC					; COMDAT

; 932  : xmlParseURI(const char *str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 933  :     xmlURIPtr uri;
; 934  :     int ret;
; 935  : 
; 936  :     if (str == NULL)

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@xmlParseUR

; 937  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseUR
$LN2@xmlParseUR:

; 938  :     uri = xmlCreateURI();

	call	_xmlCreateURI
	mov	DWORD PTR _uri$[ebp], eax

; 939  :     if (uri != NULL) {

	cmp	DWORD PTR _uri$[ebp], 0
	je	SHORT $LN3@xmlParseUR

; 940  : 	ret = xmlParse3986URIReference(uri, str);

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uri$[ebp]
	push	ecx
	call	_xmlParse3986URIReference
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 941  :         if (ret) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN3@xmlParseUR

; 942  : 	    xmlFreeURI(uri);

	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4

; 943  : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlParseUR
$LN3@xmlParseUR:

; 944  : 	}
; 945  :     }
; 946  :     return(uri);

	mov	eax, DWORD PTR _uri$[ebp]
$LN1@xmlParseUR:

; 947  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlParseURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlBuildRelativeURI
_TEXT	SEGMENT
_pos$1 = -52						; size = 4
_rptr$2 = -48						; size = 4
_remove_path$ = -44					; size = 4
_vptr$ = -40						; size = 4
_uptr$ = -36						; size = 4
_bptr$ = -32						; size = 4
_bas$ = -28						; size = 4
_ref$ = -24						; size = 4
_len$ = -20						; size = 4
_nbslash$ = -16						; size = 4
_ix$ = -12						; size = 4
_ret$ = -8						; size = 4
_val$ = -4						; size = 4
_URI$ = 8						; size = 4
_base$ = 12						; size = 4
_xmlBuildRelativeURI PROC				; COMDAT

; 2164 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 2165 :     xmlChar *val = NULL;

	mov	DWORD PTR _val$[ebp], 0

; 2166 :     int ret;
; 2167 :     int ix;
; 2168 :     int nbslash = 0;

	mov	DWORD PTR _nbslash$[ebp], 0

; 2169 :     int len;
; 2170 :     xmlURIPtr ref = NULL;

	mov	DWORD PTR _ref$[ebp], 0

; 2171 :     xmlURIPtr bas = NULL;

	mov	DWORD PTR _bas$[ebp], 0

; 2172 :     xmlChar *bptr, *uptr, *vptr;
; 2173 :     int remove_path = 0;

	mov	DWORD PTR _remove_path$[ebp], 0

; 2174 : 
; 2175 :     if ((URI == NULL) || (*URI == 0))

	cmp	DWORD PTR _URI$[ebp], 0
	je	SHORT $LN14@xmlBuildRe
	mov	eax, DWORD PTR _URI$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN13@xmlBuildRe
$LN14@xmlBuildRe:

; 2176 : 	return NULL;

	xor	eax, eax
	jmp	$LN1@xmlBuildRe
$LN13@xmlBuildRe:

; 2177 : 
; 2178 :     /*
; 2179 :      * First parse URI into a standard form
; 2180 :      */
; 2181 :     ref = xmlCreateURI ();

	call	_xmlCreateURI
	mov	DWORD PTR _ref$[ebp], eax

; 2182 :     if (ref == NULL)

	cmp	DWORD PTR _ref$[ebp], 0
	jne	SHORT $LN15@xmlBuildRe

; 2183 : 	return NULL;

	xor	eax, eax
	jmp	$LN1@xmlBuildRe
$LN15@xmlBuildRe:

; 2184 :     /* If URI not already in "relative" form */
; 2185 :     if (URI[0] != '.') {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _URI$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 46					; 0000002eH
	je	SHORT $LN16@xmlBuildRe

; 2186 : 	ret = xmlParseURIReference (ref, (const char *) URI);

	mov	eax, DWORD PTR _URI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ref$[ebp]
	push	ecx
	call	_xmlParseURIReference
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2187 : 	if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN18@xmlBuildRe

; 2188 : 	    goto done;		/* Error in URI, return NULL */

	jmp	$done$49
$LN18@xmlBuildRe:

; 2189 :     } else

	jmp	SHORT $LN17@xmlBuildRe
$LN16@xmlBuildRe:

; 2190 : 	ref->path = (char *)xmlStrdup(URI);

	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN17@xmlBuildRe:

; 2191 : 
; 2192 :     /*
; 2193 :      * Next parse base into the same standard form
; 2194 :      */
; 2195 :     if ((base == NULL) || (*base == 0)) {

	cmp	DWORD PTR _base$[ebp], 0
	je	SHORT $LN20@xmlBuildRe
	mov	edx, DWORD PTR _base$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN19@xmlBuildRe
$LN20@xmlBuildRe:

; 2196 : 	val = xmlStrdup (URI);

	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 2197 : 	goto done;

	jmp	$done$49
$LN19@xmlBuildRe:

; 2198 :     }
; 2199 :     bas = xmlCreateURI ();

	call	_xmlCreateURI
	mov	DWORD PTR _bas$[ebp], eax

; 2200 :     if (bas == NULL)

	cmp	DWORD PTR _bas$[ebp], 0
	jne	SHORT $LN21@xmlBuildRe

; 2201 : 	goto done;

	jmp	$done$49
$LN21@xmlBuildRe:

; 2202 :     if (base[0] != '.') {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _base$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 46					; 0000002eH
	je	SHORT $LN22@xmlBuildRe

; 2203 : 	ret = xmlParseURIReference (bas, (const char *) base);

	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bas$[ebp]
	push	ecx
	call	_xmlParseURIReference
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 2204 : 	if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN24@xmlBuildRe

; 2205 : 	    goto done;		/* Error in base, return NULL */

	jmp	$done$49
$LN24@xmlBuildRe:

; 2206 :     } else

	jmp	SHORT $LN23@xmlBuildRe
$LN22@xmlBuildRe:

; 2207 : 	bas->path = (char *)xmlStrdup(base);

	mov	edx, DWORD PTR _base$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _bas$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN23@xmlBuildRe:

; 2208 : 
; 2209 :     /*
; 2210 :      * If the scheme / server on the URI differs from the base,
; 2211 :      * just return the URI
; 2212 :      */
; 2213 :     if ((ref->scheme != NULL) &&

	mov	edx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN25@xmlBuildRe
	mov	eax, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN26@xmlBuildRe
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _bas$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@xmlBuildRe
	mov	edx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _bas$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlBuildRe
$LN26@xmlBuildRe:

; 2214 : 	((bas->scheme == NULL) ||
; 2215 : 	 (xmlStrcmp ((xmlChar *)bas->scheme, (xmlChar *)ref->scheme)) ||
; 2216 : 	 (xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)))) {
; 2217 : 	val = xmlStrdup (URI);

	mov	eax, DWORD PTR _URI$[ebp]
	push	eax
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 2218 : 	goto done;

	jmp	$done$49
$LN25@xmlBuildRe:

; 2219 :     }
; 2220 :     if (xmlStrEqual((xmlChar *)bas->path, (xmlChar *)ref->path)) {

	mov	ecx, DWORD PTR _ref$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _bas$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN27@xmlBuildRe

; 2221 : 	val = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 2222 : 	goto done;

	jmp	$done$49
$LN27@xmlBuildRe:

; 2223 :     }
; 2224 :     if (bas->path == NULL) {

	mov	edx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN28@xmlBuildRe

; 2225 : 	val = xmlStrdup((xmlChar *)ref->path);

	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 2226 : 	goto done;

	jmp	$done$49
$LN28@xmlBuildRe:

; 2227 :     }
; 2228 :     if (ref->path == NULL) {

	mov	edx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN29@xmlBuildRe

; 2229 :         ref->path = (char *) "/";

	mov	eax, DWORD PTR _ref$[ebp]
	mov	DWORD PTR [eax+24], OFFSET ??_C@_01KMDKNFGN@?1@

; 2230 : 	remove_path = 1;

	mov	DWORD PTR _remove_path$[ebp], 1
$LN29@xmlBuildRe:

; 2231 :     }
; 2232 : 
; 2233 :     /*
; 2234 :      * At this point (at last!) we can compare the two paths
; 2235 :      *
; 2236 :      * First we take care of the special case where either of the
; 2237 :      * two path components may be missing (bug 316224)
; 2238 :      */
; 2239 :     bptr = (xmlChar *)bas->path;

	mov	ecx, DWORD PTR _bas$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _bptr$[ebp], edx

; 2240 :     {
; 2241 :         xmlChar *rptr = (xmlChar *) ref->path;

	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _rptr$2[ebp], ecx

; 2242 :         int pos = 0;

	mov	DWORD PTR _pos$1[ebp], 0

; 2243 : 
; 2244 :         /*
; 2245 :          * Next we compare the two strings and find where they first differ
; 2246 :          */
; 2247 : 	if ((*rptr == '.') && (rptr[1] == '/'))

	mov	edx, DWORD PTR _rptr$2[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN30@xmlBuildRe
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _rptr$2[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN30@xmlBuildRe

; 2248 :             rptr += 2;

	mov	ecx, DWORD PTR _rptr$2[ebp]
	add	ecx, 2
	mov	DWORD PTR _rptr$2[ebp], ecx
$LN30@xmlBuildRe:

; 2249 : 	if ((*bptr == '.') && (bptr[1] == '/'))

	mov	edx, DWORD PTR _bptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN31@xmlBuildRe
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _bptr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN31@xmlBuildRe

; 2250 :             bptr += 2;

	mov	ecx, DWORD PTR _bptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _bptr$[ebp], ecx
	jmp	SHORT $LN2@xmlBuildRe
$LN31@xmlBuildRe:

; 2251 : 	else if ((*bptr == '/') && (*rptr != '/'))

	mov	edx, DWORD PTR _bptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN2@xmlBuildRe
	mov	ecx, DWORD PTR _rptr$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN2@xmlBuildRe

; 2252 : 	    bptr++;

	mov	eax, DWORD PTR _bptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _bptr$[ebp], eax
$LN2@xmlBuildRe:

; 2253 : 	while ((bptr[pos] == rptr[pos]) && (bptr[pos] != 0))

	mov	ecx, DWORD PTR _bptr$[ebp]
	add	ecx, DWORD PTR _pos$1[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _rptr$2[ebp]
	add	eax, DWORD PTR _pos$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN3@xmlBuildRe
	mov	edx, DWORD PTR _bptr$[ebp]
	add	edx, DWORD PTR _pos$1[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@xmlBuildRe

; 2254 : 	    pos++;

	mov	ecx, DWORD PTR _pos$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _pos$1[ebp], ecx
	jmp	SHORT $LN2@xmlBuildRe
$LN3@xmlBuildRe:

; 2255 : 
; 2256 : 	if (bptr[pos] == rptr[pos]) {

	mov	edx, DWORD PTR _bptr$[ebp]
	add	edx, DWORD PTR _pos$1[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _rptr$2[ebp]
	add	ecx, DWORD PTR _pos$1[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN34@xmlBuildRe

; 2257 : 	    val = xmlStrdup(BAD_CAST "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 2258 : 	    goto done;		/* (I can't imagine why anyone would do this) */

	jmp	$done$49
$LN34@xmlBuildRe:

; 2259 : 	}
; 2260 : 
; 2261 : 	/*
; 2262 : 	 * In URI, "back up" to the last '/' encountered.  This will be the
; 2263 : 	 * beginning of the "unique" suffix of URI
; 2264 : 	 */
; 2265 : 	ix = pos;

	mov	eax, DWORD PTR _pos$1[ebp]
	mov	DWORD PTR _ix$[ebp], eax

; 2266 : 	for (; ix > 0; ix--) {

	jmp	SHORT $LN6@xmlBuildRe
$LN4@xmlBuildRe:
	mov	ecx, DWORD PTR _ix$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ix$[ebp], ecx
$LN6@xmlBuildRe:
	cmp	DWORD PTR _ix$[ebp], 0
	jle	SHORT $LN5@xmlBuildRe

; 2267 : 	    if (rptr[ix - 1] == '/')

	mov	edx, DWORD PTR _rptr$2[ebp]
	add	edx, DWORD PTR _ix$[ebp]
	movzx	eax, BYTE PTR [edx-1]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN35@xmlBuildRe

; 2268 : 		break;

	jmp	SHORT $LN5@xmlBuildRe
$LN35@xmlBuildRe:

; 2269 : 	}

	jmp	SHORT $LN4@xmlBuildRe
$LN5@xmlBuildRe:

; 2270 : 	uptr = (xmlChar *)&rptr[ix];

	mov	ecx, DWORD PTR _rptr$2[ebp]
	add	ecx, DWORD PTR _ix$[ebp]
	mov	DWORD PTR _uptr$[ebp], ecx

; 2271 : 
; 2272 : 	/*
; 2273 : 	 * In base, count the number of '/' from the differing point
; 2274 : 	 */
; 2275 : 	for (; bptr[ix] != 0; ix++) {

	jmp	SHORT $LN9@xmlBuildRe
$LN7@xmlBuildRe:
	mov	edx, DWORD PTR _ix$[ebp]
	add	edx, 1
	mov	DWORD PTR _ix$[ebp], edx
$LN9@xmlBuildRe:
	mov	eax, DWORD PTR _bptr$[ebp]
	add	eax, DWORD PTR _ix$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@xmlBuildRe

; 2276 : 	    if (bptr[ix] == '/')

	mov	edx, DWORD PTR _bptr$[ebp]
	add	edx, DWORD PTR _ix$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN36@xmlBuildRe

; 2277 : 		nbslash++;

	mov	ecx, DWORD PTR _nbslash$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbslash$[ebp], ecx
$LN36@xmlBuildRe:

; 2278 : 	}

	jmp	SHORT $LN7@xmlBuildRe
$LN8@xmlBuildRe:

; 2279 : 
; 2280 : 	/*
; 2281 : 	 * e.g: URI="foo/" base="foo/bar" -> "./"
; 2282 : 	 */
; 2283 : 	if (nbslash == 0 && !uptr[0]) {

	cmp	DWORD PTR _nbslash$[ebp], 0
	jne	SHORT $LN37@xmlBuildRe
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _uptr$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN37@xmlBuildRe

; 2284 : 	    val = xmlStrdup(BAD_CAST "./");

	push	OFFSET ??_C@_02CAHBHFGK@?4?1@
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 2285 : 	    goto done;

	jmp	$done$49
$LN37@xmlBuildRe:

; 2286 : 	}
; 2287 : 
; 2288 : 	len = xmlStrlen (uptr) + 1;

	mov	eax, DWORD PTR _uptr$[ebp]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 2289 :     }
; 2290 : 
; 2291 :     if (nbslash == 0) {

	cmp	DWORD PTR _nbslash$[ebp], 0
	jne	SHORT $LN38@xmlBuildRe

; 2292 : 	if (uptr != NULL)

	cmp	DWORD PTR _uptr$[ebp], 0
	je	SHORT $LN39@xmlBuildRe

; 2293 : 	    /* exception characters from xmlSaveUri */
; 2294 : 	    val = xmlURIEscapeStr(uptr, BAD_CAST "/;&=+$,");

	push	OFFSET ??_C@_07OJONJGHF@?1?$DL?$CG?$DN?$CL$?0@
	mov	ecx, DWORD PTR _uptr$[ebp]
	push	ecx
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax
$LN39@xmlBuildRe:

; 2295 : 	goto done;

	jmp	$done$49
$LN38@xmlBuildRe:

; 2296 :     }
; 2297 : 
; 2298 :     /*
; 2299 :      * Allocate just enough space for the returned string -
; 2300 :      * length of the remainder of the URI, plus enough space
; 2301 :      * for the "../" groups, plus one for the terminator
; 2302 :      */
; 2303 :     val = (xmlChar *) xmlMalloc (len + 3 * nbslash);

	imul	edx, DWORD PTR _nbslash$[ebp], 3
	add	edx, DWORD PTR _len$[ebp]
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _val$[ebp], eax

; 2304 :     if (val == NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN40@xmlBuildRe

; 2305 :         xmlURIErrMemory("building relative URI\n");

	push	OFFSET ??_C@_0BH@KBJNOCC@building?5relative?5URI?6@
	call	_xmlURIErrMemory
	add	esp, 4

; 2306 : 	goto done;

	jmp	$done$49
$LN40@xmlBuildRe:

; 2307 :     }
; 2308 :     vptr = val;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _vptr$[ebp], eax

; 2309 :     /*
; 2310 :      * Put in as many "../" as needed
; 2311 :      */
; 2312 :     for (; nbslash>0; nbslash--) {

	jmp	SHORT $LN12@xmlBuildRe
$LN10@xmlBuildRe:
	mov	ecx, DWORD PTR _nbslash$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nbslash$[ebp], ecx
$LN12@xmlBuildRe:
	cmp	DWORD PTR _nbslash$[ebp], 0
	jle	SHORT $LN11@xmlBuildRe

; 2313 : 	*vptr++ = '.';

	mov	edx, DWORD PTR _vptr$[ebp]
	mov	BYTE PTR [edx], 46			; 0000002eH
	mov	eax, DWORD PTR _vptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _vptr$[ebp], eax

; 2314 : 	*vptr++ = '.';

	mov	ecx, DWORD PTR _vptr$[ebp]
	mov	BYTE PTR [ecx], 46			; 0000002eH
	mov	edx, DWORD PTR _vptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _vptr$[ebp], edx

; 2315 : 	*vptr++ = '/';

	mov	eax, DWORD PTR _vptr$[ebp]
	mov	BYTE PTR [eax], 47			; 0000002fH
	mov	ecx, DWORD PTR _vptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _vptr$[ebp], ecx

; 2316 :     }

	jmp	SHORT $LN10@xmlBuildRe
$LN11@xmlBuildRe:

; 2317 :     /*
; 2318 :      * Finish up with the end of the URI
; 2319 :      */
; 2320 :     if (uptr != NULL) {

	cmp	DWORD PTR _uptr$[ebp], 0
	je	SHORT $LN41@xmlBuildRe

; 2321 :         if ((vptr > val) && (len > 0) &&
; 2322 : 	    (uptr[0] == '/') && (vptr[-1] == '/')) {

	mov	edx, DWORD PTR _vptr$[ebp]
	cmp	edx, DWORD PTR _val$[ebp]
	jbe	SHORT $LN43@xmlBuildRe
	cmp	DWORD PTR _len$[ebp], 0
	jle	SHORT $LN43@xmlBuildRe
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _uptr$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN43@xmlBuildRe
	mov	ecx, 1
	imul	edx, ecx, -1
	mov	eax, DWORD PTR _vptr$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN43@xmlBuildRe

; 2323 : 	    memcpy (vptr, uptr + 1, len - 1);

	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _uptr$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _vptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2324 : 	    vptr[len - 2] = 0;

	mov	edx, DWORD PTR _vptr$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx-2], 0

; 2325 : 	} else {

	jmp	SHORT $LN44@xmlBuildRe
$LN43@xmlBuildRe:

; 2326 : 	    memcpy (vptr, uptr, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2327 : 	    vptr[len - 1] = 0;

	mov	eax, DWORD PTR _vptr$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax-1], 0
$LN44@xmlBuildRe:

; 2328 : 	}
; 2329 :     } else {

	jmp	SHORT $LN42@xmlBuildRe
$LN41@xmlBuildRe:

; 2330 : 	vptr[len - 1] = 0;

	mov	ecx, DWORD PTR _vptr$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx-1], 0
$LN42@xmlBuildRe:

; 2331 :     }
; 2332 : 
; 2333 :     /* escape the freshly-built path */
; 2334 :     vptr = val;

	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _vptr$[ebp], edx

; 2335 : 	/* exception characters from xmlSaveUri */
; 2336 :     val = xmlURIEscapeStr(vptr, BAD_CAST "/;&=+$,");

	push	OFFSET ??_C@_07OJONJGHF@?1?$DL?$CG?$DN?$CL$?0@
	mov	eax, DWORD PTR _vptr$[ebp]
	push	eax
	call	_xmlURIEscapeStr
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 2337 :     xmlFree(vptr);

	mov	esi, esp
	mov	ecx, DWORD PTR _vptr$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$done$49:

; 2338 : 
; 2339 : done:
; 2340 :     /*
; 2341 :      * Free the working variables
; 2342 :      */
; 2343 :     if (remove_path != 0)

	cmp	DWORD PTR _remove_path$[ebp], 0
	je	SHORT $LN45@xmlBuildRe

; 2344 :         ref->path = NULL;

	mov	edx, DWORD PTR _ref$[ebp]
	mov	DWORD PTR [edx+24], 0
$LN45@xmlBuildRe:

; 2345 :     if (ref != NULL)

	cmp	DWORD PTR _ref$[ebp], 0
	je	SHORT $LN46@xmlBuildRe

; 2346 : 	xmlFreeURI (ref);

	mov	eax, DWORD PTR _ref$[ebp]
	push	eax
	call	_xmlFreeURI
	add	esp, 4
$LN46@xmlBuildRe:

; 2347 :     if (bas != NULL)

	cmp	DWORD PTR _bas$[ebp], 0
	je	SHORT $LN47@xmlBuildRe

; 2348 : 	xmlFreeURI (bas);

	mov	ecx, DWORD PTR _bas$[ebp]
	push	ecx
	call	_xmlFreeURI
	add	esp, 4
$LN47@xmlBuildRe:

; 2349 : 
; 2350 :     return val;

	mov	eax, DWORD PTR _val$[ebp]
$LN1@xmlBuildRe:

; 2351 : }

	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBuildRelativeURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlBuildURI
_TEXT	SEGMENT
tv307 = -68						; size = 4
tv632 = -61						; size = 1
tv629 = -60						; size = 4
tv626 = -56						; size = 4
tv300 = -52						; size = 4
tv618 = -45						; size = 1
tv615 = -44						; size = 4
tv612 = -40						; size = 4
_res$ = -36						; size = 4
_bas$ = -32						; size = 4
_ref$ = -28						; size = 4
_out$ = -24						; size = 4
_cur$ = -20						; size = 4
_indx$ = -16						; size = 4
_len$ = -12						; size = 4
_ret$ = -8						; size = 4
_val$ = -4						; size = 4
_URI$ = 8						; size = 4
_base$ = 12						; size = 4
_xmlBuildURI PROC					; COMDAT

; 1882 : xmlBuildURI(const xmlChar *URI, const xmlChar *base) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1883 :     xmlChar *val = NULL;

	mov	DWORD PTR _val$[ebp], 0

; 1884 :     int ret, len, indx, cur, out;
; 1885 :     xmlURIPtr ref = NULL;

	mov	DWORD PTR _ref$[ebp], 0

; 1886 :     xmlURIPtr bas = NULL;

	mov	DWORD PTR _bas$[ebp], 0

; 1887 :     xmlURIPtr res = NULL;

	mov	DWORD PTR _res$[ebp], 0

; 1888 : 
; 1889 :     /*
; 1890 :      * 1) The URI reference is parsed into the potential four components and
; 1891 :      *    fragment identifier, as described in Section 4.3.
; 1892 :      *
; 1893 :      *    NOTE that a completely empty URI is treated by modern browsers
; 1894 :      *    as a reference to "." rather than as a synonym for the current
; 1895 :      *    URI.  Should we do that here?
; 1896 :      */
; 1897 :     if (URI == NULL)

	cmp	DWORD PTR _URI$[ebp], 0
	jne	SHORT $LN10@xmlBuildUR

; 1898 : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
	jmp	SHORT $LN11@xmlBuildUR
$LN10@xmlBuildUR:

; 1899 :     else {
; 1900 : 	if (*URI) {

	mov	eax, DWORD PTR _URI$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN12@xmlBuildUR

; 1901 : 	    ref = xmlCreateURI();

	call	_xmlCreateURI
	mov	DWORD PTR _ref$[ebp], eax

; 1902 : 	    if (ref == NULL)

	cmp	DWORD PTR _ref$[ebp], 0
	jne	SHORT $LN14@xmlBuildUR

; 1903 : 		goto done;

	jmp	$done$74
$LN14@xmlBuildUR:

; 1904 : 	    ret = xmlParseURIReference(ref, (const char *) URI);

	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	mov	eax, DWORD PTR _ref$[ebp]
	push	eax
	call	_xmlParseURIReference
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 1905 : 	}

	jmp	SHORT $LN11@xmlBuildUR
$LN12@xmlBuildUR:

; 1906 : 	else
; 1907 : 	    ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN11@xmlBuildUR:

; 1908 :     }
; 1909 :     if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN15@xmlBuildUR

; 1910 : 	goto done;

	jmp	$done$74
$LN15@xmlBuildUR:

; 1911 :     if ((ref != NULL) && (ref->scheme != NULL)) {

	cmp	DWORD PTR _ref$[ebp], 0
	je	SHORT $LN16@xmlBuildUR
	mov	ecx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN16@xmlBuildUR

; 1912 : 	/*
; 1913 : 	 * The URI is absolute don't modify.
; 1914 : 	 */
; 1915 : 	val = xmlStrdup(URI);

	mov	edx, DWORD PTR _URI$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 1916 : 	goto done;

	jmp	$done$74
$LN16@xmlBuildUR:

; 1917 :     }
; 1918 :     if (base == NULL)

	cmp	DWORD PTR _base$[ebp], 0
	jne	SHORT $LN17@xmlBuildUR

; 1919 : 	ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
	jmp	SHORT $LN18@xmlBuildUR
$LN17@xmlBuildUR:

; 1920 :     else {
; 1921 : 	bas = xmlCreateURI();

	call	_xmlCreateURI
	mov	DWORD PTR _bas$[ebp], eax

; 1922 : 	if (bas == NULL)

	cmp	DWORD PTR _bas$[ebp], 0
	jne	SHORT $LN19@xmlBuildUR

; 1923 : 	    goto done;

	jmp	$done$74
$LN19@xmlBuildUR:

; 1924 : 	ret = xmlParseURIReference(bas, (const char *) base);

	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bas$[ebp]
	push	ecx
	call	_xmlParseURIReference
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
$LN18@xmlBuildUR:

; 1925 :     }
; 1926 :     if (ret != 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN20@xmlBuildUR

; 1927 : 	if (ref)

	cmp	DWORD PTR _ref$[ebp], 0
	je	SHORT $LN21@xmlBuildUR

; 1928 : 	    val = xmlSaveUri(ref);

	mov	edx, DWORD PTR _ref$[ebp]
	push	edx
	call	_xmlSaveUri
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax
$LN21@xmlBuildUR:

; 1929 : 	goto done;

	jmp	$done$74
$LN20@xmlBuildUR:

; 1930 :     }
; 1931 :     if (ref == NULL) {

	cmp	DWORD PTR _ref$[ebp], 0
	jne	SHORT $LN22@xmlBuildUR

; 1932 : 	/*
; 1933 : 	 * the base fragment must be ignored
; 1934 : 	 */
; 1935 : 	if (bas->fragment != NULL) {

	mov	eax, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN23@xmlBuildUR

; 1936 : 	    xmlFree(bas->fragment);

	mov	esi, esp
	mov	ecx, DWORD PTR _bas$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1937 : 	    bas->fragment = NULL;

	mov	eax, DWORD PTR _bas$[ebp]
	mov	DWORD PTR [eax+32], 0
$LN23@xmlBuildUR:

; 1938 : 	}
; 1939 : 	val = xmlSaveUri(bas);

	mov	ecx, DWORD PTR _bas$[ebp]
	push	ecx
	call	_xmlSaveUri
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 1940 : 	goto done;

	jmp	$done$74
$LN22@xmlBuildUR:

; 1941 :     }
; 1942 : 
; 1943 :     /*
; 1944 :      * 2) If the path component is empty and the scheme, authority, and
; 1945 :      *    query components are undefined, then it is a reference to the
; 1946 :      *    current document and we are done.  Otherwise, the reference URI's
; 1947 :      *    query and fragment components are defined as found (or not found)
; 1948 :      *    within the URI reference and not inherited from the base URI.
; 1949 :      *
; 1950 :      *    NOTE that in modern browsers, the parsing differs from the above
; 1951 :      *    in the following aspect:  the query component is allowed to be
; 1952 :      *    defined while still treating this as a reference to the current
; 1953 :      *    document.
; 1954 :      */
; 1955 :     res = xmlCreateURI();

	call	_xmlCreateURI
	mov	DWORD PTR _res$[ebp], eax

; 1956 :     if (res == NULL)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN24@xmlBuildUR

; 1957 : 	goto done;

	jmp	$done$74
$LN24@xmlBuildUR:

; 1958 :     if ((ref->scheme == NULL) && (ref->path == NULL) &&

	mov	edx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	$LN25@xmlBuildUR
	mov	eax, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	$LN25@xmlBuildUR
	mov	ecx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	$LN25@xmlBuildUR
	mov	edx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	$LN25@xmlBuildUR

; 1959 : 	((ref->authority == NULL) && (ref->server == NULL))) {
; 1960 : 	if (bas->scheme != NULL)

	mov	eax, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN26@xmlBuildUR

; 1961 : 	    res->scheme = xmlMemStrdup(bas->scheme);

	mov	esi, esp
	mov	ecx, DWORD PTR _bas$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [ecx], eax
$LN26@xmlBuildUR:

; 1962 : 	if (bas->authority != NULL)

	mov	edx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN27@xmlBuildUR

; 1963 : 	    res->authority = xmlMemStrdup(bas->authority);

	mov	esi, esp
	mov	eax, DWORD PTR _bas$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN28@xmlBuildUR
$LN27@xmlBuildUR:

; 1964 : 	else if ((bas->server != NULL) || (bas->port == -1)) {

	mov	eax, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN30@xmlBuildUR
	mov	ecx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [ecx+20], -1
	jne	SHORT $LN28@xmlBuildUR
$LN30@xmlBuildUR:

; 1965 : 	    if (bas->server != NULL)

	mov	edx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN31@xmlBuildUR

; 1966 : 		res->server = xmlMemStrdup(bas->server);

	mov	esi, esp
	mov	eax, DWORD PTR _bas$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN31@xmlBuildUR:

; 1967 : 	    if (bas->user != NULL)

	mov	eax, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN32@xmlBuildUR

; 1968 : 		res->user = xmlMemStrdup(bas->user);

	mov	esi, esp
	mov	ecx, DWORD PTR _bas$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN32@xmlBuildUR:

; 1969 : 	    res->port = bas->port;

	mov	edx, DWORD PTR _res$[ebp]
	mov	eax, DWORD PTR _bas$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
$LN28@xmlBuildUR:

; 1970 : 	}
; 1971 : 	if (bas->path != NULL)

	mov	edx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN33@xmlBuildUR

; 1972 : 	    res->path = xmlMemStrdup(bas->path);

	mov	esi, esp
	mov	eax, DWORD PTR _bas$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+24], eax
$LN33@xmlBuildUR:

; 1973 : 	if (ref->query_raw != NULL)

	mov	eax, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN34@xmlBuildUR

; 1974 : 	    res->query_raw = xmlMemStrdup (ref->query_raw);

	mov	esi, esp
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [ecx+40], eax
	jmp	SHORT $LN35@xmlBuildUR
$LN34@xmlBuildUR:

; 1975 : 	else if (ref->query != NULL)

	mov	edx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN36@xmlBuildUR

; 1976 : 	    res->query = xmlMemStrdup(ref->query);

	mov	esi, esp
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+28], eax
	jmp	SHORT $LN35@xmlBuildUR
$LN36@xmlBuildUR:

; 1977 : 	else if (bas->query_raw != NULL)

	mov	eax, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN38@xmlBuildUR

; 1978 : 	    res->query_raw = xmlMemStrdup(bas->query_raw);

	mov	esi, esp
	mov	ecx, DWORD PTR _bas$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [ecx+40], eax
	jmp	SHORT $LN35@xmlBuildUR
$LN38@xmlBuildUR:

; 1979 : 	else if (bas->query != NULL)

	mov	edx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN35@xmlBuildUR

; 1980 : 	    res->query = xmlMemStrdup(bas->query);

	mov	esi, esp
	mov	eax, DWORD PTR _bas$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+28], eax
$LN35@xmlBuildUR:

; 1981 : 	if (ref->fragment != NULL)

	mov	eax, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN41@xmlBuildUR

; 1982 : 	    res->fragment = xmlMemStrdup(ref->fragment);

	mov	esi, esp
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [ecx+32], eax
$LN41@xmlBuildUR:

; 1983 : 	goto step_7;

	jmp	$step_7$75
$LN25@xmlBuildUR:

; 1984 :     }
; 1985 : 
; 1986 :     /*
; 1987 :      * 3) If the scheme component is defined, indicating that the reference
; 1988 :      *    starts with a scheme name, then the reference is interpreted as an
; 1989 :      *    absolute URI and we are done.  Otherwise, the reference URI's
; 1990 :      *    scheme is inherited from the base URI's scheme component.
; 1991 :      */
; 1992 :     if (ref->scheme != NULL) {

	mov	edx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN42@xmlBuildUR

; 1993 : 	val = xmlSaveUri(ref);

	mov	eax, DWORD PTR _ref$[ebp]
	push	eax
	call	_xmlSaveUri
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax

; 1994 : 	goto done;

	jmp	$done$74
$LN42@xmlBuildUR:

; 1995 :     }
; 1996 :     if (bas->scheme != NULL)

	mov	ecx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN43@xmlBuildUR

; 1997 : 	res->scheme = xmlMemStrdup(bas->scheme);

	mov	esi, esp
	mov	edx, DWORD PTR _bas$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [ecx], eax
$LN43@xmlBuildUR:

; 1998 : 
; 1999 :     if (ref->query_raw != NULL)

	mov	edx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN44@xmlBuildUR

; 2000 : 	res->query_raw = xmlMemStrdup(ref->query_raw);

	mov	esi, esp
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+40], eax
	jmp	SHORT $LN45@xmlBuildUR
$LN44@xmlBuildUR:

; 2001 :     else if (ref->query != NULL)

	mov	eax, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN45@xmlBuildUR

; 2002 : 	res->query = xmlMemStrdup(ref->query);

	mov	esi, esp
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [ecx+28], eax
$LN45@xmlBuildUR:

; 2003 :     if (ref->fragment != NULL)

	mov	edx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN47@xmlBuildUR

; 2004 : 	res->fragment = xmlMemStrdup(ref->fragment);

	mov	esi, esp
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN47@xmlBuildUR:

; 2005 : 
; 2006 :     /*
; 2007 :      * 4) If the authority component is defined, then the reference is a
; 2008 :      *    network-path and we skip to step 7.  Otherwise, the reference
; 2009 :      *    URI's authority is inherited from the base URI's authority
; 2010 :      *    component, which will also be undefined if the URI scheme does not
; 2011 :      *    use an authority component.
; 2012 :      */
; 2013 :     if ((ref->authority != NULL) || (ref->server != NULL)) {

	mov	eax, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN49@xmlBuildUR
	mov	ecx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	$LN48@xmlBuildUR
$LN49@xmlBuildUR:

; 2014 : 	if (ref->authority != NULL)

	mov	edx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN50@xmlBuildUR

; 2015 : 	    res->authority = xmlMemStrdup(ref->authority);

	mov	esi, esp
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN51@xmlBuildUR
$LN50@xmlBuildUR:

; 2016 : 	else {
; 2017 : 	    res->server = xmlMemStrdup(ref->server);

	mov	esi, esp
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+12], eax

; 2018 : 	    if (ref->user != NULL)

	mov	eax, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN52@xmlBuildUR

; 2019 : 		res->user = xmlMemStrdup(ref->user);

	mov	esi, esp
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN52@xmlBuildUR:

; 2020 :             res->port = ref->port;

	mov	edx, DWORD PTR _res$[ebp]
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
$LN51@xmlBuildUR:

; 2021 : 	}
; 2022 : 	if (ref->path != NULL)

	mov	edx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN53@xmlBuildUR

; 2023 : 	    res->path = xmlMemStrdup(ref->path);

	mov	esi, esp
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+24], eax
$LN53@xmlBuildUR:

; 2024 : 	goto step_7;

	jmp	$step_7$75
$LN48@xmlBuildUR:

; 2025 :     }
; 2026 :     if (bas->authority != NULL)

	mov	eax, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN54@xmlBuildUR

; 2027 : 	res->authority = xmlMemStrdup(bas->authority);

	mov	esi, esp
	mov	ecx, DWORD PTR _bas$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN55@xmlBuildUR
$LN54@xmlBuildUR:

; 2028 :     else if ((bas->server != NULL) || (bas->port == -1)) {

	mov	edx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN57@xmlBuildUR
	mov	eax, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [eax+20], -1
	jne	SHORT $LN55@xmlBuildUR
$LN57@xmlBuildUR:

; 2029 : 	if (bas->server != NULL)

	mov	ecx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN58@xmlBuildUR

; 2030 : 	    res->server = xmlMemStrdup(bas->server);

	mov	esi, esp
	mov	edx, DWORD PTR _bas$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN58@xmlBuildUR:

; 2031 : 	if (bas->user != NULL)

	mov	edx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN59@xmlBuildUR

; 2032 : 	    res->user = xmlMemStrdup(bas->user);

	mov	esi, esp
	mov	eax, DWORD PTR _bas$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN59@xmlBuildUR:

; 2033 : 	res->port = bas->port;

	mov	eax, DWORD PTR _res$[ebp]
	mov	ecx, DWORD PTR _bas$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
$LN55@xmlBuildUR:

; 2034 :     }
; 2035 : 
; 2036 :     /*
; 2037 :      * 5) If the path component begins with a slash character ("/"), then
; 2038 :      *    the reference is an absolute-path and we skip to step 7.
; 2039 :      */
; 2040 :     if ((ref->path != NULL) && (ref->path[0] == '/')) {

	mov	eax, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN60@xmlBuildUR
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN60@xmlBuildUR

; 2041 : 	res->path = xmlMemStrdup(ref->path);

	mov	esi, esp
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+24], eax

; 2042 : 	goto step_7;

	jmp	$step_7$75
$LN60@xmlBuildUR:

; 2043 :     }
; 2044 : 
; 2045 : 
; 2046 :     /*
; 2047 :      * 6) If this step is reached, then we are resolving a relative-path
; 2048 :      *    reference.  The relative path needs to be merged with the base
; 2049 :      *    URI's path.  Although there are many ways to do this, we will
; 2050 :      *    describe a simple method using a separate string buffer.
; 2051 :      *
; 2052 :      * Allocate a buffer large enough for the result string.
; 2053 :      */
; 2054 :     len = 2; /* extra / and 0 */

	mov	DWORD PTR _len$[ebp], 2

; 2055 :     if (ref->path != NULL)

	mov	eax, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN61@xmlBuildUR

; 2056 : 	len += strlen(ref->path);

	mov	ecx, DWORD PTR _ref$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR tv612[ebp], edx
	mov	eax, DWORD PTR tv612[ebp]
	add	eax, 1
	mov	DWORD PTR tv615[ebp], eax
$LL72@xmlBuildUR:
	mov	ecx, DWORD PTR tv612[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv618[ebp], dl
	add	DWORD PTR tv612[ebp], 1
	cmp	BYTE PTR tv618[ebp], 0
	jne	SHORT $LL72@xmlBuildUR
	mov	eax, DWORD PTR tv612[ebp]
	sub	eax, DWORD PTR tv615[ebp]
	mov	DWORD PTR tv300[ebp], eax
	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, DWORD PTR tv300[ebp]
	mov	DWORD PTR _len$[ebp], ecx
$LN61@xmlBuildUR:

; 2057 :     if (bas->path != NULL)

	mov	edx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN62@xmlBuildUR

; 2058 : 	len += strlen(bas->path);

	mov	eax, DWORD PTR _bas$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR tv626[ebp], ecx
	mov	edx, DWORD PTR tv626[ebp]
	add	edx, 1
	mov	DWORD PTR tv629[ebp], edx
$LL73@xmlBuildUR:
	mov	eax, DWORD PTR tv626[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv632[ebp], cl
	add	DWORD PTR tv626[ebp], 1
	cmp	BYTE PTR tv632[ebp], 0
	jne	SHORT $LL73@xmlBuildUR
	mov	edx, DWORD PTR tv626[ebp]
	sub	edx, DWORD PTR tv629[ebp]
	mov	DWORD PTR tv307[ebp], edx
	mov	eax, DWORD PTR _len$[ebp]
	add	eax, DWORD PTR tv307[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN62@xmlBuildUR:

; 2059 :     res->path = (char *) xmlMallocAtomic(len);

	mov	esi, esp
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _res$[ebp]
	mov	DWORD PTR [edx+24], eax

; 2060 :     if (res->path == NULL) {

	mov	eax, DWORD PTR _res$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN63@xmlBuildUR

; 2061 :         xmlURIErrMemory("resolving URI against base\n");

	push	OFFSET ??_C@_0BM@EJBDEPKK@resolving?5URI?5against?5base?6@
	call	_xmlURIErrMemory
	add	esp, 4

; 2062 : 	goto done;

	jmp	$done$74
$LN63@xmlBuildUR:

; 2063 :     }
; 2064 :     res->path[0] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _res$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	BYTE PTR [edx+ecx], 0

; 2065 : 
; 2066 :     /*
; 2067 :      * a) All but the last segment of the base URI's path component is
; 2068 :      *    copied to the buffer.  In other words, any characters after the
; 2069 :      *    last (right-most) slash character, if any, are excluded.
; 2070 :      */
; 2071 :     cur = 0;

	mov	DWORD PTR _cur$[ebp], 0

; 2072 :     out = 0;

	mov	DWORD PTR _out$[ebp], 0

; 2073 :     if (bas->path != NULL) {

	mov	edx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	$LN64@xmlBuildUR
$LN2@xmlBuildUR:

; 2074 : 	while (bas->path[cur] != 0) {

	mov	eax, DWORD PTR _bas$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	je	SHORT $LN64@xmlBuildUR
$LN4@xmlBuildUR:

; 2075 : 	    while ((bas->path[cur] != 0) && (bas->path[cur] != '/'))

	mov	ecx, DWORD PTR _bas$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	test	ecx, ecx
	je	SHORT $LN5@xmlBuildUR
	mov	edx, DWORD PTR _bas$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [eax+ecx]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN5@xmlBuildUR

; 2076 : 		cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN4@xmlBuildUR
$LN5@xmlBuildUR:

; 2077 : 	    if (bas->path[cur] == 0)

	mov	ecx, DWORD PTR _bas$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	test	ecx, ecx
	jne	SHORT $LN65@xmlBuildUR

; 2078 : 		break;

	jmp	SHORT $LN64@xmlBuildUR
$LN65@xmlBuildUR:

; 2079 : 
; 2080 : 	    cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
$LN6@xmlBuildUR:

; 2081 : 	    while (out < cur) {

	mov	eax, DWORD PTR _out$[ebp]
	cmp	eax, DWORD PTR _cur$[ebp]
	jge	SHORT $LN7@xmlBuildUR

; 2082 : 		res->path[out] = bas->path[out];

	mov	ecx, DWORD PTR _bas$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _res$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [edx+esi]
	mov	BYTE PTR [ecx+eax], dl

; 2083 : 		out++;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 2084 : 	    }

	jmp	SHORT $LN6@xmlBuildUR
$LN7@xmlBuildUR:

; 2085 : 	}

	jmp	$LN2@xmlBuildUR
$LN64@xmlBuildUR:

; 2086 :     }
; 2087 :     res->path[out] = 0;

	mov	ecx, DWORD PTR _res$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], 0

; 2088 : 
; 2089 :     /*
; 2090 :      * b) The reference's path component is appended to the buffer
; 2091 :      *    string.
; 2092 :      */
; 2093 :     if (ref->path != NULL && ref->path[0] != 0) {

	mov	ecx, DWORD PTR _ref$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN66@xmlBuildUR
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	movsx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN66@xmlBuildUR

; 2094 : 	indx = 0;

	mov	DWORD PTR _indx$[ebp], 0

; 2095 : 	/*
; 2096 : 	 * Ensure the path includes a '/'
; 2097 : 	 */
; 2098 : 	if ((out == 0) && (bas->server != NULL))

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN8@xmlBuildUR
	mov	ecx, DWORD PTR _bas$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN8@xmlBuildUR

; 2099 : 	    res->path[out++] = '/';

	mov	edx, DWORD PTR _res$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], 47			; 0000002fH
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
$LN8@xmlBuildUR:

; 2100 : 	while (ref->path[indx] != 0) {

	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _indx$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	je	SHORT $LN66@xmlBuildUR

; 2101 : 	    res->path[out++] = ref->path[indx++];

	mov	ecx, DWORD PTR _ref$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _res$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _indx$[ebp]
	mov	dl, BYTE PTR [edx+esi]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _indx$[ebp]
	add	ecx, 1
	mov	DWORD PTR _indx$[ebp], ecx

; 2102 : 	}

	jmp	SHORT $LN8@xmlBuildUR
$LN66@xmlBuildUR:

; 2103 :     }
; 2104 :     res->path[out] = 0;

	mov	edx, DWORD PTR _res$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 2105 : 
; 2106 :     /*
; 2107 :      * Steps c) to h) are really path normalization steps
; 2108 :      */
; 2109 :     xmlNormalizeURIPath(res->path);

	mov	edx, DWORD PTR _res$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_xmlNormalizeURIPath
	add	esp, 4
$step_7$75:

; 2110 : 
; 2111 : step_7:
; 2112 : 
; 2113 :     /*
; 2114 :      * 7) The resulting URI components, including any inherited from the
; 2115 :      *    base URI, are recombined to give the absolute form of the URI
; 2116 :      *    reference.
; 2117 :      */
; 2118 :     val = xmlSaveUri(res);

	mov	ecx, DWORD PTR _res$[ebp]
	push	ecx
	call	_xmlSaveUri
	add	esp, 4
	mov	DWORD PTR _val$[ebp], eax
$done$74:

; 2119 : 
; 2120 : done:
; 2121 :     if (ref != NULL)

	cmp	DWORD PTR _ref$[ebp], 0
	je	SHORT $LN68@xmlBuildUR

; 2122 : 	xmlFreeURI(ref);

	mov	edx, DWORD PTR _ref$[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4
$LN68@xmlBuildUR:

; 2123 :     if (bas != NULL)

	cmp	DWORD PTR _bas$[ebp], 0
	je	SHORT $LN69@xmlBuildUR

; 2124 : 	xmlFreeURI(bas);

	mov	eax, DWORD PTR _bas$[ebp]
	push	eax
	call	_xmlFreeURI
	add	esp, 4
$LN69@xmlBuildUR:

; 2125 :     if (res != NULL)

	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $LN70@xmlBuildUR

; 2126 : 	xmlFreeURI(res);

	mov	ecx, DWORD PTR _res$[ebp]
	push	ecx
	call	_xmlFreeURI
	add	esp, 4
$LN70@xmlBuildUR:

; 2127 :     return(val);

	mov	eax, DWORD PTR _val$[ebp]

; 2128 : }

	pop	edi
	pop	esi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlBuildURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\uri.c
;	COMDAT _xmlCreateURI
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_xmlCreateURI PROC					; COMDAT

; 1012 : xmlCreateURI(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __0B912F28_uri@c
	call	@__CheckForDebuggerJustMyCode@4

; 1013 :     xmlURIPtr ret;
; 1014 : 
; 1015 :     ret = (xmlURIPtr) xmlMalloc(sizeof(xmlURI));

	mov	esi, esp
	push	44					; 0000002cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 1016 :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlCreateU

; 1017 :         xmlURIErrMemory("creating URI structure\n");

	push	OFFSET ??_C@_0BI@NJMLMHOE@creating?5URI?5structure?6@
	call	_xmlURIErrMemory
	add	esp, 4

; 1018 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCreateU
$LN2@xmlCreateU:

; 1019 :     }
; 1020 :     memset(ret, 0, sizeof(xmlURI));

	push	44					; 0000002cH
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1021 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCreateU:

; 1022 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCreateURI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Stream$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
