; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlcatalog.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__6F93E186_xmlcatalog@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	_main
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_02LLMPMKNF@?$DO?5@			; `string'
PUBLIC	??_C@_04MKNBDEPB@exit@				; `string'
PUBLIC	??_C@_04KNNLNNGO@quit@				; `string'
PUBLIC	??_C@_03MDONDFG@bye@				; `string'
PUBLIC	??_C@_06EOMAMIIF@public@			; `string'
PUBLIC	??_C@_0BN@DCAIANKH@public?5requires?51?5arguments?6@ ; `string'
PUBLIC	??_C@_0BI@FFIBJMM@No?5entry?5for?5PUBLIC?5?$CFs?6@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_06FHFOAHML@system@			; `string'
PUBLIC	??_C@_0BN@OGHNALCF@system?5requires?51?5arguments?6@ ; `string'
PUBLIC	??_C@_0BI@GPMJOIOL@No?5entry?5for?5SYSTEM?5?$CFs?6@ ; `string'
PUBLIC	??_C@_03BDGOHNNK@add@				; `string'
PUBLIC	??_C@_0BP@EHJKBIMI@add?5requires?52?5or?53?5arguments?6@ ; `string'
PUBLIC	??_C@_0BE@JELHPCAG@add?5command?5failed?6@	; `string'
PUBLIC	??_C@_03ONKLGNNH@del@				; `string'
PUBLIC	??_C@_0BA@PNPKCAGJ@del?5requires?51?6@		; `string'
PUBLIC	??_C@_0BE@HPIOAMEN@del?5command?5failed?6@	; `string'
PUBLIC	??_C@_07CPEIJHB@resolve@			; `string'
PUBLIC	??_C@_0BO@FIFGKLE@resolve?5requires?52?5arguments?6@ ; `string'
PUBLIC	??_C@_0CD@FLKMEIPD@Resolver?5failed?5to?5find?5an?5answ@ ; `string'
PUBLIC	??_C@_04GGLOKIEE@dump@				; `string'
PUBLIC	??_C@_0BH@GHHAHJGB@dump?5has?5no?5arguments?6@	; `string'
PUBLIC	??_C@_05GFCDIDHO@debug@				; `string'
PUBLIC	??_C@_0BI@DPNEIFGM@debug?5has?5no?5arguments?6@	; `string'
PUBLIC	??_C@_05PMBAOCDH@quiet@				; `string'
PUBLIC	??_C@_0BI@CNFOPICG@quiet?5has?5no?5arguments?6@	; `string'
PUBLIC	??_C@_04PCJFHION@help@				; `string'
PUBLIC	??_C@_0BJ@LCFAJBIE@Unrecognized?5command?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BF@CNPPMLEL@Commands?5available?3?6@	; `string'
PUBLIC	??_C@_0DD@BNENJECC@?7public?5PublicID?3?5make?5a?5PUBLIC@ ; `string'
PUBLIC	??_C@_0DD@BFGOGPGB@?7system?5SystemID?3?5make?5a?5SYSTEM@ ; `string'
PUBLIC	??_C@_0DH@FFOBCHBO@?7resolve?5PublicID?5SystemID?3?5do?5@ ; `string'
PUBLIC	??_C@_0CN@PJBHDJPC@?7add?5?8type?8?5?8orig?8?5?8replace?8?5?3?5@ ; `string'
PUBLIC	??_C@_0BP@BCHNOEJB@?7del?5?8values?8?5?3?5remove?5values?6@ ; `string'
PUBLIC	??_C@_0CI@ECEJDHEJ@?7dump?3?5print?5the?5current?5catalo@ ; `string'
PUBLIC	??_C@_0CG@OIIIIIDP@?7debug?3?5increase?5the?5verbosity?5@ ; `string'
PUBLIC	??_C@_0CG@JNOLBMIB@?7quiet?3?5decrease?5the?5verbosity?5@ ; `string'
PUBLIC	??_C@_0BI@GHCHHEEB@?7exit?3?5?5quit?5the?5shell?6@ ; `string'
PUBLIC	??_C@_0BJG@IFOIFJDI@Usage?5?3?5?$CFs?5?$FLoptions?$FN?5catalogfil@ ; `string'
PUBLIC	??_C@_0BDI@HBPONJIE@?7?9?9del?5?8values?8?5?3?5remove?5values@ ; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_08FBJJFDKJ@?9verbose@			; `string'
PUBLIC	??_C@_02EJEOCNCO@?9v@				; `string'
PUBLIC	??_C@_09OOLJKHBB@?9?9verbose@			; `string'
PUBLIC	??_C@_06JPEJAHHH@?9noout@			; `string'
PUBLIC	??_C@_07FHEHAOH@?9?9noout@			; `string'
PUBLIC	??_C@_06GMHACKOA@?9shell@			; `string'
PUBLIC	??_C@_07PGENFNHA@?9?9shell@			; `string'
PUBLIC	??_C@_05GEMLGBMJ@?9sgml@			; `string'
PUBLIC	??_C@_06OGAPEHEI@?9?9sgml@			; `string'
PUBLIC	??_C@_07JNCAJKJG@?9create@			; `string'
PUBLIC	??_C@_08GNLFDEKF@?9?9create@			; `string'
PUBLIC	??_C@_08BNGAGJEJ@?9convert@			; `string'
PUBLIC	??_C@_09KCEAJNPB@?9?9convert@			; `string'
PUBLIC	??_C@_0BB@KANDGBAO@?9no?9super?9update@		; `string'
PUBLIC	??_C@_0BC@KAMKCICF@?9?9no?9super?9update@	; `string'
PUBLIC	??_C@_04MNFJLOGO@?9add@				; `string'
PUBLIC	??_C@_05BILPODI@?9?9add@			; `string'
PUBLIC	??_C@_04DDJMKOGD@?9del@				; `string'
PUBLIC	??_C@_05PPEOOODF@?9?9del@			; `string'
PUBLIC	??_C@_0BD@PDLGMOIG@Unknown?5option?5?$CFs?6@	; `string'
PUBLIC	??_C@_0CL@LMPCJLGA@No?5catalog?5entry?5specified?5to?5r@ ; `string'
PUBLIC	??_C@_07MFFOOIHD@catalog@			; `string'
PUBLIC	??_C@_07DIADFEPH@CATALOG@			; `string'
PUBLIC	??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@	; `string'
PUBLIC	??_C@_0CA@DECJMEJL@Failed?5to?5remove?5entry?5from?5?$CFs?6@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@ ; `string'
PUBLIC	??_C@_0BL@MKGCOLNC@Failed?5to?5remove?5entry?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BF@IAFAHEGC@No?5entry?5for?5URI?5?$CFs?6@ ; `string'
EXTRN	_xmlCheckVersion:PROC
EXTRN	__imp__remove:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fgets:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_xmlMemoryDump:PROC
EXTRN	_xmlCleanupParser:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlNewCatalog:PROC
EXTRN	_xmlLoadSGMLSuperCatalog:PROC
EXTRN	_xmlACatalogAdd:PROC
EXTRN	_xmlACatalogRemove:PROC
EXTRN	_xmlACatalogDump:PROC
EXTRN	_xmlCatalogIsEmpty:PROC
EXTRN	_xmlInitializeCatalog:PROC
EXTRN	_xmlLoadCatalog:PROC
EXTRN	_xmlCatalogDump:PROC
EXTRN	_xmlCatalogResolve:PROC
EXTRN	_xmlCatalogResolveSystem:PROC
EXTRN	_xmlCatalogResolvePublic:PROC
EXTRN	_xmlCatalogResolveURI:PROC
EXTRN	_xmlCatalogAdd:PROC
EXTRN	_xmlCatalogRemove:PROC
EXTRN	_xmlCatalogConvert:PROC
EXTRN	_xmlCatalogSetDebug:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__xmlFree:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_shell	DD	01H DUP (?)
_sgml	DD	01H DUP (?)
_noout	DD	01H DUP (?)
_create	DD	01H DUP (?)
_add	DD	01H DUP (?)
_del	DD	01H DUP (?)
_convert DD	01H DUP (?)
_no_super_update DD 01H DUP (?)
_verbose DD	01H DUP (?)
_filename DD	01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BF@IAFAHEGC@No?5entry?5for?5URI?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@IAFAHEGC@No?5entry?5for?5URI?5?$CFs?6@ DB 'No entry for URI %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MKGCOLNC@Failed?5to?5remove?5entry?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@MKGCOLNC@Failed?5to?5remove?5entry?5?$CFs?6@ DB 'Failed to remo'
	DB	've entry %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@
CONST	SEGMENT
??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@ DB 'could not '
	DB	'open %s for saving', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DECJMEJL@Failed?5to?5remove?5entry?5from?5?$CFs?6@
CONST	SEGMENT
??_C@_0CA@DECJMEJL@Failed?5to?5remove?5entry?5from?5?$CFs?6@ DB 'Failed t'
	DB	'o remove entry from %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
CONST	SEGMENT
??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@ DB '/etc/sgml/catalog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIADFEPH@CATALOG@
CONST	SEGMENT
??_C@_07DIADFEPH@CATALOG@ DB 'CATALOG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFFOOIHD@catalog@
CONST	SEGMENT
??_C@_07MFFOOIHD@catalog@ DB 'catalog', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LMPCJLGA@No?5catalog?5entry?5specified?5to?5r@
CONST	SEGMENT
??_C@_0CL@LMPCJLGA@No?5catalog?5entry?5specified?5to?5r@ DB 'No catalog e'
	DB	'ntry specified to remove from', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PDLGMOIG@Unknown?5option?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@PDLGMOIG@Unknown?5option?5?$CFs?6@ DB 'Unknown option %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEOOODF@?9?9del@
CONST	SEGMENT
??_C@_05PPEOOODF@?9?9del@ DB '--del', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DDJMKOGD@?9del@
CONST	SEGMENT
??_C@_04DDJMKOGD@?9del@ DB '-del', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BILPODI@?9?9add@
CONST	SEGMENT
??_C@_05BILPODI@?9?9add@ DB '--add', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MNFJLOGO@?9add@
CONST	SEGMENT
??_C@_04MNFJLOGO@?9add@ DB '-add', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KAMKCICF@?9?9no?9super?9update@
CONST	SEGMENT
??_C@_0BC@KAMKCICF@?9?9no?9super?9update@ DB '--no-super-update', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KANDGBAO@?9no?9super?9update@
CONST	SEGMENT
??_C@_0BB@KANDGBAO@?9no?9super?9update@ DB '-no-super-update', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KCEAJNPB@?9?9convert@
CONST	SEGMENT
??_C@_09KCEAJNPB@?9?9convert@ DB '--convert', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNGAGJEJ@?9convert@
CONST	SEGMENT
??_C@_08BNGAGJEJ@?9convert@ DB '-convert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GNLFDEKF@?9?9create@
CONST	SEGMENT
??_C@_08GNLFDEKF@?9?9create@ DB '--create', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNCAJKJG@?9create@
CONST	SEGMENT
??_C@_07JNCAJKJG@?9create@ DB '-create', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OGAPEHEI@?9?9sgml@
CONST	SEGMENT
??_C@_06OGAPEHEI@?9?9sgml@ DB '--sgml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GEMLGBMJ@?9sgml@
CONST	SEGMENT
??_C@_05GEMLGBMJ@?9sgml@ DB '-sgml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PGENFNHA@?9?9shell@
CONST	SEGMENT
??_C@_07PGENFNHA@?9?9shell@ DB '--shell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GMHACKOA@?9shell@
CONST	SEGMENT
??_C@_06GMHACKOA@?9shell@ DB '-shell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FHEHAOH@?9?9noout@
CONST	SEGMENT
??_C@_07FHEHAOH@?9?9noout@ DB '--noout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JPEJAHHH@?9noout@
CONST	SEGMENT
??_C@_06JPEJAHHH@?9noout@ DB '-noout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OOLJKHBB@?9?9verbose@
CONST	SEGMENT
??_C@_09OOLJKHBB@?9?9verbose@ DB '--verbose', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02EJEOCNCO@?9v@
CONST	SEGMENT
??_C@_02EJEOCNCO@?9v@ DB '-v', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FBJJFDKJ@?9verbose@
CONST	SEGMENT
??_C@_08FBJJFDKJ@?9verbose@ DB '-verbose', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDI@HBPONJIE@?7?9?9del?5?8values?8?5?3?5remove?5values@
CONST	SEGMENT
??_C@_0BDI@HBPONJIE@?7?9?9del?5?8values?8?5?3?5remove?5values@ DB 09H, '-'
	DB	'-del ''values'' : remove values', 0aH, 09H, '--noout: avoid d'
	DB	'umping the result on stdout', 0aH, 09H, '         used with -'
	DB	'-add or --del, it saves the catalog changes', 0aH, 09H, '    '
	DB	'     and with --sgml it automatically updates the super catal'
	DB	'og', 0aH, 09H, '--no-super-update: do not update the SGML sup'
	DB	'er catalog', 0aH, 09H, '-v --verbose : provide debug informat'
	DB	'ions', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJG@IFOIFJDI@Usage?5?3?5?$CFs?5?$FLoptions?$FN?5catalogfil@
CONST	SEGMENT
??_C@_0BJG@IFOIFJDI@Usage?5?3?5?$CFs?5?$FLoptions?$FN?5catalogfil@ DB 'Us'
	DB	'age : %s [options] catalogfile entities...', 0aH, 09H, 'Parse'
	DB	' the catalog file (void specification possibly expressed as "'
	DB	'"', 0aH, 09H, 'appoints the default system one) and query it '
	DB	'for the entities', 0aH, 09H, '--sgml : handle SGML Super cata'
	DB	'logs for --add and --del', 0aH, 09H, '--shell : run a shell a'
	DB	'llowing interactive queries', 0aH, 09H, '--create : create a '
	DB	'new catalog', 0aH, 09H, '--add ''type'' ''orig'' ''replace'' '
	DB	': add an XML entry', 0aH, 09H, '--add ''entry'' : add an SGML'
	DB	' entry', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GHCHHEEB@?7exit?3?5?5quit?5the?5shell?6@
CONST	SEGMENT
??_C@_0BI@GHCHHEEB@?7exit?3?5?5quit?5the?5shell?6@ DB 09H, 'exit:  quit t'
	DB	'he shell', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JNOLBMIB@?7quiet?3?5decrease?5the?5verbosity?5@
CONST	SEGMENT
??_C@_0CG@JNOLBMIB@?7quiet?3?5decrease?5the?5verbosity?5@ DB 09H, 'quiet:'
	DB	' decrease the verbosity level', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OIIIIIDP@?7debug?3?5increase?5the?5verbosity?5@
CONST	SEGMENT
??_C@_0CG@OIIIIIDP@?7debug?3?5increase?5the?5verbosity?5@ DB 09H, 'debug:'
	DB	' increase the verbosity level', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@ECEJDHEJ@?7dump?3?5print?5the?5current?5catalo@
CONST	SEGMENT
??_C@_0CI@ECEJDHEJ@?7dump?3?5print?5the?5current?5catalo@ DB 09H, 'dump: '
	DB	'print the current catalog state', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BCHNOEJB@?7del?5?8values?8?5?3?5remove?5values?6@
CONST	SEGMENT
??_C@_0BP@BCHNOEJB@?7del?5?8values?8?5?3?5remove?5values?6@ DB 09H, 'del '
	DB	'''values'' : remove values', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PJBHDJPC@?7add?5?8type?8?5?8orig?8?5?8replace?8?5?3?5@
CONST	SEGMENT
??_C@_0CN@PJBHDJPC@?7add?5?8type?8?5?8orig?8?5?8replace?8?5?3?5@ DB 09H, 'a'
	DB	'dd ''type'' ''orig'' ''replace'' : add an entry', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FFOBCHBO@?7resolve?5PublicID?5SystemID?3?5do?5@
CONST	SEGMENT
??_C@_0DH@FFOBCHBO@?7resolve?5PublicID?5SystemID?3?5do?5@ DB 09H, 'resolv'
	DB	'e PublicID SystemID: do a full resolver lookup', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BFGOGPGB@?7system?5SystemID?3?5make?5a?5SYSTEM@
CONST	SEGMENT
??_C@_0DD@BFGOGPGB@?7system?5SystemID?3?5make?5a?5SYSTEM@ DB 09H, 'system'
	DB	' SystemID: make a SYSTEM identifier lookup', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BNENJECC@?7public?5PublicID?3?5make?5a?5PUBLIC@
CONST	SEGMENT
??_C@_0DD@BNENJECC@?7public?5PublicID?3?5make?5a?5PUBLIC@ DB 09H, 'public'
	DB	' PublicID: make a PUBLIC identifier lookup', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CNPPMLEL@Commands?5available?3?6@
CONST	SEGMENT
??_C@_0BF@CNPPMLEL@Commands?5available?3?6@ DB 'Commands available:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LCFAJBIE@Unrecognized?5command?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@LCFAJBIE@Unrecognized?5command?5?$CFs?6@ DB 'Unrecognized comma'
	DB	'nd %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help@
CONST	SEGMENT
??_C@_04PCJFHION@help@ DB 'help', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CNFOPICG@quiet?5has?5no?5arguments?6@
CONST	SEGMENT
??_C@_0BI@CNFOPICG@quiet?5has?5no?5arguments?6@ DB 'quiet has no argument'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05PMBAOCDH@quiet@
CONST	SEGMENT
??_C@_05PMBAOCDH@quiet@ DB 'quiet', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DPNEIFGM@debug?5has?5no?5arguments?6@
CONST	SEGMENT
??_C@_0BI@DPNEIFGM@debug?5has?5no?5arguments?6@ DB 'debug has no argument'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFCDIDHO@debug@
CONST	SEGMENT
??_C@_05GFCDIDHO@debug@ DB 'debug', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GHHAHJGB@dump?5has?5no?5arguments?6@
CONST	SEGMENT
??_C@_0BH@GHHAHJGB@dump?5has?5no?5arguments?6@ DB 'dump has no arguments', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04GGLOKIEE@dump@
CONST	SEGMENT
??_C@_04GGLOKIEE@dump@ DB 'dump', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FLKMEIPD@Resolver?5failed?5to?5find?5an?5answ@
CONST	SEGMENT
??_C@_0CD@FLKMEIPD@Resolver?5failed?5to?5find?5an?5answ@ DB 'Resolver fai'
	DB	'led to find an answer', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FIFGKLE@resolve?5requires?52?5arguments?6@
CONST	SEGMENT
??_C@_0BO@FIFGKLE@resolve?5requires?52?5arguments?6@ DB 'resolve requires'
	DB	' 2 arguments', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPEIJHB@resolve@
CONST	SEGMENT
??_C@_07CPEIJHB@resolve@ DB 'resolve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HPIOAMEN@del?5command?5failed?6@
CONST	SEGMENT
??_C@_0BE@HPIOAMEN@del?5command?5failed?6@ DB 'del command failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PNPKCAGJ@del?5requires?51?6@
CONST	SEGMENT
??_C@_0BA@PNPKCAGJ@del?5requires?51?6@ DB 'del requires 1', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03ONKLGNNH@del@
CONST	SEGMENT
??_C@_03ONKLGNNH@del@ DB 'del', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JELHPCAG@add?5command?5failed?6@
CONST	SEGMENT
??_C@_0BE@JELHPCAG@add?5command?5failed?6@ DB 'add command failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EHJKBIMI@add?5requires?52?5or?53?5arguments?6@
CONST	SEGMENT
??_C@_0BP@EHJKBIMI@add?5requires?52?5or?53?5arguments?6@ DB 'add requires'
	DB	' 2 or 3 arguments', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDGOHNNK@add@
CONST	SEGMENT
??_C@_03BDGOHNNK@add@ DB 'add', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GPMJOIOL@No?5entry?5for?5SYSTEM?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@GPMJOIOL@No?5entry?5for?5SYSTEM?5?$CFs?6@ DB 'No entry for SYST'
	DB	'EM %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OGHNALCF@system?5requires?51?5arguments?6@
CONST	SEGMENT
??_C@_0BN@OGHNALCF@system?5requires?51?5arguments?6@ DB 'system requires '
	DB	'1 arguments', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system@
CONST	SEGMENT
??_C@_06FHFOAHML@system@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FFIBJMM@No?5entry?5for?5PUBLIC?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@FFIBJMM@No?5entry?5for?5PUBLIC?5?$CFs?6@ DB 'No entry for PUBLI'
	DB	'C %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DCAIANKH@public?5requires?51?5arguments?6@
CONST	SEGMENT
??_C@_0BN@DCAIANKH@public?5requires?51?5arguments?6@ DB 'public requires '
	DB	'1 arguments', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOMAMIIF@public@
CONST	SEGMENT
??_C@_06EOMAMIIF@public@ DB 'public', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDONDFG@bye@
CONST	SEGMENT
??_C@_03MDONDFG@bye@ DB 'bye', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNNLNNGO@quit@
CONST	SEGMENT
??_C@_04KNNLNNGO@quit@ DB 'quit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit@ DB 'exit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LLMPMKNF@?$DO?5@
CONST	SEGMENT
??_C@_02LLMPMKNF@?$DO?5@ DB '> ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlcatalog.c
;	COMDAT _main
_TEXT	SEGMENT
tv614 = -736						; size = 4
tv1677 = -732						; size = 4
tv1672 = -726						; size = 1
tv1665 = -725						; size = 1
tv1660 = -724						; size = 4
tv1662 = -720						; size = 4
tv607 = -716						; size = 4
tv1654 = -712						; size = 4
tv1649 = -706						; size = 1
tv1642 = -705						; size = 1
tv1637 = -704						; size = 4
tv1639 = -700						; size = 4
tv563 = -696						; size = 4
tv1608 = -692						; size = 4
tv1603 = -686						; size = 1
tv1596 = -685						; size = 1
tv1591 = -684						; size = 4
tv1593 = -680						; size = 4
tv556 = -676						; size = 4
tv1585 = -672						; size = 4
tv1580 = -666						; size = 1
tv1573 = -665						; size = 1
tv1568 = -664						; size = 4
tv1570 = -660						; size = 4
tv440 = -656						; size = 4
tv1485 = -652						; size = 4
tv1480 = -646						; size = 1
tv1473 = -645						; size = 1
tv1468 = -644						; size = 4
tv1470 = -640						; size = 4
tv433 = -636						; size = 4
tv1462 = -632						; size = 4
tv1457 = -626						; size = 1
tv1450 = -625						; size = 1
tv1445 = -624						; size = 4
tv1447 = -620						; size = 4
tv420 = -616						; size = 4
tv1435 = -612						; size = 4
tv1430 = -606						; size = 1
tv1423 = -605						; size = 1
tv1418 = -604						; size = 4
tv1420 = -600						; size = 4
tv413 = -596						; size = 4
tv1412 = -592						; size = 4
tv1407 = -586						; size = 1
tv1400 = -585						; size = 1
tv1395 = -584						; size = 4
tv1397 = -580						; size = 4
tv406 = -576						; size = 4
tv1389 = -572						; size = 4
tv1384 = -566						; size = 1
tv1377 = -565						; size = 1
tv1372 = -564						; size = 4
tv1374 = -560						; size = 4
tv399 = -556						; size = 4
tv1366 = -552						; size = 4
tv1361 = -546						; size = 1
tv1354 = -545						; size = 1
tv1349 = -544						; size = 4
tv1351 = -540						; size = 4
tv386 = -536						; size = 4
tv1340 = -532						; size = 4
tv1335 = -526						; size = 1
tv1328 = -525						; size = 1
tv1323 = -524						; size = 4
tv1325 = -520						; size = 4
tv303 = -516						; size = 4
tv1288 = -512						; size = 4
tv1283 = -506						; size = 1
tv1276 = -505						; size = 1
tv1271 = -504						; size = 4
tv1273 = -500						; size = 4
tv296 = -496						; size = 4
tv1265 = -492						; size = 4
tv1260 = -486						; size = 1
tv1253 = -485						; size = 1
tv1248 = -484						; size = 4
tv1250 = -480						; size = 4
tv286 = -476						; size = 4
tv1240 = -472						; size = 4
tv1235 = -466						; size = 1
tv1228 = -465						; size = 1
tv1223 = -464						; size = 4
tv1225 = -460						; size = 4
tv279 = -456						; size = 4
tv1217 = -452						; size = 4
tv1212 = -446						; size = 1
tv1205 = -445						; size = 1
tv1200 = -444						; size = 4
tv1202 = -440						; size = 4
tv258 = -436						; size = 4
tv1180 = -432						; size = 4
tv1175 = -426						; size = 1
tv1168 = -425						; size = 1
tv1163 = -424						; size = 4
tv1165 = -420						; size = 4
tv251 = -416						; size = 4
tv1157 = -412						; size = 4
tv1152 = -406						; size = 1
tv1145 = -405						; size = 1
tv1140 = -404						; size = 4
tv1142 = -400						; size = 4
tv240 = -396						; size = 4
tv1131 = -392						; size = 4
tv1126 = -386						; size = 1
tv1119 = -385						; size = 1
tv1114 = -384						; size = 4
tv1116 = -380						; size = 4
tv233 = -376						; size = 4
tv1108 = -372						; size = 4
tv1103 = -366						; size = 1
tv1096 = -365						; size = 1
tv1091 = -364						; size = 4
tv1093 = -360						; size = 4
tv225 = -356						; size = 4
tv1084 = -352						; size = 4
tv1079 = -346						; size = 1
tv1072 = -345						; size = 1
tv1067 = -344						; size = 4
tv1069 = -340						; size = 4
tv218 = -336						; size = 4
tv1061 = -332						; size = 4
tv1056 = -326						; size = 1
tv1049 = -325						; size = 1
tv1044 = -324						; size = 4
tv1046 = -320						; size = 4
tv210 = -316						; size = 4
tv1037 = -312						; size = 4
tv1032 = -306						; size = 1
tv1025 = -305						; size = 1
tv1020 = -304						; size = 4
tv1022 = -300						; size = 4
tv203 = -296						; size = 4
tv1014 = -292						; size = 4
tv1009 = -286						; size = 1
tv1002 = -285						; size = 1
tv997 = -284						; size = 4
tv999 = -280						; size = 4
tv195 = -276						; size = 4
tv990 = -272						; size = 4
tv985 = -266						; size = 1
tv978 = -265						; size = 1
tv973 = -264						; size = 4
tv975 = -260						; size = 4
tv188 = -256						; size = 4
tv967 = -252						; size = 4
tv962 = -246						; size = 1
tv955 = -245						; size = 1
tv950 = -244						; size = 4
tv952 = -240						; size = 4
tv180 = -236						; size = 4
tv943 = -232						; size = 4
tv938 = -226						; size = 1
tv931 = -225						; size = 1
tv926 = -224						; size = 4
tv928 = -220						; size = 4
tv173 = -216						; size = 4
tv920 = -212						; size = 4
tv915 = -206						; size = 1
tv908 = -205						; size = 1
tv903 = -204						; size = 4
tv905 = -200						; size = 4
tv165 = -196						; size = 4
tv896 = -192						; size = 4
tv891 = -186						; size = 1
tv884 = -185						; size = 1
tv879 = -184						; size = 4
tv881 = -180						; size = 4
tv158 = -176						; size = 4
tv873 = -172						; size = 4
tv868 = -166						; size = 1
tv861 = -165						; size = 1
tv856 = -164						; size = 4
tv858 = -160						; size = 4
tv151 = -156						; size = 4
tv850 = -152						; size = 4
tv845 = -146						; size = 1
tv838 = -145						; size = 1
tv833 = -144						; size = 4
tv835 = -140						; size = 4
tv144 = -136						; size = 4
tv827 = -132						; size = 4
tv822 = -126						; size = 1
tv815 = -125						; size = 1
tv810 = -124						; size = 4
tv812 = -120						; size = 4
tv135 = -116						; size = 4
tv802 = -112						; size = 4
tv797 = -106						; size = 1
tv790 = -105						; size = 1
tv785 = -104						; size = 4
tv787 = -100						; size = 4
tv128 = -96						; size = 4
tv779 = -92						; size = 4
tv774 = -86						; size = 1
tv767 = -85						; size = 1
tv762 = -84						; size = 4
tv764 = -80						; size = 4
tv89 = -76						; size = 4
tv756 = -72						; size = 4
tv751 = -66						; size = 1
tv744 = -65						; size = 1
tv739 = -64						; size = 4
tv741 = -60						; size = 4
tv76 = -56						; size = 4
tv730 = -52						; size = 4
tv725 = -46						; size = 1
tv718 = -45						; size = 1
tv713 = -44						; size = 4
tv715 = -40						; size = 4
_out$1 = -36						; size = 4
_ans$2 = -32						; size = 4
_uri$3 = -28						; size = 4
_out$4 = -24						; size = 4
_super$5 = -20						; size = 4
_catal$6 = -16						; size = 4
_exit_value$ = -12					; size = 4
_ret$ = -8						; size = 4
_i$ = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 330  : int main(int argc, char **argv) {

	push	ebp
	mov	ebp, esp
	sub	esp, 736				; 000002e0H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-736]
	mov	ecx, 184				; 000000b8H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6F93E186_xmlcatalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 331  :     int i;
; 332  :     int ret;
; 333  :     int exit_value = 0;

	mov	DWORD PTR _exit_value$[ebp], 0

; 334  : 
; 335  : 
; 336  :     if (argc <= 1) {

	cmp	DWORD PTR _argc$[ebp], 1
	jg	SHORT $LN14@main

; 337  : 	usage(argv[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	call	_usage
	add	esp, 4

; 338  : 	return(1);

	mov	eax, 1
	jmp	$LN1@main
$LN14@main:

; 339  :     }
; 340  : 
; 341  :     LIBXML_TEST_VERSION

	push	20909					; 000051adH
	call	_xmlCheckVersion
	add	esp, 4

; 342  :     for (i = 1; i < argc ; i++) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@main
$LN2@main:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@main:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _argc$[ebp]
	jge	$LN3@main

; 343  : 	if (!strcmp(argv[i], "-"))

	mov	DWORD PTR tv715[ebp], OFFSET ??_C@_01JOAMLHOP@?9@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv713[ebp], edx
$LL119@main:
	mov	eax, DWORD PTR tv713[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv718[ebp], cl
	mov	edx, DWORD PTR tv715[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN120@main
	cmp	BYTE PTR tv718[ebp], 0
	je	SHORT $LN121@main
	mov	eax, DWORD PTR tv713[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv725[ebp], cl
	mov	edx, DWORD PTR tv715[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN120@main
	add	DWORD PTR tv713[ebp], 2
	add	DWORD PTR tv715[ebp], 2
	cmp	BYTE PTR tv725[ebp], 0
	jne	SHORT $LL119@main
$LN121@main:
	mov	DWORD PTR tv730[ebp], 0
	jmp	SHORT $LN122@main
$LN120@main:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv730[ebp], eax
$LN122@main:
	mov	ecx, DWORD PTR tv730[ebp]
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 0
	jne	SHORT $LN15@main

; 344  : 	    break;

	jmp	$LN3@main
$LN15@main:

; 345  : 
; 346  : 	if (argv[i][0] != '-')

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	je	SHORT $LN16@main

; 347  : 	    break;

	jmp	$LN3@main
$LN16@main:

; 348  : 	if ((!strcmp(argv[i], "-verbose")) ||
; 349  : 	    (!strcmp(argv[i], "-v")) ||

	mov	DWORD PTR tv741[ebp], OFFSET ??_C@_08FBJJFDKJ@?9verbose@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv739[ebp], edx
$LL123@main:
	mov	eax, DWORD PTR tv739[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv744[ebp], cl
	mov	edx, DWORD PTR tv741[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN124@main
	cmp	BYTE PTR tv744[ebp], 0
	je	SHORT $LN125@main
	mov	eax, DWORD PTR tv739[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv751[ebp], cl
	mov	edx, DWORD PTR tv741[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN124@main
	add	DWORD PTR tv739[ebp], 2
	add	DWORD PTR tv741[ebp], 2
	cmp	BYTE PTR tv751[ebp], 0
	jne	SHORT $LL123@main
$LN125@main:
	mov	DWORD PTR tv756[ebp], 0
	jmp	SHORT $LN126@main
$LN124@main:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv756[ebp], eax
$LN126@main:
	mov	ecx, DWORD PTR tv756[ebp]
	mov	DWORD PTR tv89[ebp], ecx
	cmp	DWORD PTR tv89[ebp], 0
	je	$LN19@main
	mov	DWORD PTR tv764[ebp], OFFSET ??_C@_02EJEOCNCO@?9v@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv762[ebp], ecx
$LL127@main:
	mov	edx, DWORD PTR tv762[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv767[ebp], al
	mov	ecx, DWORD PTR tv764[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN128@main
	cmp	BYTE PTR tv767[ebp], 0
	je	SHORT $LN129@main
	mov	edx, DWORD PTR tv762[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv774[ebp], al
	mov	ecx, DWORD PTR tv764[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN128@main
	add	DWORD PTR tv762[ebp], 2
	add	DWORD PTR tv764[ebp], 2
	cmp	BYTE PTR tv774[ebp], 0
	jne	SHORT $LL127@main
$LN129@main:
	mov	DWORD PTR tv779[ebp], 0
	jmp	SHORT $LN130@main
$LN128@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv779[ebp], edx
$LN130@main:
	mov	eax, DWORD PTR tv779[ebp]
	mov	DWORD PTR tv128[ebp], eax
	cmp	DWORD PTR tv128[ebp], 0
	je	SHORT $LN19@main
	mov	DWORD PTR tv787[ebp], OFFSET ??_C@_09OOLJKHBB@?9?9verbose@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv785[ebp], eax
$LL131@main:
	mov	ecx, DWORD PTR tv785[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv790[ebp], dl
	mov	eax, DWORD PTR tv787[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN132@main
	cmp	BYTE PTR tv790[ebp], 0
	je	SHORT $LN133@main
	mov	ecx, DWORD PTR tv785[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv797[ebp], dl
	mov	eax, DWORD PTR tv787[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN132@main
	add	DWORD PTR tv785[ebp], 2
	add	DWORD PTR tv787[ebp], 2
	cmp	BYTE PTR tv797[ebp], 0
	jne	SHORT $LL131@main
$LN133@main:
	mov	DWORD PTR tv802[ebp], 0
	jmp	SHORT $LN134@main
$LN132@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv802[ebp], ecx
$LN134@main:
	mov	edx, DWORD PTR tv802[ebp]
	mov	DWORD PTR tv135[ebp], edx
	cmp	DWORD PTR tv135[ebp], 0
	jne	SHORT $LN17@main
$LN19@main:

; 350  : 	    (!strcmp(argv[i], "--verbose"))) {
; 351  : 	    verbose++;

	mov	eax, DWORD PTR _verbose
	add	eax, 1
	mov	DWORD PTR _verbose, eax

; 352  : 	    xmlCatalogSetDebug(verbose);

	mov	ecx, DWORD PTR _verbose
	push	ecx
	call	_xmlCatalogSetDebug
	add	esp, 4
	jmp	$LN18@main
$LN17@main:

; 353  : 	} else if ((!strcmp(argv[i], "-noout")) ||

	mov	DWORD PTR tv812[ebp], OFFSET ??_C@_06JPEJAHHH@?9noout@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv810[ebp], ecx
$LL135@main:
	mov	edx, DWORD PTR tv810[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv815[ebp], al
	mov	ecx, DWORD PTR tv812[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN136@main
	cmp	BYTE PTR tv815[ebp], 0
	je	SHORT $LN137@main
	mov	edx, DWORD PTR tv810[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv822[ebp], al
	mov	ecx, DWORD PTR tv812[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN136@main
	add	DWORD PTR tv810[ebp], 2
	add	DWORD PTR tv812[ebp], 2
	cmp	BYTE PTR tv822[ebp], 0
	jne	SHORT $LL135@main
$LN137@main:
	mov	DWORD PTR tv827[ebp], 0
	jmp	SHORT $LN138@main
$LN136@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv827[ebp], edx
$LN138@main:
	mov	eax, DWORD PTR tv827[ebp]
	mov	DWORD PTR tv144[ebp], eax
	cmp	DWORD PTR tv144[ebp], 0
	je	$LN22@main
	mov	DWORD PTR tv835[ebp], OFFSET ??_C@_07FHEHAOH@?9?9noout@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv833[ebp], eax
$LL139@main:
	mov	ecx, DWORD PTR tv833[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv838[ebp], dl
	mov	eax, DWORD PTR tv835[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN140@main
	cmp	BYTE PTR tv838[ebp], 0
	je	SHORT $LN141@main
	mov	ecx, DWORD PTR tv833[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv845[ebp], dl
	mov	eax, DWORD PTR tv835[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN140@main
	add	DWORD PTR tv833[ebp], 2
	add	DWORD PTR tv835[ebp], 2
	cmp	BYTE PTR tv845[ebp], 0
	jne	SHORT $LL139@main
$LN141@main:
	mov	DWORD PTR tv850[ebp], 0
	jmp	SHORT $LN142@main
$LN140@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv850[ebp], ecx
$LN142@main:
	mov	edx, DWORD PTR tv850[ebp]
	mov	DWORD PTR tv151[ebp], edx
	cmp	DWORD PTR tv151[ebp], 0
	jne	SHORT $LN20@main
$LN22@main:

; 354  : 	    (!strcmp(argv[i], "--noout"))) {
; 355  :             noout = 1;

	mov	DWORD PTR _noout, 1
	jmp	$LN18@main
$LN20@main:

; 356  : 	} else if ((!strcmp(argv[i], "-shell")) ||

	mov	DWORD PTR tv858[ebp], OFFSET ??_C@_06GMHACKOA@?9shell@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv856[ebp], edx
$LL143@main:
	mov	eax, DWORD PTR tv856[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv861[ebp], cl
	mov	edx, DWORD PTR tv858[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN144@main
	cmp	BYTE PTR tv861[ebp], 0
	je	SHORT $LN145@main
	mov	eax, DWORD PTR tv856[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv868[ebp], cl
	mov	edx, DWORD PTR tv858[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN144@main
	add	DWORD PTR tv856[ebp], 2
	add	DWORD PTR tv858[ebp], 2
	cmp	BYTE PTR tv868[ebp], 0
	jne	SHORT $LL143@main
$LN145@main:
	mov	DWORD PTR tv873[ebp], 0
	jmp	SHORT $LN146@main
$LN144@main:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv873[ebp], eax
$LN146@main:
	mov	ecx, DWORD PTR tv873[ebp]
	mov	DWORD PTR tv158[ebp], ecx
	cmp	DWORD PTR tv158[ebp], 0
	je	$LN25@main
	mov	DWORD PTR tv881[ebp], OFFSET ??_C@_07PGENFNHA@?9?9shell@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv879[ebp], ecx
$LL147@main:
	mov	edx, DWORD PTR tv879[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv884[ebp], al
	mov	ecx, DWORD PTR tv881[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN148@main
	cmp	BYTE PTR tv884[ebp], 0
	je	SHORT $LN149@main
	mov	edx, DWORD PTR tv879[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv891[ebp], al
	mov	ecx, DWORD PTR tv881[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN148@main
	add	DWORD PTR tv879[ebp], 2
	add	DWORD PTR tv881[ebp], 2
	cmp	BYTE PTR tv891[ebp], 0
	jne	SHORT $LL147@main
$LN149@main:
	mov	DWORD PTR tv896[ebp], 0
	jmp	SHORT $LN150@main
$LN148@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv896[ebp], edx
$LN150@main:
	mov	eax, DWORD PTR tv896[ebp]
	mov	DWORD PTR tv165[ebp], eax
	cmp	DWORD PTR tv165[ebp], 0
	jne	SHORT $LN23@main
$LN25@main:

; 357  : 	    (!strcmp(argv[i], "--shell"))) {
; 358  : 	    shell++;

	mov	ecx, DWORD PTR _shell
	add	ecx, 1
	mov	DWORD PTR _shell, ecx

; 359  :             noout = 1;

	mov	DWORD PTR _noout, 1
	jmp	$LN18@main
$LN23@main:

; 360  : 	} else if ((!strcmp(argv[i], "-sgml")) ||

	mov	DWORD PTR tv905[ebp], OFFSET ??_C@_05GEMLGBMJ@?9sgml@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv903[ebp], ecx
$LL151@main:
	mov	edx, DWORD PTR tv903[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv908[ebp], al
	mov	ecx, DWORD PTR tv905[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN152@main
	cmp	BYTE PTR tv908[ebp], 0
	je	SHORT $LN153@main
	mov	edx, DWORD PTR tv903[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv915[ebp], al
	mov	ecx, DWORD PTR tv905[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN152@main
	add	DWORD PTR tv903[ebp], 2
	add	DWORD PTR tv905[ebp], 2
	cmp	BYTE PTR tv915[ebp], 0
	jne	SHORT $LL151@main
$LN153@main:
	mov	DWORD PTR tv920[ebp], 0
	jmp	SHORT $LN154@main
$LN152@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv920[ebp], edx
$LN154@main:
	mov	eax, DWORD PTR tv920[ebp]
	mov	DWORD PTR tv173[ebp], eax
	cmp	DWORD PTR tv173[ebp], 0
	je	$LN28@main
	mov	DWORD PTR tv928[ebp], OFFSET ??_C@_06OGAPEHEI@?9?9sgml@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv926[ebp], eax
$LL155@main:
	mov	ecx, DWORD PTR tv926[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv931[ebp], dl
	mov	eax, DWORD PTR tv928[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN156@main
	cmp	BYTE PTR tv931[ebp], 0
	je	SHORT $LN157@main
	mov	ecx, DWORD PTR tv926[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv938[ebp], dl
	mov	eax, DWORD PTR tv928[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN156@main
	add	DWORD PTR tv926[ebp], 2
	add	DWORD PTR tv928[ebp], 2
	cmp	BYTE PTR tv938[ebp], 0
	jne	SHORT $LL155@main
$LN157@main:
	mov	DWORD PTR tv943[ebp], 0
	jmp	SHORT $LN158@main
$LN156@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv943[ebp], ecx
$LN158@main:
	mov	edx, DWORD PTR tv943[ebp]
	mov	DWORD PTR tv180[ebp], edx
	cmp	DWORD PTR tv180[ebp], 0
	jne	SHORT $LN26@main
$LN28@main:

; 361  : 	    (!strcmp(argv[i], "--sgml"))) {
; 362  : 	    sgml++;

	mov	eax, DWORD PTR _sgml
	add	eax, 1
	mov	DWORD PTR _sgml, eax
	jmp	$LN18@main
$LN26@main:

; 363  : 	} else if ((!strcmp(argv[i], "-create")) ||

	mov	DWORD PTR tv952[ebp], OFFSET ??_C@_07JNCAJKJG@?9create@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv950[ebp], eax
$LL159@main:
	mov	ecx, DWORD PTR tv950[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv955[ebp], dl
	mov	eax, DWORD PTR tv952[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN160@main
	cmp	BYTE PTR tv955[ebp], 0
	je	SHORT $LN161@main
	mov	ecx, DWORD PTR tv950[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv962[ebp], dl
	mov	eax, DWORD PTR tv952[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN160@main
	add	DWORD PTR tv950[ebp], 2
	add	DWORD PTR tv952[ebp], 2
	cmp	BYTE PTR tv962[ebp], 0
	jne	SHORT $LL159@main
$LN161@main:
	mov	DWORD PTR tv967[ebp], 0
	jmp	SHORT $LN162@main
$LN160@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv967[ebp], ecx
$LN162@main:
	mov	edx, DWORD PTR tv967[ebp]
	mov	DWORD PTR tv188[ebp], edx
	cmp	DWORD PTR tv188[ebp], 0
	je	$LN31@main
	mov	DWORD PTR tv975[ebp], OFFSET ??_C@_08GNLFDEKF@?9?9create@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv973[ebp], edx
$LL163@main:
	mov	eax, DWORD PTR tv973[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv978[ebp], cl
	mov	edx, DWORD PTR tv975[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN164@main
	cmp	BYTE PTR tv978[ebp], 0
	je	SHORT $LN165@main
	mov	eax, DWORD PTR tv973[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv985[ebp], cl
	mov	edx, DWORD PTR tv975[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN164@main
	add	DWORD PTR tv973[ebp], 2
	add	DWORD PTR tv975[ebp], 2
	cmp	BYTE PTR tv985[ebp], 0
	jne	SHORT $LL163@main
$LN165@main:
	mov	DWORD PTR tv990[ebp], 0
	jmp	SHORT $LN166@main
$LN164@main:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv990[ebp], eax
$LN166@main:
	mov	ecx, DWORD PTR tv990[ebp]
	mov	DWORD PTR tv195[ebp], ecx
	cmp	DWORD PTR tv195[ebp], 0
	jne	SHORT $LN29@main
$LN31@main:

; 364  : 	    (!strcmp(argv[i], "--create"))) {
; 365  : 	    create++;

	mov	edx, DWORD PTR _create
	add	edx, 1
	mov	DWORD PTR _create, edx
	jmp	$LN18@main
$LN29@main:

; 366  : 	} else if ((!strcmp(argv[i], "-convert")) ||

	mov	DWORD PTR tv999[ebp], OFFSET ??_C@_08BNGAGJEJ@?9convert@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv997[ebp], edx
$LL167@main:
	mov	eax, DWORD PTR tv997[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1002[ebp], cl
	mov	edx, DWORD PTR tv999[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN168@main
	cmp	BYTE PTR tv1002[ebp], 0
	je	SHORT $LN169@main
	mov	eax, DWORD PTR tv997[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1009[ebp], cl
	mov	edx, DWORD PTR tv999[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN168@main
	add	DWORD PTR tv997[ebp], 2
	add	DWORD PTR tv999[ebp], 2
	cmp	BYTE PTR tv1009[ebp], 0
	jne	SHORT $LL167@main
$LN169@main:
	mov	DWORD PTR tv1014[ebp], 0
	jmp	SHORT $LN170@main
$LN168@main:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1014[ebp], eax
$LN170@main:
	mov	ecx, DWORD PTR tv1014[ebp]
	mov	DWORD PTR tv203[ebp], ecx
	cmp	DWORD PTR tv203[ebp], 0
	je	$LN34@main
	mov	DWORD PTR tv1022[ebp], OFFSET ??_C@_09KCEAJNPB@?9?9convert@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv1020[ebp], ecx
$LL171@main:
	mov	edx, DWORD PTR tv1020[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1025[ebp], al
	mov	ecx, DWORD PTR tv1022[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN172@main
	cmp	BYTE PTR tv1025[ebp], 0
	je	SHORT $LN173@main
	mov	edx, DWORD PTR tv1020[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1032[ebp], al
	mov	ecx, DWORD PTR tv1022[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN172@main
	add	DWORD PTR tv1020[ebp], 2
	add	DWORD PTR tv1022[ebp], 2
	cmp	BYTE PTR tv1032[ebp], 0
	jne	SHORT $LL171@main
$LN173@main:
	mov	DWORD PTR tv1037[ebp], 0
	jmp	SHORT $LN174@main
$LN172@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1037[ebp], edx
$LN174@main:
	mov	eax, DWORD PTR tv1037[ebp]
	mov	DWORD PTR tv210[ebp], eax
	cmp	DWORD PTR tv210[ebp], 0
	jne	SHORT $LN32@main
$LN34@main:

; 367  : 	    (!strcmp(argv[i], "--convert"))) {
; 368  : 	    convert++;

	mov	ecx, DWORD PTR _convert
	add	ecx, 1
	mov	DWORD PTR _convert, ecx
	jmp	$LN18@main
$LN32@main:

; 369  : 	} else if ((!strcmp(argv[i], "-no-super-update")) ||

	mov	DWORD PTR tv1046[ebp], OFFSET ??_C@_0BB@KANDGBAO@?9no?9super?9update@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv1044[ebp], ecx
$LL175@main:
	mov	edx, DWORD PTR tv1044[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1049[ebp], al
	mov	ecx, DWORD PTR tv1046[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN176@main
	cmp	BYTE PTR tv1049[ebp], 0
	je	SHORT $LN177@main
	mov	edx, DWORD PTR tv1044[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1056[ebp], al
	mov	ecx, DWORD PTR tv1046[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN176@main
	add	DWORD PTR tv1044[ebp], 2
	add	DWORD PTR tv1046[ebp], 2
	cmp	BYTE PTR tv1056[ebp], 0
	jne	SHORT $LL175@main
$LN177@main:
	mov	DWORD PTR tv1061[ebp], 0
	jmp	SHORT $LN178@main
$LN176@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1061[ebp], edx
$LN178@main:
	mov	eax, DWORD PTR tv1061[ebp]
	mov	DWORD PTR tv218[ebp], eax
	cmp	DWORD PTR tv218[ebp], 0
	je	$LN37@main
	mov	DWORD PTR tv1069[ebp], OFFSET ??_C@_0BC@KAMKCICF@?9?9no?9super?9update@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1067[ebp], eax
$LL179@main:
	mov	ecx, DWORD PTR tv1067[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1072[ebp], dl
	mov	eax, DWORD PTR tv1069[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN180@main
	cmp	BYTE PTR tv1072[ebp], 0
	je	SHORT $LN181@main
	mov	ecx, DWORD PTR tv1067[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1079[ebp], dl
	mov	eax, DWORD PTR tv1069[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN180@main
	add	DWORD PTR tv1067[ebp], 2
	add	DWORD PTR tv1069[ebp], 2
	cmp	BYTE PTR tv1079[ebp], 0
	jne	SHORT $LL179@main
$LN181@main:
	mov	DWORD PTR tv1084[ebp], 0
	jmp	SHORT $LN182@main
$LN180@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1084[ebp], ecx
$LN182@main:
	mov	edx, DWORD PTR tv1084[ebp]
	mov	DWORD PTR tv225[ebp], edx
	cmp	DWORD PTR tv225[ebp], 0
	jne	SHORT $LN35@main
$LN37@main:

; 370  : 	    (!strcmp(argv[i], "--no-super-update"))) {
; 371  : 	    no_super_update++;

	mov	eax, DWORD PTR _no_super_update
	add	eax, 1
	mov	DWORD PTR _no_super_update, eax
	jmp	$LN18@main
$LN35@main:

; 372  : 	} else if ((!strcmp(argv[i], "-add")) ||

	mov	DWORD PTR tv1093[ebp], OFFSET ??_C@_04MNFJLOGO@?9add@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1091[ebp], eax
$LL183@main:
	mov	ecx, DWORD PTR tv1091[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1096[ebp], dl
	mov	eax, DWORD PTR tv1093[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN184@main
	cmp	BYTE PTR tv1096[ebp], 0
	je	SHORT $LN185@main
	mov	ecx, DWORD PTR tv1091[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1103[ebp], dl
	mov	eax, DWORD PTR tv1093[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN184@main
	add	DWORD PTR tv1091[ebp], 2
	add	DWORD PTR tv1093[ebp], 2
	cmp	BYTE PTR tv1103[ebp], 0
	jne	SHORT $LL183@main
$LN185@main:
	mov	DWORD PTR tv1108[ebp], 0
	jmp	SHORT $LN186@main
$LN184@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1108[ebp], ecx
$LN186@main:
	mov	edx, DWORD PTR tv1108[ebp]
	mov	DWORD PTR tv233[ebp], edx
	cmp	DWORD PTR tv233[ebp], 0
	je	$LN40@main
	mov	DWORD PTR tv1116[ebp], OFFSET ??_C@_05BILPODI@?9?9add@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv1114[ebp], edx
$LL187@main:
	mov	eax, DWORD PTR tv1114[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1119[ebp], cl
	mov	edx, DWORD PTR tv1116[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN188@main
	cmp	BYTE PTR tv1119[ebp], 0
	je	SHORT $LN189@main
	mov	eax, DWORD PTR tv1114[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1126[ebp], cl
	mov	edx, DWORD PTR tv1116[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN188@main
	add	DWORD PTR tv1114[ebp], 2
	add	DWORD PTR tv1116[ebp], 2
	cmp	BYTE PTR tv1126[ebp], 0
	jne	SHORT $LL187@main
$LN189@main:
	mov	DWORD PTR tv1131[ebp], 0
	jmp	SHORT $LN190@main
$LN188@main:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1131[ebp], eax
$LN190@main:
	mov	ecx, DWORD PTR tv1131[ebp]
	mov	DWORD PTR tv240[ebp], ecx
	cmp	DWORD PTR tv240[ebp], 0
	jne	SHORT $LN38@main
$LN40@main:

; 373  : 	    (!strcmp(argv[i], "--add"))) {
; 374  : 	    if (sgml)

	cmp	DWORD PTR _sgml, 0
	je	SHORT $LN41@main

; 375  : 		i += 2;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 2
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN42@main
$LN41@main:

; 376  : 	    else
; 377  : 		i += 3;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 3
	mov	DWORD PTR _i$[ebp], eax
$LN42@main:

; 378  : 	    add++;

	mov	ecx, DWORD PTR _add
	add	ecx, 1
	mov	DWORD PTR _add, ecx
	jmp	$LN18@main
$LN38@main:

; 379  : 	} else if ((!strcmp(argv[i], "-del")) ||

	mov	DWORD PTR tv1142[ebp], OFFSET ??_C@_04DDJMKOGD@?9del@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv1140[ebp], ecx
$LL191@main:
	mov	edx, DWORD PTR tv1140[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1145[ebp], al
	mov	ecx, DWORD PTR tv1142[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN192@main
	cmp	BYTE PTR tv1145[ebp], 0
	je	SHORT $LN193@main
	mov	edx, DWORD PTR tv1140[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1152[ebp], al
	mov	ecx, DWORD PTR tv1142[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN192@main
	add	DWORD PTR tv1140[ebp], 2
	add	DWORD PTR tv1142[ebp], 2
	cmp	BYTE PTR tv1152[ebp], 0
	jne	SHORT $LL191@main
$LN193@main:
	mov	DWORD PTR tv1157[ebp], 0
	jmp	SHORT $LN194@main
$LN192@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1157[ebp], edx
$LN194@main:
	mov	eax, DWORD PTR tv1157[ebp]
	mov	DWORD PTR tv251[ebp], eax
	cmp	DWORD PTR tv251[ebp], 0
	je	$LN45@main
	mov	DWORD PTR tv1165[ebp], OFFSET ??_C@_05PPEOOODF@?9?9del@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1163[ebp], eax
$LL195@main:
	mov	ecx, DWORD PTR tv1163[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1168[ebp], dl
	mov	eax, DWORD PTR tv1165[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN196@main
	cmp	BYTE PTR tv1168[ebp], 0
	je	SHORT $LN197@main
	mov	ecx, DWORD PTR tv1163[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1175[ebp], dl
	mov	eax, DWORD PTR tv1165[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN196@main
	add	DWORD PTR tv1163[ebp], 2
	add	DWORD PTR tv1165[ebp], 2
	cmp	BYTE PTR tv1175[ebp], 0
	jne	SHORT $LL195@main
$LN197@main:
	mov	DWORD PTR tv1180[ebp], 0
	jmp	SHORT $LN198@main
$LN196@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1180[ebp], ecx
$LN198@main:
	mov	edx, DWORD PTR tv1180[ebp]
	mov	DWORD PTR tv258[ebp], edx
	cmp	DWORD PTR tv258[ebp], 0
	jne	SHORT $LN43@main
$LN45@main:

; 380  : 	    (!strcmp(argv[i], "--del"))) {
; 381  : 	    i += 1;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 382  : 	    del++;

	mov	ecx, DWORD PTR _del
	add	ecx, 1
	mov	DWORD PTR _del, ecx

; 383  : 	} else {

	jmp	SHORT $LN18@main
$LN43@main:

; 384  : 	    fprintf(stderr, "Unknown option %s\n", argv[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET ??_C@_0BD@PDLGMOIG@Unknown?5option?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 385  : 	    usage(argv[0]);

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	_usage
	add	esp, 4

; 386  : 	    return(1);

	mov	eax, 1
	jmp	$LN1@main
$LN18@main:

; 387  : 	}
; 388  :     }

	jmp	$LN2@main
$LN3@main:

; 389  : 
; 390  :     for (i = 1; i < argc; i++) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN7@main
$LN5@main:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@main:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _argc$[ebp]
	jge	$LN6@main

; 391  : 	if ((!strcmp(argv[i], "-add")) ||

	mov	DWORD PTR tv1202[ebp], OFFSET ??_C@_04MNFJLOGO@?9add@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv1200[ebp], ecx
$LL199@main:
	mov	edx, DWORD PTR tv1200[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1205[ebp], al
	mov	ecx, DWORD PTR tv1202[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN200@main
	cmp	BYTE PTR tv1205[ebp], 0
	je	SHORT $LN201@main
	mov	edx, DWORD PTR tv1200[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1212[ebp], al
	mov	ecx, DWORD PTR tv1202[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN200@main
	add	DWORD PTR tv1200[ebp], 2
	add	DWORD PTR tv1202[ebp], 2
	cmp	BYTE PTR tv1212[ebp], 0
	jne	SHORT $LL199@main
$LN201@main:
	mov	DWORD PTR tv1217[ebp], 0
	jmp	SHORT $LN202@main
$LN200@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1217[ebp], edx
$LN202@main:
	mov	eax, DWORD PTR tv1217[ebp]
	mov	DWORD PTR tv279[ebp], eax
	cmp	DWORD PTR tv279[ebp], 0
	je	$LN48@main
	mov	DWORD PTR tv1225[ebp], OFFSET ??_C@_05BILPODI@?9?9add@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1223[ebp], eax
$LL203@main:
	mov	ecx, DWORD PTR tv1223[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1228[ebp], dl
	mov	eax, DWORD PTR tv1225[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN204@main
	cmp	BYTE PTR tv1228[ebp], 0
	je	SHORT $LN205@main
	mov	ecx, DWORD PTR tv1223[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1235[ebp], dl
	mov	eax, DWORD PTR tv1225[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN204@main
	add	DWORD PTR tv1223[ebp], 2
	add	DWORD PTR tv1225[ebp], 2
	cmp	BYTE PTR tv1235[ebp], 0
	jne	SHORT $LL203@main
$LN205@main:
	mov	DWORD PTR tv1240[ebp], 0
	jmp	SHORT $LN206@main
$LN204@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1240[ebp], ecx
$LN206@main:
	mov	edx, DWORD PTR tv1240[ebp]
	mov	DWORD PTR tv286[ebp], edx
	cmp	DWORD PTR tv286[ebp], 0
	jne	SHORT $LN46@main
$LN48@main:

; 392  : 	    (!strcmp(argv[i], "--add"))) {
; 393  : 	    if (sgml)

	cmp	DWORD PTR _sgml, 0
	je	SHORT $LN49@main

; 394  : 		i += 2;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN50@main
$LN49@main:

; 395  : 	    else
; 396  : 		i += 3;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 3
	mov	DWORD PTR _i$[ebp], ecx
$LN50@main:

; 397  : 	    continue;

	jmp	$LN5@main
	jmp	$LN47@main
$LN46@main:

; 398  : 	} else if ((!strcmp(argv[i], "-del")) ||

	mov	DWORD PTR tv1250[ebp], OFFSET ??_C@_04DDJMKOGD@?9del@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv1248[ebp], ecx
$LL207@main:
	mov	edx, DWORD PTR tv1248[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1253[ebp], al
	mov	ecx, DWORD PTR tv1250[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN208@main
	cmp	BYTE PTR tv1253[ebp], 0
	je	SHORT $LN209@main
	mov	edx, DWORD PTR tv1248[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1260[ebp], al
	mov	ecx, DWORD PTR tv1250[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN208@main
	add	DWORD PTR tv1248[ebp], 2
	add	DWORD PTR tv1250[ebp], 2
	cmp	BYTE PTR tv1260[ebp], 0
	jne	SHORT $LL207@main
$LN209@main:
	mov	DWORD PTR tv1265[ebp], 0
	jmp	SHORT $LN210@main
$LN208@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1265[ebp], edx
$LN210@main:
	mov	eax, DWORD PTR tv1265[ebp]
	mov	DWORD PTR tv296[ebp], eax
	cmp	DWORD PTR tv296[ebp], 0
	je	$LN53@main
	mov	DWORD PTR tv1273[ebp], OFFSET ??_C@_05PPEOOODF@?9?9del@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1271[ebp], eax
$LL211@main:
	mov	ecx, DWORD PTR tv1271[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1276[ebp], dl
	mov	eax, DWORD PTR tv1273[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN212@main
	cmp	BYTE PTR tv1276[ebp], 0
	je	SHORT $LN213@main
	mov	ecx, DWORD PTR tv1271[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1283[ebp], dl
	mov	eax, DWORD PTR tv1273[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN212@main
	add	DWORD PTR tv1271[ebp], 2
	add	DWORD PTR tv1273[ebp], 2
	cmp	BYTE PTR tv1283[ebp], 0
	jne	SHORT $LL211@main
$LN213@main:
	mov	DWORD PTR tv1288[ebp], 0
	jmp	SHORT $LN214@main
$LN212@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1288[ebp], ecx
$LN214@main:
	mov	edx, DWORD PTR tv1288[ebp]
	mov	DWORD PTR tv303[ebp], edx
	cmp	DWORD PTR tv303[ebp], 0
	jne	SHORT $LN51@main
$LN53@main:

; 399  : 	    (!strcmp(argv[i], "--del"))) {
; 400  : 	    i += 1;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 401  : 
; 402  : 	    /* No catalog entry specified */
; 403  : 	    if (i == argc || (sgml && i + 1 == argc)) {

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _argc$[ebp]
	je	SHORT $LN55@main
	cmp	DWORD PTR _sgml, 0
	je	SHORT $LN54@main
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	cmp	edx, DWORD PTR _argc$[ebp]
	jne	SHORT $LN54@main
$LN55@main:

; 404  : 		fprintf(stderr, "No catalog entry specified to remove from\n");

	push	OFFSET ??_C@_0CL@LMPCJLGA@No?5catalog?5entry?5specified?5to?5r@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 405  : 		usage (argv[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	call	_usage
	add	esp, 4

; 406  : 		return(1);

	mov	eax, 1
	jmp	$LN1@main
$LN54@main:

; 407  : 	    }
; 408  : 
; 409  : 	    continue;

	jmp	$LN5@main
	jmp	SHORT $LN47@main
$LN51@main:

; 410  : 	} else if (argv[i][0] == '-')

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN47@main

; 411  : 	    continue;

	jmp	$LN5@main
$LN47@main:

; 412  : 
; 413  : 	if (filename == NULL && argv[i][0] == '\0') {

	cmp	DWORD PTR _filename, 0
	jne	SHORT $LN57@main
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN57@main

; 414  : 	    /* Interpret empty-string catalog specification as
; 415  : 	       a shortcut for a default system catalog. */
; 416  : 	    xmlInitializeCatalog();

	call	_xmlInitializeCatalog

; 417  : 	} else {

	jmp	SHORT $LN58@main
$LN57@main:

; 418  : 	    filename = argv[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _filename, edx

; 419  : 	    ret = xmlLoadCatalog(argv[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_xmlLoadCatalog
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 420  : 	    if ((ret < 0) && (create)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN58@main
	cmp	DWORD PTR _create, 0
	je	SHORT $LN58@main

; 421  : 		xmlCatalogAdd(BAD_CAST "catalog", BAD_CAST argv[i], NULL);

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_07MFFOOIHD@catalog@
	call	_xmlCatalogAdd
	add	esp, 12					; 0000000cH
$LN58@main:

; 422  : 	    }
; 423  : 	}
; 424  : 	break;

	jmp	SHORT $LN6@main

; 425  :     }

	jmp	$LN5@main
$LN6@main:

; 426  : 
; 427  :     if (convert)

	cmp	DWORD PTR _convert, 0
	je	SHORT $LN60@main

; 428  :         ret = xmlCatalogConvert();

	call	_xmlCatalogConvert
	mov	DWORD PTR _ret$[ebp], eax
$LN60@main:

; 429  : 
; 430  :     if ((add) || (del)) {

	cmp	DWORD PTR _add, 0
	jne	SHORT $LN63@main
	cmp	DWORD PTR _del, 0
	je	$LN61@main
$LN63@main:

; 431  : 	for (i = 1; i < argc ; i++) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN10@main
$LN8@main:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@main:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _argc$[ebp]
	jge	$LN9@main

; 432  : 	    if (!strcmp(argv[i], "-"))

	mov	DWORD PTR tv1325[ebp], OFFSET ??_C@_01JOAMLHOP@?9@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv1323[ebp], ecx
$LL215@main:
	mov	edx, DWORD PTR tv1323[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1328[ebp], al
	mov	ecx, DWORD PTR tv1325[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN216@main
	cmp	BYTE PTR tv1328[ebp], 0
	je	SHORT $LN217@main
	mov	edx, DWORD PTR tv1323[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1335[ebp], al
	mov	ecx, DWORD PTR tv1325[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN216@main
	add	DWORD PTR tv1323[ebp], 2
	add	DWORD PTR tv1325[ebp], 2
	cmp	BYTE PTR tv1335[ebp], 0
	jne	SHORT $LL215@main
$LN217@main:
	mov	DWORD PTR tv1340[ebp], 0
	jmp	SHORT $LN218@main
$LN216@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1340[ebp], edx
$LN218@main:
	mov	eax, DWORD PTR tv1340[ebp]
	mov	DWORD PTR tv386[ebp], eax
	cmp	DWORD PTR tv386[ebp], 0
	jne	SHORT $LN64@main

; 433  : 		break;

	jmp	$LN9@main
$LN64@main:

; 434  : 
; 435  : 	    if (argv[i][0] != '-')

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN65@main

; 436  : 		continue;

	jmp	$LN8@main
$LN65@main:

; 437  : 	    if (strcmp(argv[i], "-add") && strcmp(argv[i], "--add") &&
; 438  : 		strcmp(argv[i], "-del") && strcmp(argv[i], "--del"))

	mov	DWORD PTR tv1351[ebp], OFFSET ??_C@_04MNFJLOGO@?9add@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv1349[ebp], ecx
$LL219@main:
	mov	edx, DWORD PTR tv1349[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1354[ebp], al
	mov	ecx, DWORD PTR tv1351[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN220@main
	cmp	BYTE PTR tv1354[ebp], 0
	je	SHORT $LN221@main
	mov	edx, DWORD PTR tv1349[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1361[ebp], al
	mov	ecx, DWORD PTR tv1351[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN220@main
	add	DWORD PTR tv1349[ebp], 2
	add	DWORD PTR tv1351[ebp], 2
	cmp	BYTE PTR tv1361[ebp], 0
	jne	SHORT $LL219@main
$LN221@main:
	mov	DWORD PTR tv1366[ebp], 0
	jmp	SHORT $LN222@main
$LN220@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1366[ebp], edx
$LN222@main:
	mov	eax, DWORD PTR tv1366[ebp]
	mov	DWORD PTR tv399[ebp], eax
	cmp	DWORD PTR tv399[ebp], 0
	je	$LN66@main
	mov	DWORD PTR tv1374[ebp], OFFSET ??_C@_05BILPODI@?9?9add@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1372[ebp], eax
$LL223@main:
	mov	ecx, DWORD PTR tv1372[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1377[ebp], dl
	mov	eax, DWORD PTR tv1374[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN224@main
	cmp	BYTE PTR tv1377[ebp], 0
	je	SHORT $LN225@main
	mov	ecx, DWORD PTR tv1372[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1384[ebp], dl
	mov	eax, DWORD PTR tv1374[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN224@main
	add	DWORD PTR tv1372[ebp], 2
	add	DWORD PTR tv1374[ebp], 2
	cmp	BYTE PTR tv1384[ebp], 0
	jne	SHORT $LL223@main
$LN225@main:
	mov	DWORD PTR tv1389[ebp], 0
	jmp	SHORT $LN226@main
$LN224@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1389[ebp], ecx
$LN226@main:
	mov	edx, DWORD PTR tv1389[ebp]
	mov	DWORD PTR tv406[ebp], edx
	cmp	DWORD PTR tv406[ebp], 0
	je	$LN66@main
	mov	DWORD PTR tv1397[ebp], OFFSET ??_C@_04DDJMKOGD@?9del@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv1395[ebp], edx
$LL227@main:
	mov	eax, DWORD PTR tv1395[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1400[ebp], cl
	mov	edx, DWORD PTR tv1397[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN228@main
	cmp	BYTE PTR tv1400[ebp], 0
	je	SHORT $LN229@main
	mov	eax, DWORD PTR tv1395[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1407[ebp], cl
	mov	edx, DWORD PTR tv1397[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN228@main
	add	DWORD PTR tv1395[ebp], 2
	add	DWORD PTR tv1397[ebp], 2
	cmp	BYTE PTR tv1407[ebp], 0
	jne	SHORT $LL227@main
$LN229@main:
	mov	DWORD PTR tv1412[ebp], 0
	jmp	SHORT $LN230@main
$LN228@main:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1412[ebp], eax
$LN230@main:
	mov	ecx, DWORD PTR tv1412[ebp]
	mov	DWORD PTR tv413[ebp], ecx
	cmp	DWORD PTR tv413[ebp], 0
	je	$LN66@main
	mov	DWORD PTR tv1420[ebp], OFFSET ??_C@_05PPEOOODF@?9?9del@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv1418[ebp], ecx
$LL231@main:
	mov	edx, DWORD PTR tv1418[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1423[ebp], al
	mov	ecx, DWORD PTR tv1420[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN232@main
	cmp	BYTE PTR tv1423[ebp], 0
	je	SHORT $LN233@main
	mov	edx, DWORD PTR tv1418[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1430[ebp], al
	mov	ecx, DWORD PTR tv1420[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN232@main
	add	DWORD PTR tv1418[ebp], 2
	add	DWORD PTR tv1420[ebp], 2
	cmp	BYTE PTR tv1430[ebp], 0
	jne	SHORT $LL231@main
$LN233@main:
	mov	DWORD PTR tv1435[ebp], 0
	jmp	SHORT $LN234@main
$LN232@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1435[ebp], edx
$LN234@main:
	mov	eax, DWORD PTR tv1435[ebp]
	mov	DWORD PTR tv420[ebp], eax
	cmp	DWORD PTR tv420[ebp], 0
	je	SHORT $LN66@main

; 439  : 		continue;

	jmp	$LN8@main
$LN66@main:

; 440  : 
; 441  : 	    if (sgml) {

	cmp	DWORD PTR _sgml, 0
	je	$LN67@main

; 442  : 		/*
; 443  : 		 * Maintenance of SGML catalogs.
; 444  : 		 */
; 445  : 		xmlCatalogPtr catal = NULL;

	mov	DWORD PTR _catal$6[ebp], 0

; 446  : 		xmlCatalogPtr super = NULL;

	mov	DWORD PTR _super$5[ebp], 0

; 447  : 
; 448  : 		catal = xmlLoadSGMLSuperCatalog(argv[i + 1]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	call	_xmlLoadSGMLSuperCatalog
	add	esp, 4
	mov	DWORD PTR _catal$6[ebp], eax

; 449  : 
; 450  : 		if ((!strcmp(argv[i], "-add")) ||

	mov	DWORD PTR tv1447[ebp], OFFSET ??_C@_04MNFJLOGO@?9add@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1445[ebp], eax
$LL235@main:
	mov	ecx, DWORD PTR tv1445[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1450[ebp], dl
	mov	eax, DWORD PTR tv1447[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN236@main
	cmp	BYTE PTR tv1450[ebp], 0
	je	SHORT $LN237@main
	mov	ecx, DWORD PTR tv1445[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1457[ebp], dl
	mov	eax, DWORD PTR tv1447[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN236@main
	add	DWORD PTR tv1445[ebp], 2
	add	DWORD PTR tv1447[ebp], 2
	cmp	BYTE PTR tv1457[ebp], 0
	jne	SHORT $LL235@main
$LN237@main:
	mov	DWORD PTR tv1462[ebp], 0
	jmp	SHORT $LN238@main
$LN236@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1462[ebp], ecx
$LN238@main:
	mov	edx, DWORD PTR tv1462[ebp]
	mov	DWORD PTR tv433[ebp], edx
	cmp	DWORD PTR tv433[ebp], 0
	je	$LN71@main
	mov	DWORD PTR tv1470[ebp], OFFSET ??_C@_05BILPODI@?9?9add@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv1468[ebp], edx
$LL239@main:
	mov	eax, DWORD PTR tv1468[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1473[ebp], cl
	mov	edx, DWORD PTR tv1470[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN240@main
	cmp	BYTE PTR tv1473[ebp], 0
	je	SHORT $LN241@main
	mov	eax, DWORD PTR tv1468[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1480[ebp], cl
	mov	edx, DWORD PTR tv1470[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN240@main
	add	DWORD PTR tv1468[ebp], 2
	add	DWORD PTR tv1470[ebp], 2
	cmp	BYTE PTR tv1480[ebp], 0
	jne	SHORT $LL239@main
$LN241@main:
	mov	DWORD PTR tv1485[ebp], 0
	jmp	SHORT $LN242@main
$LN240@main:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1485[ebp], eax
$LN242@main:
	mov	ecx, DWORD PTR tv1485[ebp]
	mov	DWORD PTR tv440[ebp], ecx
	cmp	DWORD PTR tv440[ebp], 0
	jne	$LN69@main
$LN71@main:

; 451  : 		    (!strcmp(argv[i], "--add"))) {
; 452  : 		    if (catal == NULL)

	cmp	DWORD PTR _catal$6[ebp], 0
	jne	SHORT $LN72@main

; 453  : 			catal = xmlNewCatalog(1);

	push	1
	call	_xmlNewCatalog
	add	esp, 4
	mov	DWORD PTR _catal$6[ebp], eax
$LN72@main:

; 454  : 		    xmlACatalogAdd(catal, BAD_CAST "CATALOG",

	push	0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+8]
	push	ecx
	push	OFFSET ??_C@_07DIADFEPH@CATALOG@
	mov	edx, DWORD PTR _catal$6[ebp]
	push	edx
	call	_xmlACatalogAdd
	add	esp, 16					; 00000010H

; 455  : 					 BAD_CAST argv[i + 2], NULL);
; 456  : 
; 457  : 		    if (!no_super_update) {

	cmp	DWORD PTR _no_super_update, 0
	jne	SHORT $LN73@main

; 458  : 			super = xmlLoadSGMLSuperCatalog(XML_SGML_DEFAULT_CATALOG);

	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	call	_xmlLoadSGMLSuperCatalog
	add	esp, 4
	mov	DWORD PTR _super$5[ebp], eax

; 459  : 			if (super == NULL)

	cmp	DWORD PTR _super$5[ebp], 0
	jne	SHORT $LN74@main

; 460  : 			    super = xmlNewCatalog(1);

	push	1
	call	_xmlNewCatalog
	add	esp, 4
	mov	DWORD PTR _super$5[ebp], eax
$LN74@main:

; 461  : 
; 462  : 			xmlACatalogAdd(super, BAD_CAST "CATALOG",

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	push	edx
	push	OFFSET ??_C@_07DIADFEPH@CATALOG@
	mov	eax, DWORD PTR _super$5[ebp]
	push	eax
	call	_xmlACatalogAdd
	add	esp, 16					; 00000010H
$LN73@main:

; 463  : 					     BAD_CAST argv[i + 1], NULL);
; 464  : 		    }
; 465  : 		} else {

	jmp	$LN70@main
$LN69@main:

; 466  : 		    if (catal != NULL)

	cmp	DWORD PTR _catal$6[ebp], 0
	je	SHORT $LN75@main

; 467  : 			ret = xmlACatalogRemove(catal, BAD_CAST argv[i + 2]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+8]
	push	eax
	mov	ecx, DWORD PTR _catal$6[ebp]
	push	ecx
	call	_xmlACatalogRemove
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN76@main
$LN75@main:

; 468  : 		    else
; 469  : 			ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
$LN76@main:

; 470  : 		    if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN77@main

; 471  : 			fprintf(stderr, "Failed to remove entry from %s\n",

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	push	OFFSET ??_C@_0CA@DECJMEJL@Failed?5to?5remove?5entry?5from?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 472  : 				argv[i + 1]);
; 473  : 			exit_value = 1;

	mov	DWORD PTR _exit_value$[ebp], 1
$LN77@main:

; 474  : 		    }
; 475  : 		    if ((!no_super_update) && (noout) && (catal != NULL) &&

	cmp	DWORD PTR _no_super_update, 0
	jne	$LN70@main
	cmp	DWORD PTR _noout, 0
	je	SHORT $LN70@main
	cmp	DWORD PTR _catal$6[ebp], 0
	je	SHORT $LN70@main
	mov	edx, DWORD PTR _catal$6[ebp]
	push	edx
	call	_xmlCatalogIsEmpty
	add	esp, 4
	test	eax, eax
	je	SHORT $LN70@main

; 476  : 			(xmlCatalogIsEmpty(catal))) {
; 477  : 			super = xmlLoadSGMLSuperCatalog(

	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	call	_xmlLoadSGMLSuperCatalog
	add	esp, 4
	mov	DWORD PTR _super$5[ebp], eax

; 478  : 				   XML_SGML_DEFAULT_CATALOG);
; 479  : 			if (super != NULL) {

	cmp	DWORD PTR _super$5[ebp], 0
	je	SHORT $LN70@main

; 480  : 			    ret = xmlACatalogRemove(super,

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	push	edx
	mov	eax, DWORD PTR _super$5[ebp]
	push	eax
	call	_xmlACatalogRemove
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 481  : 				    BAD_CAST argv[i + 1]);
; 482  : 			    if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN70@main

; 483  : 				fprintf(stderr,

	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	push	OFFSET ??_C@_0CA@DECJMEJL@Failed?5to?5remove?5entry?5from?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 484  : 					"Failed to remove entry from %s\n",
; 485  : 					XML_SGML_DEFAULT_CATALOG);
; 486  : 				exit_value = 1;

	mov	DWORD PTR _exit_value$[ebp], 1
$LN70@main:

; 487  : 			    }
; 488  : 			}
; 489  : 		    }
; 490  : 		}
; 491  : 		if (noout) {

	cmp	DWORD PTR _noout, 0
	je	$LN81@main

; 492  : 		    FILE *out;
; 493  : 
; 494  : 		    if (xmlCatalogIsEmpty(catal)) {

	mov	ecx, DWORD PTR _catal$6[ebp]
	push	ecx
	call	_xmlCatalogIsEmpty
	add	esp, 4
	test	eax, eax
	je	SHORT $LN83@main

; 495  : 			remove(argv[i + 1]);

	mov	esi, esp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	call	DWORD PTR __imp__remove
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 496  : 		    } else {

	jmp	$LN84@main
$LN83@main:

; 497  : 			out = fopen(argv[i + 1], "w");

	mov	esi, esp
	push	OFFSET ??_C@_01NOFIACDB@w@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _out$4[ebp], eax

; 498  : 			if (out == NULL) {

	cmp	DWORD PTR _out$4[ebp], 0
	jne	SHORT $LN85@main

; 499  : 			    fprintf(stderr, "could not open %s for saving\n",

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	push	OFFSET ??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 500  : 				    argv[i + 1]);
; 501  : 			    exit_value = 2;

	mov	DWORD PTR _exit_value$[ebp], 2

; 502  : 			    noout = 0;

	mov	DWORD PTR _noout, 0

; 503  : 			} else {

	jmp	SHORT $LN84@main
$LN85@main:

; 504  : 			    xmlACatalogDump(catal, out);

	mov	edx, DWORD PTR _out$4[ebp]
	push	edx
	mov	eax, DWORD PTR _catal$6[ebp]
	push	eax
	call	_xmlACatalogDump
	add	esp, 8

; 505  : 			    fclose(out);

	mov	esi, esp
	mov	ecx, DWORD PTR _out$4[ebp]
	push	ecx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN84@main:

; 506  : 			}
; 507  : 		    }
; 508  : 		    if (!no_super_update && super != NULL) {

	cmp	DWORD PTR _no_super_update, 0
	jne	$LN87@main
	cmp	DWORD PTR _super$5[ebp], 0
	je	$LN87@main

; 509  : 			if (xmlCatalogIsEmpty(super)) {

	mov	edx, DWORD PTR _super$5[ebp]
	push	edx
	call	_xmlCatalogIsEmpty
	add	esp, 4
	test	eax, eax
	je	SHORT $LN88@main

; 510  : 			    remove(XML_SGML_DEFAULT_CATALOG);

	mov	esi, esp
	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	call	DWORD PTR __imp__remove
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 511  : 			} else {

	jmp	$LN87@main
$LN88@main:

; 512  : 			    out = fopen(XML_SGML_DEFAULT_CATALOG, "w");

	mov	esi, esp
	push	OFFSET ??_C@_01NOFIACDB@w@
	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _out$4[ebp], eax

; 513  : 			    if (out == NULL) {

	cmp	DWORD PTR _out$4[ebp], 0
	jne	SHORT $LN90@main

; 514  : 				fprintf(stderr,

	push	OFFSET ??_C@_0BC@HONGKENJ@?1etc?1sgml?1catalog@
	push	OFFSET ??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 515  : 					"could not open %s for saving\n",
; 516  : 					XML_SGML_DEFAULT_CATALOG);
; 517  : 				exit_value = 2;

	mov	DWORD PTR _exit_value$[ebp], 2

; 518  : 				noout = 0;

	mov	DWORD PTR _noout, 0

; 519  : 			    } else {

	jmp	SHORT $LN87@main
$LN90@main:

; 520  : 
; 521  : 				xmlACatalogDump(super, out);

	mov	eax, DWORD PTR _out$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _super$5[ebp]
	push	ecx
	call	_xmlACatalogDump
	add	esp, 8

; 522  : 				fclose(out);

	mov	esi, esp
	mov	edx, DWORD PTR _out$4[ebp]
	push	edx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN87@main:

; 523  : 			    }
; 524  : 			}
; 525  : 		    }
; 526  : 		} else {

	jmp	SHORT $LN82@main
$LN81@main:

; 527  : 		    xmlACatalogDump(catal, stdout);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	eax, DWORD PTR _catal$6[ebp]
	push	eax
	call	_xmlACatalogDump
	add	esp, 8
$LN82@main:

; 528  : 		}
; 529  : 		i += 2;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 2
	mov	DWORD PTR _i$[ebp], ecx

; 530  : 	    } else {

	jmp	$LN68@main
$LN67@main:

; 531  : 		if ((!strcmp(argv[i], "-add")) ||

	mov	DWORD PTR tv1570[ebp], OFFSET ??_C@_04MNFJLOGO@?9add@
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv1568[ebp], ecx
$LL243@main:
	mov	edx, DWORD PTR tv1568[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1573[ebp], al
	mov	ecx, DWORD PTR tv1570[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN244@main
	cmp	BYTE PTR tv1573[ebp], 0
	je	SHORT $LN245@main
	mov	edx, DWORD PTR tv1568[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1580[ebp], al
	mov	ecx, DWORD PTR tv1570[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN244@main
	add	DWORD PTR tv1568[ebp], 2
	add	DWORD PTR tv1570[ebp], 2
	cmp	BYTE PTR tv1580[ebp], 0
	jne	SHORT $LL243@main
$LN245@main:
	mov	DWORD PTR tv1585[ebp], 0
	jmp	SHORT $LN246@main
$LN244@main:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv1585[ebp], edx
$LN246@main:
	mov	eax, DWORD PTR tv1585[ebp]
	mov	DWORD PTR tv556[ebp], eax
	cmp	DWORD PTR tv556[ebp], 0
	je	$LN94@main
	mov	DWORD PTR tv1593[ebp], OFFSET ??_C@_05BILPODI@?9?9add@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1591[ebp], eax
$LL247@main:
	mov	ecx, DWORD PTR tv1591[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1596[ebp], dl
	mov	eax, DWORD PTR tv1593[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN248@main
	cmp	BYTE PTR tv1596[ebp], 0
	je	SHORT $LN249@main
	mov	ecx, DWORD PTR tv1591[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1603[ebp], dl
	mov	eax, DWORD PTR tv1593[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN248@main
	add	DWORD PTR tv1591[ebp], 2
	add	DWORD PTR tv1593[ebp], 2
	cmp	BYTE PTR tv1603[ebp], 0
	jne	SHORT $LL247@main
$LN249@main:
	mov	DWORD PTR tv1608[ebp], 0
	jmp	SHORT $LN250@main
$LN248@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1608[ebp], ecx
$LN250@main:
	mov	edx, DWORD PTR tv1608[ebp]
	mov	DWORD PTR tv563[ebp], edx
	cmp	DWORD PTR tv563[ebp], 0
	jne	$LN92@main
$LN94@main:

; 532  : 		    (!strcmp(argv[i], "--add"))) {
; 533  : 			if ((argv[i + 3] == NULL) || (argv[i + 3][0] == 0))

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	cmp	DWORD PTR [ecx+eax*4+12], 0
	je	SHORT $LN97@main
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+12]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN95@main
$LN97@main:

; 534  : 			    ret = xmlCatalogAdd(BAD_CAST argv[i + 1], NULL,

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	push	edx
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	push	edx
	call	_xmlCatalogAdd
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN96@main
$LN95@main:

; 535  : 						BAD_CAST argv[i + 2]);
; 536  : 			else
; 537  : 			    ret = xmlCatalogAdd(BAD_CAST argv[i + 1],

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+12]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	push	edx
	call	_xmlCatalogAdd
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
$LN96@main:

; 538  : 						BAD_CAST argv[i + 2],
; 539  : 						BAD_CAST argv[i + 3]);
; 540  : 			if (ret != 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN98@main

; 541  : 			    printf("add command failed\n");

	push	OFFSET ??_C@_0BE@JELHPCAG@add?5command?5failed?6@
	call	_printf
	add	esp, 4

; 542  : 			    exit_value = 3;

	mov	DWORD PTR _exit_value$[ebp], 3
$LN98@main:

; 543  : 			}
; 544  : 			i += 3;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 3
	mov	DWORD PTR _i$[ebp], eax
	jmp	$LN68@main
$LN92@main:

; 545  : 		} else if ((!strcmp(argv[i], "-del")) ||

	mov	DWORD PTR tv1639[ebp], OFFSET ??_C@_04DDJMKOGD@?9del@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1637[ebp], eax
$LL251@main:
	mov	ecx, DWORD PTR tv1637[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv1642[ebp], dl
	mov	eax, DWORD PTR tv1639[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN252@main
	cmp	BYTE PTR tv1642[ebp], 0
	je	SHORT $LN253@main
	mov	ecx, DWORD PTR tv1637[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv1649[ebp], dl
	mov	eax, DWORD PTR tv1639[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN252@main
	add	DWORD PTR tv1637[ebp], 2
	add	DWORD PTR tv1639[ebp], 2
	cmp	BYTE PTR tv1649[ebp], 0
	jne	SHORT $LL251@main
$LN253@main:
	mov	DWORD PTR tv1654[ebp], 0
	jmp	SHORT $LN254@main
$LN252@main:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv1654[ebp], ecx
$LN254@main:
	mov	edx, DWORD PTR tv1654[ebp]
	mov	DWORD PTR tv607[ebp], edx
	cmp	DWORD PTR tv607[ebp], 0
	je	$LN100@main
	mov	DWORD PTR tv1662[ebp], OFFSET ??_C@_05PPEOOODF@?9?9del@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv1660[ebp], edx
$LL255@main:
	mov	eax, DWORD PTR tv1660[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1665[ebp], cl
	mov	edx, DWORD PTR tv1662[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN256@main
	cmp	BYTE PTR tv1665[ebp], 0
	je	SHORT $LN257@main
	mov	eax, DWORD PTR tv1660[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1672[ebp], cl
	mov	edx, DWORD PTR tv1662[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN256@main
	add	DWORD PTR tv1660[ebp], 2
	add	DWORD PTR tv1662[ebp], 2
	cmp	BYTE PTR tv1672[ebp], 0
	jne	SHORT $LL255@main
$LN257@main:
	mov	DWORD PTR tv1677[ebp], 0
	jmp	SHORT $LN258@main
$LN256@main:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv1677[ebp], eax
$LN258@main:
	mov	ecx, DWORD PTR tv1677[ebp]
	mov	DWORD PTR tv614[ebp], ecx
	cmp	DWORD PTR tv614[ebp], 0
	jne	SHORT $LN68@main
$LN100@main:

; 546  : 		    (!strcmp(argv[i], "--del"))) {
; 547  : 		    ret = xmlCatalogRemove(BAD_CAST argv[i + 1]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	call	_xmlCatalogRemove
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 548  : 		    if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN101@main

; 549  : 			fprintf(stderr, "Failed to remove entry %s\n",

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	push	OFFSET ??_C@_0BL@MKGCOLNC@Failed?5to?5remove?5entry?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 550  : 				argv[i + 1]);
; 551  : 			exit_value = 1;

	mov	DWORD PTR _exit_value$[ebp], 1
$LN101@main:

; 552  : 		    }
; 553  : 		    i += 1;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN68@main:

; 554  : 		}
; 555  : 	    }
; 556  : 	}

	jmp	$LN8@main
$LN9@main:

; 557  : 
; 558  :     } else if (shell) {

	jmp	$LN62@main
$LN61@main:
	cmp	DWORD PTR _shell, 0
	je	SHORT $LN102@main

; 559  : 	usershell();

	call	_usershell

; 560  :     } else {

	jmp	$LN62@main
$LN102@main:

; 561  : 	for (i++; i < argc; i++) {

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN13@main
$LN11@main:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@main:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _argc$[ebp]
	jge	$LN62@main

; 562  : 	    xmlURIPtr uri;
; 563  : 	    xmlChar *ans;
; 564  : 
; 565  : 	    uri = xmlParseURI(argv[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _uri$3[ebp], eax

; 566  : 	    if (uri == NULL) {

	cmp	DWORD PTR _uri$3[ebp], 0
	jne	SHORT $LN104@main

; 567  : 		ans = xmlCatalogResolvePublic((const xmlChar *) argv[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_xmlCatalogResolvePublic
	add	esp, 4
	mov	DWORD PTR _ans$2[ebp], eax

; 568  : 		if (ans == NULL) {

	cmp	DWORD PTR _ans$2[ebp], 0
	jne	SHORT $LN106@main

; 569  : 		    printf("No entry for PUBLIC %s\n", argv[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_0BI@FFIBJMM@No?5entry?5for?5PUBLIC?5?$CFs?6@
	call	_printf
	add	esp, 8

; 570  : 		    exit_value = 4;

	mov	DWORD PTR _exit_value$[ebp], 4

; 571  : 		} else {

	jmp	SHORT $LN107@main
$LN106@main:

; 572  : 		    printf("%s\n", (char *) ans);

	mov	eax, DWORD PTR _ans$2[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	call	_printf
	add	esp, 8

; 573  : 		    xmlFree(ans);

	mov	esi, esp
	mov	ecx, DWORD PTR _ans$2[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN107@main:

; 574  : 		}
; 575  : 	    } else {

	jmp	$LN105@main
$LN104@main:

; 576  :                 xmlFreeURI(uri);

	mov	ecx, DWORD PTR _uri$3[ebp]
	push	ecx
	call	_xmlFreeURI
	add	esp, 4

; 577  : 		ans = xmlCatalogResolveSystem((const xmlChar *) argv[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_xmlCatalogResolveSystem
	add	esp, 4
	mov	DWORD PTR _ans$2[ebp], eax

; 578  : 		if (ans == NULL) {

	cmp	DWORD PTR _ans$2[ebp], 0
	jne	SHORT $LN108@main

; 579  : 		    printf("No entry for SYSTEM %s\n", argv[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET ??_C@_0BI@GPMJOIOL@No?5entry?5for?5SYSTEM?5?$CFs?6@
	call	_printf
	add	esp, 8

; 580  : 		    ans = xmlCatalogResolveURI ((const xmlChar *) argv[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_xmlCatalogResolveURI
	add	esp, 4
	mov	DWORD PTR _ans$2[ebp], eax

; 581  : 		    if (ans == NULL) {

	cmp	DWORD PTR _ans$2[ebp], 0
	jne	SHORT $LN110@main

; 582  : 			printf ("No entry for URI %s\n", argv[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET ??_C@_0BF@IAFAHEGC@No?5entry?5for?5URI?5?$CFs?6@
	call	_printf
	add	esp, 8

; 583  : 		        exit_value = 4;

	mov	DWORD PTR _exit_value$[ebp], 4

; 584  : 		    } else {

	jmp	SHORT $LN111@main
$LN110@main:

; 585  : 		        printf("%s\n", (char *) ans);

	mov	edx, DWORD PTR _ans$2[ebp]
	push	edx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	call	_printf
	add	esp, 8

; 586  : 			xmlFree (ans);

	mov	esi, esp
	mov	eax, DWORD PTR _ans$2[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	mov	edx, DWORD PTR [ecx]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN111@main:

; 587  : 		    }
; 588  : 		} else {

	jmp	SHORT $LN105@main
$LN108@main:

; 589  : 		    printf("%s\n", (char *) ans);

	mov	eax, DWORD PTR _ans$2[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	call	_printf
	add	esp, 8

; 590  : 		    xmlFree(ans);

	mov	esi, esp
	mov	ecx, DWORD PTR _ans$2[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN105@main:

; 591  : 		}
; 592  : 	    }
; 593  : 	}

	jmp	$LN11@main
$LN62@main:

; 594  :     }
; 595  :     if ((!sgml) && ((add) || (del) || (create) || (convert))) {

	cmp	DWORD PTR _sgml, 0
	jne	$LN112@main
	cmp	DWORD PTR _add, 0
	jne	SHORT $LN113@main
	cmp	DWORD PTR _del, 0
	jne	SHORT $LN113@main
	cmp	DWORD PTR _create, 0
	jne	SHORT $LN113@main
	cmp	DWORD PTR _convert, 0
	je	$LN112@main
$LN113@main:

; 596  : 	if (noout && filename && *filename) {

	cmp	DWORD PTR _noout, 0
	je	$LN114@main
	cmp	DWORD PTR _filename, 0
	je	SHORT $LN114@main
	mov	ecx, DWORD PTR _filename
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN114@main

; 597  : 	    FILE *out;
; 598  : 
; 599  : 	    out = fopen(filename, "w");

	mov	esi, esp
	push	OFFSET ??_C@_01NOFIACDB@w@
	mov	eax, DWORD PTR _filename
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _out$1[ebp], eax

; 600  : 	    if (out == NULL) {

	cmp	DWORD PTR _out$1[ebp], 0
	jne	SHORT $LN116@main

; 601  : 		fprintf(stderr, "could not open %s for saving\n", filename);

	mov	ecx, DWORD PTR _filename
	push	ecx
	push	OFFSET ??_C@_0BO@LDFMPMFC@could?5not?5open?5?$CFs?5for?5saving?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 602  : 		exit_value = 2;

	mov	DWORD PTR _exit_value$[ebp], 2

; 603  : 		noout = 0;

	mov	DWORD PTR _noout, 0

; 604  : 	    } else {

	jmp	SHORT $LN117@main
$LN116@main:

; 605  : 		xmlCatalogDump(out);

	mov	edx, DWORD PTR _out$1[ebp]
	push	edx
	call	_xmlCatalogDump
	add	esp, 4
$LN117@main:

; 606  : 	    }
; 607  : 	} else {

	jmp	SHORT $LN112@main
$LN114@main:

; 608  : 	    xmlCatalogDump(stdout);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_xmlCatalogDump
	add	esp, 4
$LN112@main:

; 609  : 	}
; 610  :     }
; 611  : 
; 612  :     /*
; 613  :      * Cleanup and check for memory leaks
; 614  :      */
; 615  :     xmlCleanupParser();

	call	_xmlCleanupParser

; 616  :     xmlMemoryDump();

	call	_xmlMemoryDump

; 617  :     return(exit_value);

	mov	eax, DWORD PTR _exit_value$[ebp]
$LN1@main:

; 618  : }

	pop	edi
	pop	esi
	add	esp, 736				; 000002e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlcatalog.c
;	COMDAT _usage
_TEXT	SEGMENT
_name$ = 8						; size = 4
_usage	PROC						; COMDAT

; 311  : static void usage(const char *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6F93E186_xmlcatalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 312  :     /* split into 2 printf's to avoid overly long string (gcc warning) */
; 313  :     printf("\

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJG@IFOIFJDI@Usage?5?3?5?$CFs?5?$FLoptions?$FN?5catalogfil@
	call	_printf
	add	esp, 8

; 314  : Usage : %s [options] catalogfile entities...\n\
; 315  : \tParse the catalog file (void specification possibly expressed as \"\"\n\
; 316  : \tappoints the default system one) and query it for the entities\n\
; 317  : \t--sgml : handle SGML Super catalogs for --add and --del\n\
; 318  : \t--shell : run a shell allowing interactive queries\n\
; 319  : \t--create : create a new catalog\n\
; 320  : \t--add 'type' 'orig' 'replace' : add an XML entry\n\
; 321  : \t--add 'entry' : add an SGML entry\n", name);
; 322  :     printf("\

	push	OFFSET ??_C@_0BDI@HBPONJIE@?7?9?9del?5?8values?8?5?3?5remove?5values@
	call	_printf
	add	esp, 4

; 323  : \t--del 'values' : remove values\n\
; 324  : \t--noout: avoid dumping the result on stdout\n\
; 325  : \t         used with --add or --del, it saves the catalog changes\n\
; 326  : \t         and with --sgml it automatically updates the super catalog\n\
; 327  : \t--no-super-update: do not update the SGML super catalog\n\
; 328  : \t-v --verbose : provide debug informations\n");
; 329  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_usage	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlcatalog.c
;	COMDAT _usershell
_TEXT	SEGMENT
tv373 = -868						; size = 4
tv815 = -864						; size = 4
tv810 = -858						; size = 1
tv803 = -857						; size = 1
tv798 = -856						; size = 4
tv800 = -852						; size = 4
tv363 = -848						; size = 4
tv792 = -844						; size = 4
tv787 = -838						; size = 1
tv780 = -837						; size = 1
tv775 = -836						; size = 4
tv777 = -832						; size = 4
tv354 = -828						; size = 4
tv769 = -824						; size = 4
tv764 = -818						; size = 1
tv757 = -817						; size = 1
tv752 = -816						; size = 4
tv754 = -812						; size = 4
tv344 = -808						; size = 4
tv745 = -804						; size = 4
tv740 = -798						; size = 1
tv733 = -797						; size = 1
tv728 = -796						; size = 4
tv730 = -792						; size = 4
tv325 = -788						; size = 4
tv713 = -784						; size = 4
tv708 = -778						; size = 1
tv701 = -777						; size = 1
tv696 = -776						; size = 4
tv698 = -772						; size = 4
tv312 = -768						; size = 4
tv689 = -764						; size = 4
tv684 = -758						; size = 1
tv677 = -757						; size = 1
tv672 = -756						; size = 4
tv674 = -752						; size = 4
tv254 = -748						; size = 4
tv642 = -744						; size = 4
tv637 = -738						; size = 1
tv630 = -737						; size = 1
tv625 = -736						; size = 4
tv627 = -732						; size = 4
tv235 = -728						; size = 4
tv610 = -724						; size = 4
tv605 = -718						; size = 1
tv598 = -717						; size = 1
tv593 = -716						; size = 4
tv595 = -712						; size = 4
tv216 = -708						; size = 4
tv578 = -704						; size = 4
tv573 = -698						; size = 1
tv566 = -697						; size = 1
tv561 = -696						; size = 4
tv563 = -692						; size = 4
tv210 = -688						; size = 4
tv554 = -684						; size = 4
tv549 = -678						; size = 1
tv542 = -677						; size = 1
tv537 = -676						; size = 4
tv539 = -672						; size = 4
tv205 = -668						; size = 4
tv533 = -664						; size = 4
tv528 = -658						; size = 1
tv521 = -657						; size = 1
tv516 = -656						; size = 4
tv518 = -652						; size = 4
tv200 = -648						; size = 4
tv512 = -644						; size = 4
tv507 = -638						; size = 1
tv500 = -637						; size = 1
tv495 = -636						; size = 4
tv497 = -632						; size = 4
_ans$ = -628						; size = 4
_ret$ = -624						; size = 4
_i$ = -620						; size = 4
_argv$ = -612						; size = 80
_arg$ = -524						; size = 400
_command$ = -116					; size = 100
_nbargs$ = -12						; size = 4
_cur$ = -8						; size = 4
_cmdline$ = -4						; size = 4
_usershell PROC						; COMDAT

; 96   : static void usershell(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 868				; 00000364H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-868]
	mov	ecx, 217				; 000000d9H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6F93E186_xmlcatalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 97   :     char *cmdline = NULL, *cur;

	mov	DWORD PTR _cmdline$[ebp], 0
$LN2@usershell:

; 98   :     int nbargs;
; 99   :     char command[100];
; 100  :     char arg[400];
; 101  :     char *argv[20];
; 102  :     int i, ret;
; 103  :     xmlChar *ans;
; 104  : 
; 105  :     while (1) {

	mov	eax, 1
	test	eax, eax
	je	$LN1@usershell

; 106  : 	cmdline = xmlShellReadline("> ");

	push	OFFSET ??_C@_02LLMPMKNF@?$DO?5@
	call	_xmlShellReadline
	add	esp, 4
	mov	DWORD PTR _cmdline$[ebp], eax

; 107  : 	if (cmdline == NULL)

	cmp	DWORD PTR _cmdline$[ebp], 0
	jne	SHORT $LN22@usershell

; 108  : 	    return;

	jmp	$LN1@usershell
$LN22@usershell:

; 109  : 
; 110  : 	/*
; 111  : 	 * Parse the command itself
; 112  : 	 */
; 113  : 	cur = cmdline;

	mov	ecx, DWORD PTR _cmdline$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 114  : 	nbargs = 0;

	mov	DWORD PTR _nbargs$[ebp], 0
$LN4@usershell:

; 115  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN23@usershell
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jne	SHORT $LN5@usershell
$LN23@usershell:
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN4@usershell
$LN5@usershell:

; 116  : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN6@usershell:

; 117  : 	while ((*cur != ' ') && (*cur != '\t') &&
; 118  : 	       (*cur != '\n') && (*cur != '\r')) {

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN7@usershell
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	je	SHORT $LN7@usershell
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN7@usershell
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN7@usershell

; 119  : 	    if (*cur == 0)

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN24@usershell

; 120  : 		break;

	jmp	SHORT $LN7@usershell
$LN24@usershell:

; 121  : 	    command[i++] = *cur++;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _command$[ebp+edx], cl
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 122  : 	}

	jmp	SHORT $LN6@usershell
$LN7@usershell:

; 123  : 	command[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _command$[ebp+ecx], 0

; 124  : 	if (i == 0) {

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN25@usershell

; 125  : 	    free(cmdline);

	mov	esi, esp
	mov	edx, DWORD PTR _cmdline$[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 126  : 	    continue;

	jmp	$LN2@usershell
$LN25@usershell:

; 127  : 	}
; 128  : 
; 129  : 	/*
; 130  : 	 * Parse the argument string
; 131  : 	 */
; 132  : 	memset(arg, 0, sizeof(arg));

	push	400					; 00000190H
	push	0
	lea	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN8@usershell:

; 133  : 	while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN26@usershell
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jne	SHORT $LN9@usershell
$LN26@usershell:
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN8@usershell
$LN9@usershell:

; 134  : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN10@usershell:

; 135  : 	while ((*cur != '\n') && (*cur != '\r') && (*cur != 0)) {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN11@usershell
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN11@usershell
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN11@usershell

; 136  : 	    if (*cur == 0)

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN27@usershell

; 137  : 		break;

	jmp	SHORT $LN11@usershell
$LN27@usershell:

; 138  : 	    arg[i++] = *cur++;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _arg$[ebp+edx], cl
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 139  : 	}

	jmp	SHORT $LN10@usershell
$LN11@usershell:

; 140  : 	arg[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _arg$[ebp+ecx], 0

; 141  : 
; 142  : 	/*
; 143  : 	 * Parse the arguments
; 144  : 	 */
; 145  : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 146  : 	nbargs = 0;

	mov	DWORD PTR _nbargs$[ebp], 0

; 147  : 	cur = arg;

	lea	edx, DWORD PTR _arg$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 148  : 	memset(argv, 0, sizeof(argv));

	push	80					; 00000050H
	push	0
	lea	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN12@usershell:

; 149  : 	while (*cur != 0) {

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN13@usershell
$LN14@usershell:

; 150  : 	    while ((*cur == ' ') || (*cur == '\t')) cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN28@usershell
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jne	SHORT $LN15@usershell
$LN28@usershell:
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
	jmp	SHORT $LN14@usershell
$LN15@usershell:

; 151  : 	    if (*cur == '\'') {

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN29@usershell

; 152  : 		cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 153  : 		argv[i] = cur;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _argv$[ebp+edx*4], eax
$LN16@usershell:

; 154  : 		while ((*cur != 0) && (*cur != '\'')) cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN17@usershell
	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	je	SHORT $LN17@usershell
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN16@usershell
$LN17@usershell:

; 155  : 		if (*cur == '\'') {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $LN31@usershell

; 156  : 		    *cur = 0;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	BYTE PTR [edx], 0

; 157  : 		    nbargs++;

	mov	eax, DWORD PTR _nbargs$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbargs$[ebp], eax

; 158  : 		    i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 159  : 		    cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx
$LN31@usershell:

; 160  : 		}

	jmp	$LN30@usershell
$LN29@usershell:

; 161  : 	    } else if (*cur == '"') {

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN32@usershell

; 162  : 		cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 163  : 		argv[i] = cur;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _argv$[ebp+eax*4], ecx
$LN18@usershell:

; 164  : 		while ((*cur != 0) && (*cur != '"')) cur++;

	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN19@usershell
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	je	SHORT $LN19@usershell
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN18@usershell
$LN19@usershell:

; 165  : 		if (*cur == '"') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN34@usershell

; 166  : 		    *cur = 0;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	BYTE PTR [eax], 0

; 167  : 		    nbargs++;

	mov	ecx, DWORD PTR _nbargs$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbargs$[ebp], ecx

; 168  : 		    i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 169  : 		    cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
$LN34@usershell:

; 170  : 		}
; 171  : 	    } else {

	jmp	SHORT $LN30@usershell
$LN32@usershell:

; 172  : 		argv[i] = cur;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _argv$[ebp+ecx*4], edx
$LN20@usershell:

; 173  : 		while ((*cur != 0) && (*cur != ' ') && (*cur != '\t'))

	mov	eax, DWORD PTR _cur$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN21@usershell
	mov	edx, DWORD PTR _cur$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN21@usershell
	mov	ecx, DWORD PTR _cur$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	je	SHORT $LN21@usershell

; 174  : 		    cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN20@usershell
$LN21@usershell:

; 175  : 		*cur = 0;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	BYTE PTR [ecx], 0

; 176  : 		nbargs++;

	mov	edx, DWORD PTR _nbargs$[ebp]
	add	edx, 1
	mov	DWORD PTR _nbargs$[ebp], edx

; 177  : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 178  : 		cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx
$LN30@usershell:

; 179  : 	    }
; 180  : 	}

	jmp	$LN12@usershell
$LN13@usershell:

; 181  : 
; 182  : 	/*
; 183  : 	 * start interpreting the command
; 184  : 	 */
; 185  : 	if (!strcmp(command, "exit") ||
; 186  : 	    !strcmp(command, "quit") ||

	mov	DWORD PTR tv497[ebp], OFFSET ??_C@_04MKNBDEPB@exit@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv495[ebp], edx
$LL90@usershell:
	mov	eax, DWORD PTR tv495[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv500[ebp], cl
	mov	edx, DWORD PTR tv497[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN91@usershell
	cmp	BYTE PTR tv500[ebp], 0
	je	SHORT $LN92@usershell
	mov	eax, DWORD PTR tv495[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv507[ebp], cl
	mov	edx, DWORD PTR tv497[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN91@usershell
	add	DWORD PTR tv495[ebp], 2
	add	DWORD PTR tv497[ebp], 2
	cmp	BYTE PTR tv507[ebp], 0
	jne	SHORT $LL90@usershell
$LN92@usershell:
	mov	DWORD PTR tv512[ebp], 0
	jmp	SHORT $LN93@usershell
$LN91@usershell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv512[ebp], eax
$LN93@usershell:
	mov	ecx, DWORD PTR tv512[ebp]
	mov	DWORD PTR tv200[ebp], ecx
	cmp	DWORD PTR tv200[ebp], 0
	je	$LN36@usershell
	mov	DWORD PTR tv518[ebp], OFFSET ??_C@_04KNNLNNGO@quit@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv516[ebp], edx
$LL94@usershell:
	mov	eax, DWORD PTR tv516[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv521[ebp], cl
	mov	edx, DWORD PTR tv518[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN95@usershell
	cmp	BYTE PTR tv521[ebp], 0
	je	SHORT $LN96@usershell
	mov	eax, DWORD PTR tv516[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv528[ebp], cl
	mov	edx, DWORD PTR tv518[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN95@usershell
	add	DWORD PTR tv516[ebp], 2
	add	DWORD PTR tv518[ebp], 2
	cmp	BYTE PTR tv528[ebp], 0
	jne	SHORT $LL94@usershell
$LN96@usershell:
	mov	DWORD PTR tv533[ebp], 0
	jmp	SHORT $LN97@usershell
$LN95@usershell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv533[ebp], eax
$LN97@usershell:
	mov	ecx, DWORD PTR tv533[ebp]
	mov	DWORD PTR tv205[ebp], ecx
	cmp	DWORD PTR tv205[ebp], 0
	je	$LN36@usershell
	mov	DWORD PTR tv539[ebp], OFFSET ??_C@_03MDONDFG@bye@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv537[ebp], edx
$LL98@usershell:
	mov	eax, DWORD PTR tv537[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv542[ebp], cl
	mov	edx, DWORD PTR tv539[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN99@usershell
	cmp	BYTE PTR tv542[ebp], 0
	je	SHORT $LN100@usershell
	mov	eax, DWORD PTR tv537[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv549[ebp], cl
	mov	edx, DWORD PTR tv539[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN99@usershell
	add	DWORD PTR tv537[ebp], 2
	add	DWORD PTR tv539[ebp], 2
	cmp	BYTE PTR tv549[ebp], 0
	jne	SHORT $LL98@usershell
$LN100@usershell:
	mov	DWORD PTR tv554[ebp], 0
	jmp	SHORT $LN101@usershell
$LN99@usershell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv554[ebp], eax
$LN101@usershell:
	mov	ecx, DWORD PTR tv554[ebp]
	mov	DWORD PTR tv210[ebp], ecx
	cmp	DWORD PTR tv210[ebp], 0
	jne	SHORT $LN35@usershell
$LN36@usershell:

; 187  : 	    !strcmp(command, "bye")) {
; 188  : 	    free(cmdline);

	mov	esi, esp
	mov	edx, DWORD PTR _cmdline$[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 189  : 	    break;

	jmp	$LN1@usershell
$LN35@usershell:

; 190  : 	}
; 191  : 
; 192  : 	if (!strcmp(command, "public")) {

	mov	DWORD PTR tv563[ebp], OFFSET ??_C@_06EOMAMIIF@public@
	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv561[ebp], eax
$LL102@usershell:
	mov	ecx, DWORD PTR tv561[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv566[ebp], dl
	mov	eax, DWORD PTR tv563[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN103@usershell
	cmp	BYTE PTR tv566[ebp], 0
	je	SHORT $LN104@usershell
	mov	ecx, DWORD PTR tv561[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv573[ebp], dl
	mov	eax, DWORD PTR tv563[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN103@usershell
	add	DWORD PTR tv561[ebp], 2
	add	DWORD PTR tv563[ebp], 2
	cmp	BYTE PTR tv573[ebp], 0
	jne	SHORT $LL102@usershell
$LN104@usershell:
	mov	DWORD PTR tv578[ebp], 0
	jmp	SHORT $LN105@usershell
$LN103@usershell:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv578[ebp], ecx
$LN105@usershell:
	mov	edx, DWORD PTR tv578[ebp]
	mov	DWORD PTR tv216[ebp], edx
	cmp	DWORD PTR tv216[ebp], 0
	jne	$LN37@usershell

; 193  : 	    if (nbargs != 1) {

	cmp	DWORD PTR _nbargs$[ebp], 1
	je	SHORT $LN39@usershell

; 194  : 		printf("public requires 1 arguments\n");

	push	OFFSET ??_C@_0BN@DCAIANKH@public?5requires?51?5arguments?6@
	call	_printf
	add	esp, 4

; 195  : 	    } else {

	jmp	SHORT $LN40@usershell
$LN39@usershell:

; 196  : 		ans = xmlCatalogResolvePublic((const xmlChar *) argv[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp+ecx]
	push	edx
	call	_xmlCatalogResolvePublic
	add	esp, 4
	mov	DWORD PTR _ans$[ebp], eax

; 197  : 		if (ans == NULL) {

	cmp	DWORD PTR _ans$[ebp], 0
	jne	SHORT $LN41@usershell

; 198  : 		    printf("No entry for PUBLIC %s\n", argv[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp+ecx]
	push	edx
	push	OFFSET ??_C@_0BI@FFIBJMM@No?5entry?5for?5PUBLIC?5?$CFs?6@
	call	_printf
	add	esp, 8

; 199  : 		} else {

	jmp	SHORT $LN40@usershell
$LN41@usershell:

; 200  : 		    printf("%s\n", (char *) ans);

	mov	eax, DWORD PTR _ans$[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	call	_printf
	add	esp, 8

; 201  : 		    xmlFree(ans);

	mov	esi, esp
	mov	ecx, DWORD PTR _ans$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN40@usershell:

; 202  : 		}
; 203  : 	    }

	jmp	$LN38@usershell
$LN37@usershell:

; 204  : 	} else if (!strcmp(command, "system")) {

	mov	DWORD PTR tv595[ebp], OFFSET ??_C@_06FHFOAHML@system@
	lea	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv593[ebp], ecx
$LL106@usershell:
	mov	edx, DWORD PTR tv593[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv598[ebp], al
	mov	ecx, DWORD PTR tv595[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN107@usershell
	cmp	BYTE PTR tv598[ebp], 0
	je	SHORT $LN108@usershell
	mov	edx, DWORD PTR tv593[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv605[ebp], al
	mov	ecx, DWORD PTR tv595[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN107@usershell
	add	DWORD PTR tv593[ebp], 2
	add	DWORD PTR tv595[ebp], 2
	cmp	BYTE PTR tv605[ebp], 0
	jne	SHORT $LL106@usershell
$LN108@usershell:
	mov	DWORD PTR tv610[ebp], 0
	jmp	SHORT $LN109@usershell
$LN107@usershell:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv610[ebp], edx
$LN109@usershell:
	mov	eax, DWORD PTR tv610[ebp]
	mov	DWORD PTR tv235[ebp], eax
	cmp	DWORD PTR tv235[ebp], 0
	jne	$LN43@usershell

; 205  : 	    if (nbargs != 1) {

	cmp	DWORD PTR _nbargs$[ebp], 1
	je	SHORT $LN45@usershell

; 206  : 		printf("system requires 1 arguments\n");

	push	OFFSET ??_C@_0BN@OGHNALCF@system?5requires?51?5arguments?6@
	call	_printf
	add	esp, 4

; 207  : 	    } else {

	jmp	SHORT $LN46@usershell
$LN45@usershell:

; 208  : 		ans = xmlCatalogResolveSystem((const xmlChar *) argv[0]);

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _argv$[ebp+edx]
	push	eax
	call	_xmlCatalogResolveSystem
	add	esp, 4
	mov	DWORD PTR _ans$[ebp], eax

; 209  : 		if (ans == NULL) {

	cmp	DWORD PTR _ans$[ebp], 0
	jne	SHORT $LN47@usershell

; 210  : 		    printf("No entry for SYSTEM %s\n", argv[0]);

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _argv$[ebp+edx]
	push	eax
	push	OFFSET ??_C@_0BI@GPMJOIOL@No?5entry?5for?5SYSTEM?5?$CFs?6@
	call	_printf
	add	esp, 8

; 211  : 		} else {

	jmp	SHORT $LN46@usershell
$LN47@usershell:

; 212  : 		    printf("%s\n", (char *) ans);

	mov	ecx, DWORD PTR _ans$[ebp]
	push	ecx
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	call	_printf
	add	esp, 8

; 213  : 		    xmlFree(ans);

	mov	esi, esp
	mov	edx, DWORD PTR _ans$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN46@usershell:

; 214  : 		}
; 215  : 	    }

	jmp	$LN38@usershell
$LN43@usershell:

; 216  : 	} else if (!strcmp(command, "add")) {

	mov	DWORD PTR tv627[ebp], OFFSET ??_C@_03BDGOHNNK@add@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv625[ebp], edx
$LL110@usershell:
	mov	eax, DWORD PTR tv625[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv630[ebp], cl
	mov	edx, DWORD PTR tv627[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN111@usershell
	cmp	BYTE PTR tv630[ebp], 0
	je	SHORT $LN112@usershell
	mov	eax, DWORD PTR tv625[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv637[ebp], cl
	mov	edx, DWORD PTR tv627[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN111@usershell
	add	DWORD PTR tv625[ebp], 2
	add	DWORD PTR tv627[ebp], 2
	cmp	BYTE PTR tv637[ebp], 0
	jne	SHORT $LL110@usershell
$LN112@usershell:
	mov	DWORD PTR tv642[ebp], 0
	jmp	SHORT $LN113@usershell
$LN111@usershell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv642[ebp], eax
$LN113@usershell:
	mov	ecx, DWORD PTR tv642[ebp]
	mov	DWORD PTR tv254[ebp], ecx
	cmp	DWORD PTR tv254[ebp], 0
	jne	$LN49@usershell

; 217  : 	    if (sgml) {

	cmp	DWORD PTR _sgml, 0
	je	$LN51@usershell

; 218  : 		if ((nbargs != 3) && (nbargs != 2)) {

	cmp	DWORD PTR _nbargs$[ebp], 3
	je	SHORT $LN53@usershell
	cmp	DWORD PTR _nbargs$[ebp], 2
	je	SHORT $LN53@usershell

; 219  : 		    printf("add requires 2 or 3 arguments\n");

	push	OFFSET ??_C@_0BP@EHJKBIMI@add?5requires?52?5or?53?5arguments?6@
	call	_printf
	add	esp, 4

; 220  : 		} else {

	jmp	$LN54@usershell
$LN53@usershell:

; 221  : 		    if (argv[2] == NULL)

	mov	edx, 4
	shl	edx, 1
	cmp	DWORD PTR _argv$[ebp+edx], 0
	jne	SHORT $LN55@usershell

; 222  : 			ret = xmlCatalogAdd(BAD_CAST argv[0], NULL,

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _argv$[ebp+eax]
	push	ecx
	push	0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _argv$[ebp+eax]
	push	ecx
	call	_xmlCatalogAdd
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN56@usershell
$LN55@usershell:

; 223  : 					    BAD_CAST argv[1]);
; 224  : 		    else
; 225  : 			ret = xmlCatalogAdd(BAD_CAST argv[0], BAD_CAST argv[1],

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _argv$[ebp+edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _argv$[ebp+ecx]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp+ecx]
	push	edx
	call	_xmlCatalogAdd
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
$LN56@usershell:

; 226  : 					    BAD_CAST argv[2]);
; 227  : 		    if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN54@usershell

; 228  : 			printf("add command failed\n");

	push	OFFSET ??_C@_0BE@JELHPCAG@add?5command?5failed?6@
	call	_printf
	add	esp, 4
$LN54@usershell:

; 229  : 		}
; 230  : 	    } else {

	jmp	$LN52@usershell
$LN51@usershell:

; 231  : 		if ((nbargs != 3) && (nbargs != 2)) {

	cmp	DWORD PTR _nbargs$[ebp], 3
	je	SHORT $LN58@usershell
	cmp	DWORD PTR _nbargs$[ebp], 2
	je	SHORT $LN58@usershell

; 232  : 		    printf("add requires 2 or 3 arguments\n");

	push	OFFSET ??_C@_0BP@EHJKBIMI@add?5requires?52?5or?53?5arguments?6@
	call	_printf
	add	esp, 4

; 233  : 		} else {

	jmp	$LN52@usershell
$LN58@usershell:

; 234  : 		    if (argv[2] == NULL)

	mov	eax, 4
	shl	eax, 1
	cmp	DWORD PTR _argv$[ebp+eax], 0
	jne	SHORT $LN60@usershell

; 235  : 			ret = xmlCatalogAdd(BAD_CAST argv[0], NULL,

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _argv$[ebp+ecx]
	push	edx
	push	0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp+ecx]
	push	edx
	call	_xmlCatalogAdd
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
	jmp	SHORT $LN61@usershell
$LN60@usershell:

; 236  : 					    BAD_CAST argv[1]);
; 237  : 		    else
; 238  : 			ret = xmlCatalogAdd(BAD_CAST argv[0], BAD_CAST argv[1],

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _argv$[ebp+eax]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _argv$[ebp+edx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _argv$[ebp+edx]
	push	eax
	call	_xmlCatalogAdd
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax
$LN61@usershell:

; 239  : 					    BAD_CAST argv[2]);
; 240  : 		    if (ret != 0)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN52@usershell

; 241  : 			printf("add command failed\n");

	push	OFFSET ??_C@_0BE@JELHPCAG@add?5command?5failed?6@
	call	_printf
	add	esp, 4
$LN52@usershell:

; 242  : 		}
; 243  : 	    }

	jmp	$LN38@usershell
$LN49@usershell:

; 244  : 	} else if (!strcmp(command, "del")) {

	mov	DWORD PTR tv674[ebp], OFFSET ??_C@_03ONKLGNNH@del@
	lea	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv672[ebp], ecx
$LL114@usershell:
	mov	edx, DWORD PTR tv672[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv677[ebp], al
	mov	ecx, DWORD PTR tv674[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN115@usershell
	cmp	BYTE PTR tv677[ebp], 0
	je	SHORT $LN116@usershell
	mov	edx, DWORD PTR tv672[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv684[ebp], al
	mov	ecx, DWORD PTR tv674[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN115@usershell
	add	DWORD PTR tv672[ebp], 2
	add	DWORD PTR tv674[ebp], 2
	cmp	BYTE PTR tv684[ebp], 0
	jne	SHORT $LL114@usershell
$LN116@usershell:
	mov	DWORD PTR tv689[ebp], 0
	jmp	SHORT $LN117@usershell
$LN115@usershell:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv689[ebp], edx
$LN117@usershell:
	mov	eax, DWORD PTR tv689[ebp]
	mov	DWORD PTR tv312[ebp], eax
	cmp	DWORD PTR tv312[ebp], 0
	jne	SHORT $LN63@usershell

; 245  : 	    if (nbargs != 1) {

	cmp	DWORD PTR _nbargs$[ebp], 1
	je	SHORT $LN65@usershell

; 246  : 		printf("del requires 1\n");

	push	OFFSET ??_C@_0BA@PNPKCAGJ@del?5requires?51?6@
	call	_printf
	add	esp, 4

; 247  : 	    } else {

	jmp	SHORT $LN66@usershell
$LN65@usershell:

; 248  : 		ret = xmlCatalogRemove(BAD_CAST argv[0]);

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _argv$[ebp+edx]
	push	eax
	call	_xmlCatalogRemove
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 249  : 		if (ret <= 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jg	SHORT $LN66@usershell

; 250  : 		    printf("del command failed\n");

	push	OFFSET ??_C@_0BE@HPIOAMEN@del?5command?5failed?6@
	call	_printf
	add	esp, 4
$LN66@usershell:

; 251  : 
; 252  : 	    }

	jmp	$LN38@usershell
$LN63@usershell:

; 253  : 	} else if (!strcmp(command, "resolve")) {

	mov	DWORD PTR tv698[ebp], OFFSET ??_C@_07CPEIJHB@resolve@
	lea	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv696[ebp], ecx
$LL118@usershell:
	mov	edx, DWORD PTR tv696[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv701[ebp], al
	mov	ecx, DWORD PTR tv698[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN119@usershell
	cmp	BYTE PTR tv701[ebp], 0
	je	SHORT $LN120@usershell
	mov	edx, DWORD PTR tv696[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv708[ebp], al
	mov	ecx, DWORD PTR tv698[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN119@usershell
	add	DWORD PTR tv696[ebp], 2
	add	DWORD PTR tv698[ebp], 2
	cmp	BYTE PTR tv708[ebp], 0
	jne	SHORT $LL118@usershell
$LN120@usershell:
	mov	DWORD PTR tv713[ebp], 0
	jmp	SHORT $LN121@usershell
$LN119@usershell:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv713[ebp], edx
$LN121@usershell:
	mov	eax, DWORD PTR tv713[ebp]
	mov	DWORD PTR tv325[ebp], eax
	cmp	DWORD PTR tv325[ebp], 0
	jne	$LN68@usershell

; 254  : 	    if (nbargs != 2) {

	cmp	DWORD PTR _nbargs$[ebp], 2
	je	SHORT $LN70@usershell

; 255  : 		printf("resolve requires 2 arguments\n");

	push	OFFSET ??_C@_0BO@FIFGKLE@resolve?5requires?52?5arguments?6@
	call	_printf
	add	esp, 4

; 256  : 	    } else {

	jmp	SHORT $LN71@usershell
$LN70@usershell:

; 257  : 		ans = xmlCatalogResolve(BAD_CAST argv[0],

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _argv$[ebp+ecx]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp+ecx]
	push	edx
	call	_xmlCatalogResolve
	add	esp, 8
	mov	DWORD PTR _ans$[ebp], eax

; 258  : 			                BAD_CAST argv[1]);
; 259  : 		if (ans == NULL) {

	cmp	DWORD PTR _ans$[ebp], 0
	jne	SHORT $LN72@usershell

; 260  : 		    printf("Resolver failed to find an answer\n");

	push	OFFSET ??_C@_0CD@FLKMEIPD@Resolver?5failed?5to?5find?5an?5answ@
	call	_printf
	add	esp, 4

; 261  : 		} else {

	jmp	SHORT $LN71@usershell
$LN72@usershell:

; 262  : 		    printf("%s\n", (char *) ans);

	mov	eax, DWORD PTR _ans$[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	call	_printf
	add	esp, 8

; 263  : 		    xmlFree(ans);

	mov	esi, esp
	mov	ecx, DWORD PTR _ans$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN71@usershell:

; 264  : 		}
; 265  : 	    }

	jmp	$LN38@usershell
$LN68@usershell:

; 266  : 	} else if (!strcmp(command, "dump")) {

	mov	DWORD PTR tv730[ebp], OFFSET ??_C@_04GGLOKIEE@dump@
	lea	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv728[ebp], ecx
$LL122@usershell:
	mov	edx, DWORD PTR tv728[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv733[ebp], al
	mov	ecx, DWORD PTR tv730[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN123@usershell
	cmp	BYTE PTR tv733[ebp], 0
	je	SHORT $LN124@usershell
	mov	edx, DWORD PTR tv728[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv740[ebp], al
	mov	ecx, DWORD PTR tv730[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN123@usershell
	add	DWORD PTR tv728[ebp], 2
	add	DWORD PTR tv730[ebp], 2
	cmp	BYTE PTR tv740[ebp], 0
	jne	SHORT $LL122@usershell
$LN124@usershell:
	mov	DWORD PTR tv745[ebp], 0
	jmp	SHORT $LN125@usershell
$LN123@usershell:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv745[ebp], edx
$LN125@usershell:
	mov	eax, DWORD PTR tv745[ebp]
	mov	DWORD PTR tv344[ebp], eax
	cmp	DWORD PTR tv344[ebp], 0
	jne	SHORT $LN74@usershell

; 267  : 	    if (nbargs != 0) {

	cmp	DWORD PTR _nbargs$[ebp], 0
	je	SHORT $LN76@usershell

; 268  : 		printf("dump has no arguments\n");

	push	OFFSET ??_C@_0BH@GHHAHJGB@dump?5has?5no?5arguments?6@
	call	_printf
	add	esp, 4

; 269  : 	    } else {

	jmp	SHORT $LN77@usershell
$LN76@usershell:

; 270  : 		xmlCatalogDump(stdout);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_xmlCatalogDump
	add	esp, 4
$LN77@usershell:

; 271  : 	    }

	jmp	$LN38@usershell
$LN74@usershell:

; 272  : 	} else if (!strcmp(command, "debug")) {

	mov	DWORD PTR tv754[ebp], OFFSET ??_C@_05GFCDIDHO@debug@
	lea	ecx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv752[ebp], ecx
$LL126@usershell:
	mov	edx, DWORD PTR tv752[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv757[ebp], al
	mov	ecx, DWORD PTR tv754[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN127@usershell
	cmp	BYTE PTR tv757[ebp], 0
	je	SHORT $LN128@usershell
	mov	edx, DWORD PTR tv752[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv764[ebp], al
	mov	ecx, DWORD PTR tv754[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN127@usershell
	add	DWORD PTR tv752[ebp], 2
	add	DWORD PTR tv754[ebp], 2
	cmp	BYTE PTR tv764[ebp], 0
	jne	SHORT $LL126@usershell
$LN128@usershell:
	mov	DWORD PTR tv769[ebp], 0
	jmp	SHORT $LN129@usershell
$LN127@usershell:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv769[ebp], edx
$LN129@usershell:
	mov	eax, DWORD PTR tv769[ebp]
	mov	DWORD PTR tv354[ebp], eax
	cmp	DWORD PTR tv354[ebp], 0
	jne	SHORT $LN78@usershell

; 273  : 	    if (nbargs != 0) {

	cmp	DWORD PTR _nbargs$[ebp], 0
	je	SHORT $LN80@usershell

; 274  : 		printf("debug has no arguments\n");

	push	OFFSET ??_C@_0BI@DPNEIFGM@debug?5has?5no?5arguments?6@
	call	_printf
	add	esp, 4

; 275  : 	    } else {

	jmp	SHORT $LN81@usershell
$LN80@usershell:

; 276  : 		verbose++;

	mov	ecx, DWORD PTR _verbose
	add	ecx, 1
	mov	DWORD PTR _verbose, ecx

; 277  : 		xmlCatalogSetDebug(verbose);

	mov	edx, DWORD PTR _verbose
	push	edx
	call	_xmlCatalogSetDebug
	add	esp, 4
$LN81@usershell:

; 278  : 	    }

	jmp	$LN38@usershell
$LN78@usershell:

; 279  : 	} else if (!strcmp(command, "quiet")) {

	mov	DWORD PTR tv777[ebp], OFFSET ??_C@_05PMBAOCDH@quiet@
	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv775[ebp], eax
$LL130@usershell:
	mov	ecx, DWORD PTR tv775[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv780[ebp], dl
	mov	eax, DWORD PTR tv777[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN131@usershell
	cmp	BYTE PTR tv780[ebp], 0
	je	SHORT $LN132@usershell
	mov	ecx, DWORD PTR tv775[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv787[ebp], dl
	mov	eax, DWORD PTR tv777[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN131@usershell
	add	DWORD PTR tv775[ebp], 2
	add	DWORD PTR tv777[ebp], 2
	cmp	BYTE PTR tv787[ebp], 0
	jne	SHORT $LL130@usershell
$LN132@usershell:
	mov	DWORD PTR tv792[ebp], 0
	jmp	SHORT $LN133@usershell
$LN131@usershell:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv792[ebp], ecx
$LN133@usershell:
	mov	edx, DWORD PTR tv792[ebp]
	mov	DWORD PTR tv363[ebp], edx
	cmp	DWORD PTR tv363[ebp], 0
	jne	SHORT $LN82@usershell

; 280  : 	    if (nbargs != 0) {

	cmp	DWORD PTR _nbargs$[ebp], 0
	je	SHORT $LN84@usershell

; 281  : 		printf("quiet has no arguments\n");

	push	OFFSET ??_C@_0BI@CNFOPICG@quiet?5has?5no?5arguments?6@
	call	_printf
	add	esp, 4

; 282  : 	    } else {

	jmp	SHORT $LN85@usershell
$LN84@usershell:

; 283  : 		if (verbose > 0)

	cmp	DWORD PTR _verbose, 0
	jle	SHORT $LN86@usershell

; 284  : 		    verbose--;

	mov	eax, DWORD PTR _verbose
	sub	eax, 1
	mov	DWORD PTR _verbose, eax
$LN86@usershell:

; 285  : 		xmlCatalogSetDebug(verbose);

	mov	ecx, DWORD PTR _verbose
	push	ecx
	call	_xmlCatalogSetDebug
	add	esp, 4
$LN85@usershell:

; 286  : 	    }
; 287  : 	} else {

	jmp	$LN38@usershell
$LN82@usershell:

; 288  : 	    if (strcmp(command, "help")) {

	mov	DWORD PTR tv800[ebp], OFFSET ??_C@_04PCJFHION@help@
	lea	edx, DWORD PTR _command$[ebp]
	mov	DWORD PTR tv798[ebp], edx
$LL134@usershell:
	mov	eax, DWORD PTR tv798[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv803[ebp], cl
	mov	edx, DWORD PTR tv800[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN135@usershell
	cmp	BYTE PTR tv803[ebp], 0
	je	SHORT $LN136@usershell
	mov	eax, DWORD PTR tv798[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv810[ebp], cl
	mov	edx, DWORD PTR tv800[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN135@usershell
	add	DWORD PTR tv798[ebp], 2
	add	DWORD PTR tv800[ebp], 2
	cmp	BYTE PTR tv810[ebp], 0
	jne	SHORT $LL134@usershell
$LN136@usershell:
	mov	DWORD PTR tv815[ebp], 0
	jmp	SHORT $LN137@usershell
$LN135@usershell:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv815[ebp], eax
$LN137@usershell:
	mov	ecx, DWORD PTR tv815[ebp]
	mov	DWORD PTR tv373[ebp], ecx
	cmp	DWORD PTR tv373[ebp], 0
	je	SHORT $LN87@usershell

; 289  : 		printf("Unrecognized command %s\n", command);

	lea	edx, DWORD PTR _command$[ebp]
	push	edx
	push	OFFSET ??_C@_0BJ@LCFAJBIE@Unrecognized?5command?5?$CFs?6@
	call	_printf
	add	esp, 8
$LN87@usershell:

; 290  : 	    }
; 291  : 	    printf("Commands available:\n");

	push	OFFSET ??_C@_0BF@CNPPMLEL@Commands?5available?3?6@
	call	_printf
	add	esp, 4

; 292  : 	    printf("\tpublic PublicID: make a PUBLIC identifier lookup\n");

	push	OFFSET ??_C@_0DD@BNENJECC@?7public?5PublicID?3?5make?5a?5PUBLIC@
	call	_printf
	add	esp, 4

; 293  : 	    printf("\tsystem SystemID: make a SYSTEM identifier lookup\n");

	push	OFFSET ??_C@_0DD@BFGOGPGB@?7system?5SystemID?3?5make?5a?5SYSTEM@
	call	_printf
	add	esp, 4

; 294  : 	    printf("\tresolve PublicID SystemID: do a full resolver lookup\n");

	push	OFFSET ??_C@_0DH@FFOBCHBO@?7resolve?5PublicID?5SystemID?3?5do?5@
	call	_printf
	add	esp, 4

; 295  : 	    printf("\tadd 'type' 'orig' 'replace' : add an entry\n");

	push	OFFSET ??_C@_0CN@PJBHDJPC@?7add?5?8type?8?5?8orig?8?5?8replace?8?5?3?5@
	call	_printf
	add	esp, 4

; 296  : 	    printf("\tdel 'values' : remove values\n");

	push	OFFSET ??_C@_0BP@BCHNOEJB@?7del?5?8values?8?5?3?5remove?5values?6@
	call	_printf
	add	esp, 4

; 297  : 	    printf("\tdump: print the current catalog state\n");

	push	OFFSET ??_C@_0CI@ECEJDHEJ@?7dump?3?5print?5the?5current?5catalo@
	call	_printf
	add	esp, 4

; 298  : 	    printf("\tdebug: increase the verbosity level\n");

	push	OFFSET ??_C@_0CG@OIIIIIDP@?7debug?3?5increase?5the?5verbosity?5@
	call	_printf
	add	esp, 4

; 299  : 	    printf("\tquiet: decrease the verbosity level\n");

	push	OFFSET ??_C@_0CG@JNOLBMIB@?7quiet?3?5decrease?5the?5verbosity?5@
	call	_printf
	add	esp, 4

; 300  : 	    printf("\texit:  quit the shell\n");

	push	OFFSET ??_C@_0BI@GHCHHEEB@?7exit?3?5?5quit?5the?5shell?6@
	call	_printf
	add	esp, 4
$LN38@usershell:

; 301  : 	}
; 302  : 	free(cmdline); /* not xmlFree here ! */

	mov	esi, esp
	mov	eax, DWORD PTR _cmdline$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 303  :     }

	jmp	$LN2@usershell
$LN1@usershell:

; 304  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN142@usershell
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 868				; 00000364H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN142@usershell:
	DD	3
	DD	$LN141@usershell
$LN141@usershell:
	DD	-116					; ffffff8cH
	DD	100					; 00000064H
	DD	$LN138@usershell
	DD	-524					; fffffdf4H
	DD	400					; 00000190H
	DD	$LN139@usershell
	DD	-612					; fffffd9cH
	DD	80					; 00000050H
	DD	$LN140@usershell
$LN140@usershell:
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	118					; 00000076H
	DB	0
$LN139@usershell:
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	0
$LN138@usershell:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
_usershell ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlcatalog.c
;	COMDAT _xmlShellReadline
_TEXT	SEGMENT
tv84 = -536						; size = 4
tv154 = -529						; size = 1
tv151 = -528						; size = 4
tv148 = -524						; size = 4
_len$ = -520						; size = 4
_ret$ = -516						; size = 4
_line_read$ = -508					; size = 501
_prompt$ = 8						; size = 4
_xmlShellReadline PROC					; COMDAT

; 64   : xmlShellReadline(const char *prompt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 536				; 00000218H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-536]
	mov	ecx, 134				; 00000086H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6F93E186_xmlcatalog@c
	call	@__CheckForDebuggerJustMyCode@4

; 65   : #ifdef HAVE_LIBREADLINE
; 66   :     char *line_read;
; 67   : 
; 68   :     /* Get a line from the user. */
; 69   :     line_read = readline (prompt);
; 70   : 
; 71   :     /* If the line has any text in it, save it on the history. */
; 72   :     if (line_read && *line_read)
; 73   : 	add_history (line_read);
; 74   : 
; 75   :     return (line_read);
; 76   : #else
; 77   :     char line_read[501];
; 78   :     char *ret;
; 79   :     int len;
; 80   : 
; 81   :     if (prompt != NULL)

	cmp	DWORD PTR _prompt$[ebp], 0
	je	SHORT $LN2@xmlShellRe

; 82   : 	fprintf(stdout, "%s", prompt);

	mov	eax, DWORD PTR _prompt$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN2@xmlShellRe:

; 83   :     fflush(stdout);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__fflush
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 84   :     if (!fgets(line_read, 500, stdin))

	mov	esi, esp
	push	0
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	push	500					; 000001f4H
	lea	ecx, DWORD PTR _line_read$[ebp]
	push	ecx
	call	DWORD PTR __imp__fgets
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN3@xmlShellRe

; 85   :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlShellRe
$LN3@xmlShellRe:

; 86   :     line_read[500] = 0;

	mov	edx, 1
	imul	eax, edx, 500
	mov	BYTE PTR _line_read$[ebp+eax], 0

; 87   :     len = strlen(line_read);

	lea	ecx, DWORD PTR _line_read$[ebp]
	mov	DWORD PTR tv148[ebp], ecx
	mov	edx, DWORD PTR tv148[ebp]
	add	edx, 1
	mov	DWORD PTR tv151[ebp], edx
$LL6@xmlShellRe:
	mov	eax, DWORD PTR tv148[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv154[ebp], cl
	add	DWORD PTR tv148[ebp], 1
	cmp	BYTE PTR tv154[ebp], 0
	jne	SHORT $LL6@xmlShellRe
	mov	edx, DWORD PTR tv148[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR tv84[ebp], edx
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 88   :     ret = (char *) malloc(len + 1);

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 89   :     if (ret != NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN4@xmlShellRe

; 90   : 	memcpy (ret, line_read, len + 1);

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	push	edx
	lea	eax, DWORD PTR _line_read$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN4@xmlShellRe:

; 91   :     }
; 92   :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlShellRe:

; 93   : #endif
; 94   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@xmlShellRe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 536				; 00000218H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN9@xmlShellRe:
	DD	1
	DD	$LN8@xmlShellRe
$LN8@xmlShellRe:
	DD	-508					; fffffe04H
	DD	501					; 000001f5H
	DD	$LN7@xmlShellRe
$LN7@xmlShellRe:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
_xmlShellReadline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = -16						; size = 4
__Stream$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx
	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Stream$[ebp], eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Stream$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 961  :     }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Stream$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
