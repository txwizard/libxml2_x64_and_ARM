; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xmlstring.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__012E1D79_xmlstring@c DB 01H
msvcjmc	ENDS
CONST	SEGMENT
_casemap DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	040H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	05cH
	DB	05dH
	DB	05eH
	DB	05fH
	DB	060H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	07cH
	DB	07dH
	DB	07eH
	DB	07fH
	DB	080H
	DB	081H
	DB	082H
	DB	083H
	DB	084H
	DB	085H
	DB	086H
	DB	087H
	DB	088H
	DB	089H
	DB	08aH
	DB	08bH
	DB	08cH
	DB	08dH
	DB	08eH
	DB	08fH
	DB	090H
	DB	091H
	DB	092H
	DB	093H
	DB	094H
	DB	095H
	DB	096H
	DB	097H
	DB	098H
	DB	099H
	DB	09aH
	DB	09bH
	DB	09cH
	DB	09dH
	DB	09eH
	DB	09fH
	DB	0a0H
	DB	0a1H
	DB	0a2H
	DB	0a3H
	DB	0a4H
	DB	0a5H
	DB	0a6H
	DB	0a7H
	DB	0a8H
	DB	0a9H
	DB	0aaH
	DB	0abH
	DB	0acH
	DB	0adH
	DB	0aeH
	DB	0afH
	DB	0b0H
	DB	0b1H
	DB	0b2H
	DB	0b3H
	DB	0b4H
	DB	0b5H
	DB	0b6H
	DB	0b7H
	DB	0b8H
	DB	0b9H
	DB	0baH
	DB	0bbH
	DB	0bcH
	DB	0bdH
	DB	0beH
	DB	0bfH
	DB	0c0H
	DB	0c1H
	DB	0c2H
	DB	0c3H
	DB	0c4H
	DB	0c5H
	DB	0c6H
	DB	0c7H
	DB	0c8H
	DB	0c9H
	DB	0caH
	DB	0cbH
	DB	0ccH
	DB	0cdH
	DB	0ceH
	DB	0cfH
	DB	0d0H
	DB	0d1H
	DB	0d2H
	DB	0d3H
	DB	0d4H
	DB	0d5H
	DB	0d6H
	DB	0d7H
	DB	0d8H
	DB	0d9H
	DB	0daH
	DB	0dbH
	DB	0dcH
	DB	0ddH
	DB	0deH
	DB	0dfH
	DB	0e0H
	DB	0e1H
	DB	0e2H
	DB	0e3H
	DB	0e4H
	DB	0e5H
	DB	0e6H
	DB	0e7H
	DB	0e8H
	DB	0e9H
	DB	0eaH
	DB	0ebH
	DB	0ecH
	DB	0edH
	DB	0eeH
	DB	0efH
	DB	0f0H
	DB	0f1H
	DB	0f2H
	DB	0f3H
	DB	0f4H
	DB	0f5H
	DB	0f6H
	DB	0f7H
	DB	0f8H
	DB	0f9H
	DB	0faH
	DB	0fbH
	DB	0fcH
	DB	0fdH
	DB	0feH
	DB	0ffH
CONST	ENDS
PUBLIC	_xmlStrdup
PUBLIC	_xmlStrndup
PUBLIC	_xmlCharStrndup
PUBLIC	_xmlCharStrdup
PUBLIC	_xmlStrsub
PUBLIC	_xmlStrchr
PUBLIC	_xmlStrstr
PUBLIC	_xmlStrcasestr
PUBLIC	_xmlStrcmp
PUBLIC	_xmlStrncmp
PUBLIC	_xmlStrcasecmp
PUBLIC	_xmlStrncasecmp
PUBLIC	_xmlStrEqual
PUBLIC	_xmlStrQEqual
PUBLIC	_xmlStrlen
PUBLIC	_xmlStrcat
PUBLIC	_xmlStrncat
PUBLIC	_xmlStrncatNew
PUBLIC	_xmlStrPrintf
PUBLIC	_xmlStrVPrintf
PUBLIC	_xmlGetUTF8Char
PUBLIC	_xmlCheckUTF8
PUBLIC	_xmlUTF8Strsize
PUBLIC	_xmlUTF8Strndup
PUBLIC	_xmlUTF8Strpos
PUBLIC	_xmlUTF8Strloc
PUBLIC	_xmlUTF8Strsub
PUBLIC	_xmlUTF8Strlen
PUBLIC	_xmlUTF8Size
PUBLIC	_xmlUTF8Charcmp
PUBLIC	___local_stdio_printf_options
PUBLIC	_xmlEscapeFormatString
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BL@NMJALFKD@malloc?5of?5?$CFld?5byte?5failed?6@ ; `string'
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlErrMemory:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memcpy:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BL@NMJALFKD@malloc?5of?5?$CFld?5byte?5failed?6@
CONST	SEGMENT
??_C@_0BL@NMJALFKD@malloc?5of?5?$CFld?5byte?5failed?6@ DB 'malloc of %ld '
	DB	'byte failed', 0aH, 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlEscapeFormatString
_TEXT	SEGMENT
_resultLen$ = -24					; size = 4
_msgLen$ = -20						; size = 4
_count$ = -16						; size = 4
_resultPtr$ = -12					; size = 4
_result$ = -8						; size = 4
_msgPtr$ = -4						; size = 4
_msg$ = 8						; size = 4
_xmlEscapeFormatString PROC				; COMDAT

; 1002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 1003 :     xmlChar *msgPtr = NULL;

	mov	DWORD PTR _msgPtr$[ebp], 0

; 1004 :     xmlChar *result = NULL;

	mov	DWORD PTR _result$[ebp], 0

; 1005 :     xmlChar *resultPtr = NULL;

	mov	DWORD PTR _resultPtr$[ebp], 0

; 1006 :     size_t count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 1007 :     size_t msgLen = 0;

	mov	DWORD PTR _msgLen$[ebp], 0

; 1008 :     size_t resultLen = 0;

	mov	DWORD PTR _resultLen$[ebp], 0

; 1009 : 
; 1010 :     if (!msg || !*msg)

	cmp	DWORD PTR _msg$[ebp], 0
	je	SHORT $LN9@xmlEscapeF
	mov	eax, DWORD PTR _msg$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@xmlEscapeF
$LN9@xmlEscapeF:

; 1011 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlEscapeF
$LN8@xmlEscapeF:

; 1012 : 
; 1013 :     for (msgPtr = *msg; *msgPtr != '\0'; ++msgPtr) {

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _msgPtr$[ebp], edx
	jmp	SHORT $LN4@xmlEscapeF
$LN2@xmlEscapeF:
	mov	eax, DWORD PTR _msgPtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _msgPtr$[ebp], eax
$LN4@xmlEscapeF:
	mov	ecx, DWORD PTR _msgPtr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@xmlEscapeF

; 1014 :         ++msgLen;

	mov	eax, DWORD PTR _msgLen$[ebp]
	add	eax, 1
	mov	DWORD PTR _msgLen$[ebp], eax

; 1015 :         if (*msgPtr == '%')

	mov	ecx, DWORD PTR _msgPtr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	SHORT $LN10@xmlEscapeF

; 1016 :             ++count;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN10@xmlEscapeF:

; 1017 :     }

	jmp	SHORT $LN2@xmlEscapeF
$LN3@xmlEscapeF:

; 1018 : 
; 1019 :     if (count == 0)

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN11@xmlEscapeF

; 1020 :         return(*msg);

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [ecx]
	jmp	$LN1@xmlEscapeF
$LN11@xmlEscapeF:

; 1021 : 
; 1022 :     resultLen = msgLen + count + 1;

	mov	edx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _msgLen$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	mov	DWORD PTR _resultLen$[ebp], ecx

; 1023 :     result = (xmlChar *) xmlMallocAtomic(resultLen * sizeof(xmlChar));

	mov	esi, esp
	mov	edx, DWORD PTR _resultLen$[ebp]
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 1024 :     if (result == NULL) {

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $LN12@xmlEscapeF

; 1025 :         /* Clear *msg to prevent format string vulnerabilities in
; 1026 :            out-of-memory situations. */
; 1027 :         xmlFree(*msg);

	mov	esi, esp
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1028 :         *msg = NULL;

	mov	edx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR [edx], 0

; 1029 :         xmlErrMemory(NULL, NULL);

	push	0
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 1030 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlEscapeF
$LN12@xmlEscapeF:

; 1031 :     }
; 1032 : 
; 1033 :     for (msgPtr = *msg, resultPtr = result; *msgPtr != '\0'; ++msgPtr, ++resultPtr) {

	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _msgPtr$[ebp], ecx
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR _resultPtr$[ebp], edx
	jmp	SHORT $LN7@xmlEscapeF
$LN5@xmlEscapeF:
	mov	eax, DWORD PTR _msgPtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _msgPtr$[ebp], eax
	mov	ecx, DWORD PTR _resultPtr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _resultPtr$[ebp], ecx
$LN7@xmlEscapeF:
	mov	edx, DWORD PTR _msgPtr$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN6@xmlEscapeF

; 1034 :         *resultPtr = *msgPtr;

	mov	ecx, DWORD PTR _resultPtr$[ebp]
	mov	edx, DWORD PTR _msgPtr$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 1035 :         if (*msgPtr == '%')

	mov	ecx, DWORD PTR _msgPtr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	SHORT $LN13@xmlEscapeF

; 1036 :             *(++resultPtr) = '%';

	mov	eax, DWORD PTR _resultPtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _resultPtr$[ebp], eax
	mov	ecx, DWORD PTR _resultPtr$[ebp]
	mov	BYTE PTR [ecx], 37			; 00000025H
$LN13@xmlEscapeF:

; 1037 :     }

	jmp	SHORT $LN5@xmlEscapeF
$LN6@xmlEscapeF:

; 1038 :     result[resultLen - 1] = '\0';

	mov	edx, DWORD PTR _result$[ebp]
	add	edx, DWORD PTR _resultLen$[ebp]
	mov	BYTE PTR [edx-1], 0

; 1039 : 
; 1040 :     xmlFree(*msg);

	mov	esi, esp
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1041 :     *msg = result;

	mov	edx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [edx], eax

; 1042 : 
; 1043 :     return *msg;

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	eax, DWORD PTR [ecx]
$LN1@xmlEscapeF:

; 1044 : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlEscapeFormatString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Charcmp
_TEXT	SEGMENT
_utf1$ = 8						; size = 4
_utf2$ = 12						; size = 4
_xmlUTF8Charcmp PROC					; COMDAT

; 646  : xmlUTF8Charcmp(const xmlChar *utf1, const xmlChar *utf2) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 647  : 
; 648  :     if (utf1 == NULL ) {

	cmp	DWORD PTR _utf1$[ebp], 0
	jne	SHORT $LN2@xmlUTF8Cha

; 649  :         if (utf2 == NULL)

	cmp	DWORD PTR _utf2$[ebp], 0
	jne	SHORT $LN3@xmlUTF8Cha

; 650  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlUTF8Cha
$LN3@xmlUTF8Cha:

; 651  :         return -1;

	or	eax, -1
	jmp	SHORT $LN1@xmlUTF8Cha
$LN2@xmlUTF8Cha:

; 652  :     }
; 653  :     return xmlStrncmp(utf1, utf2, xmlUTF8Size(utf1));

	mov	eax, DWORD PTR _utf1$[ebp]
	push	eax
	call	_xmlUTF8Size
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _utf2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf1$[ebp]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
$LN1@xmlUTF8Cha:

; 654  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlUTF8Charcmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Size
_TEXT	SEGMENT
_len$ = -8						; size = 4
_mask$ = -1						; size = 1
_utf$ = 8						; size = 4
_xmlUTF8Size PROC					; COMDAT

; 615  : xmlUTF8Size(const xmlChar *utf) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 616  :     xmlChar mask;
; 617  :     int len;
; 618  : 
; 619  :     if (utf == NULL)

	cmp	DWORD PTR _utf$[ebp], 0
	jne	SHORT $LN5@xmlUTF8Siz

; 620  :         return -1;

	or	eax, -1
	jmp	SHORT $LN1@xmlUTF8Siz
$LN5@xmlUTF8Siz:

; 621  :     if (*utf < 0x80)

	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 128				; 00000080H
	jge	SHORT $LN6@xmlUTF8Siz

; 622  :         return 1;

	mov	eax, 1
	jmp	SHORT $LN1@xmlUTF8Siz
$LN6@xmlUTF8Siz:

; 623  :     /* check valid UTF8 character */
; 624  :     if (!(*utf & 0x40))

	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, 64					; 00000040H
	jne	SHORT $LN7@xmlUTF8Siz

; 625  :         return -1;

	or	eax, -1
	jmp	SHORT $LN1@xmlUTF8Siz
$LN7@xmlUTF8Siz:

; 626  :     /* determine number of bytes in char */
; 627  :     len = 2;

	mov	DWORD PTR _len$[ebp], 2

; 628  :     for (mask=0x20; mask != 0; mask>>=1) {

	mov	BYTE PTR _mask$[ebp], 32		; 00000020H
	jmp	SHORT $LN4@xmlUTF8Siz
$LN2@xmlUTF8Siz:
	mov	cl, BYTE PTR _mask$[ebp]
	shr	cl, 1
	mov	BYTE PTR _mask$[ebp], cl
$LN4@xmlUTF8Siz:
	movzx	edx, BYTE PTR _mask$[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlUTF8Siz

; 629  :         if (!(*utf & mask))

	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _mask$[ebp]
	and	ecx, edx
	jne	SHORT $LN8@xmlUTF8Siz

; 630  :             return len;

	mov	eax, DWORD PTR _len$[ebp]
	jmp	SHORT $LN1@xmlUTF8Siz
$LN8@xmlUTF8Siz:

; 631  :         len++;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 632  :     }

	jmp	SHORT $LN2@xmlUTF8Siz
$LN3@xmlUTF8Siz:

; 633  :     return -1;

	or	eax, -1
$LN1@xmlUTF8Siz:

; 634  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlUTF8Size ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strlen
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_utf$ = 8						; size = 4
_xmlUTF8Strlen PROC					; COMDAT

; 666  : xmlUTF8Strlen(const xmlChar *utf) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 667  :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 668  : 
; 669  :     if (utf == NULL)

	cmp	DWORD PTR _utf$[ebp], 0
	jne	SHORT $LN2@xmlUTF8Str

; 670  :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlUTF8Str
$LN2@xmlUTF8Str:

; 671  : 
; 672  :     while (*utf != 0) {

	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@xmlUTF8Str

; 673  :         if (utf[0] & 0x80) {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 128				; 00000080H
	je	$LN5@xmlUTF8Str

; 674  :             if ((utf[1] & 0xc0) != 0x80)

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 192				; 000000c0H
	cmp	edx, 128				; 00000080H
	je	SHORT $LN7@xmlUTF8Str

; 675  :                 return(-1);

	or	eax, -1
	jmp	$LN1@xmlUTF8Str
$LN7@xmlUTF8Str:

; 676  :             if ((utf[0] & 0xe0) == 0xe0) {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 224				; 000000e0H
	cmp	eax, 224				; 000000e0H
	jne	$LN8@xmlUTF8Str

; 677  :                 if ((utf[2] & 0xc0) != 0x80)

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN10@xmlUTF8Str

; 678  :                     return(-1);

	or	eax, -1
	jmp	$LN1@xmlUTF8Str
$LN10@xmlUTF8Str:

; 679  :                 if ((utf[0] & 0xf0) == 0xf0) {

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 240				; 000000f0H
	cmp	ecx, 240				; 000000f0H
	jne	SHORT $LN11@xmlUTF8Str

; 680  :                     if ((utf[0] & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 248				; 000000f8H
	cmp	edx, 240				; 000000f0H
	jne	SHORT $LN14@xmlUTF8Str
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN13@xmlUTF8Str
$LN14@xmlUTF8Str:

; 681  :                         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlUTF8Str
$LN13@xmlUTF8Str:

; 682  :                     utf += 4;

	mov	ecx, DWORD PTR _utf$[ebp]
	add	ecx, 4
	mov	DWORD PTR _utf$[ebp], ecx

; 683  :                 } else {

	jmp	SHORT $LN12@xmlUTF8Str
$LN11@xmlUTF8Str:

; 684  :                     utf += 3;

	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, 3
	mov	DWORD PTR _utf$[ebp], edx
$LN12@xmlUTF8Str:

; 685  :                 }
; 686  :             } else {

	jmp	SHORT $LN9@xmlUTF8Str
$LN8@xmlUTF8Str:

; 687  :                 utf += 2;

	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, 2
	mov	DWORD PTR _utf$[ebp], eax
$LN9@xmlUTF8Str:

; 688  :             }
; 689  :         } else {

	jmp	SHORT $LN6@xmlUTF8Str
$LN5@xmlUTF8Str:

; 690  :             utf++;

	mov	ecx, DWORD PTR _utf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _utf$[ebp], ecx
$LN6@xmlUTF8Str:

; 691  :         }
; 692  :         ret++;

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, 1
	mov	DWORD PTR _ret$[ebp], edx

; 693  :     }

	jmp	$LN2@xmlUTF8Str
$LN3@xmlUTF8Str:

; 694  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlUTF8Str:

; 695  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlUTF8Strlen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strsub
_TEXT	SEGMENT
tv90 = -24						; size = 4
tv89 = -20						; size = 4
tv73 = -16						; size = 4
tv72 = -12						; size = 4
_ch$ = -5						; size = 1
_i$ = -4						; size = 4
_utf$ = 8						; size = 4
_start$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlUTF8Strsub PROC					; COMDAT

; 964  : xmlUTF8Strsub(const xmlChar *utf, int start, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 965  :     int            i;
; 966  :     xmlChar ch;
; 967  : 
; 968  :     if (utf == NULL) return(NULL);

	cmp	DWORD PTR _utf$[ebp], 0
	jne	SHORT $LN7@xmlUTF8Str
	xor	eax, eax
	jmp	$LN1@xmlUTF8Str
$LN7@xmlUTF8Str:

; 969  :     if (start < 0) return(NULL);

	cmp	DWORD PTR _start$[ebp], 0
	jge	SHORT $LN8@xmlUTF8Str
	xor	eax, eax
	jmp	$LN1@xmlUTF8Str
$LN8@xmlUTF8Str:

; 970  :     if (len < 0) return(NULL);

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN9@xmlUTF8Str
	xor	eax, eax
	jmp	$LN1@xmlUTF8Str
$LN9@xmlUTF8Str:

; 971  : 
; 972  :     /*
; 973  :      * Skip over any leading chars
; 974  :      */
; 975  :     for (i = 0;i < start;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlUTF8Str
$LN2@xmlUTF8Str:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlUTF8Str:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _start$[ebp]
	jge	$LN3@xmlUTF8Str

; 976  :         if ((ch=*utf++) == 0) return(NULL);

	mov	edx, DWORD PTR _utf$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _ch$[ebp], al
	movzx	ecx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, 1
	mov	DWORD PTR _utf$[ebp], edx
	cmp	DWORD PTR tv72[ebp], 0
	jne	SHORT $LN15@xmlUTF8Str
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN16@xmlUTF8Str
$LN15@xmlUTF8Str:
	mov	DWORD PTR tv73[ebp], 0
$LN16@xmlUTF8Str:
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $LN10@xmlUTF8Str
	xor	eax, eax
	jmp	$LN1@xmlUTF8Str
$LN10@xmlUTF8Str:

; 977  :         if ( ch & 0x80 ) {

	movzx	eax, BYTE PTR _ch$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN11@xmlUTF8Str

; 978  :             /* if not simple ascii, verify proper format */
; 979  :             if ( (ch & 0xc0) != 0xc0 )

	movzx	ecx, BYTE PTR _ch$[ebp]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN5@xmlUTF8Str

; 980  :                 return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlUTF8Str
$LN5@xmlUTF8Str:

; 981  :             /* then skip over remaining bytes for this char */
; 982  :             while ( (ch <<= 1) & 0x80 )

	mov	dl, BYTE PTR _ch$[ebp]
	shl	dl, 1
	mov	BYTE PTR _ch$[ebp], dl
	movzx	eax, BYTE PTR _ch$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN11@xmlUTF8Str

; 983  :                 if ( (*utf++ & 0xc0) != 0x80 )

	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 192				; 000000c0H
	mov	DWORD PTR tv89[ebp], edx
	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, 1
	mov	DWORD PTR _utf$[ebp], eax
	cmp	DWORD PTR tv89[ebp], 128		; 00000080H
	je	SHORT $LN17@xmlUTF8Str
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN18@xmlUTF8Str
$LN17@xmlUTF8Str:
	mov	DWORD PTR tv90[ebp], 0
$LN18@xmlUTF8Str:
	cmp	DWORD PTR tv90[ebp], 0
	je	SHORT $LN13@xmlUTF8Str

; 984  :                     return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlUTF8Str
$LN13@xmlUTF8Str:
	jmp	SHORT $LN5@xmlUTF8Str
$LN11@xmlUTF8Str:

; 985  :         }
; 986  :     }

	jmp	$LN2@xmlUTF8Str
$LN3@xmlUTF8Str:

; 987  : 
; 988  :     return(xmlUTF8Strndup(utf, len));

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf$[ebp]
	push	edx
	call	_xmlUTF8Strndup
	add	esp, 8
$LN1@xmlUTF8Str:

; 989  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlUTF8Strsub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strloc
_TEXT	SEGMENT
tv93 = -20						; size = 4
tv92 = -16						; size = 4
_ch$ = -9						; size = 1
_size$ = -8						; size = 4
_i$ = -4						; size = 4
_utf$ = 8						; size = 4
_utfchar$ = 12						; size = 4
_xmlUTF8Strloc PROC					; COMDAT

; 927  : xmlUTF8Strloc(const xmlChar *utf, const xmlChar *utfchar) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 928  :     int i, size;
; 929  :     xmlChar ch;
; 930  : 
; 931  :     if (utf==NULL || utfchar==NULL) return -1;

	cmp	DWORD PTR _utf$[ebp], 0
	je	SHORT $LN8@xmlUTF8Str
	cmp	DWORD PTR _utfchar$[ebp], 0
	jne	SHORT $LN7@xmlUTF8Str
$LN8@xmlUTF8Str:
	or	eax, -1
	jmp	$LN1@xmlUTF8Str
$LN7@xmlUTF8Str:

; 932  :     size = xmlUTF8Strsize(utfchar, 1);

	push	1
	mov	eax, DWORD PTR _utfchar$[ebp]
	push	eax
	call	_xmlUTF8Strsize
	add	esp, 8
	mov	DWORD PTR _size$[ebp], eax

; 933  :         for(i=0; (ch=*utf) != 0; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlUTF8Str
$LN2@xmlUTF8Str:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlUTF8Str:
	mov	edx, DWORD PTR _utf$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _ch$[ebp], al
	movzx	ecx, BYTE PTR _ch$[ebp]
	test	ecx, ecx
	je	$LN3@xmlUTF8Str

; 934  :             if (xmlStrncmp(utf, utfchar, size)==0)

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _utfchar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _utf$[ebp]
	push	ecx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@xmlUTF8Str

; 935  :                 return(i);

	mov	eax, DWORD PTR _i$[ebp]
	jmp	$LN1@xmlUTF8Str
$LN9@xmlUTF8Str:

; 936  :             utf++;

	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, 1
	mov	DWORD PTR _utf$[ebp], edx

; 937  :             if ( ch & 0x80 ) {

	movzx	eax, BYTE PTR _ch$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN10@xmlUTF8Str

; 938  :                 /* if not simple ascii, verify proper format */
; 939  :                 if ( (ch & 0xc0) != 0xc0 )

	movzx	ecx, BYTE PTR _ch$[ebp]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN5@xmlUTF8Str

; 940  :                     return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlUTF8Str
$LN5@xmlUTF8Str:

; 941  :                 /* then skip over remaining bytes for this char */
; 942  :                 while ( (ch <<= 1) & 0x80 )

	mov	dl, BYTE PTR _ch$[ebp]
	shl	dl, 1
	mov	BYTE PTR _ch$[ebp], dl
	movzx	eax, BYTE PTR _ch$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN10@xmlUTF8Str

; 943  :                     if ( (*utf++ & 0xc0) != 0x80 )

	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 192				; 000000c0H
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, 1
	mov	DWORD PTR _utf$[ebp], eax
	cmp	DWORD PTR tv92[ebp], 128		; 00000080H
	je	SHORT $LN14@xmlUTF8Str
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN15@xmlUTF8Str
$LN14@xmlUTF8Str:
	mov	DWORD PTR tv93[ebp], 0
$LN15@xmlUTF8Str:
	cmp	DWORD PTR tv93[ebp], 0
	je	SHORT $LN12@xmlUTF8Str

; 944  :                         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlUTF8Str
$LN12@xmlUTF8Str:
	jmp	SHORT $LN5@xmlUTF8Str
$LN10@xmlUTF8Str:

; 945  :             }
; 946  :         }

	jmp	$LN2@xmlUTF8Str
$LN3@xmlUTF8Str:

; 947  : 
; 948  :     return(-1);

	or	eax, -1
$LN1@xmlUTF8Str:

; 949  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlUTF8Strloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strpos
_TEXT	SEGMENT
tv90 = -24						; size = 4
tv89 = -20						; size = 4
tv73 = -16						; size = 4
tv72 = -12						; size = 4
tv67 = -8						; size = 4
_ch$ = -1						; size = 1
_utf$ = 8						; size = 4
_pos$ = 12						; size = 4
_xmlUTF8Strpos PROC					; COMDAT

; 895  : xmlUTF8Strpos(const xmlChar *utf, int pos) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 896  :     xmlChar ch;
; 897  : 
; 898  :     if (utf == NULL) return(NULL);

	cmp	DWORD PTR _utf$[ebp], 0
	jne	SHORT $LN6@xmlUTF8Str
	xor	eax, eax
	jmp	$LN1@xmlUTF8Str
$LN6@xmlUTF8Str:

; 899  :     if (pos < 0)

	cmp	DWORD PTR _pos$[ebp], 0
	jge	SHORT $LN2@xmlUTF8Str

; 900  :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlUTF8Str
$LN2@xmlUTF8Str:

; 901  :     while (pos--) {

	mov	eax, DWORD PTR _pos$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR _pos$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _pos$[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 0
	je	$LN3@xmlUTF8Str

; 902  :         if ((ch=*utf++) == 0) return(NULL);

	mov	edx, DWORD PTR _utf$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _ch$[ebp], al
	movzx	ecx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, 1
	mov	DWORD PTR _utf$[ebp], edx
	cmp	DWORD PTR tv72[ebp], 0
	jne	SHORT $LN13@xmlUTF8Str
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN14@xmlUTF8Str
$LN13@xmlUTF8Str:
	mov	DWORD PTR tv73[ebp], 0
$LN14@xmlUTF8Str:
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $LN8@xmlUTF8Str
	xor	eax, eax
	jmp	SHORT $LN1@xmlUTF8Str
$LN8@xmlUTF8Str:

; 903  :         if ( ch & 0x80 ) {

	movzx	eax, BYTE PTR _ch$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN9@xmlUTF8Str

; 904  :             /* if not simple ascii, verify proper format */
; 905  :             if ( (ch & 0xc0) != 0xc0 )

	movzx	ecx, BYTE PTR _ch$[ebp]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN4@xmlUTF8Str

; 906  :                 return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlUTF8Str
$LN4@xmlUTF8Str:

; 907  :             /* then skip over remaining bytes for this char */
; 908  :             while ( (ch <<= 1) & 0x80 )

	mov	dl, BYTE PTR _ch$[ebp]
	shl	dl, 1
	mov	BYTE PTR _ch$[ebp], dl
	movzx	eax, BYTE PTR _ch$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN9@xmlUTF8Str

; 909  :                 if ( (*utf++ & 0xc0) != 0x80 )

	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 192				; 000000c0H
	mov	DWORD PTR tv89[ebp], edx
	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, 1
	mov	DWORD PTR _utf$[ebp], eax
	cmp	DWORD PTR tv89[ebp], 128		; 00000080H
	je	SHORT $LN15@xmlUTF8Str
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN16@xmlUTF8Str
$LN15@xmlUTF8Str:
	mov	DWORD PTR tv90[ebp], 0
$LN16@xmlUTF8Str:
	cmp	DWORD PTR tv90[ebp], 0
	je	SHORT $LN11@xmlUTF8Str

; 910  :                     return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlUTF8Str
$LN11@xmlUTF8Str:
	jmp	SHORT $LN4@xmlUTF8Str
$LN9@xmlUTF8Str:

; 911  :         }
; 912  :     }

	jmp	$LN2@xmlUTF8Str
$LN3@xmlUTF8Str:

; 913  :     return((xmlChar *)utf);

	mov	eax, DWORD PTR _utf$[ebp]
$LN1@xmlUTF8Str:

; 914  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlUTF8Strpos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strndup
_TEXT	SEGMENT
_i$ = -8						; size = 4
_ret$ = -4						; size = 4
_utf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlUTF8Strndup PROC					; COMDAT

; 866  : xmlUTF8Strndup(const xmlChar *utf, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 867  :     xmlChar *ret;
; 868  :     int i;
; 869  : 
; 870  :     if ((utf == NULL) || (len < 0)) return(NULL);

	cmp	DWORD PTR _utf$[ebp], 0
	je	SHORT $LN3@xmlUTF8Str
	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN2@xmlUTF8Str
$LN3@xmlUTF8Str:
	xor	eax, eax
	jmp	$LN1@xmlUTF8Str
$LN2@xmlUTF8Str:

; 871  :     i = xmlUTF8Strsize(utf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _utf$[ebp]
	push	ecx
	call	_xmlUTF8Strsize
	add	esp, 8
	mov	DWORD PTR _i$[ebp], eax

; 872  :     ret = (xmlChar *) xmlMallocAtomic((i + 1) * sizeof(xmlChar));

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 873  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN4@xmlUTF8Str

; 874  :         xmlGenericError(xmlGenericErrorContext,

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_0BL@NMJALFKD@malloc?5of?5?$CFld?5byte?5failed?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 875  :                 "malloc of %ld byte failed\n",
; 876  :                 (len + 1) * (long)sizeof(xmlChar));
; 877  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlUTF8Str
$LN4@xmlUTF8Str:

; 878  :     }
; 879  :     memcpy(ret, utf, i * sizeof(xmlChar));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _utf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 880  :     ret[i] = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], 0

; 881  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlUTF8Str:

; 882  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlUTF8Strndup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlUTF8Strsize
_TEXT	SEGMENT
tv76 = -20						; size = 4
tv69 = -16						; size = 4
tv68 = -12						; size = 4
_ch$ = -5						; size = 1
_ptr$ = -4						; size = 4
_utf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlUTF8Strsize PROC					; COMDAT

; 833  : xmlUTF8Strsize(const xmlChar *utf, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 834  :     const xmlChar   *ptr=utf;

	mov	eax, DWORD PTR _utf$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 835  :     xmlChar         ch;
; 836  : 
; 837  :     if (utf == NULL)

	cmp	DWORD PTR _utf$[ebp], 0
	jne	SHORT $LN6@xmlUTF8Str

; 838  :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlUTF8Str
$LN6@xmlUTF8Str:

; 839  : 
; 840  :     if (len <= 0)

	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN2@xmlUTF8Str

; 841  :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlUTF8Str
$LN2@xmlUTF8Str:

; 842  : 
; 843  :     while ( len-- > 0) {

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, 1
	mov	DWORD PTR _len$[ebp], edx
	cmp	DWORD PTR tv68[ebp], 0
	jle	SHORT $LN12@xmlUTF8Str
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN13@xmlUTF8Str
$LN12@xmlUTF8Str:
	mov	DWORD PTR tv69[ebp], 0
$LN13@xmlUTF8Str:
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN3@xmlUTF8Str

; 844  :         if ( !*ptr )

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN8@xmlUTF8Str

; 845  :             break;

	jmp	SHORT $LN3@xmlUTF8Str
$LN8@xmlUTF8Str:

; 846  :         if ( (ch = *ptr++) & 0x80)

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _ch$[ebp], al
	movzx	ecx, BYTE PTR _ch$[ebp]
	and	ecx, 128				; 00000080H
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN9@xmlUTF8Str
$LN4@xmlUTF8Str:

; 847  :             while ((ch<<=1) & 0x80 ) {

	mov	al, BYTE PTR _ch$[ebp]
	shl	al, 1
	mov	BYTE PTR _ch$[ebp], al
	movzx	ecx, BYTE PTR _ch$[ebp]
	and	ecx, 128				; 00000080H
	je	SHORT $LN9@xmlUTF8Str

; 848  : 		if (*ptr == 0) break;

	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN10@xmlUTF8Str
	jmp	SHORT $LN9@xmlUTF8Str
$LN10@xmlUTF8Str:

; 849  :                 ptr++;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$[ebp], ecx

; 850  : 	    }

	jmp	SHORT $LN4@xmlUTF8Str
$LN9@xmlUTF8Str:

; 851  :     }

	jmp	$LN2@xmlUTF8Str
$LN3@xmlUTF8Str:

; 852  :     return (ptr - utf);

	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, DWORD PTR _utf$[ebp]
$LN1@xmlUTF8Str:

; 853  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlUTF8Strsize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlCheckUTF8
_TEXT	SEGMENT
_c$ = -5						; size = 1
_ix$ = -4						; size = 4
_utf$ = 8						; size = 4
_xmlCheckUTF8 PROC					; COMDAT

; 782  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 783  :     int ix;
; 784  :     unsigned char c;
; 785  : 
; 786  :     if (utf == NULL)

	cmp	DWORD PTR _utf$[ebp], 0
	jne	SHORT $LN5@xmlCheckUT

; 787  :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCheckUT
$LN5@xmlCheckUT:

; 788  :     /*
; 789  :      * utf is a string of 1, 2, 3 or 4 bytes.  The valid strings
; 790  :      * are as follows (in "bit format"):
; 791  :      *    0xxxxxxx                                      valid 1-byte
; 792  :      *    110xxxxx 10xxxxxx                             valid 2-byte
; 793  :      *    1110xxxx 10xxxxxx 10xxxxxx                    valid 3-byte
; 794  :      *    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx           valid 4-byte
; 795  :      */
; 796  :     for (ix = 0; (c = utf[ix]);) {      /* string is 0-terminated */

	mov	DWORD PTR _ix$[ebp], 0
$LN4@xmlCheckUT:
	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, DWORD PTR _ix$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$[ebp], cl
	movzx	edx, BYTE PTR _c$[ebp]
	test	edx, edx
	je	$LN3@xmlCheckUT

; 797  :         if ((c & 0x80) == 0x00) {	/* 1-byte code, starts with 10 */

	movzx	eax, BYTE PTR _c$[ebp]
	and	eax, 128				; 00000080H
	jne	SHORT $LN6@xmlCheckUT

; 798  :             ix++;

	mov	ecx, DWORD PTR _ix$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ix$[ebp], ecx
	jmp	$LN7@xmlCheckUT
$LN6@xmlCheckUT:

; 799  : 	} else if ((c & 0xe0) == 0xc0) {/* 2-byte code, starts with 110 */

	movzx	edx, BYTE PTR _c$[ebp]
	and	edx, 224				; 000000e0H
	cmp	edx, 192				; 000000c0H
	jne	SHORT $LN8@xmlCheckUT

; 800  : 	    if ((utf[ix+1] & 0xc0 ) != 0x80)

	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, DWORD PTR _ix$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 128				; 00000080H
	je	SHORT $LN10@xmlCheckUT

; 801  : 	        return 0;

	xor	eax, eax
	jmp	$LN1@xmlCheckUT
$LN10@xmlCheckUT:

; 802  : 	    ix += 2;

	mov	edx, DWORD PTR _ix$[ebp]
	add	edx, 2
	mov	DWORD PTR _ix$[ebp], edx
	jmp	$LN7@xmlCheckUT
$LN8@xmlCheckUT:

; 803  : 	} else if ((c & 0xf0) == 0xe0) {/* 3-byte code, starts with 1110 */

	movzx	eax, BYTE PTR _c$[ebp]
	and	eax, 240				; 000000f0H
	cmp	eax, 224				; 000000e0H
	jne	SHORT $LN11@xmlCheckUT

; 804  : 	    if (((utf[ix+1] & 0xc0) != 0x80) ||

	mov	ecx, DWORD PTR _utf$[ebp]
	add	ecx, DWORD PTR _ix$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	and	edx, 192				; 000000c0H
	cmp	edx, 128				; 00000080H
	jne	SHORT $LN14@xmlCheckUT
	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, DWORD PTR _ix$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 128				; 00000080H
	je	SHORT $LN13@xmlCheckUT
$LN14@xmlCheckUT:

; 805  : 	        ((utf[ix+2] & 0xc0) != 0x80))
; 806  : 		    return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlCheckUT
$LN13@xmlCheckUT:

; 807  : 	    ix += 3;

	mov	edx, DWORD PTR _ix$[ebp]
	add	edx, 3
	mov	DWORD PTR _ix$[ebp], edx
	jmp	SHORT $LN7@xmlCheckUT
$LN11@xmlCheckUT:

; 808  : 	} else if ((c & 0xf8) == 0xf0) {/* 4-byte code, starts with 11110 */

	movzx	eax, BYTE PTR _c$[ebp]
	and	eax, 248				; 000000f8H
	cmp	eax, 240				; 000000f0H
	jne	SHORT $LN15@xmlCheckUT

; 809  : 	    if (((utf[ix+1] & 0xc0) != 0x80) ||
; 810  : 	        ((utf[ix+2] & 0xc0) != 0x80) ||

	mov	ecx, DWORD PTR _utf$[ebp]
	add	ecx, DWORD PTR _ix$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	and	edx, 192				; 000000c0H
	cmp	edx, 128				; 00000080H
	jne	SHORT $LN18@xmlCheckUT
	mov	eax, DWORD PTR _utf$[ebp]
	add	eax, DWORD PTR _ix$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	and	ecx, 192				; 000000c0H
	cmp	ecx, 128				; 00000080H
	jne	SHORT $LN18@xmlCheckUT
	mov	edx, DWORD PTR _utf$[ebp]
	add	edx, DWORD PTR _ix$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN17@xmlCheckUT
$LN18@xmlCheckUT:

; 811  : 		((utf[ix+3] & 0xc0) != 0x80))
; 812  : 		    return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlCheckUT
$LN17@xmlCheckUT:

; 813  : 	    ix += 4;

	mov	ecx, DWORD PTR _ix$[ebp]
	add	ecx, 4
	mov	DWORD PTR _ix$[ebp], ecx

; 814  : 	} else				/* unknown encoding */

	jmp	SHORT $LN7@xmlCheckUT
$LN15@xmlCheckUT:

; 815  : 	    return 0;

	xor	eax, eax
	jmp	SHORT $LN1@xmlCheckUT
$LN7@xmlCheckUT:

; 816  :       }

	jmp	$LN4@xmlCheckUT
$LN3@xmlCheckUT:

; 817  :       return(1);

	mov	eax, 1
$LN1@xmlCheckUT:

; 818  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCheckUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlGetUTF8Char
_TEXT	SEGMENT
_c$ = -4						; size = 4
_utf$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlGetUTF8Char PROC					; COMDAT

; 710  : xmlGetUTF8Char(const unsigned char *utf, int *len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 711  :     unsigned int c;
; 712  : 
; 713  :     if (utf == NULL)

	cmp	DWORD PTR _utf$[ebp], 0
	jne	SHORT $LN2@xmlGetUTF8

; 714  :         goto error;

	jmp	$error$20
$LN2@xmlGetUTF8:

; 715  :     if (len == NULL)

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN3@xmlGetUTF8

; 716  :         goto error;

	jmp	$error$20
$LN3@xmlGetUTF8:

; 717  :     if (*len < 1)

	mov	eax, DWORD PTR _len$[ebp]
	cmp	DWORD PTR [eax], 1
	jge	SHORT $LN4@xmlGetUTF8

; 718  :         goto error;

	jmp	$error$20
$LN4@xmlGetUTF8:

; 719  : 
; 720  :     c = utf[0];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR _c$[ebp], ecx

; 721  :     if (c & 0x80) {

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 128				; 00000080H
	je	$LN5@xmlGetUTF8

; 722  :         if (*len < 2)

	mov	eax, DWORD PTR _len$[ebp]
	cmp	DWORD PTR [eax], 2
	jge	SHORT $LN7@xmlGetUTF8

; 723  :             goto error;

	jmp	$error$20
$LN7@xmlGetUTF8:

; 724  :         if ((utf[1] & 0xc0) != 0x80)

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN8@xmlGetUTF8

; 725  :             goto error;

	jmp	$error$20
$LN8@xmlGetUTF8:

; 726  :         if ((c & 0xe0) == 0xe0) {

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, 224				; 000000e0H
	cmp	ecx, 224				; 000000e0H
	jne	$LN9@xmlGetUTF8

; 727  :             if (*len < 3)

	mov	edx, DWORD PTR _len$[ebp]
	cmp	DWORD PTR [edx], 3
	jge	SHORT $LN11@xmlGetUTF8

; 728  :                 goto error;

	jmp	$error$20
$LN11@xmlGetUTF8:

; 729  :             if ((utf[2] & 0xc0) != 0x80)

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 192				; 000000c0H
	cmp	edx, 128				; 00000080H
	je	SHORT $LN12@xmlGetUTF8

; 730  :                 goto error;

	jmp	$error$20
$LN12@xmlGetUTF8:

; 731  :             if ((c & 0xf0) == 0xf0) {

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 240				; 000000f0H
	cmp	eax, 240				; 000000f0H
	jne	$LN13@xmlGetUTF8

; 732  :                 if (*len < 4)

	mov	ecx, DWORD PTR _len$[ebp]
	cmp	DWORD PTR [ecx], 4
	jge	SHORT $LN15@xmlGetUTF8

; 733  :                     goto error;

	jmp	$error$20
$LN15@xmlGetUTF8:

; 734  :                 if ((c & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 248				; 000000f8H
	cmp	edx, 240				; 000000f0H
	jne	SHORT $LN17@xmlGetUTF8
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	je	SHORT $LN16@xmlGetUTF8
$LN17@xmlGetUTF8:

; 735  :                     goto error;

	jmp	$error$20
$LN16@xmlGetUTF8:

; 736  :                 *len = 4;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], 4

; 737  :                 /* 4-byte code */
; 738  :                 c = (utf[0] & 0x7) << 18;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 7
	shl	edx, 18					; 00000012H
	mov	DWORD PTR _c$[ebp], edx

; 739  :                 c |= (utf[1] & 0x3f) << 12;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	shl	edx, 12					; 0000000cH
	or	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 740  :                 c |= (utf[2] & 0x3f) << 6;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	shl	edx, 6
	or	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 741  :                 c |= utf[3] & 0x3f;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _utf$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 742  :             } else {

	jmp	SHORT $LN14@xmlGetUTF8
$LN13@xmlGetUTF8:

; 743  :               /* 3-byte code */
; 744  :                 *len = 3;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [ecx], 3

; 745  :                 c = (utf[0] & 0xf) << 12;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 15					; 0000000fH
	shl	edx, 12					; 0000000cH
	mov	DWORD PTR _c$[ebp], edx

; 746  :                 c |= (utf[1] & 0x3f) << 6;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	shl	edx, 6
	or	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 747  :                 c |= utf[2] & 0x3f;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _utf$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	or	edx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], edx
$LN14@xmlGetUTF8:

; 748  :             }
; 749  :         } else {

	jmp	SHORT $LN10@xmlGetUTF8
$LN9@xmlGetUTF8:

; 750  :           /* 2-byte code */
; 751  :             *len = 2;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax], 2

; 752  :             c = (utf[0] & 0x1f) << 6;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 31					; 0000001fH
	shl	ecx, 6
	mov	DWORD PTR _c$[ebp], ecx

; 753  :             c |= utf[1] & 0x3f;

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _utf$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], ecx
$LN10@xmlGetUTF8:

; 754  :         }
; 755  :     } else {

	jmp	SHORT $LN6@xmlGetUTF8
$LN5@xmlGetUTF8:

; 756  :         /* 1-byte code */
; 757  :         *len = 1;

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx], 1
$LN6@xmlGetUTF8:

; 758  :     }
; 759  :     return(c);

	mov	eax, DWORD PTR _c$[ebp]
	jmp	SHORT $LN1@xmlGetUTF8
$error$20:

; 760  : 
; 761  : error:
; 762  :     if (len != NULL)

	cmp	DWORD PTR _len$[ebp], 0
	je	SHORT $LN18@xmlGetUTF8

; 763  : 	*len = 0;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax], 0
$LN18@xmlGetUTF8:

; 764  :     return(-1);

	or	eax, -1
$LN1@xmlGetUTF8:

; 765  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetUTF8Char ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrVPrintf
_TEXT	SEGMENT
tv85 = -12						; size = 4
__Result$1 = -8						; size = 4
_ret$ = -4						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_msg$ = 16						; size = 4
_ap$ = 20						; size = 4
_xmlStrVPrintf PROC					; COMDAT

; 577  : xmlStrVPrintf(xmlChar *buf, int len, const char *msg, va_list ap) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 578  :     int ret;
; 579  : 
; 580  :     if((buf == NULL) || (msg == NULL)) {

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlStrVPri
	cmp	DWORD PTR _msg$[ebp], 0
	jne	SHORT $LN2@xmlStrVPri
$LN3@xmlStrVPri:

; 581  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlStrVPri
$LN2@xmlStrVPri:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	eax, DWORD PTR _ap$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN7@xmlStrVPri
	mov	DWORD PTR tv85[ebp], -1
	jmp	SHORT $LN5@xmlStrVPri
$LN7@xmlStrVPri:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv85[ebp], eax
$LN5@xmlStrVPri:
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c

; 584  :     ret = vsnprintf((char *) buf, len, (const char *) msg, ap);

	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR _ret$[ebp], ecx

; 585  :     buf[len - 1] = 0; /* be safe ! */

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx-1], 0

; 586  : 
; 587  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlStrVPri:

; 588  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrVPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrPrintf
_TEXT	SEGMENT
tv86 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
_ret$ = -8						; size = 4
_args$ = -4						; size = 4
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
_msg$ = 16						; size = 4
_xmlStrPrintf PROC					; COMDAT

; 549  : xmlStrPrintf(xmlChar *buf, int len, const char *msg, ...) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 550  :     va_list args;
; 551  :     int ret;
; 552  : 
; 553  :     if((buf == NULL) || (msg == NULL)) {

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN3@xmlStrPrin
	cmp	DWORD PTR _msg$[ebp], 0
	jne	SHORT $LN2@xmlStrPrin
$LN3@xmlStrPrin:

; 554  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlStrPrin
$LN2@xmlStrPrin:

; 555  :     }
; 556  : 
; 557  :     va_start(args, msg);

	lea	eax, DWORD PTR _msg$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 558  :     ret = vsnprintf((char *) buf, len, (const char *) msg, args);

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN7@xmlStrPrin
	mov	DWORD PTR tv86[ebp], -1
	jmp	SHORT $LN5@xmlStrPrin
$LN7@xmlStrPrin:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv86[ebp], eax
$LN5@xmlStrPrin:
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c

; 558  :     ret = vsnprintf((char *) buf, len, (const char *) msg, args);

	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _ret$[ebp], ecx

; 559  :     va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 560  :     buf[len - 1] = 0; /* be safe ! */

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx-1], 0

; 561  : 
; 562  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlStrPrin:

; 563  : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrncatNew
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_size$ = -4						; size = 4
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlStrncatNew PROC					; COMDAT

; 485  : xmlStrncatNew(const xmlChar *str1, const xmlChar *str2, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 486  :     int size;
; 487  :     xmlChar *ret;
; 488  : 
; 489  :     if (len < 0) {

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN2@xmlStrncat

; 490  :         len = xmlStrlen(str2);

	mov	eax, DWORD PTR _str2$[ebp]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 491  :         if (len < 0)

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN2@xmlStrncat

; 492  :             return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlStrncat
$LN2@xmlStrncat:

; 493  :     }
; 494  :     if ((str2 == NULL) || (len == 0))

	cmp	DWORD PTR _str2$[ebp], 0
	je	SHORT $LN5@xmlStrncat
	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN4@xmlStrncat
$LN5@xmlStrncat:

; 495  :         return(xmlStrdup(str1));

	mov	ecx, DWORD PTR _str1$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	jmp	$LN1@xmlStrncat
$LN4@xmlStrncat:

; 496  :     if (str1 == NULL)

	cmp	DWORD PTR _str1$[ebp], 0
	jne	SHORT $LN6@xmlStrncat

; 497  :         return(xmlStrndup(str2, len));

	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _str2$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	jmp	$LN1@xmlStrncat
$LN6@xmlStrncat:

; 498  : 
; 499  :     size = xmlStrlen(str1);

	mov	ecx, DWORD PTR _str1$[ebp]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 500  :     if (size < 0)

	cmp	DWORD PTR _size$[ebp], 0
	jge	SHORT $LN7@xmlStrncat

; 501  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlStrncat
$LN7@xmlStrncat:

; 502  :     ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));

	mov	edx, DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 503  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN8@xmlStrncat

; 504  :         xmlErrMemory(NULL, NULL);

	push	0
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 505  :         return(xmlStrndup(str1, size));

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _str1$[ebp]
	push	eax
	call	_xmlStrndup
	add	esp, 8
	jmp	SHORT $LN1@xmlStrncat
$LN8@xmlStrncat:

; 506  :     }
; 507  :     memcpy(ret, str1, size * sizeof(xmlChar));

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str1$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 508  :     memcpy(&ret[size], str2, len * sizeof(xmlChar));

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str2$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 509  :     ret[size + len] = 0;

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 510  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlStrncat:

; 511  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrncatNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrncat
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_size$ = -4						; size = 4
_cur$ = 8						; size = 4
_add$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlStrncat PROC					; COMDAT

; 448  : xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 449  :     int size;
; 450  :     xmlChar *ret;
; 451  : 
; 452  :     if ((add == NULL) || (len == 0))

	cmp	DWORD PTR _add$[ebp], 0
	je	SHORT $LN3@xmlStrncat
	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN2@xmlStrncat
$LN3@xmlStrncat:

; 453  :         return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	jmp	$LN1@xmlStrncat
$LN2@xmlStrncat:

; 454  :     if (len < 0)

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN4@xmlStrncat

; 455  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlStrncat
$LN4@xmlStrncat:

; 456  :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN5@xmlStrncat

; 457  :         return(xmlStrndup(add, len));

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _add$[ebp]
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	jmp	SHORT $LN1@xmlStrncat
$LN5@xmlStrncat:

; 458  : 
; 459  :     size = xmlStrlen(cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 460  :     if (size < 0)

	cmp	DWORD PTR _size$[ebp], 0
	jge	SHORT $LN6@xmlStrncat

; 461  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlStrncat
$LN6@xmlStrncat:

; 462  :     ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));

	mov	eax, DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 463  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN7@xmlStrncat

; 464  :         xmlErrMemory(NULL, NULL);

	push	0
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 465  :         return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	jmp	SHORT $LN1@xmlStrncat
$LN7@xmlStrncat:

; 466  :     }
; 467  :     memcpy(&ret[size], add, len * sizeof(xmlChar));

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _add$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 468  :     ret[size + len] = 0;

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 469  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlStrncat:

; 470  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrncat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrcat
_TEXT	SEGMENT
_p$ = -4						; size = 4
_cur$ = 8						; size = 4
_add$ = 12						; size = 4
_xmlStrcat PROC						; COMDAT

; 526  : xmlStrcat(xmlChar *cur, const xmlChar *add) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 527  :     const xmlChar *p = add;

	mov	eax, DWORD PTR _add$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 528  : 
; 529  :     if (add == NULL) return(cur);

	cmp	DWORD PTR _add$[ebp], 0
	jne	SHORT $LN4@xmlStrcat
	mov	eax, DWORD PTR _cur$[ebp]
	jmp	SHORT $LN1@xmlStrcat
$LN4@xmlStrcat:

; 530  :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlStrcat

; 531  :         return(xmlStrdup(add));

	mov	ecx, DWORD PTR _add$[ebp]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	jmp	SHORT $LN1@xmlStrcat
$LN2@xmlStrcat:

; 532  : 
; 533  :     while (*p != 0) p++; /* non input consuming */

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@xmlStrcat
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN2@xmlStrcat
$LN3@xmlStrcat:

; 534  :     return(xmlStrncat(cur, add, p - add));

	mov	edx, DWORD PTR _p$[ebp]
	sub	edx, DWORD PTR _add$[ebp]
	push	edx
	mov	eax, DWORD PTR _add$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlStrncat
	add	esp, 12					; 0000000cH
$LN1@xmlStrcat:

; 535  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrcat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrlen
_TEXT	SEGMENT
_len$ = -4						; size = 4
_str$ = 8						; size = 4
_xmlStrlen PROC						; COMDAT

; 422  : xmlStrlen(const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 423  :     int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 424  : 
; 425  :     if (str == NULL) return(0);

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@xmlStrlen
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrlen
$LN2@xmlStrlen:

; 426  :     while (*str != 0) { /* non input consuming */

	mov	eax, DWORD PTR _str$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@xmlStrlen

; 427  :         str++;

	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx

; 428  :         len++;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 429  :     }

	jmp	SHORT $LN2@xmlStrlen
$LN3@xmlStrlen:

; 430  :     return(len);

	mov	eax, DWORD PTR _len$[ebp]
$LN1@xmlStrlen:

; 431  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrlen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrQEqual
_TEXT	SEGMENT
tv131 = -37						; size = 1
tv128 = -36						; size = 4
tv95 = -32						; size = 4
tv94 = -28						; size = 4
tv88 = -24						; size = 4
tv87 = -20						; size = 4
tv79 = -13						; size = 1
tv76 = -12						; size = 4
tv75 = -8						; size = 4
tv74 = -4						; size = 4
_pref$ = 8						; size = 4
_name$ = 12						; size = 4
_str$ = 16						; size = 4
_xmlStrQEqual PROC					; COMDAT

; 179  : xmlStrQEqual(const xmlChar *pref, const xmlChar *name, const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 180  :     if (pref == NULL) return(xmlStrEqual(name, str));

	cmp	DWORD PTR _pref$[ebp], 0
	jne	SHORT $LN8@xmlStrQEqu
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	jmp	$LN1@xmlStrQEqu
$LN8@xmlStrQEqu:

; 181  :     if (name == NULL) return(0);

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN9@xmlStrQEqu
	xor	eax, eax
	jmp	$LN1@xmlStrQEqu
$LN9@xmlStrQEqu:

; 182  :     if (str == NULL) return(0);

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN4@xmlStrQEqu
	xor	eax, eax
	jmp	$LN1@xmlStrQEqu
$LN4@xmlStrQEqu:

; 183  : 
; 184  :     do {
; 185  :         if (*pref++ != *str) return(0);

	mov	edx, DWORD PTR _pref$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv74[ebp], eax
	mov	ecx, DWORD PTR _str$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv75[ebp], edx
	mov	eax, DWORD PTR _pref$[ebp]
	add	eax, 1
	mov	DWORD PTR _pref$[ebp], eax
	mov	ecx, DWORD PTR tv74[ebp]
	cmp	ecx, DWORD PTR tv75[ebp]
	je	SHORT $LN16@xmlStrQEqu
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN17@xmlStrQEqu
$LN16@xmlStrQEqu:
	mov	DWORD PTR tv76[ebp], 0
$LN17@xmlStrQEqu:
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@xmlStrQEqu
	xor	eax, eax
	jmp	$LN1@xmlStrQEqu
$LN2@xmlStrQEqu:

; 186  :     } while ((*str++) && (*pref));

	mov	edx, DWORD PTR _str$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv79[ebp], al
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str$[ebp], ecx
	movzx	edx, BYTE PTR tv79[ebp]
	test	edx, edx
	je	SHORT $LN3@xmlStrQEqu
	mov	eax, DWORD PTR _pref$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@xmlStrQEqu
$LN3@xmlStrQEqu:

; 187  :     if (*str++ != ':') return(0);

	mov	edx, DWORD PTR _str$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv87[ebp], eax
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str$[ebp], ecx
	cmp	DWORD PTR tv87[ebp], 58			; 0000003aH
	je	SHORT $LN18@xmlStrQEqu
	mov	DWORD PTR tv88[ebp], 1
	jmp	SHORT $LN19@xmlStrQEqu
$LN18@xmlStrQEqu:
	mov	DWORD PTR tv88[ebp], 0
$LN19@xmlStrQEqu:
	cmp	DWORD PTR tv88[ebp], 0
	je	SHORT $LN7@xmlStrQEqu
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrQEqu
$LN7@xmlStrQEqu:

; 188  :     do {
; 189  :         if (*name++ != *str) return(0);

	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR _str$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv95[ebp], edx
	mov	eax, DWORD PTR _name$[ebp]
	add	eax, 1
	mov	DWORD PTR _name$[ebp], eax
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR tv95[ebp]
	je	SHORT $LN20@xmlStrQEqu
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN21@xmlStrQEqu
$LN20@xmlStrQEqu:
	mov	DWORD PTR tv128[ebp], 0
$LN21@xmlStrQEqu:
	cmp	DWORD PTR tv128[ebp], 0
	je	SHORT $LN5@xmlStrQEqu
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrQEqu
$LN5@xmlStrQEqu:

; 190  :     } while (*str++);

	mov	edx, DWORD PTR _str$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv131[ebp], al
	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str$[ebp], ecx
	movzx	edx, BYTE PTR tv131[ebp]
	test	edx, edx
	jne	SHORT $LN7@xmlStrQEqu

; 191  :     return(1);

	mov	eax, 1
$LN1@xmlStrQEqu:

; 192  : }

	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrQEqual ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrEqual
_TEXT	SEGMENT
tv76 = -13						; size = 1
tv73 = -12						; size = 4
tv72 = -8						; size = 4
tv71 = -4						; size = 4
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_xmlStrEqual PROC					; COMDAT

; 157  : xmlStrEqual(const xmlChar *str1, const xmlChar *str2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 158  :     if (str1 == str2) return(1);

	mov	eax, DWORD PTR _str1$[ebp]
	cmp	eax, DWORD PTR _str2$[ebp]
	jne	SHORT $LN5@xmlStrEqua
	mov	eax, 1
	jmp	SHORT $LN1@xmlStrEqua
$LN5@xmlStrEqua:

; 159  :     if (str1 == NULL) return(0);

	cmp	DWORD PTR _str1$[ebp], 0
	jne	SHORT $LN6@xmlStrEqua
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrEqua
$LN6@xmlStrEqua:

; 160  :     if (str2 == NULL) return(0);

	cmp	DWORD PTR _str2$[ebp], 0
	jne	SHORT $LN4@xmlStrEqua
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrEqua
$LN4@xmlStrEqua:

; 161  :     do {
; 162  :         if (*str1++ != *str2) return(0);

	mov	ecx, DWORD PTR _str1$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv71[ebp], edx
	mov	eax, DWORD PTR _str2$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR _str1$[ebp]
	add	edx, 1
	mov	DWORD PTR _str1$[ebp], edx
	mov	eax, DWORD PTR tv71[ebp]
	cmp	eax, DWORD PTR tv72[ebp]
	je	SHORT $LN10@xmlStrEqua
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN11@xmlStrEqua
$LN10@xmlStrEqua:
	mov	DWORD PTR tv73[ebp], 0
$LN11@xmlStrEqua:
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $LN2@xmlStrEqua
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrEqua
$LN2@xmlStrEqua:

; 163  :     } while (*str2++);

	mov	ecx, DWORD PTR _str2$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv76[ebp], dl
	mov	eax, DWORD PTR _str2$[ebp]
	add	eax, 1
	mov	DWORD PTR _str2$[ebp], eax
	movzx	ecx, BYTE PTR tv76[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@xmlStrEqua

; 164  :     return(1);

	mov	eax, 1
$LN1@xmlStrEqua:

; 165  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrEqual ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrncasecmp
_TEXT	SEGMENT
tv85 = -12						; size = 4
tv84 = -8						; size = 4
_tmp$ = -4						; size = 4
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlStrncasecmp PROC					; COMDAT

; 296  : xmlStrncasecmp(const xmlChar *str1, const xmlChar *str2, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 297  :     register int tmp;
; 298  : 
; 299  :     if (len <= 0) return(0);

	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN5@xmlStrncas
	xor	eax, eax
	jmp	$LN1@xmlStrncas
$LN5@xmlStrncas:

; 300  :     if (str1 == str2) return(0);

	mov	eax, DWORD PTR _str1$[ebp]
	cmp	eax, DWORD PTR _str2$[ebp]
	jne	SHORT $LN6@xmlStrncas
	xor	eax, eax
	jmp	$LN1@xmlStrncas
$LN6@xmlStrncas:

; 301  :     if (str1 == NULL) return(-1);

	cmp	DWORD PTR _str1$[ebp], 0
	jne	SHORT $LN7@xmlStrncas
	or	eax, -1
	jmp	SHORT $LN1@xmlStrncas
$LN7@xmlStrncas:

; 302  :     if (str2 == NULL) return(1);

	cmp	DWORD PTR _str2$[ebp], 0
	jne	SHORT $LN4@xmlStrncas
	mov	eax, 1
	jmp	SHORT $LN1@xmlStrncas
$LN4@xmlStrncas:

; 303  :     do {
; 304  :         tmp = casemap[*str1++] - casemap[*str2];

	mov	ecx, DWORD PTR _str1$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _casemap[edx]
	mov	ecx, DWORD PTR _str2$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	ecx, BYTE PTR _casemap[edx]
	sub	eax, ecx
	mov	DWORD PTR _tmp$[ebp], eax
	mov	edx, DWORD PTR _str1$[ebp]
	add	edx, 1
	mov	DWORD PTR _str1$[ebp], edx

; 305  :         if (tmp != 0 || --len == 0) return(tmp);

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN10@xmlStrncas
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	jne	SHORT $LN2@xmlStrncas
$LN10@xmlStrncas:
	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	SHORT $LN1@xmlStrncas
$LN2@xmlStrncas:

; 306  :     } while (*str2++ != 0);

	mov	ecx, DWORD PTR _str2$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv84[ebp], edx
	mov	eax, DWORD PTR _str2$[ebp]
	add	eax, 1
	mov	DWORD PTR _str2$[ebp], eax
	cmp	DWORD PTR tv84[ebp], 0
	je	SHORT $LN12@xmlStrncas
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN13@xmlStrncas
$LN12@xmlStrncas:
	mov	DWORD PTR tv85[ebp], 0
$LN13@xmlStrncas:
	cmp	DWORD PTR tv85[ebp], 0
	jne	SHORT $LN4@xmlStrncas

; 307  :     return 0;

	xor	eax, eax
$LN1@xmlStrncas:

; 308  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrncasecmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrcasecmp
_TEXT	SEGMENT
tv82 = -12						; size = 4
tv81 = -8						; size = 4
_tmp$ = -4						; size = 4
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_xmlStrcasecmp PROC					; COMDAT

; 271  : xmlStrcasecmp(const xmlChar *str1, const xmlChar *str2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 272  :     register int tmp;
; 273  : 
; 274  :     if (str1 == str2) return(0);

	mov	eax, DWORD PTR _str1$[ebp]
	cmp	eax, DWORD PTR _str2$[ebp]
	jne	SHORT $LN5@xmlStrcase
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrcase
$LN5@xmlStrcase:

; 275  :     if (str1 == NULL) return(-1);

	cmp	DWORD PTR _str1$[ebp], 0
	jne	SHORT $LN6@xmlStrcase
	or	eax, -1
	jmp	SHORT $LN1@xmlStrcase
$LN6@xmlStrcase:

; 276  :     if (str2 == NULL) return(1);

	cmp	DWORD PTR _str2$[ebp], 0
	jne	SHORT $LN4@xmlStrcase
	mov	eax, 1
	jmp	SHORT $LN1@xmlStrcase
$LN4@xmlStrcase:

; 277  :     do {
; 278  :         tmp = casemap[*str1++] - casemap[*str2];

	mov	ecx, DWORD PTR _str1$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _casemap[edx]
	mov	ecx, DWORD PTR _str2$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	ecx, BYTE PTR _casemap[edx]
	sub	eax, ecx
	mov	DWORD PTR _tmp$[ebp], eax
	mov	edx, DWORD PTR _str1$[ebp]
	add	edx, 1
	mov	DWORD PTR _str1$[ebp], edx

; 279  :         if (tmp != 0) return(tmp);

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN2@xmlStrcase
	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	SHORT $LN1@xmlStrcase
$LN2@xmlStrcase:

; 280  :     } while (*str2++ != 0);

	mov	eax, DWORD PTR _str2$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv81[ebp], ecx
	mov	edx, DWORD PTR _str2$[ebp]
	add	edx, 1
	mov	DWORD PTR _str2$[ebp], edx
	cmp	DWORD PTR tv81[ebp], 0
	je	SHORT $LN10@xmlStrcase
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN11@xmlStrcase
$LN10@xmlStrcase:
	mov	DWORD PTR tv82[ebp], 0
$LN11@xmlStrcase:
	cmp	DWORD PTR tv82[ebp], 0
	jne	SHORT $LN4@xmlStrcase

; 281  :     return 0;

	xor	eax, eax
$LN1@xmlStrcase:

; 282  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrcasecmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrncmp
_TEXT	SEGMENT
tv79 = -12						; size = 4
tv78 = -8						; size = 4
_tmp$ = -4						; size = 4
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlStrncmp PROC					; COMDAT

; 206  : xmlStrncmp(const xmlChar *str1, const xmlChar *str2, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 207  :     register int tmp;
; 208  : 
; 209  :     if (len <= 0) return(0);

	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN5@xmlStrncmp
	xor	eax, eax
	jmp	$LN1@xmlStrncmp
$LN5@xmlStrncmp:

; 210  :     if (str1 == str2) return(0);

	mov	eax, DWORD PTR _str1$[ebp]
	cmp	eax, DWORD PTR _str2$[ebp]
	jne	SHORT $LN6@xmlStrncmp
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrncmp
$LN6@xmlStrncmp:

; 211  :     if (str1 == NULL) return(-1);

	cmp	DWORD PTR _str1$[ebp], 0
	jne	SHORT $LN7@xmlStrncmp
	or	eax, -1
	jmp	SHORT $LN1@xmlStrncmp
$LN7@xmlStrncmp:

; 212  :     if (str2 == NULL) return(1);

	cmp	DWORD PTR _str2$[ebp], 0
	jne	SHORT $LN4@xmlStrncmp
	mov	eax, 1
	jmp	SHORT $LN1@xmlStrncmp
$LN4@xmlStrncmp:

; 213  : #ifdef __GNUC__
; 214  :     tmp = strncmp((const char *)str1, (const char *)str2, len);
; 215  :     return tmp;
; 216  : #else
; 217  :     do {
; 218  :         tmp = *str1++ - *str2;

	mov	ecx, DWORD PTR _str1$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _str2$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	mov	DWORD PTR _tmp$[ebp], edx
	mov	edx, DWORD PTR _str1$[ebp]
	add	edx, 1
	mov	DWORD PTR _str1$[ebp], edx

; 219  :         if (tmp != 0 || --len == 0) return(tmp);

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN10@xmlStrncmp
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	jne	SHORT $LN2@xmlStrncmp
$LN10@xmlStrncmp:
	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	SHORT $LN1@xmlStrncmp
$LN2@xmlStrncmp:

; 220  :     } while (*str2++ != 0);

	mov	ecx, DWORD PTR _str2$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv78[ebp], edx
	mov	eax, DWORD PTR _str2$[ebp]
	add	eax, 1
	mov	DWORD PTR _str2$[ebp], eax
	cmp	DWORD PTR tv78[ebp], 0
	je	SHORT $LN12@xmlStrncmp
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN13@xmlStrncmp
$LN12@xmlStrncmp:
	mov	DWORD PTR tv79[ebp], 0
$LN13@xmlStrncmp:
	cmp	DWORD PTR tv79[ebp], 0
	jne	SHORT $LN4@xmlStrncmp

; 221  :     return 0;

	xor	eax, eax
$LN1@xmlStrncmp:

; 222  : #endif
; 223  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrncmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrcmp
_TEXT	SEGMENT
tv76 = -12						; size = 4
tv75 = -8						; size = 4
_tmp$ = -4						; size = 4
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_xmlStrcmp PROC						; COMDAT

; 132  : xmlStrcmp(const xmlChar *str1, const xmlChar *str2) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 133  :     register int tmp;
; 134  : 
; 135  :     if (str1 == str2) return(0);

	mov	eax, DWORD PTR _str1$[ebp]
	cmp	eax, DWORD PTR _str2$[ebp]
	jne	SHORT $LN5@xmlStrcmp
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrcmp
$LN5@xmlStrcmp:

; 136  :     if (str1 == NULL) return(-1);

	cmp	DWORD PTR _str1$[ebp], 0
	jne	SHORT $LN6@xmlStrcmp
	or	eax, -1
	jmp	SHORT $LN1@xmlStrcmp
$LN6@xmlStrcmp:

; 137  :     if (str2 == NULL) return(1);

	cmp	DWORD PTR _str2$[ebp], 0
	jne	SHORT $LN4@xmlStrcmp
	mov	eax, 1
	jmp	SHORT $LN1@xmlStrcmp
$LN4@xmlStrcmp:

; 138  :     do {
; 139  :         tmp = *str1++ - *str2;

	mov	ecx, DWORD PTR _str1$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _str2$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	mov	DWORD PTR _tmp$[ebp], edx
	mov	edx, DWORD PTR _str1$[ebp]
	add	edx, 1
	mov	DWORD PTR _str1$[ebp], edx

; 140  :         if (tmp != 0) return(tmp);

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN2@xmlStrcmp
	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	SHORT $LN1@xmlStrcmp
$LN2@xmlStrcmp:

; 141  :     } while (*str2++ != 0);

	mov	eax, DWORD PTR _str2$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv75[ebp], ecx
	mov	edx, DWORD PTR _str2$[ebp]
	add	edx, 1
	mov	DWORD PTR _str2$[ebp], edx
	cmp	DWORD PTR tv75[ebp], 0
	je	SHORT $LN10@xmlStrcmp
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN11@xmlStrcmp
$LN10@xmlStrcmp:
	mov	DWORD PTR tv76[ebp], 0
$LN11@xmlStrcmp:
	cmp	DWORD PTR tv76[ebp], 0
	jne	SHORT $LN4@xmlStrcmp

; 142  :     return 0;

	xor	eax, eax
$LN1@xmlStrcmp:

; 143  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrcmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrcasestr
_TEXT	SEGMENT
_n$ = -4						; size = 4
_str$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlStrcasestr PROC					; COMDAT

; 369  : xmlStrcasestr(const xmlChar *str, const xmlChar *val) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 370  :     int n;
; 371  : 
; 372  :     if (str == NULL) return(NULL);

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN4@xmlStrcase
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrcase
$LN4@xmlStrcase:

; 373  :     if (val == NULL) return(NULL);

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN5@xmlStrcase
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrcase
$LN5@xmlStrcase:

; 374  :     n = xmlStrlen(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 375  : 
; 376  :     if (n == 0) return(str);

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN2@xmlStrcase
	mov	eax, DWORD PTR _str$[ebp]
	jmp	SHORT $LN1@xmlStrcase
$LN2@xmlStrcase:

; 377  :     while (*str != 0) { /* non input consuming */

	mov	ecx, DWORD PTR _str$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@xmlStrcase

; 378  :         if (casemap[*str] == casemap[*val])

	mov	eax, DWORD PTR _str$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _casemap[ecx]
	mov	eax, DWORD PTR _val$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	eax, BYTE PTR _casemap[ecx]
	cmp	edx, eax
	jne	SHORT $LN7@xmlStrcase

; 379  :             if (!xmlStrncasecmp(str, val, n)) return(str);

	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlStrncasecmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@xmlStrcase
	mov	eax, DWORD PTR _str$[ebp]
	jmp	SHORT $LN1@xmlStrcase
$LN7@xmlStrcase:

; 380  :         str++;

	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str$[ebp], ecx

; 381  :     }

	jmp	SHORT $LN2@xmlStrcase
$LN3@xmlStrcase:

; 382  :     return(NULL);

	xor	eax, eax
$LN1@xmlStrcase:

; 383  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrcasestr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrstr
_TEXT	SEGMENT
_n$ = -4						; size = 4
_str$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlStrstr PROC						; COMDAT

; 341  : xmlStrstr(const xmlChar *str, const xmlChar *val) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 342  :     int n;
; 343  : 
; 344  :     if (str == NULL) return(NULL);

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN4@xmlStrstr
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrstr
$LN4@xmlStrstr:

; 345  :     if (val == NULL) return(NULL);

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN5@xmlStrstr
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrstr
$LN5@xmlStrstr:

; 346  :     n = xmlStrlen(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 347  : 
; 348  :     if (n == 0) return(str);

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN2@xmlStrstr
	mov	eax, DWORD PTR _str$[ebp]
	jmp	SHORT $LN1@xmlStrstr
$LN2@xmlStrstr:

; 349  :     while (*str != 0) { /* non input consuming */

	mov	ecx, DWORD PTR _str$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@xmlStrstr

; 350  :         if (*str == *val) {

	mov	eax, DWORD PTR _str$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _val$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN7@xmlStrstr

; 351  :             if (!xmlStrncmp(str, val, n)) return((const xmlChar *) str);

	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@xmlStrstr
	mov	eax, DWORD PTR _str$[ebp]
	jmp	SHORT $LN1@xmlStrstr
$LN7@xmlStrstr:

; 352  :         }
; 353  :         str++;

	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str$[ebp], ecx

; 354  :     }

	jmp	SHORT $LN2@xmlStrstr
$LN3@xmlStrstr:

; 355  :     return(NULL);

	xor	eax, eax
$LN1@xmlStrstr:

; 356  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrstr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrchr
_TEXT	SEGMENT
_str$ = 8						; size = 4
_val$ = 12						; size = 1
_xmlStrchr PROC						; COMDAT

; 321  : xmlStrchr(const xmlChar *str, xmlChar val) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 322  :     if (str == NULL) return(NULL);

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@xmlStrchr
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrchr
$LN2@xmlStrchr:

; 323  :     while (*str != 0) { /* non input consuming */

	mov	eax, DWORD PTR _str$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@xmlStrchr

; 324  :         if (*str == val) return((xmlChar *) str);

	mov	edx, DWORD PTR _str$[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _val$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN5@xmlStrchr
	mov	eax, DWORD PTR _str$[ebp]
	jmp	SHORT $LN1@xmlStrchr
$LN5@xmlStrchr:

; 325  :         str++;

	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx

; 326  :     }

	jmp	SHORT $LN2@xmlStrchr
$LN3@xmlStrchr:

; 327  :     return(NULL);

	xor	eax, eax
$LN1@xmlStrchr:

; 328  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlStrchr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrsub
_TEXT	SEGMENT
_i$ = -4						; size = 4
_str$ = 8						; size = 4
_start$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlStrsub PROC						; COMDAT

; 397  : xmlStrsub(const xmlChar *str, int start, int len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 398  :     int i;
; 399  : 
; 400  :     if (str == NULL) return(NULL);

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN5@xmlStrsub
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrsub
$LN5@xmlStrsub:

; 401  :     if (start < 0) return(NULL);

	cmp	DWORD PTR _start$[ebp], 0
	jge	SHORT $LN6@xmlStrsub
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrsub
$LN6@xmlStrsub:

; 402  :     if (len < 0) return(NULL);

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN7@xmlStrsub
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrsub
$LN7@xmlStrsub:

; 403  : 
; 404  :     for (i = 0;i < start;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlStrsub
$LN2@xmlStrsub:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlStrsub:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _start$[ebp]
	jge	SHORT $LN3@xmlStrsub

; 405  :         if (*str == 0) return(NULL);

	mov	edx, DWORD PTR _str$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN8@xmlStrsub
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrsub
$LN8@xmlStrsub:

; 406  :         str++;

	mov	ecx, DWORD PTR _str$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str$[ebp], ecx

; 407  :     }

	jmp	SHORT $LN2@xmlStrsub
$LN3@xmlStrsub:

; 408  :     if (*str == 0) return(NULL);

	mov	edx, DWORD PTR _str$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN9@xmlStrsub
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrsub
$LN9@xmlStrsub:

; 409  :     return(xmlStrndup(str, len));

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
$LN1@xmlStrsub:

; 410  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrsub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlCharStrdup
_TEXT	SEGMENT
_p$ = -4						; size = 4
_cur$ = 8						; size = 4
_xmlCharStrdup PROC					; COMDAT

; 113  : xmlCharStrdup(const char *cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 114  :     const char *p = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 115  : 
; 116  :     if (cur == NULL) return(NULL);

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlCharStr
	xor	eax, eax
	jmp	SHORT $LN1@xmlCharStr
$LN2@xmlCharStr:

; 117  :     while (*p != '\0') p++; /* non input consuming */

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@xmlCharStr
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN2@xmlCharStr
$LN3@xmlCharStr:

; 118  :     return(xmlCharStrndup(cur, p - cur));

	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlCharStrndup
	add	esp, 8
$LN1@xmlCharStr:

; 119  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCharStrdup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlCharStrndup
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_i$ = -4						; size = 4
_cur$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlCharStrndup PROC					; COMDAT

; 85   : xmlCharStrndup(const char *cur, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 86   :     int i;
; 87   :     xmlChar *ret;
; 88   : 
; 89   :     if ((cur == NULL) || (len < 0)) return(NULL);

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@xmlCharStr
	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN5@xmlCharStr
$LN6@xmlCharStr:
	xor	eax, eax
	jmp	SHORT $LN1@xmlCharStr
$LN5@xmlCharStr:

; 90   :     ret = (xmlChar *) xmlMallocAtomic((len + 1) * sizeof(xmlChar));

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 91   :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN7@xmlCharStr

; 92   :         xmlErrMemory(NULL, NULL);

	push	0
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 93   :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlCharStr
$LN7@xmlCharStr:

; 94   :     }
; 95   :     for (i = 0;i < len;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlCharStr
$LN2@xmlCharStr:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlCharStr:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jge	SHORT $LN3@xmlCharStr

; 96   :         ret[i] = (xmlChar) cur[i];

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 97   :         if (ret[i] == 0) return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN8@xmlCharStr
	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlCharStr
$LN8@xmlCharStr:

; 98   :     }

	jmp	SHORT $LN2@xmlCharStr
$LN3@xmlCharStr:

; 99   :     ret[len] = 0;

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [edx], 0

; 100  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCharStr:

; 101  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCharStrndup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrndup
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_cur$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlStrndup PROC					; COMDAT

; 41   : xmlStrndup(const xmlChar *cur, int len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 42   :     xmlChar *ret;
; 43   : 
; 44   :     if ((cur == NULL) || (len < 0)) return(NULL);

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@xmlStrndup
	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN2@xmlStrndup
$LN3@xmlStrndup:
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrndup
$LN2@xmlStrndup:

; 45   :     ret = (xmlChar *) xmlMallocAtomic((len + 1) * sizeof(xmlChar));

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 46   :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN4@xmlStrndup

; 47   :         xmlErrMemory(NULL, NULL);

	push	0
	push	0
	call	_xmlErrMemory
	add	esp, 8

; 48   :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlStrndup
$LN4@xmlStrndup:

; 49   :     }
; 50   :     memcpy(ret, cur, len * sizeof(xmlChar));

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 51   :     ret[len] = 0;

	mov	ecx, DWORD PTR _ret$[ebp]
	add	ecx, DWORD PTR _len$[ebp]
	mov	BYTE PTR [ecx], 0

; 52   :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlStrndup:

; 53   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrndup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xmlstring.c
;	COMDAT _xmlStrdup
_TEXT	SEGMENT
_p$ = -4						; size = 4
_cur$ = 8						; size = 4
_xmlStrdup PROC						; COMDAT

; 66   : xmlStrdup(const xmlChar *cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __012E1D79_xmlstring@c
	call	@__CheckForDebuggerJustMyCode@4

; 67   :     const xmlChar *p = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 68   : 
; 69   :     if (cur == NULL) return(NULL);

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlStrdup
	xor	eax, eax
	jmp	SHORT $LN1@xmlStrdup
$LN2@xmlStrdup:

; 70   :     while (*p != 0) p++; /* non input consuming */

	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@xmlStrdup
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN2@xmlStrdup
$LN3@xmlStrdup:

; 71   :     return(xmlStrndup(cur, p - cur));

	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlStrndup
	add	esp, 8
$LN1@xmlStrdup:

; 72   : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlStrdup ENDP
_TEXT	ENDS
END
