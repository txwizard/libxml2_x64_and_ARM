; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xpointer.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlXPathNAN:QWORD
COMM	_xmlXPathPINF:QWORD
COMM	_xmlXPathNINF:QWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__BEF3E6F7_xpointer@c DB 01H
msvcjmc	ENDS
PUBLIC	_xmlXPtrLocationSetCreate
PUBLIC	_xmlXPtrFreeLocationSet
PUBLIC	_xmlXPtrLocationSetMerge
PUBLIC	_xmlXPtrNewRange
PUBLIC	_xmlXPtrNewRangePoints
PUBLIC	_xmlXPtrNewRangeNodePoint
PUBLIC	_xmlXPtrNewRangePointNode
PUBLIC	_xmlXPtrNewRangeNodes
PUBLIC	_xmlXPtrNewLocationSetNodes
PUBLIC	_xmlXPtrNewLocationSetNodeSet
PUBLIC	_xmlXPtrNewRangeNodeObject
PUBLIC	_xmlXPtrNewCollapsedRange
PUBLIC	_xmlXPtrLocationSetAdd
PUBLIC	_xmlXPtrWrapLocationSet
PUBLIC	_xmlXPtrLocationSetDel
PUBLIC	_xmlXPtrLocationSetRemove
PUBLIC	_xmlXPtrNewContext
PUBLIC	_xmlXPtrEval
PUBLIC	_xmlXPtrRangeToFunction
PUBLIC	_xmlXPtrBuildNodeList
PUBLIC	_xmlXPtrEvalRangePredicate
PUBLIC	_xmlXPtrAdvanceNode
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BB@DMDDEGKA@allocating?5point@		; `string'
PUBLIC	??_C@_0BB@PBEHJOM@allocating?5range@		; `string'
PUBLIC	??_C@_0BH@HNICMPAH@allocating?5locationset@	; `string'
PUBLIC	??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@	; `string'
PUBLIC	??_C@_0BC@MDOPFBLJ@allocating?5buffer@		; `string'
PUBLIC	??_C@_08DNJCJFMK@xpointer@			; `string'
PUBLIC	??_C@_07HCLJNICE@element@			; `string'
PUBLIC	??_C@_05PPEFOGKI@xmlns@				; `string'
PUBLIC	??_C@_0BJ@PBEDODCO@unsupported?5scheme?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0CG@PNGJONJE@warning?3?5ChildSeq?5not?5starting?5@ ; `string'
PUBLIC	??_C@_0BO@HMMGLLBJ@allocating?5evaluation?5context@ ; `string'
PUBLIC	??_C@_05CCGOGOBM@range@				; `string'
PUBLIC	??_C@_0N@FPBCPIBK@range?9inside@		; `string'
PUBLIC	??_C@_0N@NHPDEMLM@string?9range@		; `string'
PUBLIC	??_C@_0M@KAHBAHMC@start?9point@			; `string'
PUBLIC	??_C@_09BKKFPLJK@end?9point@			; `string'
PUBLIC	??_C@_04NDJIBAID@here@				; `string'
PUBLIC	??_C@_07NGBELOAG@?5origin@			; `string'
PUBLIC	??_C@_0DF@PGJMIHPP@xmlXPtrEval?3?5evaluation?5failed?5@ ; `string'
PUBLIC	??_C@_0CP@NCKIHCDF@xmlXPtrEval?3?5object?$CIs?$CJ?5left?5on?5@ ; `string'
PUBLIC	??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@ ; `string'
PUBLIC	??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ ; `string'
PUBLIC	??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrncmp:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	_xmlNewText:PROC
EXTRN	_xmlNewTextLen:PROC
EXTRN	_xmlCopyNode:PROC
EXTRN	_xmlAddChild:PROC
EXTRN	_xmlAddNextSibling:PROC
EXTRN	_xmlResetError:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	___xmlGenericError:PROC
EXTRN	___xmlGenericErrorContext:PROC
EXTRN	_xmlXPathFreeObject:PROC
EXTRN	_xmlXPathObjectCopy:PROC
EXTRN	_xmlXPathCmpNodes:PROC
EXTRN	_xmlXPathNewContext:PROC
EXTRN	_xmlXPathInit:PROC
EXTRN	_xmlParseURI:PROC
EXTRN	_xmlSaveUri:PROC
EXTRN	_xmlFreeURI:PROC
EXTRN	_xmlXPathErr:PROC
EXTRN	_xmlXPathRegisterNs:PROC
EXTRN	_xmlXPathRegisterFunc:PROC
EXTRN	_xmlXPathNewParserContext:PROC
EXTRN	_xmlXPathFreeParserContext:PROC
EXTRN	_valuePop:PROC
EXTRN	_valuePush:PROC
EXTRN	_xmlXPathNewString:PROC
EXTRN	_xmlXPathNewNodeSet:PROC
EXTRN	_xmlXPathRoot:PROC
EXTRN	_xmlXPathEvalExpr:PROC
EXTRN	_xmlXPathParseName:PROC
EXTRN	_xmlXPathParseNCName:PROC
EXTRN	_xmlXPathEvaluatePredicateResult:PROC
EXTRN	_xmlXPathIdFunction:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memset:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@ DB 'Internal erro'
	DB	'r at %s:%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
CONST	SEGMENT
??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@ DB 'Unimplem'
	DB	'ented block at %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
CONST	SEGMENT
??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@ DB 'c:\users\dag'
	DB	'\documents\_clients\codeproject authors group\windows on arm\'
	DB	'libxml2\libxml2-2.9.9\xpointer.c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NCKIHCDF@xmlXPtrEval?3?5object?$CIs?$CJ?5left?5on?5@
CONST	SEGMENT
??_C@_0CP@NCKIHCDF@xmlXPtrEval?3?5object?$CIs?$CJ?5left?5on?5@ DB 'xmlXPt'
	DB	'rEval: object(s) left on the eval stack', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PGJMIHPP@xmlXPtrEval?3?5evaluation?5failed?5@
CONST	SEGMENT
??_C@_0DF@PGJMIHPP@xmlXPtrEval?3?5evaluation?5failed?5@ DB 'xmlXPtrEval: '
	DB	'evaluation failed to return a node set', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NGBELOAG@?5origin@
CONST	SEGMENT
??_C@_07NGBELOAG@?5origin@ DB ' origin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NDJIBAID@here@
CONST	SEGMENT
??_C@_04NDJIBAID@here@ DB 'here', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BKKFPLJK@end?9point@
CONST	SEGMENT
??_C@_09BKKFPLJK@end?9point@ DB 'end-point', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KAHBAHMC@start?9point@
CONST	SEGMENT
??_C@_0M@KAHBAHMC@start?9point@ DB 'start-point', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NHPDEMLM@string?9range@
CONST	SEGMENT
??_C@_0N@NHPDEMLM@string?9range@ DB 'string-range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FPBCPIBK@range?9inside@
CONST	SEGMENT
??_C@_0N@FPBCPIBK@range?9inside@ DB 'range-inside', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCGOGOBM@range@
CONST	SEGMENT
??_C@_05CCGOGOBM@range@ DB 'range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HMMGLLBJ@allocating?5evaluation?5context@
CONST	SEGMENT
??_C@_0BO@HMMGLLBJ@allocating?5evaluation?5context@ DB 'allocating evalua'
	DB	'tion context', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PNGJONJE@warning?3?5ChildSeq?5not?5starting?5@
CONST	SEGMENT
??_C@_0CG@PNGJONJE@warning?3?5ChildSeq?5not?5starting?5@ DB 'warning: Chi'
	DB	'ldSeq not starting by /1', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PBEDODCO@unsupported?5scheme?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BJ@PBEDODCO@unsupported?5scheme?5?8?$CFs?8?6@ DB 'unsupported sche'
	DB	'me ''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPEFOGKI@xmlns@
CONST	SEGMENT
??_C@_05PPEFOGKI@xmlns@ DB 'xmlns', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07HCLJNICE@element@
CONST	SEGMENT
??_C@_07HCLJNICE@element@ DB 'element', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DNJCJFMK@xpointer@
CONST	SEGMENT
??_C@_08DNJCJFMK@xpointer@ DB 'xpointer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
CONST	SEGMENT
??_C@_0BC@MDOPFBLJ@allocating?5buffer@ DB 'allocating buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@
CONST	SEGMENT
??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@ DB 'adding location to set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HNICMPAH@allocating?5locationset@
CONST	SEGMENT
??_C@_0BH@HNICMPAH@allocating?5locationset@ DB 'allocating locationset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PBEHJOM@allocating?5range@
CONST	SEGMENT
??_C@_0BB@PBEHJOM@allocating?5range@ DB 'allocating range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DMDDEGKA@allocating?5point@
CONST	SEGMENT
??_C@_0BB@DMDDEGKA@allocating?5point@ DB 'allocating point', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@ DB 'Memory al'
	DB	'location failed : %s', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetEndPoint
_TEXT	SEGMENT
tv68 = -4						; size = 4
_obj$ = 8						; size = 4
_node$ = 12						; size = 4
_indx$ = 16						; size = 4
_xmlXPtrGetEndPoint PROC				; COMDAT

; 2634 : xmlXPtrGetEndPoint(xmlXPathObjectPtr obj, xmlNodePtr *node, int *indx) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2635 :     if ((obj == NULL) || (node == NULL) || (indx == NULL))

	cmp	DWORD PTR _obj$[ebp], 0
	je	SHORT $LN5@xmlXPtrGet
	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN5@xmlXPtrGet
	cmp	DWORD PTR _indx$[ebp], 0
	jne	SHORT $LN4@xmlXPtrGet
$LN5@xmlXPtrGet:

; 2636 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlXPtrGet
$LN4@xmlXPtrGet:

; 2637 : 
; 2638 :     switch (obj->type) {

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 5
	je	SHORT $LN6@xmlXPtrGet
	cmp	DWORD PTR tv68[ebp], 6
	je	SHORT $LN9@xmlXPtrGet
	jmp	SHORT $LN2@xmlXPtrGet
$LN6@xmlXPtrGet:

; 2639 :         case XPATH_POINT:
; 2640 : 	    *node = obj->user;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx], ecx

; 2641 : 	    if (obj->index <= 0)

	mov	edx, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jg	SHORT $LN7@xmlXPtrGet

; 2642 : 		*indx = 0;

	mov	eax, DWORD PTR _indx$[ebp]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN8@xmlXPtrGet
$LN7@xmlXPtrGet:

; 2643 : 	    else
; 2644 : 		*indx = obj->index;

	mov	ecx, DWORD PTR _indx$[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx], eax
$LN8@xmlXPtrGet:

; 2645 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrGet
$LN9@xmlXPtrGet:

; 2646 :         case XPATH_RANGE:
; 2647 : 	    *node = obj->user;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx], eax

; 2648 : 	    if (obj->index <= 0)

	mov	ecx, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	jg	SHORT $LN10@xmlXPtrGet

; 2649 : 		*indx = 0;

	mov	edx, DWORD PTR _indx$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN11@xmlXPtrGet
$LN10@xmlXPtrGet:

; 2650 : 	    else
; 2651 : 		*indx = obj->index;

	mov	eax, DWORD PTR _indx$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax], edx
$LN11@xmlXPtrGet:

; 2652 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrGet
$LN2@xmlXPtrGet:

; 2653 : 	default:
; 2654 : 	    break;
; 2655 :     }
; 2656 :     return(-1);

	or	eax, -1
$LN1@xmlXPtrGet:

; 2657 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrGetEndPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetStartPoint
_TEXT	SEGMENT
tv68 = -4						; size = 4
_obj$ = 8						; size = 4
_node$ = 12						; size = 4
_indx$ = 16						; size = 4
_xmlXPtrGetStartPoint PROC				; COMDAT

; 2598 : xmlXPtrGetStartPoint(xmlXPathObjectPtr obj, xmlNodePtr *node, int *indx) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2599 :     if ((obj == NULL) || (node == NULL) || (indx == NULL))

	cmp	DWORD PTR _obj$[ebp], 0
	je	SHORT $LN5@xmlXPtrGet
	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN5@xmlXPtrGet
	cmp	DWORD PTR _indx$[ebp], 0
	jne	SHORT $LN4@xmlXPtrGet
$LN5@xmlXPtrGet:

; 2600 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlXPtrGet
$LN4@xmlXPtrGet:

; 2601 : 
; 2602 :     switch (obj->type) {

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 5
	je	SHORT $LN6@xmlXPtrGet
	cmp	DWORD PTR tv68[ebp], 6
	je	SHORT $LN9@xmlXPtrGet
	jmp	SHORT $LN2@xmlXPtrGet
$LN6@xmlXPtrGet:

; 2603 :         case XPATH_POINT:
; 2604 : 	    *node = obj->user;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx], ecx

; 2605 : 	    if (obj->index <= 0)

	mov	edx, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jg	SHORT $LN7@xmlXPtrGet

; 2606 : 		*indx = 0;

	mov	eax, DWORD PTR _indx$[ebp]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN8@xmlXPtrGet
$LN7@xmlXPtrGet:

; 2607 : 	    else
; 2608 : 		*indx = obj->index;

	mov	ecx, DWORD PTR _indx$[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx], eax
$LN8@xmlXPtrGet:

; 2609 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrGet
$LN9@xmlXPtrGet:

; 2610 :         case XPATH_RANGE:
; 2611 : 	    *node = obj->user;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx], eax

; 2612 : 	    if (obj->index <= 0)

	mov	ecx, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	jg	SHORT $LN10@xmlXPtrGet

; 2613 : 		*indx = 0;

	mov	edx, DWORD PTR _indx$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN11@xmlXPtrGet
$LN10@xmlXPtrGet:

; 2614 : 	    else
; 2615 : 		*indx = obj->index;

	mov	eax, DWORD PTR _indx$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax], edx
$LN11@xmlXPtrGet:

; 2616 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrGet
$LN2@xmlXPtrGet:

; 2617 : 	default:
; 2618 : 	    break;
; 2619 :     }
; 2620 :     return(-1);

	or	eax, -1
$LN1@xmlXPtrGet:

; 2621 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrGetStartPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetLastChar
_TEXT	SEGMENT
_len$ = -12						; size = 4
_pos$ = -8						; size = 4
_cur$ = -4						; size = 4
_node$ = 8						; size = 4
_indx$ = 12						; size = 4
_xmlXPtrGetLastChar PROC				; COMDAT

; 2552 : xmlXPtrGetLastChar(xmlNodePtr *node, int *indx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2553 :     xmlNodePtr cur;
; 2554 :     int pos, len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 2555 : 
; 2556 :     if ((node == NULL) || (*node == NULL) ||
; 2557 :         ((*node)->type == XML_NAMESPACE_DECL) || (indx == NULL))

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN5@xmlXPtrGet
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@xmlXPtrGet
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+4], 18			; 00000012H
	je	SHORT $LN5@xmlXPtrGet
	cmp	DWORD PTR _indx$[ebp], 0
	jne	SHORT $LN4@xmlXPtrGet
$LN5@xmlXPtrGet:

; 2558 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlXPtrGet
$LN4@xmlXPtrGet:

; 2559 :     cur = *node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 2560 :     pos = *indx;

	mov	edx, DWORD PTR _indx$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pos$[ebp], eax

; 2561 : 
; 2562 :     if ((cur->type == XML_ELEMENT_NODE) ||
; 2563 : 	(cur->type == XML_DOCUMENT_NODE) ||

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	je	SHORT $LN7@xmlXPtrGet
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 9
	je	SHORT $LN7@xmlXPtrGet
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	jne	SHORT $LN2@xmlXPtrGet
$LN7@xmlXPtrGet:

; 2564 : 	(cur->type == XML_HTML_DOCUMENT_NODE)) {
; 2565 : 	if (pos > 0) {

	cmp	DWORD PTR _pos$[ebp], 0
	jle	SHORT $LN2@xmlXPtrGet

; 2566 : 	    cur = xmlXPtrGetNthChild(cur, pos);

	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlXPtrGetNthChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$LN2@xmlXPtrGet:

; 2567 : 	}
; 2568 :     }
; 2569 :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@xmlXPtrGet

; 2570 : 	if (cur->last != NULL)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN9@xmlXPtrGet

; 2571 : 	    cur = cur->last;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _cur$[ebp], edx
	jmp	SHORT $LN10@xmlXPtrGet
$LN9@xmlXPtrGet:

; 2572 : 	else if ((cur->type != XML_ELEMENT_NODE) &&

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN11@xmlXPtrGet
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN11@xmlXPtrGet

; 2573 : 	         (cur->content != NULL)) {
; 2574 : 	    len = xmlStrlen(cur->content);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 2575 : 	    break;

	jmp	SHORT $LN3@xmlXPtrGet

; 2576 : 	} else {

	jmp	SHORT $LN10@xmlXPtrGet
$LN11@xmlXPtrGet:

; 2577 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlXPtrGet
$LN10@xmlXPtrGet:

; 2578 : 	}
; 2579 :     }

	jmp	SHORT $LN2@xmlXPtrGet
$LN3@xmlXPtrGet:

; 2580 :     if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN13@xmlXPtrGet

; 2581 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlXPtrGet
$LN13@xmlXPtrGet:

; 2582 :     *node = cur;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 2583 :     *indx = len;

	mov	eax, DWORD PTR _indx$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax], ecx

; 2584 :     return(0);

	xor	eax, eax
$LN1@xmlXPtrGet:

; 2585 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrGetLastChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrSearchString
_TEXT	SEGMENT
_first$ = -17						; size = 1
_len$ = -16						; size = 4
_pos$ = -12						; size = 4
_str$ = -8						; size = 4
_cur$ = -4						; size = 4
_string$ = 8						; size = 4
_start$ = 12						; size = 4
_startindex$ = 16					; size = 4
_end$ = 20						; size = 4
_endindex$ = 24						; size = 4
_xmlXPtrSearchString PROC				; COMDAT

; 2468 : 	            xmlNodePtr *end, int *endindex) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2469 :     xmlNodePtr cur;
; 2470 :     const xmlChar *str;
; 2471 :     int pos; /* 0 based */
; 2472 :     int len; /* in bytes */
; 2473 :     xmlChar first;
; 2474 : 
; 2475 :     if (string == NULL)

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN6@xmlXPtrSea

; 2476 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlXPtrSea
$LN6@xmlXPtrSea:

; 2477 :     if ((start == NULL) || (*start == NULL) ||
; 2478 :         ((*start)->type == XML_NAMESPACE_DECL) || (startindex == NULL))

	cmp	DWORD PTR _start$[ebp], 0
	je	SHORT $LN8@xmlXPtrSea
	mov	eax, DWORD PTR _start$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@xmlXPtrSea
	mov	ecx, DWORD PTR _start$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+4], 18			; 00000012H
	je	SHORT $LN8@xmlXPtrSea
	cmp	DWORD PTR _startindex$[ebp], 0
	jne	SHORT $LN7@xmlXPtrSea
$LN8@xmlXPtrSea:

; 2479 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlXPtrSea
$LN7@xmlXPtrSea:

; 2480 :     if ((end == NULL) || (endindex == NULL))

	cmp	DWORD PTR _end$[ebp], 0
	je	SHORT $LN10@xmlXPtrSea
	cmp	DWORD PTR _endindex$[ebp], 0
	jne	SHORT $LN9@xmlXPtrSea
$LN10@xmlXPtrSea:

; 2481 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlXPtrSea
$LN9@xmlXPtrSea:

; 2482 :     cur = *start;

	mov	eax, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 2483 :     pos = *startindex - 1;

	mov	edx, DWORD PTR _startindex$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	DWORD PTR _pos$[ebp], eax

; 2484 :     first = string[0];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _string$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR _first$[ebp], cl
$LN2@xmlXPtrSea:

; 2485 : 
; 2486 :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN3@xmlXPtrSea

; 2487 : 	if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	$LN11@xmlXPtrSea
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	$LN11@xmlXPtrSea

; 2488 : 	    len = xmlStrlen(cur->content);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN4@xmlXPtrSea:

; 2489 : 	    while (pos <= len) {

	mov	eax, DWORD PTR _pos$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jg	$LN11@xmlXPtrSea

; 2490 : 		if (first != 0) {

	movzx	ecx, BYTE PTR _first$[ebp]
	test	ecx, ecx
	je	$LN12@xmlXPtrSea

; 2491 : 		    str = xmlStrchr(&cur->content[pos], first);

	movzx	edx, BYTE PTR _first$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	add	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_xmlStrchr
	add	esp, 8
	mov	DWORD PTR _str$[ebp], eax

; 2492 : 		    if (str != NULL) {

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN14@xmlXPtrSea

; 2493 : 			pos = (str - (xmlChar *)(cur->content));

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _str$[ebp]
	sub	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _pos$[ebp], eax

; 2494 : #ifdef DEBUG_RANGES
; 2495 : 			xmlGenericError(xmlGenericErrorContext,
; 2496 : 				"found '%c' at index %d of ->",
; 2497 : 				first, pos + 1);
; 2498 : 			xmlDebugDumpString(stdout, cur->content);
; 2499 : 			xmlGenericError(xmlGenericErrorContext, "\n");
; 2500 : #endif
; 2501 : 			if (xmlXPtrMatchString(string, cur, pos + 1,

	mov	ecx, DWORD PTR _endindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_xmlXPtrMatchString
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN16@xmlXPtrSea

; 2502 : 					       end, endindex)) {
; 2503 : 			    *start = cur;

	mov	eax, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 2504 : 			    *startindex = pos + 1;

	mov	edx, DWORD PTR _pos$[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _startindex$[ebp]
	mov	DWORD PTR [eax], edx

; 2505 : 			    return(1);

	mov	eax, 1
	jmp	$LN1@xmlXPtrSea
$LN16@xmlXPtrSea:

; 2506 : 			}
; 2507 : 			pos++;

	mov	ecx, DWORD PTR _pos$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pos$[ebp], ecx

; 2508 : 		    } else {

	jmp	SHORT $LN15@xmlXPtrSea
$LN14@xmlXPtrSea:

; 2509 : 			pos = len + 1;

	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _pos$[ebp], edx
$LN15@xmlXPtrSea:

; 2510 : 		    }
; 2511 : 		} else {

	jmp	SHORT $LN13@xmlXPtrSea
$LN12@xmlXPtrSea:

; 2512 : 		    /*
; 2513 : 		     * An empty string is considered to match before each
; 2514 : 		     * character of the string-value and after the final
; 2515 : 		     * character.
; 2516 : 		     */
; 2517 : #ifdef DEBUG_RANGES
; 2518 : 		    xmlGenericError(xmlGenericErrorContext,
; 2519 : 			    "found '' at index %d of ->",
; 2520 : 			    pos + 1);
; 2521 : 		    xmlDebugDumpString(stdout, cur->content);
; 2522 : 		    xmlGenericError(xmlGenericErrorContext, "\n");
; 2523 : #endif
; 2524 : 		    *start = cur;

	mov	eax, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 2525 : 		    *startindex = pos + 1;

	mov	edx, DWORD PTR _pos$[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _startindex$[ebp]
	mov	DWORD PTR [eax], edx

; 2526 : 		    *end = cur;

	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 2527 : 		    *endindex = pos + 1;

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _endindex$[ebp]
	mov	DWORD PTR [ecx], eax

; 2528 : 		    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlXPtrSea
$LN13@xmlXPtrSea:

; 2529 : 		}
; 2530 : 	    }

	jmp	$LN4@xmlXPtrSea
$LN11@xmlXPtrSea:

; 2531 : 	}
; 2532 : 	if ((cur == *end) && (pos >= *endindex))

	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN17@xmlXPtrSea
	mov	ecx, DWORD PTR _endindex$[ebp]
	mov	edx, DWORD PTR _pos$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN17@xmlXPtrSea

; 2533 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrSea
$LN17@xmlXPtrSea:

; 2534 : 	cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlXPtrAdvanceNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 2535 : 	if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN18@xmlXPtrSea

; 2536 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrSea
$LN18@xmlXPtrSea:

; 2537 : 	pos = 1;

	mov	DWORD PTR _pos$[ebp], 1

; 2538 :     }

	jmp	$LN2@xmlXPtrSea
$LN3@xmlXPtrSea:

; 2539 :     return(0);

	xor	eax, eax
$LN1@xmlXPtrSea:

; 2540 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrSearchString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrMatchString
_TEXT	SEGMENT
tv141 = -32						; size = 4
tv129 = -28						; size = 4
_sub$1 = -24						; size = 4
_match$ = -20						; size = 4
_stringlen$ = -16					; size = 4
_len$ = -12						; size = 4
_pos$ = -8						; size = 4
_cur$ = -4						; size = 4
_string$ = 8						; size = 4
_start$ = 12						; size = 4
_startindex$ = 16					; size = 4
_end$ = 20						; size = 4
_endindex$ = 24						; size = 4
_xmlXPtrMatchString PROC				; COMDAT

; 2384 : 	            xmlNodePtr *end, int *endindex) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2385 :     xmlNodePtr cur;
; 2386 :     int pos; /* 0 based */
; 2387 :     int len; /* in bytes */
; 2388 :     int stringlen; /* in bytes */
; 2389 :     int match;
; 2390 : 
; 2391 :     if (string == NULL)

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN4@xmlXPtrMat

; 2392 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlXPtrMat
$LN4@xmlXPtrMat:

; 2393 :     if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR _start$[ebp], 0
	je	SHORT $LN6@xmlXPtrMat
	mov	eax, DWORD PTR _start$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN5@xmlXPtrMat
$LN6@xmlXPtrMat:

; 2394 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlXPtrMat
$LN5@xmlXPtrMat:

; 2395 :     if ((end == NULL) || (*end == NULL) ||
; 2396 :         ((*end)->type == XML_NAMESPACE_DECL) || (endindex == NULL))

	cmp	DWORD PTR _end$[ebp], 0
	je	SHORT $LN8@xmlXPtrMat
	mov	ecx, DWORD PTR _end$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN8@xmlXPtrMat
	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	je	SHORT $LN8@xmlXPtrMat
	cmp	DWORD PTR _endindex$[ebp], 0
	jne	SHORT $LN7@xmlXPtrMat
$LN8@xmlXPtrMat:

; 2397 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlXPtrMat
$LN7@xmlXPtrMat:

; 2398 :     cur = start;

	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx

; 2399 :     pos = startindex - 1;

	mov	edx, DWORD PTR _startindex$[ebp]
	sub	edx, 1
	mov	DWORD PTR _pos$[ebp], edx

; 2400 :     stringlen = xmlStrlen(string);

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _stringlen$[ebp], eax
$LN2@xmlXPtrMat:

; 2401 : 
; 2402 :     while (stringlen > 0) {

	cmp	DWORD PTR _stringlen$[ebp], 0
	jle	$LN3@xmlXPtrMat

; 2403 : 	if ((cur == *end) && (pos + stringlen > *endindex))

	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN9@xmlXPtrMat
	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR _stringlen$[ebp]
	mov	ecx, DWORD PTR _endindex$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jle	SHORT $LN9@xmlXPtrMat

; 2404 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlXPtrMat
$LN9@xmlXPtrMat:

; 2405 : 
; 2406 : 	if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	$LN10@xmlXPtrMat
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	$LN10@xmlXPtrMat

; 2407 : 	    len = xmlStrlen(cur->content);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 2408 : 	    if (len >= pos + stringlen) {

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR _stringlen$[ebp]
	cmp	DWORD PTR _len$[ebp], eax
	jl	SHORT $LN11@xmlXPtrMat

; 2409 : 		match = (!xmlStrncmp(&cur->content[pos], string, stringlen));

	mov	ecx, DWORD PTR _stringlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	add	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@xmlXPtrMat
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN20@xmlXPtrMat
$LN19@xmlXPtrMat:
	mov	DWORD PTR tv129[ebp], 0
$LN20@xmlXPtrMat:
	mov	edx, DWORD PTR tv129[ebp]
	mov	DWORD PTR _match$[ebp], edx

; 2410 : 		if (match) {

	cmp	DWORD PTR _match$[ebp], 0
	je	SHORT $LN13@xmlXPtrMat

; 2411 : #ifdef DEBUG_RANGES
; 2412 : 		    xmlGenericError(xmlGenericErrorContext,
; 2413 : 			    "found range %d bytes at index %d of ->",
; 2414 : 			    stringlen, pos + 1);
; 2415 : 		    xmlDebugDumpString(stdout, cur->content);
; 2416 : 		    xmlGenericError(xmlGenericErrorContext, "\n");
; 2417 : #endif
; 2418 : 		    *end = cur;

	mov	eax, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 2419 : 		    *endindex = pos + stringlen;

	mov	edx, DWORD PTR _pos$[ebp]
	add	edx, DWORD PTR _stringlen$[ebp]
	mov	eax, DWORD PTR _endindex$[ebp]
	mov	DWORD PTR [eax], edx

; 2420 : 		    return(1);

	mov	eax, 1
	jmp	$LN1@xmlXPtrMat

; 2421 : 		} else {

	jmp	SHORT $LN14@xmlXPtrMat
$LN13@xmlXPtrMat:

; 2422 : 		    return(0);

	xor	eax, eax
	jmp	$LN1@xmlXPtrMat
$LN14@xmlXPtrMat:

; 2423 : 		}
; 2424 : 	    } else {

	jmp	SHORT $LN10@xmlXPtrMat
$LN11@xmlXPtrMat:

; 2425 :                 int sub = len - pos;

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR _sub$1[ebp], ecx

; 2426 : 		match = (!xmlStrncmp(&cur->content[pos], string, sub));

	mov	edx, DWORD PTR _sub$1[ebp]
	push	edx
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	add	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@xmlXPtrMat
	mov	DWORD PTR tv141[ebp], 1
	jmp	SHORT $LN22@xmlXPtrMat
$LN21@xmlXPtrMat:
	mov	DWORD PTR tv141[ebp], 0
$LN22@xmlXPtrMat:
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR _match$[ebp], eax

; 2427 : 		if (match) {

	cmp	DWORD PTR _match$[ebp], 0
	je	SHORT $LN15@xmlXPtrMat

; 2428 : #ifdef DEBUG_RANGES
; 2429 : 		    xmlGenericError(xmlGenericErrorContext,
; 2430 : 			    "found subrange %d bytes at index %d of ->",
; 2431 : 			    sub, pos + 1);
; 2432 : 		    xmlDebugDumpString(stdout, cur->content);
; 2433 : 		    xmlGenericError(xmlGenericErrorContext, "\n");
; 2434 : #endif
; 2435 :                     string = &string[sub];

	mov	ecx, DWORD PTR _string$[ebp]
	add	ecx, DWORD PTR _sub$1[ebp]
	mov	DWORD PTR _string$[ebp], ecx

; 2436 : 		    stringlen -= sub;

	mov	edx, DWORD PTR _stringlen$[ebp]
	sub	edx, DWORD PTR _sub$1[ebp]
	mov	DWORD PTR _stringlen$[ebp], edx

; 2437 : 		} else {

	jmp	SHORT $LN10@xmlXPtrMat
$LN15@xmlXPtrMat:

; 2438 : 		    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrMat
$LN10@xmlXPtrMat:

; 2439 : 		}
; 2440 : 	    }
; 2441 : 	}
; 2442 : 	cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlXPtrAdvanceNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 2443 : 	if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN17@xmlXPtrMat

; 2444 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrMat
$LN17@xmlXPtrMat:

; 2445 : 	pos = 0;

	mov	DWORD PTR _pos$[ebp], 0

; 2446 :     }

	jmp	$LN2@xmlXPtrMat
$LN3@xmlXPtrMat:

; 2447 :     return(1);

	mov	eax, 1
$LN1@xmlXPtrMat:

; 2448 : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrMatchString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrAdvanceChar
_TEXT	SEGMENT
_len$ = -12						; size = 4
_pos$ = -8						; size = 4
_cur$ = -4						; size = 4
_node$ = 8						; size = 4
_indx$ = 12						; size = 4
_bytes$ = 16						; size = 4
_xmlXPtrAdvanceChar PROC				; COMDAT

; 2294 : xmlXPtrAdvanceChar(xmlNodePtr *node, int *indx, int bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2295 :     xmlNodePtr cur;
; 2296 :     int pos;
; 2297 :     int len;
; 2298 : 
; 2299 :     if ((node == NULL) || (indx == NULL))

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN7@xmlXPtrAdv
	cmp	DWORD PTR _indx$[ebp], 0
	jne	SHORT $LN6@xmlXPtrAdv
$LN7@xmlXPtrAdv:

; 2300 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlXPtrAdv
$LN6@xmlXPtrAdv:

; 2301 :     cur = *node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 2302 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN9@xmlXPtrAdv
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 18			; 00000012H
	jne	SHORT $LN8@xmlXPtrAdv
$LN9@xmlXPtrAdv:

; 2303 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlXPtrAdv
$LN8@xmlXPtrAdv:

; 2304 :     pos = *indx;

	mov	eax, DWORD PTR _indx$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pos$[ebp], ecx
$LN2@xmlXPtrAdv:

; 2305 : 
; 2306 :     while (bytes >= 0) {

	cmp	DWORD PTR _bytes$[ebp], 0
	jl	$LN3@xmlXPtrAdv
$LN4@xmlXPtrAdv:

; 2307 : 	/*
; 2308 : 	 * First position to the beginning of the first text node
; 2309 : 	 * corresponding to this point
; 2310 : 	 */
; 2311 : 	while ((cur != NULL) &&

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN5@xmlXPtrAdv
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	SHORT $LN10@xmlXPtrAdv
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 9
	je	SHORT $LN10@xmlXPtrAdv
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	jne	SHORT $LN5@xmlXPtrAdv
$LN10@xmlXPtrAdv:

; 2312 : 	       ((cur->type == XML_ELEMENT_NODE) ||
; 2313 : 	        (cur->type == XML_DOCUMENT_NODE) ||
; 2314 : 	        (cur->type == XML_HTML_DOCUMENT_NODE))) {
; 2315 : 	    if (pos > 0) {

	cmp	DWORD PTR _pos$[ebp], 0
	jle	SHORT $LN11@xmlXPtrAdv

; 2316 : 		cur = xmlXPtrGetNthChild(cur, pos);

	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlXPtrGetNthChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 2317 : 		pos = 0;

	mov	DWORD PTR _pos$[ebp], 0

; 2318 : 	    } else {

	jmp	SHORT $LN12@xmlXPtrAdv
$LN11@xmlXPtrAdv:

; 2319 : 		cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlXPtrAdvanceNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 2320 : 		pos = 0;

	mov	DWORD PTR _pos$[ebp], 0
$LN12@xmlXPtrAdv:

; 2321 : 	    }
; 2322 : 	}

	jmp	SHORT $LN4@xmlXPtrAdv
$LN5@xmlXPtrAdv:

; 2323 : 
; 2324 : 	if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN13@xmlXPtrAdv

; 2325 : 	    *node = NULL;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx], 0

; 2326 : 	    *indx = 0;

	mov	eax, DWORD PTR _indx$[ebp]
	mov	DWORD PTR [eax], 0

; 2327 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlXPtrAdv
$LN13@xmlXPtrAdv:

; 2328 : 	}
; 2329 : 
; 2330 : 	/*
; 2331 : 	 * if there is no move needed return the current value.
; 2332 : 	 */
; 2333 : 	if (pos == 0) pos = 1;

	cmp	DWORD PTR _pos$[ebp], 0
	jne	SHORT $LN14@xmlXPtrAdv
	mov	DWORD PTR _pos$[ebp], 1
$LN14@xmlXPtrAdv:

; 2334 : 	if (bytes == 0) {

	cmp	DWORD PTR _bytes$[ebp], 0
	jne	SHORT $LN15@xmlXPtrAdv

; 2335 : 	    *node = cur;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 2336 : 	    *indx = pos;

	mov	eax, DWORD PTR _indx$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR [eax], ecx

; 2337 : 	    return(0);

	xor	eax, eax
	jmp	$LN1@xmlXPtrAdv
$LN15@xmlXPtrAdv:

; 2338 : 	}
; 2339 : 	/*
; 2340 : 	 * We should have a text (or cdata) node ...
; 2341 : 	 */
; 2342 : 	len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 2343 : 	if ((cur->type != XML_ELEMENT_NODE) &&

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	SHORT $LN16@xmlXPtrAdv
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN16@xmlXPtrAdv

; 2344 :             (cur->content != NULL)) {
; 2345 : 	    len = xmlStrlen(cur->content);

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN16@xmlXPtrAdv:

; 2346 : 	}
; 2347 : 	if (pos > len) {

	mov	eax, DWORD PTR _pos$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jle	SHORT $LN17@xmlXPtrAdv

; 2348 : 	    /* Strange, the indx in the text node is greater than it's len */
; 2349 : 	    STRANGE

	mov	esi, esp
	push	2349					; 0000092dH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2350 : 	    pos = len;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _pos$[ebp], eax
$LN17@xmlXPtrAdv:

; 2351 : 	}
; 2352 : 	if (pos + bytes >= len) {

	mov	ecx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR _bytes$[ebp]
	cmp	ecx, DWORD PTR _len$[ebp]
	jl	SHORT $LN18@xmlXPtrAdv

; 2353 : 	    bytes -= (len - pos);

	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _bytes$[ebp]
	sub	eax, edx
	mov	DWORD PTR _bytes$[ebp], eax

; 2354 : 	    cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlXPtrAdvanceNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 2355 : 	    pos = 0;

	mov	DWORD PTR _pos$[ebp], 0
	jmp	SHORT $LN19@xmlXPtrAdv
$LN18@xmlXPtrAdv:

; 2356 : 	} else if (pos + bytes < len) {

	mov	edx, DWORD PTR _pos$[ebp]
	add	edx, DWORD PTR _bytes$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jge	SHORT $LN19@xmlXPtrAdv

; 2357 : 	    pos += bytes;

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _pos$[ebp], eax

; 2358 : 	    *node = cur;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], edx

; 2359 : 	    *indx = pos;

	mov	eax, DWORD PTR _indx$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR [eax], ecx

; 2360 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrAdv
$LN19@xmlXPtrAdv:

; 2361 : 	}
; 2362 :     }

	jmp	$LN2@xmlXPtrAdv
$LN3@xmlXPtrAdv:

; 2363 :     return(-1);

	or	eax, -1
$LN1@xmlXPtrAdv:

; 2364 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrAdvanceChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrInsideRange
_TEXT	SEGMENT
tv144 = -20						; size = 4
tv75 = -16						; size = 4
tv72 = -12						; size = 4
_node$1 = -8						; size = 4
_node$2 = -4						; size = 4
_ctxt$ = 8						; size = 4
_loc$ = 12						; size = 4
_xmlXPtrInsideRange PROC				; COMDAT

; 2073 : xmlXPtrInsideRange(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr loc) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2074 :     if (loc == NULL)

	cmp	DWORD PTR _loc$[ebp], 0
	jne	SHORT $LN8@xmlXPtrIns

; 2075 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrIns
$LN8@xmlXPtrIns:

; 2076 :     if ((ctxt == NULL) || (ctxt->context == NULL) ||

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN10@xmlXPtrIns
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN10@xmlXPtrIns
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN9@xmlXPtrIns
$LN10@xmlXPtrIns:

; 2077 : 	(ctxt->context->doc == NULL))
; 2078 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrIns
$LN9@xmlXPtrIns:

; 2079 :     switch (loc->type) {

	mov	eax, DWORD PTR _loc$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 5
	je	SHORT $LN11@xmlXPtrIns
	cmp	DWORD PTR tv72[ebp], 6
	je	$LN17@xmlXPtrIns
	jmp	$LN25@xmlXPtrIns
$LN11@xmlXPtrIns:

; 2080 :         case XPATH_POINT: {
; 2081 : 	    xmlNodePtr node = (xmlNodePtr) loc->user;

	mov	edx, DWORD PTR _loc$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _node$2[ebp], eax

; 2082 : 	    switch (node->type) {

	mov	ecx, DWORD PTR _node$2[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv75[ebp], edx
	mov	eax, DWORD PTR tv75[ebp]
	sub	eax, 1
	mov	DWORD PTR tv75[ebp], eax
	cmp	DWORD PTR tv75[ebp], 12			; 0000000cH
	ja	$LN4@xmlXPtrIns
	mov	ecx, DWORD PTR tv75[ebp]
	movzx	edx, BYTE PTR $LN27@xmlXPtrIns[ecx]
	jmp	DWORD PTR $LN29@xmlXPtrIns[edx*4]
$LN12@xmlXPtrIns:

; 2083 : 		case XML_PI_NODE:
; 2084 : 		case XML_COMMENT_NODE:
; 2085 : 		case XML_TEXT_NODE:
; 2086 : 		case XML_CDATA_SECTION_NODE: {
; 2087 : 		    if (node->content == NULL) {

	mov	eax, DWORD PTR _node$2[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN13@xmlXPtrIns

; 2088 : 			return(xmlXPtrNewRange(node, 0, node, 0));

	push	0
	mov	ecx, DWORD PTR _node$2[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _node$2[ebp]
	push	edx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	$LN1@xmlXPtrIns

; 2089 : 		    } else {

	jmp	SHORT $LN15@xmlXPtrIns
$LN13@xmlXPtrIns:

; 2090 : 			return(xmlXPtrNewRange(node, 0, node,

	mov	eax, DWORD PTR _node$2[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_xmlStrlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _node$2[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _node$2[ebp]
	push	eax
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	$LN1@xmlXPtrIns
$LN15@xmlXPtrIns:

; 2091 : 					       xmlStrlen(node->content)));
; 2092 : 		    }
; 2093 : 		}
; 2094 : 		case XML_ATTRIBUTE_NODE:
; 2095 : 		case XML_ELEMENT_NODE:
; 2096 : 		case XML_ENTITY_REF_NODE:
; 2097 : 		case XML_DOCUMENT_NODE:
; 2098 : 		case XML_NOTATION_NODE:
; 2099 : 		case XML_HTML_DOCUMENT_NODE: {
; 2100 : 		    return(xmlXPtrNewRange(node, 0, node,

	mov	ecx, DWORD PTR _node$2[ebp]
	push	ecx
	call	_xmlXPtrGetArity
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _node$2[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _node$2[ebp]
	push	eax
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	$LN1@xmlXPtrIns
$LN4@xmlXPtrIns:

; 2101 : 					   xmlXPtrGetArity(node)));
; 2102 : 		}
; 2103 : 		default:
; 2104 : 		    break;
; 2105 : 	    }
; 2106 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrIns
$LN17@xmlXPtrIns:

; 2107 : 	}
; 2108 :         case XPATH_RANGE: {
; 2109 : 	    xmlNodePtr node = (xmlNodePtr) loc->user;

	mov	ecx, DWORD PTR _loc$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _node$1[ebp], edx

; 2110 : 	    if (loc->user2 != NULL) {

	mov	eax, DWORD PTR _loc$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN18@xmlXPtrIns

; 2111 : 		return(xmlXPtrNewRange(node, loc->index,

	mov	ecx, DWORD PTR _loc$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _loc$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _loc$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _node$1[ebp]
	push	ecx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	$LN1@xmlXPtrIns

; 2112 : 			               loc->user2, loc->index2));
; 2113 : 	    } else {

	jmp	$LN25@xmlXPtrIns
$LN18@xmlXPtrIns:

; 2114 : 		switch (node->type) {

	mov	edx, DWORD PTR _node$1[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv144[ebp], eax
	mov	ecx, DWORD PTR tv144[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv144[ebp], ecx
	cmp	DWORD PTR tv144[ebp], 12		; 0000000cH
	ja	SHORT $LN6@xmlXPtrIns
	mov	edx, DWORD PTR tv144[ebp]
	movzx	eax, BYTE PTR $LN28@xmlXPtrIns[edx]
	jmp	DWORD PTR $LN30@xmlXPtrIns[eax*4]
$LN20@xmlXPtrIns:

; 2115 : 		    case XML_PI_NODE:
; 2116 : 		    case XML_COMMENT_NODE:
; 2117 : 		    case XML_TEXT_NODE:
; 2118 : 		    case XML_CDATA_SECTION_NODE: {
; 2119 : 			if (node->content == NULL) {

	mov	ecx, DWORD PTR _node$1[ebp]
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN21@xmlXPtrIns

; 2120 : 			    return(xmlXPtrNewRange(node, 0, node, 0));

	push	0
	mov	edx, DWORD PTR _node$1[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _node$1[ebp]
	push	eax
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@xmlXPtrIns

; 2121 : 			} else {

	jmp	SHORT $LN23@xmlXPtrIns
$LN21@xmlXPtrIns:

; 2122 : 			    return(xmlXPtrNewRange(node, 0, node,

	mov	ecx, DWORD PTR _node$1[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _node$1[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _node$1[ebp]
	push	ecx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@xmlXPtrIns
$LN23@xmlXPtrIns:

; 2123 : 						   xmlStrlen(node->content)));
; 2124 : 			}
; 2125 : 		    }
; 2126 : 		    case XML_ATTRIBUTE_NODE:
; 2127 : 		    case XML_ELEMENT_NODE:
; 2128 : 		    case XML_ENTITY_REF_NODE:
; 2129 : 		    case XML_DOCUMENT_NODE:
; 2130 : 		    case XML_NOTATION_NODE:
; 2131 : 		    case XML_HTML_DOCUMENT_NODE: {
; 2132 : 			return(xmlXPtrNewRange(node, 0, node,

	mov	edx, DWORD PTR _node$1[ebp]
	push	edx
	call	_xmlXPtrGetArity
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _node$1[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _node$1[ebp]
	push	ecx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@xmlXPtrIns
$LN6@xmlXPtrIns:

; 2133 : 					       xmlXPtrGetArity(node)));
; 2134 : 		    }
; 2135 : 		    default:
; 2136 : 			break;
; 2137 : 		}
; 2138 : 		return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrIns
$LN25@xmlXPtrIns:

; 2139 : 	    }
; 2140 :         }
; 2141 : 	default:
; 2142 : 	    TODO /* missed one case ??? */

	mov	esi, esp
	push	2142					; 0000085eH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___xmlGenericError
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2143 :     }
; 2144 :     return(NULL);

	xor	eax, eax
$LN1@xmlXPtrIns:

; 2145 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN29@xmlXPtrIns:
	DD	$LN15@xmlXPtrIns
	DD	$LN12@xmlXPtrIns
	DD	$LN4@xmlXPtrIns
$LN27@xmlXPtrIns:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	2
	DB	1
	DB	1
	DB	0
	DB	2
	DB	2
	DB	0
	DB	0
	npad	3
$LN30@xmlXPtrIns:
	DD	$LN23@xmlXPtrIns
	DD	$LN20@xmlXPtrIns
	DD	$LN6@xmlXPtrIns
$LN28@xmlXPtrIns:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	2
	DB	1
	DB	1
	DB	0
	DB	2
	DB	2
	DB	0
	DB	0
_xmlXPtrInsideRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrCoveringRange
_TEXT	SEGMENT
tv137 = -16						; size = 4
tv72 = -12						; size = 4
_indx$1 = -8						; size = 4
_node$2 = -4						; size = 4
_ctxt$ = 8						; size = 4
_loc$ = 12						; size = 4
_xmlXPtrCoveringRange PROC				; COMDAT

; 1949 : xmlXPtrCoveringRange(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr loc) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1950 :     if (loc == NULL)

	cmp	DWORD PTR _loc$[ebp], 0
	jne	SHORT $LN6@xmlXPtrCov

; 1951 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrCov
$LN6@xmlXPtrCov:

; 1952 :     if ((ctxt == NULL) || (ctxt->context == NULL) ||

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN8@xmlXPtrCov
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN8@xmlXPtrCov
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN7@xmlXPtrCov
$LN8@xmlXPtrCov:

; 1953 : 	(ctxt->context->doc == NULL))
; 1954 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrCov
$LN7@xmlXPtrCov:

; 1955 :     switch (loc->type) {

	mov	eax, DWORD PTR _loc$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 5
	je	SHORT $LN9@xmlXPtrCov
	cmp	DWORD PTR tv72[ebp], 6
	je	SHORT $LN10@xmlXPtrCov
	jmp	$LN18@xmlXPtrCov
$LN9@xmlXPtrCov:

; 1956 :         case XPATH_POINT:
; 1957 : 	    return(xmlXPtrNewRange(loc->user, loc->index,

	mov	edx, DWORD PTR _loc$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _loc$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _loc$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _loc$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	$LN1@xmlXPtrCov
$LN10@xmlXPtrCov:

; 1958 : 			           loc->user, loc->index));
; 1959 :         case XPATH_RANGE:
; 1960 : 	    if (loc->user2 != NULL) {

	mov	ecx, DWORD PTR _loc$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN11@xmlXPtrCov

; 1961 : 		return(xmlXPtrNewRange(loc->user, loc->index,

	mov	edx, DWORD PTR _loc$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _loc$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _loc$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _loc$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	$LN1@xmlXPtrCov

; 1962 : 			              loc->user2, loc->index2));
; 1963 : 	    } else {

	jmp	$LN18@xmlXPtrCov
$LN11@xmlXPtrCov:

; 1964 : 		xmlNodePtr node = (xmlNodePtr) loc->user;

	mov	ecx, DWORD PTR _loc$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _node$2[ebp], edx

; 1965 : 		if (node == (xmlNodePtr) ctxt->context->doc) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _node$2[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@xmlXPtrCov

; 1966 : 		    return(xmlXPtrNewRange(node, 0, node,

	mov	eax, DWORD PTR _node$2[ebp]
	push	eax
	call	_xmlXPtrGetArity
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _node$2[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _node$2[ebp]
	push	edx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	$LN1@xmlXPtrCov

; 1967 : 					   xmlXPtrGetArity(node)));
; 1968 : 		} else {

	jmp	$LN18@xmlXPtrCov
$LN13@xmlXPtrCov:

; 1969 : 		    switch (node->type) {

	mov	eax, DWORD PTR _node$2[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv137[ebp], ecx
	mov	edx, DWORD PTR tv137[ebp]
	sub	edx, 1
	mov	DWORD PTR tv137[ebp], edx
	cmp	DWORD PTR tv137[ebp], 12		; 0000000cH
	ja	SHORT $LN17@xmlXPtrCov
	mov	eax, DWORD PTR tv137[ebp]
	movzx	ecx, BYTE PTR $LN20@xmlXPtrCov[eax]
	jmp	DWORD PTR $LN21@xmlXPtrCov[ecx*4]
$LN15@xmlXPtrCov:

; 1970 : 			case XML_ATTRIBUTE_NODE:
; 1971 : 			/* !!! our model is slightly different than XPath */
; 1972 : 			    return(xmlXPtrNewRange(node, 0, node,

	mov	edx, DWORD PTR _node$2[ebp]
	push	edx
	call	_xmlXPtrGetArity
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _node$2[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _node$2[ebp]
	push	ecx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@xmlXPtrCov
$LN16@xmlXPtrCov:

; 1973 : 					           xmlXPtrGetArity(node)));
; 1974 : 			case XML_ELEMENT_NODE:
; 1975 : 			case XML_TEXT_NODE:
; 1976 : 			case XML_CDATA_SECTION_NODE:
; 1977 : 			case XML_ENTITY_REF_NODE:
; 1978 : 			case XML_PI_NODE:
; 1979 : 			case XML_COMMENT_NODE:
; 1980 : 			case XML_DOCUMENT_NODE:
; 1981 : 			case XML_NOTATION_NODE:
; 1982 : 			case XML_HTML_DOCUMENT_NODE: {
; 1983 : 			    int indx = xmlXPtrGetIndex(node);

	mov	edx, DWORD PTR _node$2[ebp]
	push	edx
	call	_xmlXPtrGetIndex
	add	esp, 4
	mov	DWORD PTR _indx$1[ebp], eax

; 1984 : 
; 1985 : 			    node = node->parent;

	mov	eax, DWORD PTR _node$2[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _node$2[ebp], ecx

; 1986 : 			    return(xmlXPtrNewRange(node, indx - 1,

	mov	edx, DWORD PTR _indx$1[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _node$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _indx$1[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _node$2[ebp]
	push	edx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@xmlXPtrCov
$LN17@xmlXPtrCov:

; 1987 : 					           node, indx + 1));
; 1988 : 			}
; 1989 : 			default:
; 1990 : 			    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrCov
$LN18@xmlXPtrCov:

; 1991 : 		    }
; 1992 : 		}
; 1993 : 	    }
; 1994 : 	default:
; 1995 : 	    TODO /* missed one case ??? */

	mov	esi, esp
	push	1995					; 000007cbH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1996 :     }
; 1997 :     return(NULL);

	xor	eax, eax
$LN1@xmlXPtrCov:

; 1998 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN21@xmlXPtrCov:
	DD	$LN16@xmlXPtrCov
	DD	$LN15@xmlXPtrCov
	DD	$LN17@xmlXPtrCov
$LN20@xmlXPtrCov:
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	2
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	0
	DB	0
_xmlXPtrCoveringRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNbLocChildren
_TEXT	SEGMENT
tv66 = -8						; size = 4
_ret$ = -4						; size = 4
_node$ = 8						; size = 4
_xmlXPtrNbLocChildren PROC				; COMDAT

; 1676 : xmlXPtrNbLocChildren(xmlNodePtr node) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1677 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 1678 :     if (node == NULL)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN6@xmlXPtrNbL

; 1679 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlXPtrNbL
$LN6@xmlXPtrNbL:

; 1680 :     switch (node->type) {

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR tv66[ebp]
	sub	edx, 1
	mov	DWORD PTR tv66[ebp], edx
	cmp	DWORD PTR tv66[ebp], 12			; 0000000cH
	ja	SHORT $LN11@xmlXPtrNbL
	mov	eax, DWORD PTR tv66[ebp]
	movzx	ecx, BYTE PTR $LN13@xmlXPtrNbL[eax]
	jmp	DWORD PTR $LN14@xmlXPtrNbL[ecx*4]
$LN7@xmlXPtrNbL:

; 1681 :         case XML_HTML_DOCUMENT_NODE:
; 1682 :         case XML_DOCUMENT_NODE:
; 1683 :         case XML_ELEMENT_NODE:
; 1684 : 	    node = node->children;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _node$[ebp], eax
$LN4@xmlXPtrNbL:

; 1685 : 	    while (node != NULL) {

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN5@xmlXPtrNbL

; 1686 : 		if (node->type == XML_ELEMENT_NODE)

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN8@xmlXPtrNbL

; 1687 : 		    ret++;

	mov	edx, DWORD PTR _ret$[ebp]
	add	edx, 1
	mov	DWORD PTR _ret$[ebp], edx
$LN8@xmlXPtrNbL:

; 1688 : 		node = node->next;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _node$[ebp], ecx

; 1689 : 	    }

	jmp	SHORT $LN4@xmlXPtrNbL
$LN5@xmlXPtrNbL:

; 1690 : 	    break;

	jmp	SHORT $LN2@xmlXPtrNbL
$LN9@xmlXPtrNbL:

; 1691 :         case XML_ATTRIBUTE_NODE:
; 1692 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlXPtrNbL
$LN10@xmlXPtrNbL:

; 1693 : 
; 1694 :         case XML_PI_NODE:
; 1695 :         case XML_COMMENT_NODE:
; 1696 :         case XML_TEXT_NODE:
; 1697 :         case XML_CDATA_SECTION_NODE:
; 1698 :         case XML_ENTITY_REF_NODE:
; 1699 : 	    ret = xmlStrlen(node->content);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 1700 : 	    break;

	jmp	SHORT $LN2@xmlXPtrNbL
$LN11@xmlXPtrNbL:

; 1701 : 	default:
; 1702 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlXPtrNbL
$LN2@xmlXPtrNbL:

; 1703 :     }
; 1704 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNbL:

; 1705 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN14@xmlXPtrNbL:
	DD	$LN7@xmlXPtrNbL
	DD	$LN9@xmlXPtrNbL
	DD	$LN10@xmlXPtrNbL
	DD	$LN11@xmlXPtrNbL
$LN13@xmlXPtrNbL:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	3
	DB	2
	DB	2
	DB	0
	DB	3
	DB	3
	DB	3
	DB	0
_xmlXPtrNbLocChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrBuildRangeNodeList
_TEXT	SEGMENT
tv186 = -52						; size = 4
_content$1 = -48					; size = 4
_len$2 = -44						; size = 4
_content$3 = -40					; size = 4
_index2$ = -36						; size = 4
_index1$ = -32						; size = 4
_end$ = -28						; size = 4
_cur$ = -24						; size = 4
_start$ = -20						; size = 4
_tmp$ = -16						; size = 4
_parent$ = -12						; size = 4
_last$ = -8						; size = 4
_list$ = -4						; size = 4
_range$ = 8						; size = 4
_xmlXPtrBuildRangeNodeList PROC				; COMDAT

; 1409 : xmlXPtrBuildRangeNodeList(xmlXPathObjectPtr range) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1410 :     /* pointers to generated nodes */
; 1411 :     xmlNodePtr list = NULL, last = NULL, parent = NULL, tmp;

	mov	DWORD PTR _list$[ebp], 0
	mov	DWORD PTR _last$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0

; 1412 :     /* pointers to traversal nodes */
; 1413 :     xmlNodePtr start, cur, end;
; 1414 :     int index1, index2;
; 1415 : 
; 1416 :     if (range == NULL)

	cmp	DWORD PTR _range$[ebp], 0
	jne	SHORT $LN6@xmlXPtrBui

; 1417 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrBui
$LN6@xmlXPtrBui:

; 1418 :     if (range->type != XPATH_RANGE)

	mov	eax, DWORD PTR _range$[ebp]
	cmp	DWORD PTR [eax], 6
	je	SHORT $LN7@xmlXPtrBui

; 1419 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrBui
$LN7@xmlXPtrBui:

; 1420 :     start = (xmlNodePtr) range->user;

	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _start$[ebp], edx

; 1421 : 
; 1422 :     if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR _start$[ebp], 0
	je	SHORT $LN9@xmlXPtrBui
	mov	eax, DWORD PTR _start$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN8@xmlXPtrBui
$LN9@xmlXPtrBui:

; 1423 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrBui
$LN8@xmlXPtrBui:

; 1424 :     end = range->user2;

	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _end$[ebp], edx

; 1425 :     if (end == NULL)

	cmp	DWORD PTR _end$[ebp], 0
	jne	SHORT $LN10@xmlXPtrBui

; 1426 : 	return(xmlCopyNode(start, 1));

	push	1
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlCopyNode
	add	esp, 8
	jmp	$LN1@xmlXPtrBui
$LN10@xmlXPtrBui:

; 1427 :     if (end->type == XML_NAMESPACE_DECL)

	mov	ecx, DWORD PTR _end$[ebp]
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	jne	SHORT $LN11@xmlXPtrBui

; 1428 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrBui
$LN11@xmlXPtrBui:

; 1429 : 
; 1430 :     cur = start;

	mov	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 1431 :     index1 = range->index;

	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _index1$[ebp], ecx

; 1432 :     index2 = range->index2;

	mov	edx, DWORD PTR _range$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _index2$[ebp], eax
$LN2@xmlXPtrBui:

; 1433 :     while (cur != NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN3@xmlXPtrBui

; 1434 : 	if (cur == end) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jne	$LN12@xmlXPtrBui

; 1435 : 	    if (cur->type == XML_TEXT_NODE) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 3
	jne	$LN14@xmlXPtrBui

; 1436 : 		const xmlChar *content = cur->content;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _content$3[ebp], ecx

; 1437 : 		int len;
; 1438 : 
; 1439 : 		if (content == NULL) {

	cmp	DWORD PTR _content$3[ebp], 0
	jne	SHORT $LN16@xmlXPtrBui

; 1440 : 		    tmp = xmlNewTextLen(NULL, 0);

	push	0
	push	0
	call	_xmlNewTextLen
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax

; 1441 : 		} else {

	jmp	SHORT $LN17@xmlXPtrBui
$LN16@xmlXPtrBui:

; 1442 : 		    len = index2;

	mov	edx, DWORD PTR _index2$[ebp]
	mov	DWORD PTR _len$2[ebp], edx

; 1443 : 		    if ((cur == start) && (index1 > 1)) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	jne	SHORT $LN18@xmlXPtrBui
	cmp	DWORD PTR _index1$[ebp], 1
	jle	SHORT $LN18@xmlXPtrBui

; 1444 : 			content += (index1 - 1);

	mov	ecx, DWORD PTR _index1$[ebp]
	mov	edx, DWORD PTR _content$3[ebp]
	lea	eax, DWORD PTR [edx+ecx-1]
	mov	DWORD PTR _content$3[ebp], eax

; 1445 : 			len -= (index1 - 1);

	mov	ecx, DWORD PTR _index1$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _len$2[ebp]
	sub	edx, ecx
	mov	DWORD PTR _len$2[ebp], edx

; 1446 : 			index1 = 0;

	mov	DWORD PTR _index1$[ebp], 0

; 1447 : 		    } else {

	jmp	SHORT $LN19@xmlXPtrBui
$LN18@xmlXPtrBui:

; 1448 : 			len = index2;

	mov	eax, DWORD PTR _index2$[ebp]
	mov	DWORD PTR _len$2[ebp], eax
$LN19@xmlXPtrBui:

; 1449 : 		    }
; 1450 : 		    tmp = xmlNewTextLen(content, len);

	mov	ecx, DWORD PTR _len$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _content$3[ebp]
	push	edx
	call	_xmlNewTextLen
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax
$LN17@xmlXPtrBui:

; 1451 : 		}
; 1452 : 		/* single sub text node selection */
; 1453 : 		if (list == NULL)

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN20@xmlXPtrBui

; 1454 : 		    return(tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	jmp	$LN1@xmlXPtrBui
$LN20@xmlXPtrBui:

; 1455 : 		/* prune and return full set */
; 1456 : 		if (last != NULL)

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN21@xmlXPtrBui

; 1457 : 		    xmlAddNextSibling(last, tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _last$[ebp]
	push	ecx
	call	_xmlAddNextSibling
	add	esp, 8
	jmp	SHORT $LN22@xmlXPtrBui
$LN21@xmlXPtrBui:

; 1458 : 		else
; 1459 : 		    xmlAddChild(parent, tmp);

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
$LN22@xmlXPtrBui:

; 1460 : 		return(list);

	mov	eax, DWORD PTR _list$[ebp]
	jmp	$LN1@xmlXPtrBui

; 1461 : 	    } else {

	jmp	$LN15@xmlXPtrBui
$LN14@xmlXPtrBui:

; 1462 : 		tmp = xmlCopyNode(cur, 0);

	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlCopyNode
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax

; 1463 : 		if (list == NULL)

	cmp	DWORD PTR _list$[ebp], 0
	jne	SHORT $LN23@xmlXPtrBui

; 1464 : 		    list = tmp;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _list$[ebp], edx
	jmp	SHORT $LN24@xmlXPtrBui
$LN23@xmlXPtrBui:

; 1465 : 		else {
; 1466 : 		    if (last != NULL)

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN25@xmlXPtrBui

; 1467 : 			xmlAddNextSibling(last, tmp);

	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _last$[ebp]
	push	ecx
	call	_xmlAddNextSibling
	add	esp, 8
	jmp	SHORT $LN24@xmlXPtrBui
$LN25@xmlXPtrBui:

; 1468 : 		    else
; 1469 : 			xmlAddChild(parent, tmp);

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
$LN24@xmlXPtrBui:

; 1470 : 		}
; 1471 : 		last = NULL;

	mov	DWORD PTR _last$[ebp], 0

; 1472 : 		parent = tmp;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 1473 : 
; 1474 : 		if (index2 > 1) {

	cmp	DWORD PTR _index2$[ebp], 1
	jle	SHORT $LN27@xmlXPtrBui

; 1475 : 		    end = xmlXPtrGetNthChild(cur, index2 - 1);

	mov	edx, DWORD PTR _index2$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlXPtrGetNthChild
	add	esp, 8
	mov	DWORD PTR _end$[ebp], eax

; 1476 : 		    index2 = 0;

	mov	DWORD PTR _index2$[ebp], 0
$LN27@xmlXPtrBui:

; 1477 : 		}
; 1478 : 		if ((cur == start) && (index1 > 1)) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	ecx, DWORD PTR _start$[ebp]
	jne	SHORT $LN28@xmlXPtrBui
	cmp	DWORD PTR _index1$[ebp], 1
	jle	SHORT $LN28@xmlXPtrBui

; 1479 : 		    cur = xmlXPtrGetNthChild(cur, index1 - 1);

	mov	edx, DWORD PTR _index1$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlXPtrGetNthChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1480 : 		    index1 = 0;

	mov	DWORD PTR _index1$[ebp], 0

; 1481 : 		} else {

	jmp	SHORT $LN29@xmlXPtrBui
$LN28@xmlXPtrBui:

; 1482 : 		    cur = cur->children;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx
$LN29@xmlXPtrBui:

; 1483 : 		}
; 1484 : 		/*
; 1485 : 		 * Now gather the remaining nodes from cur to end
; 1486 : 		 */
; 1487 : 		continue; /* while */

	jmp	$LN2@xmlXPtrBui
$LN15@xmlXPtrBui:

; 1488 : 	    }

	jmp	$LN13@xmlXPtrBui
$LN12@xmlXPtrBui:

; 1489 : 	} else if ((cur == start) &&

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	jne	$LN30@xmlXPtrBui
	cmp	DWORD PTR _list$[ebp], 0
	jne	$LN30@xmlXPtrBui

; 1490 : 		   (list == NULL) /* looks superfluous but ... */ ) {
; 1491 : 	    if ((cur->type == XML_TEXT_NODE) ||

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 3
	je	SHORT $LN34@xmlXPtrBui
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 4
	jne	SHORT $LN32@xmlXPtrBui
$LN34@xmlXPtrBui:

; 1492 : 		(cur->type == XML_CDATA_SECTION_NODE)) {
; 1493 : 		const xmlChar *content = cur->content;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _content$1[ebp], ecx

; 1494 : 
; 1495 : 		if (content == NULL) {

	cmp	DWORD PTR _content$1[ebp], 0
	jne	SHORT $LN35@xmlXPtrBui

; 1496 : 		    tmp = xmlNewTextLen(NULL, 0);

	push	0
	push	0
	call	_xmlNewTextLen
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax

; 1497 : 		} else {

	jmp	SHORT $LN36@xmlXPtrBui
$LN35@xmlXPtrBui:

; 1498 : 		    if (index1 > 1) {

	cmp	DWORD PTR _index1$[ebp], 1
	jle	SHORT $LN37@xmlXPtrBui

; 1499 : 			content += (index1 - 1);

	mov	edx, DWORD PTR _index1$[ebp]
	mov	eax, DWORD PTR _content$1[ebp]
	lea	ecx, DWORD PTR [eax+edx-1]
	mov	DWORD PTR _content$1[ebp], ecx
$LN37@xmlXPtrBui:

; 1500 : 		    }
; 1501 : 		    tmp = xmlNewText(content);

	mov	edx, DWORD PTR _content$1[ebp]
	push	edx
	call	_xmlNewText
	add	esp, 4
	mov	DWORD PTR _tmp$[ebp], eax
$LN36@xmlXPtrBui:

; 1502 : 		}
; 1503 : 		last = list = tmp;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _list$[ebp], eax
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR _last$[ebp], ecx

; 1504 : 	    } else {

	jmp	SHORT $LN33@xmlXPtrBui
$LN32@xmlXPtrBui:

; 1505 : 		if ((cur == start) && (index1 > 1)) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	edx, DWORD PTR _start$[ebp]
	jne	SHORT $LN38@xmlXPtrBui
	cmp	DWORD PTR _index1$[ebp], 1
	jle	SHORT $LN38@xmlXPtrBui

; 1506 : 		    tmp = xmlCopyNode(cur, 0);

	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlCopyNode
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax

; 1507 : 		    list = tmp;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _list$[ebp], ecx

; 1508 : 		    parent = tmp;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 1509 : 		    last = NULL;

	mov	DWORD PTR _last$[ebp], 0

; 1510 : 		    cur = xmlXPtrGetNthChild(cur, index1 - 1);

	mov	eax, DWORD PTR _index1$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlXPtrGetNthChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1511 : 		    index1 = 0;

	mov	DWORD PTR _index1$[ebp], 0

; 1512 : 		    /*
; 1513 : 		     * Now gather the remaining nodes from cur to end
; 1514 : 		     */
; 1515 : 		    continue; /* while */

	jmp	$LN2@xmlXPtrBui
$LN38@xmlXPtrBui:

; 1516 : 		}
; 1517 : 		tmp = xmlCopyNode(cur, 1);

	push	1
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlCopyNode
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax

; 1518 : 		list = tmp;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _list$[ebp], eax

; 1519 : 		parent = NULL;

	mov	DWORD PTR _parent$[ebp], 0

; 1520 : 		last = tmp;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _last$[ebp], ecx
$LN33@xmlXPtrBui:

; 1521 : 	    }
; 1522 : 	} else {

	jmp	$LN13@xmlXPtrBui
$LN30@xmlXPtrBui:

; 1523 : 	    tmp = NULL;

	mov	DWORD PTR _tmp$[ebp], 0

; 1524 : 	    switch (cur->type) {

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv186[ebp], eax
	mov	ecx, DWORD PTR tv186[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv186[ebp], ecx
	cmp	DWORD PTR tv186[ebp], 18		; 00000012H
	ja	SHORT $LN43@xmlXPtrBui
	mov	edx, DWORD PTR tv186[ebp]
	movzx	eax, BYTE PTR $LN54@xmlXPtrBui[edx]
	jmp	DWORD PTR $LN55@xmlXPtrBui[eax*4]
$LN39@xmlXPtrBui:

; 1525 : 		case XML_DTD_NODE:
; 1526 : 		case XML_ELEMENT_DECL:
; 1527 : 		case XML_ATTRIBUTE_DECL:
; 1528 : 		case XML_ENTITY_NODE:
; 1529 : 		    /* Do not copy DTD informations */
; 1530 : 		    break;

	jmp	SHORT $LN4@xmlXPtrBui
$LN40@xmlXPtrBui:

; 1531 : 		case XML_ENTITY_DECL:
; 1532 : 		    TODO /* handle crossing entities -> stack needed */

	mov	esi, esp
	push	1532					; 000005fcH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1533 : 		    break;

	jmp	SHORT $LN4@xmlXPtrBui
$LN41@xmlXPtrBui:

; 1534 : 		case XML_XINCLUDE_START:
; 1535 : 		case XML_XINCLUDE_END:
; 1536 : 		    /* don't consider it part of the tree content */
; 1537 : 		    break;

	jmp	SHORT $LN4@xmlXPtrBui
$LN42@xmlXPtrBui:

; 1538 : 		case XML_ATTRIBUTE_NODE:
; 1539 : 		    /* Humm, should not happen ! */
; 1540 : 		    STRANGE

	mov	esi, esp
	push	1540					; 00000604H
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1541 : 		    break;

	jmp	SHORT $LN4@xmlXPtrBui
$LN43@xmlXPtrBui:

; 1542 : 		default:
; 1543 : 		    tmp = xmlCopyNode(cur, 1);

	push	1
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlCopyNode
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax
$LN4@xmlXPtrBui:

; 1544 : 		    break;
; 1545 : 	    }
; 1546 : 	    if (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN13@xmlXPtrBui

; 1547 : 		if ((list == NULL) || ((last == NULL) && (parent == NULL)))  {

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN46@xmlXPtrBui
	cmp	DWORD PTR _last$[ebp], 0
	jne	SHORT $LN45@xmlXPtrBui
	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN45@xmlXPtrBui
$LN46@xmlXPtrBui:

; 1548 : 		    STRANGE

	mov	esi, esp
	push	1548					; 0000060cH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1549 : 		    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrBui
$LN45@xmlXPtrBui:

; 1550 : 		}
; 1551 : 		if (last != NULL)

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN47@xmlXPtrBui

; 1552 : 		    xmlAddNextSibling(last, tmp);

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _last$[ebp]
	push	eax
	call	_xmlAddNextSibling
	add	esp, 8
	jmp	SHORT $LN13@xmlXPtrBui
$LN47@xmlXPtrBui:

; 1553 : 		else {
; 1554 : 		    xmlAddChild(parent, tmp);

	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8

; 1555 : 		    last = tmp;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _last$[ebp], eax
$LN13@xmlXPtrBui:

; 1556 : 		}
; 1557 : 	    }
; 1558 : 	}
; 1559 : 	/*
; 1560 : 	 * Skip to next node in document order
; 1561 : 	 */
; 1562 : 	if ((list == NULL) || ((last == NULL) && (parent == NULL)))  {

	cmp	DWORD PTR _list$[ebp], 0
	je	SHORT $LN50@xmlXPtrBui
	cmp	DWORD PTR _last$[ebp], 0
	jne	SHORT $LN49@xmlXPtrBui
	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN49@xmlXPtrBui
$LN50@xmlXPtrBui:

; 1563 : 	    STRANGE

	mov	esi, esp
	push	1563					; 0000061bH
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BJ@DADKHPPP@Internal?5error?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___xmlGenericError
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1564 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrBui
$LN49@xmlXPtrBui:

; 1565 : 	}
; 1566 : 	cur = xmlXPtrAdvanceNode(cur, NULL);

	push	0
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlXPtrAdvanceNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1567 :     }

	jmp	$LN2@xmlXPtrBui
$LN3@xmlXPtrBui:

; 1568 :     return(list);

	mov	eax, DWORD PTR _list$[ebp]
$LN1@xmlXPtrBui:

; 1569 : }

	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN55@xmlXPtrBui:
	DD	$LN42@xmlXPtrBui
	DD	$LN39@xmlXPtrBui
	DD	$LN40@xmlXPtrBui
	DD	$LN41@xmlXPtrBui
	DD	$LN43@xmlXPtrBui
$LN54@xmlXPtrBui:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	1
	DB	1
	DB	2
	DB	4
	DB	3
	DB	3
_xmlXPtrBuildRangeNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrRangeFunction
_TEXT	SEGMENT
_tmp$1 = -20						; size = 4
_newset$ = -16						; size = 4
_oldset$ = -12						; size = 4
_set$ = -8						; size = 4
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrRangeFunction PROC				; COMDAT

; 2014 : xmlXPtrRangeFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2015 :     int i;
; 2016 :     xmlXPathObjectPtr set;
; 2017 :     xmlLocationSetPtr oldset;
; 2018 :     xmlLocationSetPtr newset;
; 2019 : 
; 2020 :     CHECK_ARITY(1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN5@xmlXPtrRan
	jmp	$LN1@xmlXPtrRan
$LN5@xmlXPtrRan:
	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN6@xmlXPtrRan
	push	12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrRan
$LN6@xmlXPtrRan:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+20], edx
	jge	SHORT $LN7@xmlXPtrRan
	push	23					; 00000017H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrRan
$LN7@xmlXPtrRan:

; 2021 :     if ((ctxt->value == NULL) ||

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN9@xmlXPtrRan
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 7
	je	SHORT $LN8@xmlXPtrRan
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN8@xmlXPtrRan
$LN9@xmlXPtrRan:

; 2022 : 	((ctxt->value->type != XPATH_LOCATIONSET) &&
; 2023 : 	 (ctxt->value->type != XPATH_NODESET)))
; 2024 :         XP_ERROR(XPATH_INVALID_TYPE)

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrRan
$LN8@xmlXPtrRan:

; 2025 : 
; 2026 :     set = valuePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _set$[ebp], eax

; 2027 :     if (set->type == XPATH_NODESET) {

	mov	eax, DWORD PTR _set$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN10@xmlXPtrRan

; 2028 : 	xmlXPathObjectPtr tmp;
; 2029 : 
; 2030 : 	/*
; 2031 : 	 * First convert to a location set
; 2032 : 	 */
; 2033 : 	tmp = xmlXPtrNewLocationSetNodeSet(set->nodesetval);

	mov	ecx, DWORD PTR _set$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlXPtrNewLocationSetNodeSet
	add	esp, 4
	mov	DWORD PTR _tmp$1[ebp], eax

; 2034 : 	xmlXPathFreeObject(set);

	mov	eax, DWORD PTR _set$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 2035 : 	if (tmp == NULL)

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN11@xmlXPtrRan

; 2036 :             XP_ERROR(XPATH_MEMORY_ERROR)

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrRan
$LN11@xmlXPtrRan:

; 2037 : 	set = tmp;

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _set$[ebp], edx
$LN10@xmlXPtrRan:

; 2038 :     }
; 2039 :     oldset = (xmlLocationSetPtr) set->user;

	mov	eax, DWORD PTR _set$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _oldset$[ebp], ecx

; 2040 : 
; 2041 :     /*
; 2042 :      * The loop is to compute the covering range for each item and add it
; 2043 :      */
; 2044 :     newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$[ebp], eax

; 2045 :     if (newset == NULL) {

	cmp	DWORD PTR _newset$[ebp], 0
	jne	SHORT $LN12@xmlXPtrRan

; 2046 : 	xmlXPathFreeObject(set);

	mov	edx, DWORD PTR _set$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 2047 :         XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN1@xmlXPtrRan
$LN12@xmlXPtrRan:

; 2048 :     }
; 2049 :     if (oldset != NULL) {

	cmp	DWORD PTR _oldset$[ebp], 0
	je	SHORT $LN13@xmlXPtrRan

; 2050 :         for (i = 0;i < oldset->locNr;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlXPtrRan
$LN2@xmlXPtrRan:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlXPtrRan:
	mov	edx, DWORD PTR _oldset$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN13@xmlXPtrRan

; 2051 :             xmlXPtrLocationSetAdd(newset,

	mov	ecx, DWORD PTR _oldset$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPtrCoveringRange
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _newset$[ebp]
	push	eax
	call	_xmlXPtrLocationSetAdd
	add	esp, 8

; 2052 :                     xmlXPtrCoveringRange(ctxt, oldset->locTab[i]));
; 2053 :         }

	jmp	SHORT $LN2@xmlXPtrRan
$LN13@xmlXPtrRan:

; 2054 :     }
; 2055 : 
; 2056 :     /*
; 2057 :      * Save the new value and cleanup
; 2058 :      */
; 2059 :     valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	mov	ecx, DWORD PTR _newset$[ebp]
	push	ecx
	call	_xmlXPtrWrapLocationSet
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePush
	add	esp, 8

; 2060 :     xmlXPathFreeObject(set);

	mov	eax, DWORD PTR _set$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4
$LN1@xmlXPtrRan:

; 2061 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrRangeFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrRangeInsideFunction
_TEXT	SEGMENT
_tmp$1 = -20						; size = 4
_newset$ = -16						; size = 4
_oldset$ = -12						; size = 4
_set$ = -8						; size = 4
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrRangeInsideFunction PROC			; COMDAT

; 2168 : xmlXPtrRangeInsideFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2169 :     int i;
; 2170 :     xmlXPathObjectPtr set;
; 2171 :     xmlLocationSetPtr oldset;
; 2172 :     xmlLocationSetPtr newset;
; 2173 : 
; 2174 :     CHECK_ARITY(1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN5@xmlXPtrRan
	jmp	$LN1@xmlXPtrRan
$LN5@xmlXPtrRan:
	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN6@xmlXPtrRan
	push	12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrRan
$LN6@xmlXPtrRan:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+20], edx
	jge	SHORT $LN7@xmlXPtrRan
	push	23					; 00000017H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrRan
$LN7@xmlXPtrRan:

; 2175 :     if ((ctxt->value == NULL) ||

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN9@xmlXPtrRan
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 7
	je	SHORT $LN8@xmlXPtrRan
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN8@xmlXPtrRan
$LN9@xmlXPtrRan:

; 2176 : 	((ctxt->value->type != XPATH_LOCATIONSET) &&
; 2177 : 	 (ctxt->value->type != XPATH_NODESET)))
; 2178 :         XP_ERROR(XPATH_INVALID_TYPE)

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrRan
$LN8@xmlXPtrRan:

; 2179 : 
; 2180 :     set = valuePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _set$[ebp], eax

; 2181 :     if (set->type == XPATH_NODESET) {

	mov	eax, DWORD PTR _set$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN10@xmlXPtrRan

; 2182 : 	xmlXPathObjectPtr tmp;
; 2183 : 
; 2184 : 	/*
; 2185 : 	 * First convert to a location set
; 2186 : 	 */
; 2187 : 	tmp = xmlXPtrNewLocationSetNodeSet(set->nodesetval);

	mov	ecx, DWORD PTR _set$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlXPtrNewLocationSetNodeSet
	add	esp, 4
	mov	DWORD PTR _tmp$1[ebp], eax

; 2188 : 	xmlXPathFreeObject(set);

	mov	eax, DWORD PTR _set$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 2189 : 	if (tmp == NULL)

	cmp	DWORD PTR _tmp$1[ebp], 0
	jne	SHORT $LN11@xmlXPtrRan

; 2190 : 	     XP_ERROR(XPATH_MEMORY_ERROR)

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrRan
$LN11@xmlXPtrRan:

; 2191 : 	set = tmp;

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR _set$[ebp], edx
$LN10@xmlXPtrRan:

; 2192 :     }
; 2193 :     oldset = (xmlLocationSetPtr) set->user;

	mov	eax, DWORD PTR _set$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _oldset$[ebp], ecx

; 2194 : 
; 2195 :     /*
; 2196 :      * The loop is to compute the covering range for each item and add it
; 2197 :      */
; 2198 :     newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$[ebp], eax

; 2199 :     if (newset == NULL) {

	cmp	DWORD PTR _newset$[ebp], 0
	jne	SHORT $LN12@xmlXPtrRan

; 2200 : 	xmlXPathFreeObject(set);

	mov	edx, DWORD PTR _set$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 2201 :         XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN1@xmlXPtrRan
$LN12@xmlXPtrRan:

; 2202 :     }
; 2203 :     for (i = 0;i < oldset->locNr;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlXPtrRan
$LN2@xmlXPtrRan:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlXPtrRan:
	mov	edx, DWORD PTR _oldset$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN3@xmlXPtrRan

; 2204 : 	xmlXPtrLocationSetAdd(newset,

	mov	ecx, DWORD PTR _oldset$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPtrInsideRange
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _newset$[ebp]
	push	eax
	call	_xmlXPtrLocationSetAdd
	add	esp, 8

; 2205 : 		xmlXPtrInsideRange(ctxt, oldset->locTab[i]));
; 2206 :     }

	jmp	SHORT $LN2@xmlXPtrRan
$LN3@xmlXPtrRan:

; 2207 : 
; 2208 :     /*
; 2209 :      * Save the new value and cleanup
; 2210 :      */
; 2211 :     valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	mov	ecx, DWORD PTR _newset$[ebp]
	push	ecx
	call	_xmlXPtrWrapLocationSet
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePush
	add	esp, 8

; 2212 :     xmlXPathFreeObject(set);

	mov	eax, DWORD PTR _set$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4
$LN1@xmlXPtrRan:

; 2213 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrRangeInsideFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrOriginFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrOriginFunction PROC				; COMDAT

; 1734 : xmlXPtrOriginFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1735 :     CHECK_ARITY(0);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlXPtrOri
	jmp	SHORT $LN1@xmlXPtrOri
$LN2@xmlXPtrOri:
	cmp	DWORD PTR _nargs$[ebp], 0
	je	SHORT $LN3@xmlXPtrOri
	push	12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN1@xmlXPtrOri
$LN3@xmlXPtrOri:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [edx+44]
	jge	SHORT $LN4@xmlXPtrOri
	push	23					; 00000017H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN1@xmlXPtrOri
$LN4@xmlXPtrOri:

; 1736 : 
; 1737 :     if (ctxt->context->origin == NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	DWORD PTR [eax+84], 0
	jne	SHORT $LN5@xmlXPtrOri

; 1738 : 	XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN1@xmlXPtrOri
$LN5@xmlXPtrOri:

; 1739 : 
; 1740 :     valuePush(ctxt, xmlXPtrNewLocationSetNodes(ctxt->context->origin, NULL));

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	call	_xmlXPtrNewLocationSetNodes
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePush
	add	esp, 8
$LN1@xmlXPtrOri:

; 1741 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlXPtrOriginFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrHereFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrHereFunction PROC				; COMDAT

; 1716 : xmlXPtrHereFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1717 :     CHECK_ARITY(0);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlXPtrHer
	jmp	SHORT $LN1@xmlXPtrHer
$LN2@xmlXPtrHer:
	cmp	DWORD PTR _nargs$[ebp], 0
	je	SHORT $LN3@xmlXPtrHer
	push	12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN1@xmlXPtrHer
$LN3@xmlXPtrHer:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [edx+44]
	jge	SHORT $LN4@xmlXPtrHer
	push	23					; 00000017H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN1@xmlXPtrHer
$LN4@xmlXPtrHer:

; 1718 : 
; 1719 :     if (ctxt->context->here == NULL)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	DWORD PTR [eax+80], 0
	jne	SHORT $LN5@xmlXPtrHer

; 1720 : 	XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN1@xmlXPtrHer
$LN5@xmlXPtrHer:

; 1721 : 
; 1722 :     valuePush(ctxt, xmlXPtrNewLocationSetNodes(ctxt->context->here, NULL));

	push	0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	call	_xmlXPtrNewLocationSetNodes
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePush
	add	esp, 8
$LN1@xmlXPtrHer:

; 1723 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlXPtrHereFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEndPointFunction
_TEXT	SEGMENT
tv143 = -32						; size = 4
_node$1 = -28						; size = 4
_i$2 = -24						; size = 4
_oldset$ = -20						; size = 4
_newset$ = -16						; size = 4
_point$ = -12						; size = 4
_obj$ = -8						; size = 4
_tmp$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrEndPointFunction PROC				; COMDAT

; 1863 : xmlXPtrEndPointFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1864 :     xmlXPathObjectPtr tmp, obj, point;
; 1865 :     xmlLocationSetPtr newset = NULL;

	mov	DWORD PTR _newset$[ebp], 0

; 1866 :     xmlLocationSetPtr oldset = NULL;

	mov	DWORD PTR _oldset$[ebp], 0

; 1867 : 
; 1868 :     CHECK_ARITY(1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN7@xmlXPtrEnd
	jmp	$LN1@xmlXPtrEnd
$LN7@xmlXPtrEnd:
	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN8@xmlXPtrEnd
	push	12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEnd
$LN8@xmlXPtrEnd:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+20], edx
	jge	SHORT $LN9@xmlXPtrEnd
	push	23					; 00000017H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEnd
$LN9@xmlXPtrEnd:

; 1869 :     if ((ctxt->value == NULL) ||

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN11@xmlXPtrEnd
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 7
	je	SHORT $LN10@xmlXPtrEnd
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN10@xmlXPtrEnd
$LN11@xmlXPtrEnd:

; 1870 : 	((ctxt->value->type != XPATH_LOCATIONSET) &&
; 1871 : 	 (ctxt->value->type != XPATH_NODESET)))
; 1872 :         XP_ERROR(XPATH_INVALID_TYPE)

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEnd
$LN10@xmlXPtrEnd:

; 1873 : 
; 1874 :     obj = valuePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _obj$[ebp], eax

; 1875 :     if (obj->type == XPATH_NODESET) {

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN12@xmlXPtrEnd

; 1876 : 	/*
; 1877 : 	 * First convert to a location set
; 1878 : 	 */
; 1879 : 	tmp = xmlXPtrNewLocationSetNodeSet(obj->nodesetval);

	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlXPtrNewLocationSetNodeSet
	add	esp, 4
	mov	DWORD PTR _tmp$[ebp], eax

; 1880 : 	xmlXPathFreeObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1881 : 	if (tmp == NULL)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN13@xmlXPtrEnd

; 1882 :             XP_ERROR(XPATH_MEMORY_ERROR)

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEnd
$LN13@xmlXPtrEnd:

; 1883 : 	obj = tmp;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _obj$[ebp], edx
$LN12@xmlXPtrEnd:

; 1884 :     }
; 1885 : 
; 1886 :     newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$[ebp], eax

; 1887 :     if (newset == NULL) {

	cmp	DWORD PTR _newset$[ebp], 0
	jne	SHORT $LN14@xmlXPtrEnd

; 1888 : 	xmlXPathFreeObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1889 :         XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEnd
$LN14@xmlXPtrEnd:

; 1890 :     }
; 1891 :     oldset = (xmlLocationSetPtr) obj->user;

	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _oldset$[ebp], eax

; 1892 :     if (oldset != NULL) {

	cmp	DWORD PTR _oldset$[ebp], 0
	je	$LN15@xmlXPtrEnd

; 1893 : 	int i;
; 1894 : 
; 1895 : 	for (i = 0; i < oldset->locNr; i++) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@xmlXPtrEnd
$LN2@xmlXPtrEnd:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN4@xmlXPtrEnd:
	mov	edx, DWORD PTR _oldset$[ebp]
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	$LN15@xmlXPtrEnd

; 1896 : 	    tmp = oldset->locTab[i];

	mov	ecx, DWORD PTR _oldset$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _tmp$[ebp], ecx

; 1897 : 	    if (tmp == NULL)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN16@xmlXPtrEnd

; 1898 : 		continue;

	jmp	SHORT $LN2@xmlXPtrEnd
$LN16@xmlXPtrEnd:

; 1899 : 	    point = NULL;

	mov	DWORD PTR _point$[ebp], 0

; 1900 : 	    switch (tmp->type) {

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv143[ebp], eax
	cmp	DWORD PTR tv143[ebp], 5
	je	SHORT $LN17@xmlXPtrEnd
	cmp	DWORD PTR tv143[ebp], 6
	je	SHORT $LN18@xmlXPtrEnd
	jmp	$LN5@xmlXPtrEnd
$LN17@xmlXPtrEnd:

; 1901 : 		case XPATH_POINT:
; 1902 : 		    point = xmlXPtrNewPoint(tmp->user, tmp->index);

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_xmlXPtrNewPoint
	add	esp, 8
	mov	DWORD PTR _point$[ebp], eax

; 1903 : 		    break;

	jmp	$LN5@xmlXPtrEnd
$LN18@xmlXPtrEnd:

; 1904 : 		case XPATH_RANGE: {
; 1905 : 		    xmlNodePtr node = tmp->user2;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _node$1[ebp], eax

; 1906 : 		    if (node != NULL) {

	cmp	DWORD PTR _node$1[ebp], 0
	je	SHORT $LN19@xmlXPtrEnd

; 1907 : 			if ((node->type == XML_ATTRIBUTE_NODE) ||

	mov	ecx, DWORD PTR _node$1[ebp]
	cmp	DWORD PTR [ecx+4], 2
	je	SHORT $LN22@xmlXPtrEnd
	mov	edx, DWORD PTR _node$1[ebp]
	cmp	DWORD PTR [edx+4], 18			; 00000012H
	jne	SHORT $LN21@xmlXPtrEnd
$LN22@xmlXPtrEnd:

; 1908 :                             (node->type == XML_NAMESPACE_DECL)) {
; 1909 : 			    xmlXPathFreeObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1910 : 			    xmlXPtrFreeLocationSet(newset);

	mov	ecx, DWORD PTR _newset$[ebp]
	push	ecx
	call	_xmlXPtrFreeLocationSet
	add	esp, 4

; 1911 : 			    XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN1@xmlXPtrEnd
$LN21@xmlXPtrEnd:

; 1912 : 			}
; 1913 : 			point = xmlXPtrNewPoint(node, tmp->index2);

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _node$1[ebp]
	push	edx
	call	_xmlXPtrNewPoint
	add	esp, 8
	mov	DWORD PTR _point$[ebp], eax
	jmp	SHORT $LN5@xmlXPtrEnd
$LN19@xmlXPtrEnd:

; 1914 : 		    } else if (tmp->user == NULL) {

	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN5@xmlXPtrEnd

; 1915 : 			point = xmlXPtrNewPoint(node,

	mov	ecx, DWORD PTR _node$1[ebp]
	push	ecx
	call	_xmlXPtrNbLocChildren
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _node$1[ebp]
	push	edx
	call	_xmlXPtrNewPoint
	add	esp, 8
	mov	DWORD PTR _point$[ebp], eax
$LN5@xmlXPtrEnd:

; 1916 : 				       xmlXPtrNbLocChildren(node));
; 1917 : 		    }
; 1918 : 		    break;
; 1919 : 	        }
; 1920 : 		default:
; 1921 : 		    /*** Should we raise an error ?
; 1922 : 		    xmlXPathFreeObject(obj);
; 1923 : 		    xmlXPathFreeObject(newset);
; 1924 : 		    XP_ERROR(XPATH_INVALID_TYPE)
; 1925 : 		    ***/
; 1926 : 		    break;
; 1927 : 	    }
; 1928 :             if (point != NULL)

	cmp	DWORD PTR _point$[ebp], 0
	je	SHORT $LN25@xmlXPtrEnd

; 1929 : 		xmlXPtrLocationSetAdd(newset, point);

	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newset$[ebp]
	push	ecx
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
$LN25@xmlXPtrEnd:

; 1930 : 	}

	jmp	$LN2@xmlXPtrEnd
$LN15@xmlXPtrEnd:

; 1931 :     }
; 1932 :     xmlXPathFreeObject(obj);

	mov	edx, DWORD PTR _obj$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1933 :     valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	mov	eax, DWORD PTR _newset$[ebp]
	push	eax
	call	_xmlXPtrWrapLocationSet
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_valuePush
	add	esp, 8
$LN1@xmlXPtrEnd:

; 1934 : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrEndPointFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrStartPointFunction
_TEXT	SEGMENT
tv143 = -32						; size = 4
_node$1 = -28						; size = 4
_i$2 = -24						; size = 4
_oldset$ = -20						; size = 4
_newset$ = -16						; size = 4
_point$ = -12						; size = 4
_obj$ = -8						; size = 4
_tmp$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrStartPointFunction PROC				; COMDAT

; 1767 : xmlXPtrStartPointFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1768 :     xmlXPathObjectPtr tmp, obj, point;
; 1769 :     xmlLocationSetPtr newset = NULL;

	mov	DWORD PTR _newset$[ebp], 0

; 1770 :     xmlLocationSetPtr oldset = NULL;

	mov	DWORD PTR _oldset$[ebp], 0

; 1771 : 
; 1772 :     CHECK_ARITY(1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN7@xmlXPtrSta
	jmp	$LN1@xmlXPtrSta
$LN7@xmlXPtrSta:
	cmp	DWORD PTR _nargs$[ebp], 1
	je	SHORT $LN8@xmlXPtrSta
	push	12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrSta
$LN8@xmlXPtrSta:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+20], edx
	jge	SHORT $LN9@xmlXPtrSta
	push	23					; 00000017H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrSta
$LN9@xmlXPtrSta:

; 1773 :     if ((ctxt->value == NULL) ||

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN11@xmlXPtrSta
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 7
	je	SHORT $LN10@xmlXPtrSta
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN10@xmlXPtrSta
$LN11@xmlXPtrSta:

; 1774 : 	((ctxt->value->type != XPATH_LOCATIONSET) &&
; 1775 : 	 (ctxt->value->type != XPATH_NODESET)))
; 1776 :         XP_ERROR(XPATH_INVALID_TYPE)

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrSta
$LN10@xmlXPtrSta:

; 1777 : 
; 1778 :     obj = valuePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _obj$[ebp], eax

; 1779 :     if (obj->type == XPATH_NODESET) {

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN12@xmlXPtrSta

; 1780 : 	/*
; 1781 : 	 * First convert to a location set
; 1782 : 	 */
; 1783 : 	tmp = xmlXPtrNewLocationSetNodeSet(obj->nodesetval);

	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlXPtrNewLocationSetNodeSet
	add	esp, 4
	mov	DWORD PTR _tmp$[ebp], eax

; 1784 : 	xmlXPathFreeObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1785 : 	if (tmp == NULL)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN13@xmlXPtrSta

; 1786 :             XP_ERROR(XPATH_MEMORY_ERROR)

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrSta
$LN13@xmlXPtrSta:

; 1787 : 	obj = tmp;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _obj$[ebp], edx
$LN12@xmlXPtrSta:

; 1788 :     }
; 1789 : 
; 1790 :     newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$[ebp], eax

; 1791 :     if (newset == NULL) {

	cmp	DWORD PTR _newset$[ebp], 0
	jne	SHORT $LN14@xmlXPtrSta

; 1792 : 	xmlXPathFreeObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1793 :         XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrSta
$LN14@xmlXPtrSta:

; 1794 :     }
; 1795 :     oldset = (xmlLocationSetPtr) obj->user;

	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _oldset$[ebp], eax

; 1796 :     if (oldset != NULL) {

	cmp	DWORD PTR _oldset$[ebp], 0
	je	$LN15@xmlXPtrSta

; 1797 : 	int i;
; 1798 : 
; 1799 : 	for (i = 0; i < oldset->locNr; i++) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@xmlXPtrSta
$LN2@xmlXPtrSta:
	mov	ecx, DWORD PTR _i$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$2[ebp], ecx
$LN4@xmlXPtrSta:
	mov	edx, DWORD PTR _oldset$[ebp]
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	$LN15@xmlXPtrSta

; 1800 : 	    tmp = oldset->locTab[i];

	mov	ecx, DWORD PTR _oldset$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _tmp$[ebp], ecx

; 1801 : 	    if (tmp == NULL)

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN16@xmlXPtrSta

; 1802 : 		continue;

	jmp	SHORT $LN2@xmlXPtrSta
$LN16@xmlXPtrSta:

; 1803 : 	    point = NULL;

	mov	DWORD PTR _point$[ebp], 0

; 1804 : 	    switch (tmp->type) {

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv143[ebp], eax
	cmp	DWORD PTR tv143[ebp], 5
	je	SHORT $LN17@xmlXPtrSta
	cmp	DWORD PTR tv143[ebp], 6
	je	SHORT $LN18@xmlXPtrSta
	jmp	SHORT $LN5@xmlXPtrSta
$LN17@xmlXPtrSta:

; 1805 : 		case XPATH_POINT:
; 1806 : 		    point = xmlXPtrNewPoint(tmp->user, tmp->index);

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_xmlXPtrNewPoint
	add	esp, 8
	mov	DWORD PTR _point$[ebp], eax

; 1807 : 		    break;

	jmp	SHORT $LN5@xmlXPtrSta
$LN18@xmlXPtrSta:

; 1808 : 		case XPATH_RANGE: {
; 1809 : 		    xmlNodePtr node = tmp->user;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _node$1[ebp], eax

; 1810 : 		    if (node != NULL) {

	cmp	DWORD PTR _node$1[ebp], 0
	je	SHORT $LN5@xmlXPtrSta

; 1811 : 			if ((node->type == XML_ATTRIBUTE_NODE) ||

	mov	ecx, DWORD PTR _node$1[ebp]
	cmp	DWORD PTR [ecx+4], 2
	je	SHORT $LN21@xmlXPtrSta
	mov	edx, DWORD PTR _node$1[ebp]
	cmp	DWORD PTR [edx+4], 18			; 00000012H
	jne	SHORT $LN20@xmlXPtrSta
$LN21@xmlXPtrSta:

; 1812 :                             (node->type == XML_NAMESPACE_DECL)) {
; 1813 : 			    xmlXPathFreeObject(obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1814 : 			    xmlXPtrFreeLocationSet(newset);

	mov	ecx, DWORD PTR _newset$[ebp]
	push	ecx
	call	_xmlXPtrFreeLocationSet
	add	esp, 4

; 1815 : 			    XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathErr
	add	esp, 8
	jmp	SHORT $LN1@xmlXPtrSta
$LN20@xmlXPtrSta:

; 1816 : 			}
; 1817 : 			point = xmlXPtrNewPoint(node, tmp->index);

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _node$1[ebp]
	push	edx
	call	_xmlXPtrNewPoint
	add	esp, 8
	mov	DWORD PTR _point$[ebp], eax
$LN5@xmlXPtrSta:

; 1818 : 		    }
; 1819 : 		    break;
; 1820 : 	        }
; 1821 : 		default:
; 1822 : 		    /*** Should we raise an error ?
; 1823 : 		    xmlXPathFreeObject(obj);
; 1824 : 		    xmlXPathFreeObject(newset);
; 1825 : 		    XP_ERROR(XPATH_INVALID_TYPE)
; 1826 : 		    ***/
; 1827 : 		    break;
; 1828 : 	    }
; 1829 :             if (point != NULL)

	cmp	DWORD PTR _point$[ebp], 0
	je	SHORT $LN23@xmlXPtrSta

; 1830 : 		xmlXPtrLocationSetAdd(newset, point);

	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newset$[ebp]
	push	ecx
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
$LN23@xmlXPtrSta:

; 1831 : 	}

	jmp	$LN2@xmlXPtrSta
$LN15@xmlXPtrSta:

; 1832 :     }
; 1833 :     xmlXPathFreeObject(obj);

	mov	edx, DWORD PTR _obj$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1834 :     valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	mov	eax, DWORD PTR _newset$[ebp]
	push	eax
	call	_xmlXPtrWrapLocationSet
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_valuePush
	add	esp, 8
$LN1@xmlXPtrSta:

; 1835 : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrStartPointFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrStringRangeFunction
_TEXT	SEGMENT
_rend$1 = -136						; size = 4
_rindx$2 = -124						; size = 4
_tmp$3 = -116						; size = 4
_num$ = -112						; size = 4
_pos$ = -108						; size = 4
_found$ = -104						; size = 4
_number$ = -100						; size = 4
_position$ = -96					; size = 4
_string$ = -92						; size = 4
_newset$ = -88						; size = 4
_oldset$ = -84						; size = 4
_set$ = -80						; size = 4
_fend$ = -72						; size = 4
_end$ = -60						; size = 4
_start$ = -48						; size = 4
_fendindex$ = -36					; size = 4
_endindex$ = -24					; size = 4
_startindex$ = -12					; size = 4
_i$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrStringRangeFunction PROC			; COMDAT

; 2696 : xmlXPtrStringRangeFunction(xmlXPathParserContextPtr ctxt, int nargs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	edi
	lea	edi, DWORD PTR [ebp-140]
	mov	ecx, 35					; 00000023H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2697 :     int i, startindex, endindex = 0, fendindex;

	mov	DWORD PTR _endindex$[ebp], 0

; 2698 :     xmlNodePtr start, end = 0, fend;

	mov	DWORD PTR _end$[ebp], 0

; 2699 :     xmlXPathObjectPtr set;
; 2700 :     xmlLocationSetPtr oldset;
; 2701 :     xmlLocationSetPtr newset;
; 2702 :     xmlXPathObjectPtr string;
; 2703 :     xmlXPathObjectPtr position = NULL;

	mov	DWORD PTR _position$[ebp], 0

; 2704 :     xmlXPathObjectPtr number = NULL;

	mov	DWORD PTR _number$[ebp], 0

; 2705 :     int found, pos = 0, num = 0;

	mov	DWORD PTR _pos$[ebp], 0
	mov	DWORD PTR _num$[ebp], 0

; 2706 : 
; 2707 :     /*
; 2708 :      * Grab the arguments
; 2709 :      */
; 2710 :     if ((nargs < 2) || (nargs > 4))

	cmp	DWORD PTR _nargs$[ebp], 2
	jl	SHORT $LN9@xmlXPtrStr
	cmp	DWORD PTR _nargs$[ebp], 4
	jle	SHORT $LN8@xmlXPtrStr
$LN9@xmlXPtrStr:

; 2711 : 	XP_ERROR(XPATH_INVALID_ARITY);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN37@xmlXPtrStr
$LN8@xmlXPtrStr:

; 2712 : 
; 2713 :     if (nargs >= 4) {

	cmp	DWORD PTR _nargs$[ebp], 4
	jl	SHORT $LN13@xmlXPtrStr

; 2714 : 	CHECK_TYPE(XPATH_NUMBER);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN12@xmlXPtrStr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN11@xmlXPtrStr
$LN12@xmlXPtrStr:
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN37@xmlXPtrStr
$LN11@xmlXPtrStr:

; 2715 : 	number = valuePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _number$[ebp], eax

; 2716 : 	if (number != NULL)

	cmp	DWORD PTR _number$[ebp], 0
	je	SHORT $LN13@xmlXPtrStr

; 2717 : 	    num = (int) number->floatval;

	mov	eax, DWORD PTR _number$[ebp]
	cvttsd2si ecx, QWORD PTR [eax+16]
	mov	DWORD PTR _num$[ebp], ecx
$LN13@xmlXPtrStr:

; 2718 :     }
; 2719 :     if (nargs >= 3) {

	cmp	DWORD PTR _nargs$[ebp], 3
	jl	SHORT $LN17@xmlXPtrStr

; 2720 : 	CHECK_TYPE(XPATH_NUMBER);

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN16@xmlXPtrStr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 3
	je	SHORT $LN15@xmlXPtrStr
$LN16@xmlXPtrStr:
	push	11					; 0000000bH
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN37@xmlXPtrStr
$LN15@xmlXPtrStr:

; 2721 : 	position = valuePop(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _position$[ebp], eax

; 2722 : 	if (position != NULL)

	cmp	DWORD PTR _position$[ebp], 0
	je	SHORT $LN17@xmlXPtrStr

; 2723 : 	    pos = (int) position->floatval;

	mov	ecx, DWORD PTR _position$[ebp]
	cvttsd2si edx, QWORD PTR [ecx+16]
	mov	DWORD PTR _pos$[ebp], edx
$LN17@xmlXPtrStr:

; 2724 :     }
; 2725 :     CHECK_TYPE(XPATH_STRING);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN19@xmlXPtrStr
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [edx], 4
	je	SHORT $LN18@xmlXPtrStr
$LN19@xmlXPtrStr:
	push	11					; 0000000bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN37@xmlXPtrStr
$LN18@xmlXPtrStr:

; 2726 :     string = valuePop(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _string$[ebp], eax

; 2727 :     if ((ctxt->value == NULL) ||

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN21@xmlXPtrStr
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 7
	je	SHORT $LN20@xmlXPtrStr
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN20@xmlXPtrStr
$LN21@xmlXPtrStr:

; 2728 : 	((ctxt->value->type != XPATH_LOCATIONSET) &&
; 2729 : 	 (ctxt->value->type != XPATH_NODESET)))
; 2730 :         XP_ERROR(XPATH_INVALID_TYPE)

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN37@xmlXPtrStr
$LN20@xmlXPtrStr:

; 2731 : 
; 2732 :     set = valuePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _set$[ebp], eax

; 2733 :     newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$[ebp], eax

; 2734 :     if (newset == NULL) {

	cmp	DWORD PTR _newset$[ebp], 0
	jne	SHORT $LN22@xmlXPtrStr

; 2735 : 	xmlXPathFreeObject(set);

	mov	eax, DWORD PTR _set$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 2736 :         XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN37@xmlXPtrStr
$LN22@xmlXPtrStr:

; 2737 :     }
; 2738 :     if (set->nodesetval == NULL) {

	mov	edx, DWORD PTR _set$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN23@xmlXPtrStr

; 2739 :         goto error;

	jmp	$error$49
$LN23@xmlXPtrStr:

; 2740 :     }
; 2741 :     if (set->type == XPATH_NODESET) {

	mov	eax, DWORD PTR _set$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN24@xmlXPtrStr

; 2742 : 	xmlXPathObjectPtr tmp;
; 2743 : 
; 2744 : 	/*
; 2745 : 	 * First convert to a location set
; 2746 : 	 */
; 2747 : 	tmp = xmlXPtrNewLocationSetNodeSet(set->nodesetval);

	mov	ecx, DWORD PTR _set$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlXPtrNewLocationSetNodeSet
	add	esp, 4
	mov	DWORD PTR _tmp$3[ebp], eax

; 2748 : 	xmlXPathFreeObject(set);

	mov	eax, DWORD PTR _set$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 2749 : 	if (tmp == NULL)

	cmp	DWORD PTR _tmp$3[ebp], 0
	jne	SHORT $LN25@xmlXPtrStr

; 2750 : 	     XP_ERROR(XPATH_MEMORY_ERROR)

	push	15					; 0000000fH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN37@xmlXPtrStr
$LN25@xmlXPtrStr:

; 2751 : 	set = tmp;

	mov	edx, DWORD PTR _tmp$3[ebp]
	mov	DWORD PTR _set$[ebp], edx
$LN24@xmlXPtrStr:

; 2752 :     }
; 2753 :     oldset = (xmlLocationSetPtr) set->user;

	mov	eax, DWORD PTR _set$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _oldset$[ebp], ecx

; 2754 : 
; 2755 :     /*
; 2756 :      * The loop is to search for each element in the location set
; 2757 :      * the list of location set corresponding to that search
; 2758 :      */
; 2759 :     for (i = 0;i < oldset->locNr;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlXPtrStr
$LN2@xmlXPtrStr:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@xmlXPtrStr:
	mov	eax, DWORD PTR _oldset$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$error$49

; 2760 : #ifdef DEBUG_RANGES
; 2761 : 	xmlXPathDebugDumpObject(stdout, oldset->locTab[i], 0);
; 2762 : #endif
; 2763 : 
; 2764 : 	xmlXPtrGetStartPoint(oldset->locTab[i], &start, &startindex);

	lea	edx, DWORD PTR _startindex$[ebp]
	push	edx
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldset$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_xmlXPtrGetStartPoint
	add	esp, 12					; 0000000cH

; 2765 : 	xmlXPtrGetEndPoint(oldset->locTab[i], &end, &endindex);

	lea	edx, DWORD PTR _endindex$[ebp]
	push	edx
	lea	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldset$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_xmlXPtrGetEndPoint
	add	esp, 12					; 0000000cH

; 2766 : 	xmlXPtrAdvanceChar(&start, &startindex, 0);

	push	0
	lea	edx, DWORD PTR _startindex$[ebp]
	push	edx
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlXPtrAdvanceChar
	add	esp, 12					; 0000000cH

; 2767 : 	xmlXPtrGetLastChar(&end, &endindex);

	lea	ecx, DWORD PTR _endindex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _end$[ebp]
	push	edx
	call	_xmlXPtrGetLastChar
	add	esp, 8
$LN7@xmlXPtrStr:

; 2768 : 
; 2769 : #ifdef DEBUG_RANGES
; 2770 : 	xmlGenericError(xmlGenericErrorContext,
; 2771 : 		"from index %d of ->", startindex);
; 2772 : 	xmlDebugDumpString(stdout, start->content);
; 2773 : 	xmlGenericError(xmlGenericErrorContext, "\n");
; 2774 : 	xmlGenericError(xmlGenericErrorContext,
; 2775 : 		"to index %d of ->", endindex);
; 2776 : 	xmlDebugDumpString(stdout, end->content);
; 2777 : 	xmlGenericError(xmlGenericErrorContext, "\n");
; 2778 : #endif
; 2779 : 	do {
; 2780 :             fend = end;

	mov	eax, DWORD PTR _end$[ebp]
	mov	DWORD PTR _fend$[ebp], eax

; 2781 :             fendindex = endindex;

	mov	ecx, DWORD PTR _endindex$[ebp]
	mov	DWORD PTR _fendindex$[ebp], ecx

; 2782 : 	    found = xmlXPtrSearchString(string->stringval, &start, &startindex,

	lea	edx, DWORD PTR _fendindex$[ebp]
	push	edx
	lea	eax, DWORD PTR _fend$[ebp]
	push	eax
	lea	ecx, DWORD PTR _startindex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _string$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_xmlXPtrSearchString
	add	esp, 20					; 00000014H
	mov	DWORD PTR _found$[ebp], eax

; 2783 : 		                        &fend, &fendindex);
; 2784 : 	    if (found == 1) {

	cmp	DWORD PTR _found$[ebp], 1
	jne	$LN35@xmlXPtrStr

; 2785 : 		if (position == NULL) {

	cmp	DWORD PTR _position$[ebp], 0
	jne	SHORT $LN27@xmlXPtrStr

; 2786 : 		    xmlXPtrLocationSetAdd(newset,

	mov	edx, DWORD PTR _fendindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _fend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _startindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR _newset$[ebp]
	push	eax
	call	_xmlXPtrLocationSetAdd
	add	esp, 8

; 2787 : 			 xmlXPtrNewRange(start, startindex, fend, fendindex));
; 2788 : 		} else if (xmlXPtrAdvanceChar(&start, &startindex,

	jmp	$LN34@xmlXPtrStr
$LN27@xmlXPtrStr:

; 2789 : 			                      pos - 1) == 0) {

	mov	ecx, DWORD PTR _pos$[ebp]
	sub	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _startindex$[ebp]
	push	edx
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlXPtrAdvanceChar
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN34@xmlXPtrStr

; 2790 : 		    if ((number != NULL) && (num > 0)) {

	cmp	DWORD PTR _number$[ebp], 0
	je	SHORT $LN30@xmlXPtrStr
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $LN30@xmlXPtrStr

; 2791 : 			int rindx;
; 2792 : 			xmlNodePtr rend;
; 2793 : 			rend = start;

	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _rend$1[ebp], ecx

; 2794 : 			rindx = startindex - 1;

	mov	edx, DWORD PTR _startindex$[ebp]
	sub	edx, 1
	mov	DWORD PTR _rindx$2[ebp], edx

; 2795 : 			if (xmlXPtrAdvanceChar(&rend, &rindx,
; 2796 : 				               num) == 0) {

	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rindx$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _rend$1[ebp]
	push	edx
	call	_xmlXPtrAdvanceChar
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN32@xmlXPtrStr

; 2797 : 			    xmlXPtrLocationSetAdd(newset,

	mov	eax, DWORD PTR _rindx$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _rend$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _startindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _newset$[ebp]
	push	ecx
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
$LN32@xmlXPtrStr:

; 2798 : 					xmlXPtrNewRange(start, startindex,
; 2799 : 							rend, rindx));
; 2800 : 			}

	jmp	SHORT $LN34@xmlXPtrStr
$LN30@xmlXPtrStr:

; 2801 : 		    } else if ((number != NULL) && (num <= 0)) {

	cmp	DWORD PTR _number$[ebp], 0
	je	SHORT $LN33@xmlXPtrStr
	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $LN33@xmlXPtrStr

; 2802 : 			xmlXPtrLocationSetAdd(newset,

	mov	edx, DWORD PTR _startindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _startindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR _newset$[ebp]
	push	eax
	call	_xmlXPtrLocationSetAdd
	add	esp, 8

; 2803 : 				    xmlXPtrNewRange(start, startindex,
; 2804 : 						    start, startindex));
; 2805 : 		    } else {

	jmp	SHORT $LN34@xmlXPtrStr
$LN33@xmlXPtrStr:

; 2806 : 			xmlXPtrLocationSetAdd(newset,

	mov	ecx, DWORD PTR _fendindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fend$[ebp]
	push	edx
	mov	eax, DWORD PTR _startindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	call	_xmlXPtrNewRange
	add	esp, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _newset$[ebp]
	push	edx
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
$LN34@xmlXPtrStr:

; 2807 : 				    xmlXPtrNewRange(start, startindex,
; 2808 : 						    fend, fendindex));
; 2809 : 		    }
; 2810 : 		}
; 2811 : 		start = fend;

	mov	eax, DWORD PTR _fend$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 2812 : 		startindex = fendindex;

	mov	ecx, DWORD PTR _fendindex$[ebp]
	mov	DWORD PTR _startindex$[ebp], ecx

; 2813 : 		if (string->stringval[0] == 0)

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _string$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	jne	SHORT $LN35@xmlXPtrStr

; 2814 : 		    startindex++;

	mov	ecx, DWORD PTR _startindex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _startindex$[ebp], ecx
$LN35@xmlXPtrStr:

; 2815 : 	    }
; 2816 : 	} while (found == 1);

	cmp	DWORD PTR _found$[ebp], 1
	je	$LN7@xmlXPtrStr

; 2817 :     }

	jmp	$LN2@xmlXPtrStr
$error$49:

; 2818 : 
; 2819 :     /*
; 2820 :      * Save the new value and cleanup
; 2821 :      */
; 2822 : error:
; 2823 :     valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	mov	edx, DWORD PTR _newset$[ebp]
	push	edx
	call	_xmlXPtrWrapLocationSet
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_valuePush
	add	esp, 8

; 2824 :     xmlXPathFreeObject(set);

	mov	ecx, DWORD PTR _set$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 2825 :     xmlXPathFreeObject(string);

	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 2826 :     if (position) xmlXPathFreeObject(position);

	cmp	DWORD PTR _position$[ebp], 0
	je	SHORT $LN36@xmlXPtrStr
	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4
$LN36@xmlXPtrStr:

; 2827 :     if (number) xmlXPathFreeObject(number);

	cmp	DWORD PTR _number$[ebp], 0
	je	SHORT $LN37@xmlXPtrStr
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4
$LN37@xmlXPtrStr:

; 2828 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN48@xmlXPtrStr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 140				; 0000008cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN48@xmlXPtrStr:
	DD	8
	DD	$LN47@xmlXPtrStr
$LN47@xmlXPtrStr:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN39@xmlXPtrStr
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN40@xmlXPtrStr
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN41@xmlXPtrStr
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN42@xmlXPtrStr
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN43@xmlXPtrStr
	DD	-72					; ffffffb8H
	DD	4
	DD	$LN44@xmlXPtrStr
	DD	-124					; ffffff84H
	DD	4
	DD	$LN45@xmlXPtrStr
	DD	-136					; ffffff78H
	DD	4
	DD	$LN46@xmlXPtrStr
$LN46@xmlXPtrStr:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN45@xmlXPtrStr:
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	120					; 00000078H
	DB	0
$LN44@xmlXPtrStr:
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN43@xmlXPtrStr:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN42@xmlXPtrStr:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$LN41@xmlXPtrStr:
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN40@xmlXPtrStr:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN39@xmlXPtrStr:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
_xmlXPtrStringRangeFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEvalXPointer
_TEXT	SEGMENT
tv179 = -12						; size = 4
tv133 = -8						; size = 4
_name$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlXPtrEvalXPointer PROC				; COMDAT

; 1228 : xmlXPtrEvalXPointer(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1229 :     if (ctxt->valueTab == NULL) {

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN2@xmlXPtrEva

; 1230 : 	/* Allocate the value stack */
; 1231 : 	ctxt->valueTab = (xmlXPathObjectPtr *)

	mov	esi, esp
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1232 : 			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
; 1233 : 	if (ctxt->valueTab == NULL) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN7@xmlXPtrEva

; 1234 : 	    xmlXPtrErrMemory("allocating evaluation context");

	push	OFFSET ??_C@_0BO@HMMGLLBJ@allocating?5evaluation?5context@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 1235 : 	    return;

	jmp	$LN1@xmlXPtrEva
$LN7@xmlXPtrEva:

; 1236 : 	}
; 1237 : 	ctxt->valueNr = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1238 : 	ctxt->valueMax = 10;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx+24], 10			; 0000000aH

; 1239 : 	ctxt->value = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1240 : 	ctxt->valueFrame = 0;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax+44], 0
$LN2@xmlXPtrEva:

; 1241 :     }
; 1242 :     SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN8@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN9@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN8@xmlXPtrEva
$LN9@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPtrEva
$LN8@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN19@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv133[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN20@xmlXPtrEva
$LN19@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv133[ebp], ecx
$LN20@xmlXPtrEva:
	jmp	SHORT $LN2@xmlXPtrEva
$LN3@xmlXPtrEva:

; 1243 :     if (CUR == '/') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN10@xmlXPtrEva

; 1244 : 	xmlXPathRoot(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathRoot
	add	esp, 4

; 1245 :         xmlXPtrEvalChildSeq(ctxt, NULL);

	push	0
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPtrEvalChildSeq
	add	esp, 8

; 1246 :     } else {

	jmp	SHORT $LN4@xmlXPtrEva
$LN10@xmlXPtrEva:

; 1247 : 	xmlChar *name;
; 1248 : 
; 1249 : 	name = xmlXPathParseName(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathParseName
	add	esp, 4
	mov	DWORD PTR _name$1[ebp], eax

; 1250 : 	if (name == NULL)

	cmp	DWORD PTR _name$1[ebp], 0
	jne	SHORT $LN12@xmlXPtrEva

; 1251 : 	    XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN12@xmlXPtrEva:

; 1252 : 	if (CUR == '(') {

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 40					; 00000028H
	jne	SHORT $LN13@xmlXPtrEva

; 1253 : 	    xmlXPtrEvalFullXPtr(ctxt, name);

	mov	eax, DWORD PTR _name$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPtrEvalFullXPtr
	add	esp, 8

; 1254 : 	    /* Short evaluation */
; 1255 : 	    return;

	jmp	$LN1@xmlXPtrEva

; 1256 : 	} else {

	jmp	SHORT $LN4@xmlXPtrEva
$LN13@xmlXPtrEva:

; 1257 : 	    /* this handle both Bare Names and Child Sequences */
; 1258 : 	    xmlXPtrEvalChildSeq(ctxt, name);

	mov	edx, DWORD PTR _name$1[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPtrEvalChildSeq
	add	esp, 8
$LN4@xmlXPtrEva:

; 1259 : 	}
; 1260 :     }
; 1261 :     SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN15@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN16@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN15@xmlXPtrEva
$LN16@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPtrEva
$LN15@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN21@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv179[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN22@xmlXPtrEva
$LN21@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv179[ebp], ecx
$LN22@xmlXPtrEva:
	jmp	SHORT $LN4@xmlXPtrEva
$LN5@xmlXPtrEva:

; 1262 :     if (CUR != 0)

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@xmlXPtrEva

; 1263 : 	XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathErr
	add	esp, 8
$LN1@xmlXPtrEva:

; 1264 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrEvalXPointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEvalFullXPtr
_TEXT	SEGMENT
tv157 = -20						; size = 4
tv82 = -16						; size = 4
_loc$1 = -12						; size = 4
_loc$2 = -8						; size = 4
_obj$3 = -4						; size = 4
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlXPtrEvalFullXPtr PROC				; COMDAT

; 1117 : xmlXPtrEvalFullXPtr(xmlXPathParserContextPtr ctxt, xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1118 :     if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN11@xmlXPtrEva

; 1119 :     name = xmlXPathParseName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax
$LN11@xmlXPtrEva:

; 1120 :     if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN2@xmlXPtrEva

; 1121 : 	XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN2@xmlXPtrEva:

; 1122 :     while (name != NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	je	$LN1@xmlXPtrEva

; 1123 : 	ctxt->error = XPATH_EXPRESSION_OK;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1124 : 	xmlXPtrEvalXPtrPart(ctxt, name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPtrEvalXPtrPart
	add	esp, 8

; 1125 : 
; 1126 : 	/* in case of syntax error, break here */
; 1127 : 	if ((ctxt->error != XPATH_EXPRESSION_OK) &&

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN13@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 1900			; 0000076cH
	je	SHORT $LN13@xmlXPtrEva

; 1128 :             (ctxt->error != XML_XPTR_UNKNOWN_SCHEME))
; 1129 : 	    return;

	jmp	$LN1@xmlXPtrEva
$LN13@xmlXPtrEva:

; 1130 : 
; 1131 : 	/*
; 1132 : 	 * If the returned value is a non-empty nodeset
; 1133 : 	 * or location set, return here.
; 1134 : 	 */
; 1135 : 	if (ctxt->value != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	$LN9@xmlXPtrEva

; 1136 : 	    xmlXPathObjectPtr obj = ctxt->value;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _obj$3[ebp], eax

; 1137 : 
; 1138 : 	    switch (obj->type) {

	mov	ecx, DWORD PTR _obj$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv82[ebp], edx
	cmp	DWORD PTR tv82[ebp], 1
	je	SHORT $LN17@xmlXPtrEva
	cmp	DWORD PTR tv82[ebp], 7
	je	SHORT $LN15@xmlXPtrEva
	jmp	SHORT $LN8@xmlXPtrEva
$LN15@xmlXPtrEva:

; 1139 : 		case XPATH_LOCATIONSET: {
; 1140 : 		    xmlLocationSetPtr loc = ctxt->value->user;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _loc$2[ebp], edx

; 1141 : 		    if ((loc != NULL) && (loc->locNr > 0))

	cmp	DWORD PTR _loc$2[ebp], 0
	je	SHORT $LN16@xmlXPtrEva
	mov	eax, DWORD PTR _loc$2[ebp]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN16@xmlXPtrEva

; 1142 : 			return;

	jmp	$LN1@xmlXPtrEva
$LN16@xmlXPtrEva:

; 1143 : 		    break;

	jmp	SHORT $LN8@xmlXPtrEva
$LN17@xmlXPtrEva:

; 1144 : 		}
; 1145 : 		case XPATH_NODESET: {
; 1146 : 		    xmlNodeSetPtr loc = ctxt->value->nodesetval;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _loc$1[ebp], eax

; 1147 : 		    if ((loc != NULL) && (loc->nodeNr > 0))

	cmp	DWORD PTR _loc$1[ebp], 0
	je	SHORT $LN8@xmlXPtrEva
	mov	ecx, DWORD PTR _loc$1[ebp]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN8@xmlXPtrEva

; 1148 : 			return;

	jmp	$LN1@xmlXPtrEva
$LN8@xmlXPtrEva:

; 1149 : 		    break;
; 1150 : 		}
; 1151 : 		default:
; 1152 : 		    break;
; 1153 : 	    }
; 1154 : 
; 1155 : 	    /*
; 1156 : 	     * Evaluating to improper values is equivalent to
; 1157 : 	     * a sub-resource error, clean-up the stack
; 1158 : 	     */
; 1159 : 	    do {
; 1160 : 		obj = valuePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _obj$3[ebp], eax

; 1161 : 		if (obj != NULL) {

	cmp	DWORD PTR _obj$3[ebp], 0
	je	SHORT $LN6@xmlXPtrEva

; 1162 : 		    xmlXPathFreeObject(obj);

	mov	eax, DWORD PTR _obj$3[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4
$LN6@xmlXPtrEva:

; 1163 : 		}
; 1164 : 	    } while (obj != NULL);

	cmp	DWORD PTR _obj$3[ebp], 0
	jne	SHORT $LN8@xmlXPtrEva
$LN9@xmlXPtrEva:

; 1165 : 	}
; 1166 : 
; 1167 : 	/*
; 1168 : 	 * Is there another XPointer part.
; 1169 : 	 */
; 1170 : 	SKIP_BLANKS;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN21@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 9
	jl	SHORT $LN22@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN21@xmlXPtrEva
$LN22@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN10@xmlXPtrEva
$LN21@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN24@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN25@xmlXPtrEva
$LN24@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv157[ebp], ecx
$LN25@xmlXPtrEva:
	jmp	SHORT $LN9@xmlXPtrEva
$LN10@xmlXPtrEva:

; 1171 : 	name = xmlXPathParseName(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 1172 :     }

	jmp	$LN2@xmlXPtrEva
$LN1@xmlXPtrEva:

; 1173 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrEvalFullXPtr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEvalXPtrPart
_TEXT	SEGMENT
tv327 = -72						; size = 4
tv301 = -68						; size = 4
tv282 = -64						; size = 4
tv194 = -60						; size = 4
tv181 = -56						; size = 4
tv147 = -52						; size = 4
tv86 = -48						; size = 4
_value$1 = -44						; size = 4
_URI$2 = -40						; size = 4
_prefix$3 = -36						; size = 4
_left$4 = -32						; size = 4
_name2$5 = -28						; size = 4
_left$6 = -24						; size = 4
_left$7 = -20						; size = 4
_level$ = -16						; size = 4
_len$ = -12						; size = 4
_cur$ = -8						; size = 4
_buffer$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlXPtrEvalXPtrPart PROC				; COMDAT

; 949  : xmlXPtrEvalXPtrPart(xmlXPathParserContextPtr ctxt, xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 950  :     xmlChar *buffer, *cur;
; 951  :     int len;
; 952  :     int level;
; 953  : 
; 954  :     if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN8@xmlXPtrEva

; 955  :     name = xmlXPathParseName(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathParseName
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax
$LN8@xmlXPtrEva:

; 956  :     if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN9@xmlXPtrEva

; 957  : 	XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN9@xmlXPtrEva:

; 958  : 
; 959  :     if (CUR != '(') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	je	SHORT $LN10@xmlXPtrEva

; 960  :         xmlFree(name);

	mov	esi, esp
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 961  : 	XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN10@xmlXPtrEva:

; 962  :     }
; 963  :     NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN39@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv86[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN40@xmlXPtrEva
$LN39@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv86[ebp], ecx
$LN40@xmlXPtrEva:

; 964  :     level = 1;

	mov	DWORD PTR _level$[ebp], 1

; 965  : 
; 966  :     len = xmlStrlen(ctxt->cur);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_xmlStrlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 967  :     len++;

	mov	ecx, DWORD PTR _len$[ebp]
	add	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx

; 968  :     buffer = (xmlChar *) xmlMallocAtomic(len * sizeof (xmlChar));

	mov	esi, esp
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	call	DWORD PTR _xmlMallocAtomic
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buffer$[ebp], eax

; 969  :     if (buffer == NULL) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN11@xmlXPtrEva

; 970  :         xmlXPtrErrMemory("allocating buffer");

	push	OFFSET ??_C@_0BC@MDOPFBLJ@allocating?5buffer@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 971  :         xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 972  : 	return;

	jmp	$LN1@xmlXPtrEva
$LN11@xmlXPtrEva:

; 973  :     }
; 974  : 
; 975  :     cur = buffer;

	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _cur$[ebp], ecx
$LN2@xmlXPtrEva:

; 976  :     while (CUR != 0) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@xmlXPtrEva

; 977  : 	if (CUR == ')') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 41					; 00000029H
	jne	SHORT $LN12@xmlXPtrEva

; 978  : 	    level--;

	mov	edx, DWORD PTR _level$[ebp]
	sub	edx, 1
	mov	DWORD PTR _level$[ebp], edx

; 979  : 	    if (level == 0) {

	jne	SHORT $LN14@xmlXPtrEva

; 980  : 		NEXT;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN41@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN42@xmlXPtrEva
$LN41@xmlXPtrEva:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv147[ebp], eax
$LN42@xmlXPtrEva:

; 981  : 		break;

	jmp	$LN3@xmlXPtrEva
$LN14@xmlXPtrEva:

; 982  : 	    }

	jmp	$LN13@xmlXPtrEva
$LN12@xmlXPtrEva:

; 983  : 	} else if (CUR == '(') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN15@xmlXPtrEva

; 984  : 	    level++;

	mov	ecx, DWORD PTR _level$[ebp]
	add	ecx, 1
	mov	DWORD PTR _level$[ebp], ecx
	jmp	SHORT $LN13@xmlXPtrEva
$LN15@xmlXPtrEva:

; 985  : 	} else if (CUR == '^') {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN13@xmlXPtrEva

; 986  :             if ((NXT(1) == ')') || (NXT(1) == '(') || (NXT(1) == '^')) {

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 41					; 00000029H
	je	SHORT $LN19@xmlXPtrEva
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN19@xmlXPtrEva
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN13@xmlXPtrEva
$LN19@xmlXPtrEva:

; 987  :                 NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@xmlXPtrEva
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN13@xmlXPtrEva
$LN43@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv181[ebp], edx
$LN13@xmlXPtrEva:

; 988  :             }
; 989  : 	}
; 990  :         *cur++ = CUR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 991  : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@xmlXPtrEva
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv194[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN46@xmlXPtrEva
$LN45@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv194[ebp], edx
$LN46@xmlXPtrEva:

; 992  :     }

	jmp	$LN2@xmlXPtrEva
$LN3@xmlXPtrEva:

; 993  :     *cur = 0;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	BYTE PTR [eax], 0

; 994  : 
; 995  :     if ((level != 0) && (CUR == 0)) {

	cmp	DWORD PTR _level$[ebp], 0
	je	SHORT $LN20@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN20@xmlXPtrEva

; 996  :         xmlFree(name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 997  : 	xmlFree(buffer);

	mov	esi, esp
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 998  : 	XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN20@xmlXPtrEva:

; 999  :     }
; 1000 : 
; 1001 :     if (xmlStrEqual(name, (xmlChar *) "xpointer")) {

	push	OFFSET ??_C@_08DNJCJFMK@xpointer@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@xmlXPtrEva

; 1002 : 	const xmlChar *left = CUR_PTR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _left$7[ebp], eax

; 1003 : 
; 1004 : 	CUR_PTR = buffer;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [ecx], edx

; 1005 : 	/*
; 1006 : 	 * To evaluate an xpointer scheme element (4.3) we need:
; 1007 : 	 *   context initialized to the root
; 1008 : 	 *   context position initalized to 1
; 1009 : 	 *   context size initialized to 1
; 1010 : 	 */
; 1011 : 	ctxt->context->node = (xmlNodePtr)ctxt->context->doc;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx

; 1012 : 	ctxt->context->proximityPosition = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+72], 1

; 1013 : 	ctxt->context->contextSize = 1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+68], 1

; 1014 : 	xmlXPathEvalExpr(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathEvalExpr
	add	esp, 4

; 1015 : 	CUR_PTR=left;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _left$7[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	$LN22@xmlXPtrEva
$LN21@xmlXPtrEva:

; 1016 :     } else if (xmlStrEqual(name, (xmlChar *) "element")) {

	push	OFFSET ??_C@_07HCLJNICE@element@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN23@xmlXPtrEva

; 1017 : 	const xmlChar *left = CUR_PTR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _left$6[ebp], edx

; 1018 : 	xmlChar *name2;
; 1019 : 
; 1020 : 	CUR_PTR = buffer;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [eax], ecx

; 1021 : 	if (buffer[0] == '/') {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _buffer$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN25@xmlXPtrEva

; 1022 : 	    xmlXPathRoot(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathRoot
	add	esp, 4

; 1023 : 	    xmlXPtrEvalChildSeq(ctxt, NULL);

	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPtrEvalChildSeq
	add	esp, 8

; 1024 : 	} else {

	jmp	SHORT $LN26@xmlXPtrEva
$LN25@xmlXPtrEva:

; 1025 : 	    name2 = xmlXPathParseName(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathParseName
	add	esp, 4
	mov	DWORD PTR _name2$5[ebp], eax

; 1026 : 	    if (name2 == NULL) {

	cmp	DWORD PTR _name2$5[ebp], 0
	jne	SHORT $LN27@xmlXPtrEva

; 1027 : 		CUR_PTR = left;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _left$6[ebp]
	mov	DWORD PTR [eax], ecx

; 1028 : 		xmlFree(buffer);

	mov	esi, esp
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1029 :                 xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1030 : 		XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN27@xmlXPtrEva:

; 1031 : 	    }
; 1032 : 	    xmlXPtrEvalChildSeq(ctxt, name2);

	mov	edx, DWORD PTR _name2$5[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPtrEvalChildSeq
	add	esp, 8
$LN26@xmlXPtrEva:

; 1033 : 	}
; 1034 : 	CUR_PTR = left;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _left$6[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	$LN22@xmlXPtrEva
$LN23@xmlXPtrEva:

; 1035 : #ifdef XPTR_XMLNS_SCHEME
; 1036 :     } else if (xmlStrEqual(name, (xmlChar *) "xmlns")) {

	push	OFFSET ??_C@_05PPEFOGKI@xmlns@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	$LN28@xmlXPtrEva

; 1037 : 	const xmlChar *left = CUR_PTR;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _left$4[ebp], edx

; 1038 : 	xmlChar *prefix;
; 1039 : 	xmlChar *URI;
; 1040 : 	xmlURIPtr value;
; 1041 : 
; 1042 : 	CUR_PTR = buffer;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [eax], ecx

; 1043 :         prefix = xmlXPathParseNCName(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathParseNCName
	add	esp, 4
	mov	DWORD PTR _prefix$3[ebp], eax

; 1044 : 	if (prefix == NULL) {

	cmp	DWORD PTR _prefix$3[ebp], 0
	jne	SHORT $LN4@xmlXPtrEva

; 1045 : 	    xmlFree(buffer);

	mov	esi, esp
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1046 : 	    xmlFree(name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1047 : 	    XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN4@xmlXPtrEva:

; 1048 : 	}
; 1049 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN31@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN32@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN31@xmlXPtrEva
$LN32@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPtrEva
$LN31@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN47@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv282[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN48@xmlXPtrEva
$LN47@xmlXPtrEva:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv282[ebp], eax
$LN48@xmlXPtrEva:
	jmp	SHORT $LN4@xmlXPtrEva
$LN5@xmlXPtrEva:

; 1050 : 	if (CUR != '=') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN33@xmlXPtrEva

; 1051 : 	    xmlFree(prefix);

	mov	esi, esp
	mov	ecx, DWORD PTR _prefix$3[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1052 : 	    xmlFree(buffer);

	mov	esi, esp
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1053 : 	    xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1054 : 	    XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN33@xmlXPtrEva:

; 1055 : 	}
; 1056 : 	NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN49@xmlXPtrEva
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv301[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN6@xmlXPtrEva
$LN49@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv301[ebp], edx
$LN6@xmlXPtrEva:

; 1057 : 	SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN34@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN35@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN34@xmlXPtrEva
$LN35@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN7@xmlXPtrEva
$LN34@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN51@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv327[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN52@xmlXPtrEva
$LN51@xmlXPtrEva:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv327[ebp], eax
$LN52@xmlXPtrEva:
	jmp	SHORT $LN6@xmlXPtrEva
$LN7@xmlXPtrEva:

; 1058 : 	/* @@ check escaping in the XPointer WD */
; 1059 : 
; 1060 : 	value = xmlParseURI((const char *)ctxt->cur);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_xmlParseURI
	add	esp, 4
	mov	DWORD PTR _value$1[ebp], eax

; 1061 : 	if (value == NULL) {

	cmp	DWORD PTR _value$1[ebp], 0
	jne	SHORT $LN36@xmlXPtrEva

; 1062 : 	    xmlFree(prefix);

	mov	esi, esp
	mov	eax, DWORD PTR _prefix$3[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1063 : 	    xmlFree(buffer);

	mov	esi, esp
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1064 : 	    xmlFree(name);

	mov	esi, esp
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1065 : 	    XP_ERROR(XPTR_SYNTAX_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN36@xmlXPtrEva:

; 1066 : 	}
; 1067 : 	URI = xmlSaveUri(value);

	mov	ecx, DWORD PTR _value$1[ebp]
	push	ecx
	call	_xmlSaveUri
	add	esp, 4
	mov	DWORD PTR _URI$2[ebp], eax

; 1068 : 	xmlFreeURI(value);

	mov	edx, DWORD PTR _value$1[ebp]
	push	edx
	call	_xmlFreeURI
	add	esp, 4

; 1069 : 	if (URI == NULL) {

	cmp	DWORD PTR _URI$2[ebp], 0
	jne	SHORT $LN37@xmlXPtrEva

; 1070 : 	    xmlFree(prefix);

	mov	esi, esp
	mov	eax, DWORD PTR _prefix$3[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1071 : 	    xmlFree(buffer);

	mov	esi, esp
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1072 : 	    xmlFree(name);

	mov	esi, esp
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1073 : 	    XP_ERROR(XPATH_MEMORY_ERROR);

	push	15					; 0000000fH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN37@xmlXPtrEva:

; 1074 : 	}
; 1075 : 
; 1076 : 	xmlXPathRegisterNs(ctxt->context, prefix, URI);

	mov	ecx, DWORD PTR _URI$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$3[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH

; 1077 : 	CUR_PTR = left;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _left$4[ebp]
	mov	DWORD PTR [edx], eax

; 1078 : 	xmlFree(URI);

	mov	esi, esp
	mov	ecx, DWORD PTR _URI$2[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1079 : 	xmlFree(prefix);

	mov	esi, esp
	mov	edx, DWORD PTR _prefix$3[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1080 : #endif /* XPTR_XMLNS_SCHEME */
; 1081 :     } else {

	jmp	SHORT $LN22@xmlXPtrEva
$LN28@xmlXPtrEva:

; 1082 :         xmlXPtrErr(ctxt, XML_XPTR_UNKNOWN_SCHEME,

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@PBEDODCO@unsupported?5scheme?5?8?$CFs?8?6@
	push	1900					; 0000076cH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPtrErr
	add	esp, 16					; 00000010H
$LN22@xmlXPtrEva:

; 1083 : 		   "unsupported scheme '%s'\n", name);
; 1084 :     }
; 1085 :     xmlFree(buffer);

	mov	esi, esp
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1086 :     xmlFree(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlXPtrEva:

; 1087 : }

	pop	edi
	pop	esi
	add	esp, 72					; 00000048H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrEvalXPtrPart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetChildNo
_TEXT	SEGMENT
_oldset$ = -12						; size = 4
_obj$ = -8						; size = 4
_cur$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_indx$ = 12						; size = 4
_xmlXPtrGetChildNo PROC					; COMDAT

; 891  : xmlXPtrGetChildNo(xmlXPathParserContextPtr ctxt, int indx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 892  :     xmlNodePtr cur = NULL;

	mov	DWORD PTR _cur$[ebp], 0

; 893  :     xmlXPathObjectPtr obj;
; 894  :     xmlNodeSetPtr oldset;
; 895  : 
; 896  :     CHECK_TYPE(XPATH_NODESET);

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN3@xmlXPtrGet
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [edx], 1
	je	SHORT $LN2@xmlXPtrGet
$LN3@xmlXPtrGet:
	push	11					; 0000000bH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrGet
$LN2@xmlXPtrGet:

; 897  :     obj = valuePop(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _obj$[ebp], eax

; 898  :     oldset = obj->nodesetval;

	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldset$[ebp], eax

; 899  :     if ((indx <= 0) || (oldset == NULL) || (oldset->nodeNr != 1)) {

	cmp	DWORD PTR _indx$[ebp], 0
	jle	SHORT $LN5@xmlXPtrGet
	cmp	DWORD PTR _oldset$[ebp], 0
	je	SHORT $LN5@xmlXPtrGet
	mov	ecx, DWORD PTR _oldset$[ebp]
	cmp	DWORD PTR [ecx], 1
	je	SHORT $LN4@xmlXPtrGet
$LN5@xmlXPtrGet:

; 900  : 	xmlXPathFreeObject(obj);

	mov	edx, DWORD PTR _obj$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 901  : 	valuePush(ctxt, xmlXPathNewNodeSet(NULL));

	push	0
	call	_xmlXPathNewNodeSet
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_valuePush
	add	esp, 8

; 902  : 	return;

	jmp	SHORT $LN1@xmlXPtrGet
$LN4@xmlXPtrGet:

; 903  :     }
; 904  :     cur = xmlXPtrGetNthChild(oldset->nodeTab[0], indx);

	mov	ecx, DWORD PTR _indx$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _oldset$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	call	_xmlXPtrGetNthChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 905  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN6@xmlXPtrGet

; 906  : 	xmlXPathFreeObject(obj);

	mov	ecx, DWORD PTR _obj$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 907  : 	valuePush(ctxt, xmlXPathNewNodeSet(NULL));

	push	0
	call	_xmlXPathNewNodeSet
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePush
	add	esp, 8

; 908  : 	return;

	jmp	SHORT $LN1@xmlXPtrGet
$LN6@xmlXPtrGet:

; 909  :     }
; 910  :     oldset->nodeTab[0] = cur;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _oldset$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 911  :     valuePush(ctxt, obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_valuePush
	add	esp, 8
$LN1@xmlXPtrGet:

; 912  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrGetChildNo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEvalChildSeq
_TEXT	SEGMENT
tv157 = -12						; size = 4
tv133 = -8						; size = 4
_child$1 = -4						; size = 4
_ctxt$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlXPtrEvalChildSeq PROC				; COMDAT

; 1187 : xmlXPtrEvalChildSeq(xmlXPathParserContextPtr ctxt, xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1188 :     /*
; 1189 :      * XPointer don't allow by syntax to address in mutirooted trees
; 1190 :      * this might prove useful in some cases, warn about it.
; 1191 :      */
; 1192 :     if ((name == NULL) && (CUR == '/') && (NXT(1) != '1')) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN6@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN6@xmlXPtrEva
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	eax, 49					; 00000031H
	je	SHORT $LN6@xmlXPtrEva

; 1193 :         xmlXPtrErr(ctxt, XML_XPTR_CHILDSEQ_START,

	push	0
	push	OFFSET ??_C@_0CG@PNGJONJE@warning?3?5ChildSeq?5not?5starting?5@
	push	1901					; 0000076dH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPtrErr
	add	esp, 16					; 00000010H
$LN6@xmlXPtrEva:

; 1194 : 		   "warning: ChildSeq not starting by /1\n", NULL);
; 1195 :     }
; 1196 : 
; 1197 :     if (name != NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN2@xmlXPtrEva

; 1198 : 	valuePush(ctxt, xmlXPathNewString(name));

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlXPathNewString
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_valuePush
	add	esp, 8

; 1199 : 	xmlFree(name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1200 : 	xmlXPathIdFunction(ctxt, 1);

	push	1
	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathIdFunction
	add	esp, 8

; 1201 : 	CHECK_ERROR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@xmlXPtrEva
	jmp	$LN1@xmlXPtrEva
$LN2@xmlXPtrEva:

; 1202 :     }
; 1203 : 
; 1204 :     while (CUR == '/') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	$LN1@xmlXPtrEva

; 1205 : 	int child = 0;

	mov	DWORD PTR _child$1[ebp], 0

; 1206 : 	NEXT;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN10@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv133[ebp], edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN4@xmlXPtrEva
$LN10@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv133[ebp], ecx
$LN4@xmlXPtrEva:

; 1207 : 
; 1208 : 	while ((CUR >= '0') && (CUR <= '9')) {

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN5@xmlXPtrEva
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN5@xmlXPtrEva

; 1209 : 	    child = child * 10 + (CUR - '0');

	imul	edx, DWORD PTR _child$1[ebp], 10
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [edx+eax-48]
	mov	DWORD PTR _child$1[ebp], ecx

; 1210 : 	    NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN12@xmlXPtrEva
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv157[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN13@xmlXPtrEva
$LN12@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv157[ebp], edx
$LN13@xmlXPtrEva:

; 1211 : 	}

	jmp	SHORT $LN4@xmlXPtrEva
$LN5@xmlXPtrEva:

; 1212 : 	xmlXPtrGetChildNo(ctxt, child);

	mov	eax, DWORD PTR _child$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPtrGetChildNo
	add	esp, 8

; 1213 :     }

	jmp	$LN2@xmlXPtrEva
$LN1@xmlXPtrEva:

; 1214 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrEvalChildSeq ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangeInternal
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_start$ = 8						; size = 4
_startindex$ = 12					; size = 4
_end$ = 16						; size = 4
_endindex$ = 20						; size = 4
_xmlXPtrNewRangeInternal PROC				; COMDAT

; 344  :                         xmlNodePtr end, int endindex) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 345  :     xmlXPathObjectPtr ret;
; 346  : 
; 347  :     /*
; 348  :      * Namespace nodes must be copied (see xmlXPathNodeSetDupNs).
; 349  :      * Disallow them for now.
; 350  :      */
; 351  :     if ((start != NULL) && (start->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR _start$[ebp], 0
	je	SHORT $LN2@xmlXPtrNew
	mov	eax, DWORD PTR _start$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN2@xmlXPtrNew

; 352  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrNew
$LN2@xmlXPtrNew:

; 353  :     if ((end != NULL) && (end->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR _end$[ebp], 0
	je	SHORT $LN3@xmlXPtrNew
	mov	ecx, DWORD PTR _end$[ebp]
	cmp	DWORD PTR [ecx+4], 18			; 00000012H
	jne	SHORT $LN3@xmlXPtrNew

; 354  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN3@xmlXPtrNew:

; 355  : 
; 356  :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	mov	esi, esp
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 357  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN4@xmlXPtrNew

; 358  :         xmlXPtrErrMemory("allocating range");

	push	OFFSET ??_C@_0BB@PBEHJOM@allocating?5range@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 359  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN4@xmlXPtrNew:

; 360  :     }
; 361  :     memset(ret, 0, sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 362  :     ret->type = XPATH_RANGE;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax], 6

; 363  :     ret->user = start;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 364  :     ret->index = startindex;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _startindex$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 365  :     ret->user2 = end;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _end$[ebp]
	mov	DWORD PTR [edx+36], eax

; 366  :     ret->index2 = endindex;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _endindex$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 367  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 368  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewRangeInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrRangesEqual
_TEXT	SEGMENT
_range1$ = 8						; size = 4
_range2$ = 12						; size = 4
_xmlXPtrRangesEqual PROC				; COMDAT

; 311  : xmlXPtrRangesEqual(xmlXPathObjectPtr range1, xmlXPathObjectPtr range2) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 312  :     if (range1 == range2)

	mov	eax, DWORD PTR _range1$[ebp]
	cmp	eax, DWORD PTR _range2$[ebp]
	jne	SHORT $LN2@xmlXPtrRan

; 313  : 	return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlXPtrRan
$LN2@xmlXPtrRan:

; 314  :     if ((range1 == NULL) || (range2 == NULL))

	cmp	DWORD PTR _range1$[ebp], 0
	je	SHORT $LN4@xmlXPtrRan
	cmp	DWORD PTR _range2$[ebp], 0
	jne	SHORT $LN3@xmlXPtrRan
$LN4@xmlXPtrRan:

; 315  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrRan
$LN3@xmlXPtrRan:

; 316  :     if (range1->type != range2->type)

	mov	ecx, DWORD PTR _range1$[ebp]
	mov	edx, DWORD PTR _range2$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN5@xmlXPtrRan

; 317  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrRan
$LN5@xmlXPtrRan:

; 318  :     if (range1->type != XPATH_RANGE)

	mov	ecx, DWORD PTR _range1$[ebp]
	cmp	DWORD PTR [ecx], 6
	je	SHORT $LN6@xmlXPtrRan

; 319  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrRan
$LN6@xmlXPtrRan:

; 320  :     if (range1->user != range2->user)

	mov	edx, DWORD PTR _range1$[ebp]
	mov	eax, DWORD PTR _range2$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	cmp	ecx, DWORD PTR [eax+28]
	je	SHORT $LN7@xmlXPtrRan

; 321  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrRan
$LN7@xmlXPtrRan:

; 322  :     if (range1->index != range2->index)

	mov	edx, DWORD PTR _range1$[ebp]
	mov	eax, DWORD PTR _range2$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	cmp	ecx, DWORD PTR [eax+32]
	je	SHORT $LN8@xmlXPtrRan

; 323  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrRan
$LN8@xmlXPtrRan:

; 324  :     if (range1->user2 != range2->user2)

	mov	edx, DWORD PTR _range1$[ebp]
	mov	eax, DWORD PTR _range2$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	cmp	ecx, DWORD PTR [eax+36]
	je	SHORT $LN9@xmlXPtrRan

; 325  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrRan
$LN9@xmlXPtrRan:

; 326  :     if (range1->index2 != range2->index2)

	mov	edx, DWORD PTR _range1$[ebp]
	mov	eax, DWORD PTR _range2$[ebp]
	mov	ecx, DWORD PTR [edx+40]
	cmp	ecx, DWORD PTR [eax+40]
	je	SHORT $LN10@xmlXPtrRan

; 327  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrRan
$LN10@xmlXPtrRan:

; 328  :     return(1);

	mov	eax, 1
$LN1@xmlXPtrRan:

; 329  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlXPtrRangesEqual ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrRangeCheckOrder
_TEXT	SEGMENT
_tmp2$ = -8						; size = 4
_tmp$ = -4						; size = 4
_range$ = 8						; size = 4
_xmlXPtrRangeCheckOrder PROC				; COMDAT

; 280  : xmlXPtrRangeCheckOrder(xmlXPathObjectPtr range) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 281  :     int tmp;
; 282  :     xmlNodePtr tmp2;
; 283  :     if (range == NULL)

	cmp	DWORD PTR _range$[ebp], 0
	jne	SHORT $LN2@xmlXPtrRan

; 284  : 	return;

	jmp	SHORT $LN1@xmlXPtrRan
$LN2@xmlXPtrRan:

; 285  :     if (range->type != XPATH_RANGE)

	mov	eax, DWORD PTR _range$[ebp]
	cmp	DWORD PTR [eax], 6
	je	SHORT $LN3@xmlXPtrRan

; 286  : 	return;

	jmp	SHORT $LN1@xmlXPtrRan
$LN3@xmlXPtrRan:

; 287  :     if (range->user2 == NULL)

	mov	ecx, DWORD PTR _range$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN4@xmlXPtrRan

; 288  : 	return;

	jmp	SHORT $LN1@xmlXPtrRan
$LN4@xmlXPtrRan:

; 289  :     tmp = xmlXPtrCmpPoints(range->user, range->index,

	mov	edx, DWORD PTR _range$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _range$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	_xmlXPtrCmpPoints
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tmp$[ebp], eax

; 290  : 	                     range->user2, range->index2);
; 291  :     if (tmp == -1) {

	cmp	DWORD PTR _tmp$[ebp], -1
	jne	SHORT $LN1@xmlXPtrRan

; 292  : 	tmp2 = range->user;

	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _tmp2$[ebp], edx

; 293  : 	range->user = range->user2;

	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+28], edx

; 294  : 	range->user2 = tmp2;

	mov	eax, DWORD PTR _range$[ebp]
	mov	ecx, DWORD PTR _tmp2$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 295  : 	tmp = range->index;

	mov	edx, DWORD PTR _range$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _tmp$[ebp], eax

; 296  : 	range->index = range->index2;

	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR _range$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+32], eax

; 297  : 	range->index2 = tmp;

	mov	ecx, DWORD PTR _range$[ebp]
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [ecx+40], edx
$LN1@xmlXPtrRan:

; 298  :     }
; 299  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrRangeCheckOrder ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewPoint
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_node$ = 8						; size = 4
_indx$ = 12						; size = 4
_xmlXPtrNewPoint PROC					; COMDAT

; 253  : xmlXPtrNewPoint(xmlNodePtr node, int indx) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 254  :     xmlXPathObjectPtr ret;
; 255  : 
; 256  :     if (node == NULL)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN2@xmlXPtrNew

; 257  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN2@xmlXPtrNew:

; 258  :     if (indx < 0)

	cmp	DWORD PTR _indx$[ebp], 0
	jge	SHORT $LN3@xmlXPtrNew

; 259  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN3@xmlXPtrNew:

; 260  : 
; 261  :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	mov	esi, esp
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 262  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN4@xmlXPtrNew

; 263  :         xmlXPtrErrMemory("allocating point");

	push	OFFSET ??_C@_0BB@DMDDEGKA@allocating?5point@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 264  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN4@xmlXPtrNew:

; 265  :     }
; 266  :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 267  :     ret->type = XPATH_POINT;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], 5

; 268  :     ret->user = (void *) node;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+28], eax

; 269  :     ret->index = indx;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _indx$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 270  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 271  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrCmpPoints
_TEXT	SEGMENT
_node1$ = 8						; size = 4
_index1$ = 12						; size = 4
_node2$ = 16						; size = 4
_index2$ = 20						; size = 4
_xmlXPtrCmpPoints PROC					; COMDAT

; 227  : xmlXPtrCmpPoints(xmlNodePtr node1, int index1, xmlNodePtr node2, int index2) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 228  :     if ((node1 == NULL) || (node2 == NULL))

	cmp	DWORD PTR _node1$[ebp], 0
	je	SHORT $LN3@xmlXPtrCmp
	cmp	DWORD PTR _node2$[ebp], 0
	jne	SHORT $LN2@xmlXPtrCmp
$LN3@xmlXPtrCmp:

; 229  : 	return(-2);

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@xmlXPtrCmp
$LN2@xmlXPtrCmp:

; 230  :     /*
; 231  :      * a couple of optimizations which will avoid computations in most cases
; 232  :      */
; 233  :     if (node1 == node2) {

	mov	eax, DWORD PTR _node1$[ebp]
	cmp	eax, DWORD PTR _node2$[ebp]
	jne	SHORT $LN4@xmlXPtrCmp

; 234  : 	if (index1 < index2)

	mov	ecx, DWORD PTR _index1$[ebp]
	cmp	ecx, DWORD PTR _index2$[ebp]
	jge	SHORT $LN5@xmlXPtrCmp

; 235  : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlXPtrCmp
$LN5@xmlXPtrCmp:

; 236  : 	if (index1 > index2)

	mov	edx, DWORD PTR _index1$[ebp]
	cmp	edx, DWORD PTR _index2$[ebp]
	jle	SHORT $LN6@xmlXPtrCmp

; 237  : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlXPtrCmp
$LN6@xmlXPtrCmp:

; 238  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrCmp
$LN4@xmlXPtrCmp:

; 239  :     }
; 240  :     return(xmlXPathCmpNodes(node1, node2));

	mov	eax, DWORD PTR _node2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node1$[ebp]
	push	ecx
	call	_xmlXPathCmpNodes
	add	esp, 8
$LN1@xmlXPtrCmp:

; 241  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlXPtrCmpPoints ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetNthChild
_TEXT	SEGMENT
_i$ = -4						; size = 4
_cur$ = 8						; size = 4
_no$ = 12						; size = 4
_xmlXPtrGetNthChild PROC				; COMDAT

; 189  : xmlXPtrGetNthChild(xmlNodePtr cur, int no) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 190  :     int i;
; 191  :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@xmlXPtrGet
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN5@xmlXPtrGet
$LN6@xmlXPtrGet:

; 192  : 	return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	jmp	SHORT $LN1@xmlXPtrGet
$LN5@xmlXPtrGet:

; 193  :     cur = cur->children;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx

; 194  :     for (i = 0;i <= no;cur = cur->next) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlXPtrGet
$LN2@xmlXPtrGet:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@xmlXPtrGet:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _no$[ebp]
	jg	SHORT $LN3@xmlXPtrGet

; 195  : 	if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN7@xmlXPtrGet

; 196  : 	    return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	jmp	SHORT $LN1@xmlXPtrGet
$LN7@xmlXPtrGet:

; 197  : 	if ((cur->type == XML_ELEMENT_NODE) ||
; 198  : 	    (cur->type == XML_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN9@xmlXPtrGet
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 9
	je	SHORT $LN9@xmlXPtrGet
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 13			; 0000000dH
	jne	SHORT $LN8@xmlXPtrGet
$LN9@xmlXPtrGet:

; 199  : 	    (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 200  : 	    i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 201  : 	    if (i == no)

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _no$[ebp]
	jne	SHORT $LN8@xmlXPtrGet

; 202  : 		break;

	jmp	SHORT $LN3@xmlXPtrGet
$LN8@xmlXPtrGet:

; 203  : 	}
; 204  :     }

	jmp	SHORT $LN2@xmlXPtrGet
$LN3@xmlXPtrGet:

; 205  :     return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
$LN1@xmlXPtrGet:

; 206  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrGetNthChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetIndex
_TEXT	SEGMENT
_i$ = -4						; size = 4
_cur$ = 8						; size = 4
_xmlXPtrGetIndex PROC					; COMDAT

; 167  : xmlXPtrGetIndex(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 168  :     int i;
; 169  :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@xmlXPtrGet
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN5@xmlXPtrGet
$LN6@xmlXPtrGet:

; 170  : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlXPtrGet
$LN5@xmlXPtrGet:

; 171  :     for (i = 1;cur != NULL;cur = cur->prev) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@xmlXPtrGet
$LN2@xmlXPtrGet:
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@xmlXPtrGet:
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@xmlXPtrGet

; 172  : 	if ((cur->type == XML_ELEMENT_NODE) ||
; 173  : 	    (cur->type == XML_DOCUMENT_NODE) ||

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN8@xmlXPtrGet
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 9
	je	SHORT $LN8@xmlXPtrGet
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 13			; 0000000dH
	jne	SHORT $LN7@xmlXPtrGet
$LN8@xmlXPtrGet:

; 174  : 	    (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 175  : 	    i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@xmlXPtrGet:

; 176  : 	}
; 177  :     }

	jmp	SHORT $LN2@xmlXPtrGet
$LN3@xmlXPtrGet:

; 178  :     return(i);

	mov	eax, DWORD PTR _i$[ebp]
$LN1@xmlXPtrGet:

; 179  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrGetIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrGetArity
_TEXT	SEGMENT
_i$ = -4						; size = 4
_cur$ = 8						; size = 4
_xmlXPtrGetArity PROC					; COMDAT

; 144  : xmlXPtrGetArity(xmlNodePtr cur) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 145  :     int i;
; 146  :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@xmlXPtrGet
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN5@xmlXPtrGet
$LN6@xmlXPtrGet:

; 147  : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlXPtrGet
$LN5@xmlXPtrGet:

; 148  :     cur = cur->children;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx

; 149  :     for (i = 0;cur != NULL;cur = cur->next) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlXPtrGet
$LN2@xmlXPtrGet:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@xmlXPtrGet:
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@xmlXPtrGet

; 150  : 	if ((cur->type == XML_ELEMENT_NODE) ||
; 151  : 	    (cur->type == XML_DOCUMENT_NODE) ||

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 1
	je	SHORT $LN8@xmlXPtrGet
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 9
	je	SHORT $LN8@xmlXPtrGet
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	jne	SHORT $LN7@xmlXPtrGet
$LN8@xmlXPtrGet:

; 152  : 	    (cur->type == XML_HTML_DOCUMENT_NODE)) {
; 153  : 	    i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@xmlXPtrGet:

; 154  : 	}
; 155  :     }

	jmp	SHORT $LN2@xmlXPtrGet
$LN3@xmlXPtrGet:

; 156  :     return(i);

	mov	eax, DWORD PTR _i$[ebp]
$LN1@xmlXPtrGet:

; 157  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrGetArity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrAdvanceNode
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_level$ = 12						; size = 4
_xmlXPtrAdvanceNode PROC				; COMDAT

; 2242 : xmlXPtrAdvanceNode(xmlNodePtr cur, int *level) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4
$next$16:

; 2243 : next:
; 2244 :     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@xmlXPtrAdv
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 18			; 00000012H
	jne	SHORT $LN5@xmlXPtrAdv
$LN6@xmlXPtrAdv:

; 2245 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrAdv
$LN5@xmlXPtrAdv:

; 2246 :     if (cur->children != NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $skip$17

; 2247 :         cur = cur->children ;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax

; 2248 : 	if (level != NULL)

	cmp	DWORD PTR _level$[ebp], 0
	je	SHORT $LN8@xmlXPtrAdv

; 2249 : 	    (*level)++;

	mov	ecx, DWORD PTR _level$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR [eax], edx
$LN8@xmlXPtrAdv:

; 2250 : 	goto found;

	jmp	SHORT $found$18
$skip$17:

; 2251 :     }
; 2252 : skip:		/* This label should only be needed if something is wrong! */
; 2253 :     if (cur->next != NULL) {

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN4@xmlXPtrAdv

; 2254 : 	cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 2255 : 	goto found;

	jmp	SHORT $found$18
$LN4@xmlXPtrAdv:

; 2256 :     }
; 2257 :     do {
; 2258 :         cur = cur->parent;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _cur$[ebp], edx

; 2259 : 	if (level != NULL)

	cmp	DWORD PTR _level$[ebp], 0
	je	SHORT $LN10@xmlXPtrAdv

; 2260 : 	    (*level)--;

	mov	eax, DWORD PTR _level$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _level$[ebp]
	mov	DWORD PTR [edx], ecx
$LN10@xmlXPtrAdv:

; 2261 :         if (cur == NULL) return(NULL);

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN11@xmlXPtrAdv
	xor	eax, eax
	jmp	$LN1@xmlXPtrAdv
$LN11@xmlXPtrAdv:

; 2262 :         if (cur->next != NULL) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN2@xmlXPtrAdv

; 2263 : 	    cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 2264 : 	    goto found;

	jmp	SHORT $found$18
$LN2@xmlXPtrAdv:

; 2265 : 	}
; 2266 :     } while (cur != NULL);

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN4@xmlXPtrAdv
$found$18:

; 2267 : 
; 2268 : found:
; 2269 :     if ((cur->type != XML_ELEMENT_NODE) &&
; 2270 : 	(cur->type != XML_TEXT_NODE) &&
; 2271 : 	(cur->type != XML_DOCUMENT_NODE) &&
; 2272 : 	(cur->type != XML_HTML_DOCUMENT_NODE) &&

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN13@xmlXPtrAdv
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 3
	je	SHORT $LN13@xmlXPtrAdv
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 9
	je	SHORT $LN13@xmlXPtrAdv
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 13			; 0000000dH
	je	SHORT $LN13@xmlXPtrAdv
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+4], 4
	je	SHORT $LN13@xmlXPtrAdv

; 2273 : 	(cur->type != XML_CDATA_SECTION_NODE)) {
; 2274 : 	    if (cur->type == XML_ENTITY_REF_NODE) {	/* Shouldn't happen */

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 5
	jne	SHORT $LN14@xmlXPtrAdv

; 2275 : 		TODO

	mov	esi, esp
	push	2275					; 000008e3H
	push	OFFSET ??_C@_0GK@GBFDPHAH@c?3?2users?2dag?2documents?2_clients@
	push	OFFSET ??_C@_0BO@MDEMDPPE@Unimplemented?5block?5at?5?$CFs?3?$CFd?6@
	call	___xmlGenericErrorContext
	mov	eax, DWORD PTR [eax]
	push	eax
	call	___xmlGenericError
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2276 : 		goto skip;

	jmp	$skip$17
$LN14@xmlXPtrAdv:

; 2277 : 	    }
; 2278 : 	    goto next;

	jmp	$next$16
$LN13@xmlXPtrAdv:

; 2279 : 	}
; 2280 :     return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
$LN1@xmlXPtrAdv:

; 2281 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlXPtrAdvanceNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrErr
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_error$ = 12						; size = 4
_msg$ = 16						; size = 4
_extra$ = 20						; size = 4
_xmlXPtrErr PROC					; COMDAT

; 96   : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 97   :     if (ctxt != NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN2@xmlXPtrErr

; 98   :         ctxt->error = error;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN2@xmlXPtrErr:

; 99   :     if ((ctxt == NULL) || (ctxt->context == NULL)) {

	cmp	DWORD PTR _ctxt$[ebp], 0
	je	SHORT $LN4@xmlXPtrErr
	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN3@xmlXPtrErr
$LN4@xmlXPtrErr:

; 100  : 	__xmlRaiseError(NULL, NULL, NULL,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _extra$[ebp]
	push	edx
	push	0
	push	0
	push	2
	mov	eax, DWORD PTR _error$[ebp]
	push	eax
	push	13					; 0000000dH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 101  : 			NULL, NULL, XML_FROM_XPOINTER, error,
; 102  : 			XML_ERR_ERROR, NULL, 0,
; 103  : 			(const char *) extra, NULL, NULL, 0, 0,
; 104  : 			msg, extra);
; 105  : 	return;

	jmp	$LN1@xmlXPtrErr
$LN3@xmlXPtrErr:

; 106  :     }
; 107  : 
; 108  :     /* cleanup current last error */
; 109  :     xmlResetError(&ctxt->context->lastError);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 136				; 00000088H
	push	edx
	call	_xmlResetError
	add	esp, 4

; 110  : 
; 111  :     ctxt->context->lastError.domain = XML_FROM_XPOINTER;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+136], 13			; 0000000dH

; 112  :     ctxt->context->lastError.code = error;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax+140], ecx

; 113  :     ctxt->context->lastError.level = XML_ERR_ERROR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+148], 2

; 114  :     ctxt->context->lastError.str1 = (char *) xmlStrdup(ctxt->base);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+160], eax

; 115  :     ctxt->context->lastError.int1 = ctxt->cur - ctxt->base;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+172], edx

; 116  :     ctxt->context->lastError.node = ctxt->context->debugNode;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax+188]
	mov	DWORD PTR [edx+184], eax

; 117  :     if (ctxt->context->error != NULL) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	DWORD PTR [edx+132], 0
	je	SHORT $LN5@xmlXPtrErr

; 118  : 	ctxt->context->error(ctxt->context->userData,

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 136				; 00000088H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+132]
	call	ecx
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 119  : 	                     &ctxt->context->lastError);
; 120  :     } else {

	jmp	SHORT $LN1@xmlXPtrErr
$LN5@xmlXPtrErr:

; 121  : 	__xmlRaiseError(NULL, NULL, NULL,

	mov	edx, DWORD PTR _extra$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	0
	push	0
	push	2
	mov	ecx, DWORD PTR _error$[ebp]
	push	ecx
	push	13					; 0000000dH
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+188]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H
$LN1@xmlXPtrErr:

; 122  : 			NULL, ctxt->context->debugNode, XML_FROM_XPOINTER,
; 123  : 			error, XML_ERR_ERROR, NULL, 0,
; 124  : 			(const char *) extra, (const char *) ctxt->base, NULL,
; 125  : 			ctxt->cur - ctxt->base, 0,
; 126  : 			msg, extra);
; 127  :     }
; 128  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlXPtrErr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlXPtrErrMemory PROC					; COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 80   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_XPOINTER,

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@DJFHNAOK@Memory?5allocation?5failed?5?3?5?$CFs?6@
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _extra$[ebp]
	push	ecx
	push	0
	push	0
	push	2
	push	2
	push	13					; 0000000dH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 81   : 		    XML_ERR_NO_MEMORY, XML_ERR_ERROR, NULL, 0, extra,
; 82   : 		    NULL, NULL, 0, 0,
; 83   : 		    "Memory allocation failed : %s\n", extra);
; 84   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlXPtrErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEvalRangePredicate
_TEXT	SEGMENT
tv295 = -48						; size = 4
tv269 = -44						; size = 4
tv164 = -40						; size = 4
tv138 = -36						; size = 4
tv90 = -32						; size = 4
_i$ = -28						; size = 4
_oldset$ = -24						; size = 4
_newset$ = -20						; size = 4
_tmp$ = -16						; size = 4
_obj$ = -12						; size = 4
_res$ = -8						; size = 4
_cur$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlXPtrEvalRangePredicate PROC				; COMDAT

; 2841 : xmlXPtrEvalRangePredicate(xmlXPathParserContextPtr ctxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2842 :     const xmlChar *cur;
; 2843 :     xmlXPathObjectPtr res;
; 2844 :     xmlXPathObjectPtr obj, tmp;
; 2845 :     xmlLocationSetPtr newset = NULL;

	mov	DWORD PTR _newset$[ebp], 0

; 2846 :     xmlLocationSetPtr oldset;
; 2847 :     int i;
; 2848 : 
; 2849 :     if (ctxt == NULL) return;

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN2@xmlXPtrEva
	jmp	$LN1@xmlXPtrEva
$LN2@xmlXPtrEva:

; 2850 : 
; 2851 :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN12@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN13@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN12@xmlXPtrEva
$LN13@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@xmlXPtrEva
$LN12@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN32@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv90[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN33@xmlXPtrEva
$LN32@xmlXPtrEva:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv90[ebp], eax
$LN33@xmlXPtrEva:
	jmp	SHORT $LN2@xmlXPtrEva
$LN3@xmlXPtrEva:

; 2852 :     if (CUR != '[') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 91					; 0000005bH
	je	SHORT $LN14@xmlXPtrEva

; 2853 : 	XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);

	push	6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN14@xmlXPtrEva:

; 2854 :     }
; 2855 :     NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN34@xmlXPtrEva
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv138[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN4@xmlXPtrEva
$LN34@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv138[ebp], edx
$LN4@xmlXPtrEva:

; 2856 :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN15@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN16@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN15@xmlXPtrEva
$LN16@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN5@xmlXPtrEva
$LN15@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN36@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv164[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN37@xmlXPtrEva
$LN36@xmlXPtrEva:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv164[ebp], eax
$LN37@xmlXPtrEva:
	jmp	SHORT $LN4@xmlXPtrEva
$LN5@xmlXPtrEva:

; 2857 : 
; 2858 :     /*
; 2859 :      * Extract the old set, and then evaluate the result of the
; 2860 :      * expression for all the element in the set. use it to grow
; 2861 :      * up a new set.
; 2862 :      */
; 2863 :     CHECK_TYPE(XPATH_LOCATIONSET);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN18@xmlXPtrEva
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax], 7
	je	SHORT $LN17@xmlXPtrEva
$LN18@xmlXPtrEva:
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN17@xmlXPtrEva:

; 2864 :     obj = valuePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _obj$[ebp], eax

; 2865 :     oldset = obj->user;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _oldset$[ebp], ecx

; 2866 :     ctxt->context->node = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+4], 0

; 2867 : 
; 2868 :     if ((oldset == NULL) || (oldset->locNr == 0)) {

	cmp	DWORD PTR _oldset$[ebp], 0
	je	SHORT $LN21@xmlXPtrEva
	mov	ecx, DWORD PTR _oldset$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN19@xmlXPtrEva
$LN21@xmlXPtrEva:

; 2869 : 	ctxt->context->contextSize = 0;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+68], 0

; 2870 : 	ctxt->context->proximityPosition = 0;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+72], 0

; 2871 : 	xmlXPathEvalExpr(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathEvalExpr
	add	esp, 4

; 2872 : 	res = valuePop(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _res$[ebp], eax

; 2873 : 	if (res != NULL)

	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $LN22@xmlXPtrEva

; 2874 : 	    xmlXPathFreeObject(res);

	mov	edx, DWORD PTR _res$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4
$LN22@xmlXPtrEva:

; 2875 : 	valuePush(ctxt, obj);

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_valuePush
	add	esp, 8

; 2876 : 	CHECK_ERROR;

	mov	edx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN23@xmlXPtrEva
	jmp	$LN1@xmlXPtrEva
$LN23@xmlXPtrEva:

; 2877 :     } else {

	jmp	$LN20@xmlXPtrEva
$LN19@xmlXPtrEva:

; 2878 : 	/*
; 2879 : 	 * Save the expression pointer since we will have to evaluate
; 2880 : 	 * it multiple times. Initialize the new set.
; 2881 : 	 */
; 2882 :         cur = ctxt->cur;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 2883 : 	newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$[ebp], eax

; 2884 : 
; 2885 :         for (i = 0; i < oldset->locNr; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@xmlXPtrEva
$LN6@xmlXPtrEva:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN8@xmlXPtrEva:
	mov	eax, DWORD PTR _oldset$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN7@xmlXPtrEva

; 2886 : 	    ctxt->cur = cur;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 2887 : 
; 2888 : 	    /*
; 2889 : 	     * Run the evaluation with a node list made of a single item
; 2890 : 	     * in the nodeset.
; 2891 : 	     */
; 2892 : 	    ctxt->context->node = oldset->locTab[i]->user;

	mov	ecx, DWORD PTR _oldset$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+4], ecx

; 2893 : 	    tmp = xmlXPathNewNodeSet(ctxt->context->node);

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlXPathNewNodeSet
	add	esp, 4
	mov	DWORD PTR _tmp$[ebp], eax

; 2894 : 	    valuePush(ctxt, tmp);

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_valuePush
	add	esp, 8

; 2895 : 	    ctxt->context->contextSize = oldset->locNr;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _oldset$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+68], ecx

; 2896 : 	    ctxt->context->proximityPosition = i + 1;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+72], edx

; 2897 : 
; 2898 : 	    xmlXPathEvalExpr(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_xmlXPathEvalExpr
	add	esp, 4

; 2899 : 	    CHECK_ERROR;

	mov	eax, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN24@xmlXPtrEva
	jmp	$LN1@xmlXPtrEva
$LN24@xmlXPtrEva:

; 2900 : 
; 2901 : 	    /*
; 2902 : 	     * The result of the evaluation need to be tested to
; 2903 : 	     * decided whether the filter succeeded or not
; 2904 : 	     */
; 2905 : 	    res = valuePop(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _res$[ebp], eax

; 2906 : 	    if (xmlXPathEvaluatePredicateResult(ctxt, res)) {

	mov	edx, DWORD PTR _res$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathEvaluatePredicateResult
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@xmlXPtrEva

; 2907 : 	        xmlXPtrLocationSetAdd(newset,

	mov	ecx, DWORD PTR _oldset$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_xmlXPathObjectCopy
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _newset$[ebp]
	push	edx
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
$LN25@xmlXPtrEva:

; 2908 : 			xmlXPathObjectCopy(oldset->locTab[i]));
; 2909 : 	    }
; 2910 : 
; 2911 : 	    /*
; 2912 : 	     * Cleanup
; 2913 : 	     */
; 2914 : 	    if (res != NULL)

	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $LN26@xmlXPtrEva

; 2915 : 		xmlXPathFreeObject(res);

	mov	eax, DWORD PTR _res$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4
$LN26@xmlXPtrEva:

; 2916 : 	    if (ctxt->value == tmp) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _tmp$[ebp]
	jne	SHORT $LN27@xmlXPtrEva

; 2917 : 		res = valuePop(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _res$[ebp], eax

; 2918 : 		xmlXPathFreeObject(res);

	mov	ecx, DWORD PTR _res$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4
$LN27@xmlXPtrEva:

; 2919 : 	    }
; 2920 : 
; 2921 : 	    ctxt->context->node = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+4], 0

; 2922 : 	}

	jmp	$LN6@xmlXPtrEva
$LN7@xmlXPtrEva:

; 2923 : 
; 2924 : 	/*
; 2925 : 	 * The result is used as the new evaluation set.
; 2926 : 	 */
; 2927 : 	xmlXPathFreeObject(obj);

	mov	ecx, DWORD PTR _obj$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 2928 : 	ctxt->context->node = NULL;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+4], 0

; 2929 : 	ctxt->context->contextSize = -1;

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+68], -1

; 2930 : 	ctxt->context->proximityPosition = -1;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+72], -1

; 2931 : 	valuePush(ctxt, xmlXPtrWrapLocationSet(newset));

	mov	edx, DWORD PTR _newset$[ebp]
	push	edx
	call	_xmlXPtrWrapLocationSet
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_valuePush
	add	esp, 8
$LN20@xmlXPtrEva:

; 2932 :     }
; 2933 :     if (CUR != ']') {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN28@xmlXPtrEva

; 2934 : 	XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);

	push	6
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlXPathErr
	add	esp, 8
	jmp	$LN1@xmlXPtrEva
$LN28@xmlXPtrEva:

; 2935 :     }
; 2936 : 
; 2937 :     NEXT;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN38@xmlXPtrEva
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv269[ebp], eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN9@xmlXPtrEva
$LN38@xmlXPtrEva:
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv269[ebp], edx
$LN9@xmlXPtrEva:

; 2938 :     SKIP_BLANKS;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN29@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 9
	jl	SHORT $LN30@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jle	SHORT $LN29@xmlXPtrEva
$LN30@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN1@xmlXPtrEva
$LN29@xmlXPtrEva:
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN40@xmlXPtrEva
	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv295[ebp], ecx
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN41@xmlXPtrEva
$LN40@xmlXPtrEva:
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv295[ebp], eax
$LN41@xmlXPtrEva:
	jmp	SHORT $LN9@xmlXPtrEva
$LN1@xmlXPtrEva:

; 2939 : }

	pop	edi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrEvalRangePredicate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrBuildNodeList
_TEXT	SEGMENT
tv80 = -28						; size = 4
tv66 = -24						; size = 4
_set$1 = -20						; size = 4
_set$2 = -16						; size = 4
_i$ = -12						; size = 4
_last$ = -8						; size = 4
_list$ = -4						; size = 4
_obj$ = 8						; size = 4
_xmlXPtrBuildNodeList PROC				; COMDAT

; 1582 : xmlXPtrBuildNodeList(xmlXPathObjectPtr obj) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1583 :     xmlNodePtr list = NULL, last = NULL;

	mov	DWORD PTR _list$[ebp], 0
	mov	DWORD PTR _last$[ebp], 0

; 1584 :     int i;
; 1585 : 
; 1586 :     if (obj == NULL)

	cmp	DWORD PTR _obj$[ebp], 0
	jne	SHORT $LN14@xmlXPtrBui

; 1587 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrBui
$LN14@xmlXPtrBui:

; 1588 :     switch (obj->type) {

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR tv66[ebp]
	sub	edx, 1
	mov	DWORD PTR tv66[ebp], edx
	cmp	DWORD PTR tv66[ebp], 6
	ja	$LN2@xmlXPtrBui
	mov	eax, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN33@xmlXPtrBui[eax*4]
$LN15@xmlXPtrBui:

; 1589 :         case XPATH_NODESET: {
; 1590 : 	    xmlNodeSetPtr set = obj->nodesetval;

	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _set$2[ebp], edx

; 1591 : 	    if (set == NULL)

	cmp	DWORD PTR _set$2[ebp], 0
	jne	SHORT $LN16@xmlXPtrBui

; 1592 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrBui
$LN16@xmlXPtrBui:

; 1593 : 	    for (i = 0;i < set->nodeNr;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@xmlXPtrBui
$LN4@xmlXPtrBui:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@xmlXPtrBui:
	mov	ecx, DWORD PTR _set$2[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	$LN5@xmlXPtrBui

; 1594 : 		if (set->nodeTab[i] == NULL)

	mov	eax, DWORD PTR _set$2[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	jne	SHORT $LN17@xmlXPtrBui

; 1595 : 		    continue;

	jmp	SHORT $LN4@xmlXPtrBui
$LN17@xmlXPtrBui:

; 1596 : 		switch (set->nodeTab[i]->type) {

	mov	eax, DWORD PTR _set$2[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv80[ebp], ecx
	mov	edx, DWORD PTR tv80[ebp]
	sub	edx, 2
	mov	DWORD PTR tv80[ebp], edx
	cmp	DWORD PTR tv80[ebp], 16			; 00000010H
	ja	SHORT $LN7@xmlXPtrBui
	mov	eax, DWORD PTR tv80[ebp]
	movzx	ecx, BYTE PTR $LN32@xmlXPtrBui[eax]
	jmp	DWORD PTR $LN34@xmlXPtrBui[ecx*4]

; 1597 : 		    case XML_TEXT_NODE:
; 1598 : 		    case XML_CDATA_SECTION_NODE:
; 1599 : 		    case XML_ELEMENT_NODE:
; 1600 : 		    case XML_ENTITY_REF_NODE:
; 1601 : 		    case XML_ENTITY_NODE:
; 1602 : 		    case XML_PI_NODE:
; 1603 : 		    case XML_COMMENT_NODE:
; 1604 : 		    case XML_DOCUMENT_NODE:
; 1605 : 		    case XML_HTML_DOCUMENT_NODE:
; 1606 : #ifdef LIBXML_DOCB_ENABLED
; 1607 : 		    case XML_DOCB_DOCUMENT_NODE:
; 1608 : #endif
; 1609 : 		    case XML_XINCLUDE_START:
; 1610 : 		    case XML_XINCLUDE_END:
; 1611 : 			break;

	jmp	SHORT $LN7@xmlXPtrBui
$LN19@xmlXPtrBui:

; 1612 : 		    case XML_ATTRIBUTE_NODE:
; 1613 : 		    case XML_NAMESPACE_DECL:
; 1614 : 		    case XML_DOCUMENT_TYPE_NODE:
; 1615 : 		    case XML_DOCUMENT_FRAG_NODE:
; 1616 : 		    case XML_NOTATION_NODE:
; 1617 : 		    case XML_DTD_NODE:
; 1618 : 		    case XML_ELEMENT_DECL:
; 1619 : 		    case XML_ATTRIBUTE_DECL:
; 1620 : 		    case XML_ENTITY_DECL:
; 1621 : 			continue; /* for */

	jmp	SHORT $LN4@xmlXPtrBui
$LN7@xmlXPtrBui:

; 1622 : 		}
; 1623 : 		if (last == NULL)

	cmp	DWORD PTR _last$[ebp], 0
	jne	SHORT $LN20@xmlXPtrBui

; 1624 : 		    list = last = xmlCopyNode(set->nodeTab[i], 1);

	push	1
	mov	edx, DWORD PTR _set$2[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_xmlCopyNode
	add	esp, 8
	mov	DWORD PTR _last$[ebp], eax
	mov	eax, DWORD PTR _last$[ebp]
	mov	DWORD PTR _list$[ebp], eax
	jmp	SHORT $LN21@xmlXPtrBui
$LN20@xmlXPtrBui:

; 1625 : 		else {
; 1626 : 		    xmlAddNextSibling(last, xmlCopyNode(set->nodeTab[i], 1));

	push	1
	mov	ecx, DWORD PTR _set$2[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_xmlCopyNode
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _last$[ebp]
	push	edx
	call	_xmlAddNextSibling
	add	esp, 8

; 1627 : 		    if (last->next != NULL)

	mov	eax, DWORD PTR _last$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN21@xmlXPtrBui

; 1628 : 			last = last->next;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _last$[ebp], edx
$LN21@xmlXPtrBui:

; 1629 : 		}
; 1630 : 	    }

	jmp	$LN4@xmlXPtrBui
$LN5@xmlXPtrBui:

; 1631 : 	    break;

	jmp	$LN2@xmlXPtrBui
$LN23@xmlXPtrBui:

; 1632 : 	}
; 1633 : 	case XPATH_LOCATIONSET: {
; 1634 : 	    xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;

	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _set$1[ebp], ecx

; 1635 : 	    if (set == NULL)

	cmp	DWORD PTR _set$1[ebp], 0
	jne	SHORT $LN24@xmlXPtrBui

; 1636 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrBui
$LN24@xmlXPtrBui:

; 1637 : 	    for (i = 0;i < set->locNr;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@xmlXPtrBui
$LN9@xmlXPtrBui:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN11@xmlXPtrBui:
	mov	eax, DWORD PTR _set$1[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN10@xmlXPtrBui

; 1638 : 		if (last == NULL)

	cmp	DWORD PTR _last$[ebp], 0
	jne	SHORT $LN25@xmlXPtrBui

; 1639 : 		    list = last = xmlXPtrBuildNodeList(set->locTab[i]);

	mov	edx, DWORD PTR _set$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_xmlXPtrBuildNodeList
	add	esp, 4
	mov	DWORD PTR _last$[ebp], eax
	mov	eax, DWORD PTR _last$[ebp]
	mov	DWORD PTR _list$[ebp], eax
	jmp	SHORT $LN26@xmlXPtrBui
$LN25@xmlXPtrBui:

; 1640 : 		else
; 1641 : 		    xmlAddNextSibling(last,

	mov	ecx, DWORD PTR _set$1[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_xmlXPtrBuildNodeList
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _last$[ebp]
	push	edx
	call	_xmlAddNextSibling
	add	esp, 8
$LN26@xmlXPtrBui:

; 1642 : 			    xmlXPtrBuildNodeList(set->locTab[i]));
; 1643 : 		if (last != NULL) {

	cmp	DWORD PTR _last$[ebp], 0
	je	SHORT $LN27@xmlXPtrBui
$LN12@xmlXPtrBui:

; 1644 : 		    while (last->next != NULL)

	mov	eax, DWORD PTR _last$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN27@xmlXPtrBui

; 1645 : 			last = last->next;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _last$[ebp], edx
	jmp	SHORT $LN12@xmlXPtrBui
$LN27@xmlXPtrBui:

; 1646 : 		}
; 1647 : 	    }

	jmp	SHORT $LN9@xmlXPtrBui
$LN10@xmlXPtrBui:

; 1648 : 	    break;

	jmp	SHORT $LN2@xmlXPtrBui
$LN28@xmlXPtrBui:

; 1649 : 	}
; 1650 : 	case XPATH_RANGE:
; 1651 : 	    return(xmlXPtrBuildRangeNodeList(obj));

	mov	eax, DWORD PTR _obj$[ebp]
	push	eax
	call	_xmlXPtrBuildRangeNodeList
	add	esp, 4
	jmp	SHORT $LN1@xmlXPtrBui
$LN29@xmlXPtrBui:

; 1652 : 	case XPATH_POINT:
; 1653 : 	    return(xmlCopyNode(obj->user, 0));

	push	0
	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	_xmlCopyNode
	add	esp, 8
	jmp	SHORT $LN1@xmlXPtrBui
$LN2@xmlXPtrBui:

; 1654 : 	default:
; 1655 : 	    break;
; 1656 :     }
; 1657 :     return(list);

	mov	eax, DWORD PTR _list$[ebp]
$LN1@xmlXPtrBui:

; 1658 : }

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN33@xmlXPtrBui:
	DD	$LN15@xmlXPtrBui
	DD	$LN2@xmlXPtrBui
	DD	$LN2@xmlXPtrBui
	DD	$LN2@xmlXPtrBui
	DD	$LN29@xmlXPtrBui
	DD	$LN28@xmlXPtrBui
	DD	$LN23@xmlXPtrBui
$LN34@xmlXPtrBui:
	DD	$LN19@xmlXPtrBui
	DD	$LN7@xmlXPtrBui
$LN32@xmlXPtrBui:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
_xmlXPtrBuildNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrRangeToFunction
_TEXT	SEGMENT
_ctxt$ = 8						; size = 4
_nargs$ = 12						; size = 4
_xmlXPtrRangeToFunction PROC				; COMDAT

; 2227 :                        int nargs ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 2228 :     XP_ERROR(XPATH_EXPR_ERROR);

	push	7
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathErr
	add	esp, 8

; 2229 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlXPtrRangeToFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrEval
_TEXT	SEGMENT
_set$1 = -24						; size = 4
_stack$ = -20						; size = 4
_init$ = -16						; size = 4
_tmp$ = -12						; size = 4
_res$ = -8						; size = 4
_ctxt$ = -4						; size = 4
_str$ = 8						; size = 4
_ctx$ = 12						; size = 4
_xmlXPtrEval PROC					; COMDAT

; 1339 : xmlXPtrEval(const xmlChar *str, xmlXPathContextPtr ctx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1340 :     xmlXPathParserContextPtr ctxt;
; 1341 :     xmlXPathObjectPtr res = NULL, tmp;

	mov	DWORD PTR _res$[ebp], 0

; 1342 :     xmlXPathObjectPtr init = NULL;

	mov	DWORD PTR _init$[ebp], 0

; 1343 :     int stack = 0;

	mov	DWORD PTR _stack$[ebp], 0

; 1344 : 
; 1345 :     xmlXPathInit();

	call	_xmlXPathInit

; 1346 : 
; 1347 :     if ((ctx == NULL) || (str == NULL))

	cmp	DWORD PTR _ctx$[ebp], 0
	je	SHORT $LN6@xmlXPtrEva
	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN5@xmlXPtrEva
$LN6@xmlXPtrEva:

; 1348 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrEva
$LN5@xmlXPtrEva:

; 1349 : 
; 1350 :     ctxt = xmlXPathNewParserContext(str, ctx);

	mov	eax, DWORD PTR _ctx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_xmlXPathNewParserContext
	add	esp, 8
	mov	DWORD PTR _ctxt$[ebp], eax

; 1351 :     if (ctxt == NULL)

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN7@xmlXPtrEva

; 1352 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrEva
$LN7@xmlXPtrEva:

; 1353 :     ctxt->xptr = 1;

	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	DWORD PTR [edx+36], 1

; 1354 :     xmlXPtrEvalXPointer(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPtrEvalXPointer
	add	esp, 4

; 1355 : 
; 1356 :     if ((ctxt->value != NULL) &&
; 1357 : 	(ctxt->value->type != XPATH_NODESET) &&

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN8@xmlXPtrEva
	mov	edx, DWORD PTR _ctxt$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN8@xmlXPtrEva
	mov	ecx, DWORD PTR _ctxt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	DWORD PTR [edx], 7
	je	SHORT $LN8@xmlXPtrEva

; 1358 : 	(ctxt->value->type != XPATH_LOCATIONSET)) {
; 1359 :         xmlXPtrErr(ctxt, XML_XPTR_EVAL_FAILED,

	push	0
	push	OFFSET ??_C@_0DF@PGJMIHPP@xmlXPtrEval?3?5evaluation?5failed?5@
	push	1902					; 0000076eH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPtrErr
	add	esp, 16					; 00000010H

; 1360 : 		"xmlXPtrEval: evaluation failed to return a node set\n",
; 1361 : 		   NULL);
; 1362 :     } else {

	jmp	SHORT $LN4@xmlXPtrEva
$LN8@xmlXPtrEva:

; 1363 : 	res = valuePop(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _res$[ebp], eax
$LN4@xmlXPtrEva:

; 1364 :     }
; 1365 : 
; 1366 :     do {
; 1367 :         tmp = valuePop(ctxt);

	mov	edx, DWORD PTR _ctxt$[ebp]
	push	edx
	call	_valuePop
	add	esp, 4
	mov	DWORD PTR _tmp$[ebp], eax

; 1368 : 	if (tmp != NULL) {

	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN2@xmlXPtrEva

; 1369 : 	    if (tmp != init) {

	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	eax, DWORD PTR _init$[ebp]
	je	SHORT $LN11@xmlXPtrEva

; 1370 : 		if (tmp->type == XPATH_NODESET) {

	mov	ecx, DWORD PTR _tmp$[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN12@xmlXPtrEva

; 1371 : 		    /*
; 1372 : 		     * Evaluation may push a root nodeset which is unused
; 1373 : 		     */
; 1374 : 		    xmlNodeSetPtr set;
; 1375 : 		    set = tmp->nodesetval;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _set$1[ebp], eax

; 1376 : 		    if ((set == NULL) || (set->nodeNr != 1) ||

	cmp	DWORD PTR _set$1[ebp], 0
	je	SHORT $LN15@xmlXPtrEva
	mov	ecx, DWORD PTR _set$1[ebp]
	cmp	DWORD PTR [ecx], 1
	jne	SHORT $LN15@xmlXPtrEva
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _set$1[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _ctx$[ebp]
	mov	edx, DWORD PTR [eax+edx]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN14@xmlXPtrEva
$LN15@xmlXPtrEva:

; 1377 : 			(set->nodeTab[0] != (xmlNodePtr) ctx->doc))
; 1378 : 			stack++;

	mov	eax, DWORD PTR _stack$[ebp]
	add	eax, 1
	mov	DWORD PTR _stack$[ebp], eax
$LN14@xmlXPtrEva:

; 1379 : 		} else

	jmp	SHORT $LN11@xmlXPtrEva
$LN12@xmlXPtrEva:

; 1380 : 		    stack++;

	mov	ecx, DWORD PTR _stack$[ebp]
	add	ecx, 1
	mov	DWORD PTR _stack$[ebp], ecx
$LN11@xmlXPtrEva:

; 1381 : 	    }
; 1382 : 	    xmlXPathFreeObject(tmp);

	mov	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4
$LN2@xmlXPtrEva:

; 1383 :         }
; 1384 :     } while (tmp != NULL);

	cmp	DWORD PTR _tmp$[ebp], 0
	jne	SHORT $LN4@xmlXPtrEva

; 1385 :     if (stack != 0) {

	cmp	DWORD PTR _stack$[ebp], 0
	je	SHORT $LN16@xmlXPtrEva

; 1386 :         xmlXPtrErr(ctxt, XML_XPTR_EXTRA_OBJECTS,

	push	0
	push	OFFSET ??_C@_0CP@NCKIHCDF@xmlXPtrEval?3?5object?$CIs?$CJ?5left?5on?5@
	push	1903					; 0000076fH
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPtrErr
	add	esp, 16					; 00000010H
$LN16@xmlXPtrEva:

; 1387 : 		   "xmlXPtrEval: object(s) left on the eval stack\n",
; 1388 : 		   NULL);
; 1389 :     }
; 1390 :     if (ctxt->error != XPATH_EXPRESSION_OK) {

	mov	ecx, DWORD PTR _ctxt$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN17@xmlXPtrEva

; 1391 : 	xmlXPathFreeObject(res);

	mov	edx, DWORD PTR _res$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1392 : 	res = NULL;

	mov	DWORD PTR _res$[ebp], 0
$LN17@xmlXPtrEva:

; 1393 :     }
; 1394 : 
; 1395 :     xmlXPathFreeParserContext(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlXPathFreeParserContext
	add	esp, 4

; 1396 :     return(res);

	mov	eax, DWORD PTR _res$[ebp]
$LN1@xmlXPtrEva:

; 1397 : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrEval ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewContext
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_doc$ = 8						; size = 4
_here$ = 12						; size = 4
_origin$ = 16						; size = 4
_xmlXPtrNewContext PROC					; COMDAT

; 1300 : xmlXPtrNewContext(xmlDocPtr doc, xmlNodePtr here, xmlNodePtr origin) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 1301 :     xmlXPathContextPtr ret;
; 1302 : 
; 1303 :     ret = xmlXPathNewContext(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlXPathNewContext
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 1304 :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlXPtrNew

; 1305 : 	return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	$LN1@xmlXPtrNew
$LN2@xmlXPtrNew:

; 1306 :     ret->xptr = 1;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+76], 1

; 1307 :     ret->here = here;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _here$[ebp]
	mov	DWORD PTR [edx+80], eax

; 1308 :     ret->origin = origin;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _origin$[ebp]
	mov	DWORD PTR [ecx+84], edx

; 1309 : 
; 1310 :     xmlXPathRegisterFunc(ret, (xmlChar *)"range",

	push	OFFSET _xmlXPtrRangeFunction
	push	OFFSET ??_C@_05CCGOGOBM@range@
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlXPathRegisterFunc
	add	esp, 12					; 0000000cH

; 1311 : 	                 xmlXPtrRangeFunction);
; 1312 :     xmlXPathRegisterFunc(ret, (xmlChar *)"range-inside",

	push	OFFSET _xmlXPtrRangeInsideFunction
	push	OFFSET ??_C@_0N@FPBCPIBK@range?9inside@
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlXPathRegisterFunc
	add	esp, 12					; 0000000cH

; 1313 : 	                 xmlXPtrRangeInsideFunction);
; 1314 :     xmlXPathRegisterFunc(ret, (xmlChar *)"string-range",

	push	OFFSET _xmlXPtrStringRangeFunction
	push	OFFSET ??_C@_0N@NHPDEMLM@string?9range@
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlXPathRegisterFunc
	add	esp, 12					; 0000000cH

; 1315 : 	                 xmlXPtrStringRangeFunction);
; 1316 :     xmlXPathRegisterFunc(ret, (xmlChar *)"start-point",

	push	OFFSET _xmlXPtrStartPointFunction
	push	OFFSET ??_C@_0M@KAHBAHMC@start?9point@
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlXPathRegisterFunc
	add	esp, 12					; 0000000cH

; 1317 : 	                 xmlXPtrStartPointFunction);
; 1318 :     xmlXPathRegisterFunc(ret, (xmlChar *)"end-point",

	push	OFFSET _xmlXPtrEndPointFunction
	push	OFFSET ??_C@_09BKKFPLJK@end?9point@
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlXPathRegisterFunc
	add	esp, 12					; 0000000cH

; 1319 : 	                 xmlXPtrEndPointFunction);
; 1320 :     xmlXPathRegisterFunc(ret, (xmlChar *)"here",

	push	OFFSET _xmlXPtrHereFunction
	push	OFFSET ??_C@_04NDJIBAID@here@
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlXPathRegisterFunc
	add	esp, 12					; 0000000cH

; 1321 : 	                 xmlXPtrHereFunction);
; 1322 :     xmlXPathRegisterFunc(ret, (xmlChar *)" origin",

	push	OFFSET _xmlXPtrOriginFunction
	push	OFFSET ??_C@_07NGBELOAG@?5origin@
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlXPathRegisterFunc
	add	esp, 12					; 0000000cH

; 1323 : 	                 xmlXPtrOriginFunction);
; 1324 : 
; 1325 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 1326 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrLocationSetRemove
_TEXT	SEGMENT
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPtrLocationSetRemove PROC				; COMDAT

; 723  : xmlXPtrLocationSetRemove(xmlLocationSetPtr cur, int val) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 724  :     if (cur == NULL) return;

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN5@xmlXPtrLoc
	jmp	SHORT $LN1@xmlXPtrLoc
$LN5@xmlXPtrLoc:

; 725  :     if (val >= cur->locNr) return;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN6@xmlXPtrLoc
	jmp	SHORT $LN1@xmlXPtrLoc
$LN6@xmlXPtrLoc:

; 726  :     cur->locNr--;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx], eax

; 727  :     for (;val < cur->locNr;val++)

	jmp	SHORT $LN4@xmlXPtrLoc
$LN2@xmlXPtrLoc:
	mov	edx, DWORD PTR _val$[ebp]
	add	edx, 1
	mov	DWORD PTR _val$[ebp], edx
$LN4@xmlXPtrLoc:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _val$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@xmlXPtrLoc

; 728  :         cur->locTab[val] = cur->locTab[val + 1];

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	esi, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [eax+esi*4+4]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN2@xmlXPtrLoc
$LN3@xmlXPtrLoc:

; 729  :     cur->locTab[cur->locNr] = NULL;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+edx*4], 0
$LN1@xmlXPtrLoc:

; 730  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlXPtrLocationSetRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrLocationSetDel
_TEXT	SEGMENT
_i$ = -4						; size = 4
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPtrLocationSetDel PROC				; COMDAT

; 690  : xmlXPtrLocationSetDel(xmlLocationSetPtr cur, xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 691  :     int i;
; 692  : 
; 693  :     if (cur == NULL) return;

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN8@xmlXPtrLoc
	jmp	$LN1@xmlXPtrLoc
$LN8@xmlXPtrLoc:

; 694  :     if (val == NULL) return;

	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN9@xmlXPtrLoc
	jmp	$LN1@xmlXPtrLoc
$LN9@xmlXPtrLoc:

; 695  : 
; 696  :     /*
; 697  :      * check against doublons
; 698  :      */
; 699  :     for (i = 0;i < cur->locNr;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlXPtrLoc
$LN2@xmlXPtrLoc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlXPtrLoc:
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN3@xmlXPtrLoc

; 700  :         if (cur->locTab[i] == val) break;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _val$[ebp]
	jne	SHORT $LN10@xmlXPtrLoc
	jmp	SHORT $LN3@xmlXPtrLoc
$LN10@xmlXPtrLoc:
	jmp	SHORT $LN2@xmlXPtrLoc
$LN3@xmlXPtrLoc:

; 701  : 
; 702  :     if (i >= cur->locNr) {

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN11@xmlXPtrLoc

; 703  : #ifdef DEBUG
; 704  :         xmlGenericError(xmlGenericErrorContext,
; 705  : 	        "xmlXPtrLocationSetDel: Range wasn't found in RangeList\n");
; 706  : #endif
; 707  :         return;

	jmp	SHORT $LN1@xmlXPtrLoc
$LN11@xmlXPtrLoc:

; 708  :     }
; 709  :     cur->locNr--;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], ecx

; 710  :     for (;i < cur->locNr;i++)

	jmp	SHORT $LN7@xmlXPtrLoc
$LN5@xmlXPtrLoc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@xmlXPtrLoc:
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN6@xmlXPtrLoc

; 711  :         cur->locTab[i] = cur->locTab[i + 1];

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN5@xmlXPtrLoc
$LN6@xmlXPtrLoc:

; 712  :     cur->locTab[cur->locNr] = NULL;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+eax*4], 0
$LN1@xmlXPtrLoc:

; 713  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrLocationSetDel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrWrapLocationSet
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_val$ = 8						; size = 4
_xmlXPtrWrapLocationSet PROC				; COMDAT

; 826  : xmlXPtrWrapLocationSet(xmlLocationSetPtr val) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 827  :     xmlXPathObjectPtr ret;
; 828  : 
; 829  :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	mov	esi, esp
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 830  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlXPtrWra

; 831  :         xmlXPtrErrMemory("allocating locationset");

	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 832  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrWra
$LN2@xmlXPtrWra:

; 833  :     }
; 834  :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 835  :     ret->type = XPATH_LOCATIONSET;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], 7

; 836  :     ret->user = (void *) val;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx+28], eax

; 837  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrWra:

; 838  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrWrapLocationSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrLocationSetAdd
_TEXT	SEGMENT
_temp$1 = -8						; size = 4
_i$ = -4						; size = 4
_cur$ = 8						; size = 4
_val$ = 12						; size = 4
_xmlXPtrLocationSetAdd PROC				; COMDAT

; 612  : xmlXPtrLocationSetAdd(xmlLocationSetPtr cur, xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 613  :     int i;
; 614  : 
; 615  :     if ((cur == NULL) || (val == NULL)) return;

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@xmlXPtrLoc
	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN5@xmlXPtrLoc
$LN6@xmlXPtrLoc:
	jmp	$LN1@xmlXPtrLoc
$LN5@xmlXPtrLoc:

; 616  : 
; 617  :     /*
; 618  :      * check against doublons
; 619  :      */
; 620  :     for (i = 0;i < cur->locNr;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlXPtrLoc
$LN2@xmlXPtrLoc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlXPtrLoc:
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN3@xmlXPtrLoc

; 621  : 	if (xmlXPtrRangesEqual(cur->locTab[i], val)) {

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_xmlXPtrRangesEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@xmlXPtrLoc

; 622  : 	    xmlXPathFreeObject(val);

	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 623  : 	    return;

	jmp	$LN1@xmlXPtrLoc
$LN7@xmlXPtrLoc:

; 624  : 	}
; 625  :     }

	jmp	SHORT $LN2@xmlXPtrLoc
$LN3@xmlXPtrLoc:

; 626  : 
; 627  :     /*
; 628  :      * grow the locTab if needed
; 629  :      */
; 630  :     if (cur->locMax == 0) {

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN8@xmlXPtrLoc

; 631  :         cur->locTab = (xmlXPathObjectPtr *) xmlMalloc(XML_RANGESET_DEFAULT *

	mov	esi, esp
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 632  : 					     sizeof(xmlXPathObjectPtr));
; 633  : 	if (cur->locTab == NULL) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@xmlXPtrLoc

; 634  : 	    xmlXPtrErrMemory("adding location to set");

	push	OFFSET ??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 635  : 	    return;

	jmp	$LN1@xmlXPtrLoc
$LN10@xmlXPtrLoc:

; 636  : 	}
; 637  : 	memset(cur->locTab, 0 ,

	xor	eax, eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], eax
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], eax
	mov	DWORD PTR [edx+16], eax
	mov	DWORD PTR [edx+20], eax
	mov	DWORD PTR [edx+24], eax
	mov	DWORD PTR [edx+28], eax
	mov	DWORD PTR [edx+32], eax
	mov	DWORD PTR [edx+36], eax

; 638  : 	       XML_RANGESET_DEFAULT * (size_t) sizeof(xmlXPathObjectPtr));
; 639  :         cur->locMax = XML_RANGESET_DEFAULT;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4], 10			; 0000000aH
	jmp	SHORT $LN9@xmlXPtrLoc
$LN8@xmlXPtrLoc:

; 640  :     } else if (cur->locNr == cur->locMax) {

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN9@xmlXPtrLoc

; 641  :         xmlXPathObjectPtr *temp;
; 642  : 
; 643  :         cur->locMax *= 2;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 1
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4], edx

; 644  : 	temp = (xmlXPathObjectPtr *) xmlRealloc(cur->locTab, cur->locMax *

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _temp$1[ebp], eax

; 645  : 				      sizeof(xmlXPathObjectPtr));
; 646  : 	if (temp == NULL) {

	cmp	DWORD PTR _temp$1[ebp], 0
	jne	SHORT $LN12@xmlXPtrLoc

; 647  : 	    xmlXPtrErrMemory("adding location to set");

	push	OFFSET ??_C@_0BH@MIMPNDJH@adding?5location?5to?5set@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 648  : 	    return;

	jmp	SHORT $LN1@xmlXPtrLoc
$LN12@xmlXPtrLoc:

; 649  : 	}
; 650  : 	cur->locTab = temp;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR _temp$1[ebp]
	mov	DWORD PTR [edx+8], eax
$LN9@xmlXPtrLoc:

; 651  :     }
; 652  :     cur->locTab[cur->locNr++] = val;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], edx
$LN1@xmlXPtrLoc:

; 653  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrLocationSetAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewCollapsedRange
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_start$ = 8						; size = 4
_xmlXPtrNewCollapsedRange PROC				; COMDAT

; 510  : xmlXPtrNewCollapsedRange(xmlNodePtr start) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 511  :     xmlXPathObjectPtr ret;
; 512  : 
; 513  :     if (start == NULL)

	cmp	DWORD PTR _start$[ebp], 0
	jne	SHORT $LN2@xmlXPtrNew

; 514  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN2@xmlXPtrNew:

; 515  : 
; 516  :     ret = xmlXPtrNewRangeInternal(start, -1, NULL, -1);

	push	-1
	push	0
	push	-1
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlXPtrNewRangeInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 517  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 518  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewCollapsedRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangeNodeObject
_TEXT	SEGMENT
tv67 = -16						; size = 4
_ret$ = -12						; size = 4
_endIndex$ = -8						; size = 4
_endNode$ = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewRangeNodeObject PROC				; COMDAT

; 530  : xmlXPtrNewRangeNodeObject(xmlNodePtr start, xmlXPathObjectPtr end) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 531  :     xmlNodePtr endNode;
; 532  :     int endIndex;
; 533  :     xmlXPathObjectPtr ret;
; 534  : 
; 535  :     if (start == NULL)

	cmp	DWORD PTR _start$[ebp], 0
	jne	SHORT $LN4@xmlXPtrNew

; 536  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrNew
$LN4@xmlXPtrNew:

; 537  :     if (end == NULL)

	cmp	DWORD PTR _end$[ebp], 0
	jne	SHORT $LN5@xmlXPtrNew

; 538  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrNew
$LN5@xmlXPtrNew:

; 539  :     switch (end->type) {

	mov	eax, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 1
	je	SHORT $LN8@xmlXPtrNew
	cmp	DWORD PTR tv67[ebp], 5
	je	SHORT $LN6@xmlXPtrNew
	cmp	DWORD PTR tv67[ebp], 6
	je	SHORT $LN7@xmlXPtrNew
	jmp	SHORT $LN11@xmlXPtrNew
$LN6@xmlXPtrNew:

; 540  : 	case XPATH_POINT:
; 541  : 	    endNode = end->user;

	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _endNode$[ebp], eax

; 542  : 	    endIndex = end->index;

	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _endIndex$[ebp], edx

; 543  : 	    break;

	jmp	SHORT $LN2@xmlXPtrNew
$LN7@xmlXPtrNew:

; 544  : 	case XPATH_RANGE:
; 545  : 	    endNode = end->user2;

	mov	eax, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _endNode$[ebp], ecx

; 546  : 	    endIndex = end->index2;

	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _endIndex$[ebp], eax

; 547  : 	    break;

	jmp	SHORT $LN2@xmlXPtrNew
$LN8@xmlXPtrNew:

; 548  : 	case XPATH_NODESET:
; 549  : 	    /*
; 550  : 	     * Empty set ...
; 551  : 	     */
; 552  : 	    if ((end->nodesetval == NULL) || (end->nodesetval->nodeNr <= 0))

	mov	ecx, DWORD PTR _end$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN10@xmlXPtrNew
	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN9@xmlXPtrNew
$LN10@xmlXPtrNew:

; 553  : 		return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN9@xmlXPtrNew:

; 554  : 	    endNode = end->nodesetval->nodeTab[end->nodesetval->nodeNr - 1];

	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	DWORD PTR _endNode$[ebp], edx

; 555  : 	    endIndex = -1;

	mov	DWORD PTR _endIndex$[ebp], -1

; 556  : 	    break;

	jmp	SHORT $LN2@xmlXPtrNew
$LN11@xmlXPtrNew:

; 557  : 	default:
; 558  : 	    /* TODO */
; 559  : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN2@xmlXPtrNew:

; 560  :     }
; 561  : 
; 562  :     ret = xmlXPtrNewRangeInternal(start, -1, endNode, endIndex);

	mov	eax, DWORD PTR _endIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _endNode$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_xmlXPtrNewRangeInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 563  :     xmlXPtrRangeCheckOrder(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlXPtrRangeCheckOrder
	add	esp, 4

; 564  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 565  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewRangeNodeObject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewLocationSetNodeSet
_TEXT	SEGMENT
_newset$1 = -12						; size = 4
_i$2 = -8						; size = 4
_ret$ = -4						; size = 4
_set$ = 8						; size = 4
_xmlXPtrNewLocationSetNodeSet PROC			; COMDAT

; 790  : xmlXPtrNewLocationSetNodeSet(xmlNodeSetPtr set) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 791  :     xmlXPathObjectPtr ret;
; 792  : 
; 793  :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	mov	esi, esp
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 794  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN5@xmlXPtrNew

; 795  :         xmlXPtrErrMemory("allocating locationset");

	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 796  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrNew
$LN5@xmlXPtrNew:

; 797  :     }
; 798  :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 799  :     ret->type = XPATH_LOCATIONSET;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], 7

; 800  :     if (set != NULL) {

	cmp	DWORD PTR _set$[ebp], 0
	je	SHORT $LN6@xmlXPtrNew

; 801  : 	int i;
; 802  : 	xmlLocationSetPtr newset;
; 803  : 
; 804  : 	newset = xmlXPtrLocationSetCreate(NULL);

	push	0
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	DWORD PTR _newset$1[ebp], eax

; 805  : 	if (newset == NULL)

	cmp	DWORD PTR _newset$1[ebp], 0
	jne	SHORT $LN7@xmlXPtrNew

; 806  : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlXPtrNew
$LN7@xmlXPtrNew:

; 807  : 
; 808  : 	for (i = 0;i < set->nodeNr;i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@xmlXPtrNew
$LN2@xmlXPtrNew:
	mov	edx, DWORD PTR _i$2[ebp]
	add	edx, 1
	mov	DWORD PTR _i$2[ebp], edx
$LN4@xmlXPtrNew:
	mov	eax, DWORD PTR _set$[ebp]
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@xmlXPtrNew

; 809  : 	    xmlXPtrLocationSetAdd(newset,

	mov	edx, DWORD PTR _set$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _i$2[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_xmlXPtrNewCollapsedRange
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _newset$1[ebp]
	push	eax
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
	jmp	SHORT $LN2@xmlXPtrNew
$LN3@xmlXPtrNew:

; 810  : 		        xmlXPtrNewCollapsedRange(set->nodeTab[i]));
; 811  : 
; 812  : 	ret->user = (void *) newset;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _newset$1[ebp]
	mov	DWORD PTR [ecx+28], edx
$LN6@xmlXPtrNew:

; 813  :     }
; 814  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 815  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewLocationSetNodeSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewLocationSetNodes
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewLocationSetNodes PROC			; COMDAT

; 763  : xmlXPtrNewLocationSetNodes(xmlNodePtr start, xmlNodePtr end) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 764  :     xmlXPathObjectPtr ret;
; 765  : 
; 766  :     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));

	mov	esi, esp
	push	48					; 00000030H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 767  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlXPtrNew

; 768  :         xmlXPtrErrMemory("allocating locationset");

	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 769  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN2@xmlXPtrNew:

; 770  :     }
; 771  :     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));

	push	48					; 00000030H
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 772  :     ret->type = XPATH_LOCATIONSET;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], 7

; 773  :     if (end == NULL)

	cmp	DWORD PTR _end$[ebp], 0
	jne	SHORT $LN3@xmlXPtrNew

; 774  : 	ret->user = xmlXPtrLocationSetCreate(xmlXPtrNewCollapsedRange(start));

	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_xmlXPtrNewCollapsedRange
	add	esp, 4
	push	eax
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+28], eax
	jmp	SHORT $LN4@xmlXPtrNew
$LN3@xmlXPtrNew:

; 775  :     else
; 776  : 	ret->user = xmlXPtrLocationSetCreate(xmlXPtrNewRangeNodes(start,end));

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlXPtrNewRangeNodes
	add	esp, 8
	push	eax
	call	_xmlXPtrLocationSetCreate
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+28], eax
$LN4@xmlXPtrNew:

; 777  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 778  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewLocationSetNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangeNodes
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewRangeNodes PROC				; COMDAT

; 488  : xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 489  :     xmlXPathObjectPtr ret;
; 490  : 
; 491  :     if (start == NULL)

	cmp	DWORD PTR _start$[ebp], 0
	jne	SHORT $LN2@xmlXPtrNew

; 492  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN2@xmlXPtrNew:

; 493  :     if (end == NULL)

	cmp	DWORD PTR _end$[ebp], 0
	jne	SHORT $LN3@xmlXPtrNew

; 494  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN3@xmlXPtrNew:

; 495  : 
; 496  :     ret = xmlXPtrNewRangeInternal(start, -1, end, -1);

	push	-1
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	call	_xmlXPtrNewRangeInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 497  :     xmlXPtrRangeCheckOrder(ret);

	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	call	_xmlXPtrRangeCheckOrder
	add	esp, 4

; 498  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 499  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewRangeNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangePointNode
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewRangePointNode PROC				; COMDAT

; 438  : xmlXPtrNewRangePointNode(xmlXPathObjectPtr start, xmlNodePtr end) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 439  :     xmlXPathObjectPtr ret;
; 440  : 
; 441  :     if (start == NULL)

	cmp	DWORD PTR _start$[ebp], 0
	jne	SHORT $LN2@xmlXPtrNew

; 442  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN2@xmlXPtrNew:

; 443  :     if (end == NULL)

	cmp	DWORD PTR _end$[ebp], 0
	jne	SHORT $LN3@xmlXPtrNew

; 444  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN3@xmlXPtrNew:

; 445  :     if (start->type != XPATH_POINT)

	mov	eax, DWORD PTR _start$[ebp]
	cmp	DWORD PTR [eax], 5
	je	SHORT $LN4@xmlXPtrNew

; 446  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN4@xmlXPtrNew:

; 447  : 
; 448  :     ret = xmlXPtrNewRangeInternal(start->user, start->index, end, -1);

	push	-1
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	_xmlXPtrNewRangeInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 449  :     xmlXPtrRangeCheckOrder(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlXPtrRangeCheckOrder
	add	esp, 4

; 450  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 451  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewRangePointNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangeNodePoint
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewRangeNodePoint PROC				; COMDAT

; 463  : xmlXPtrNewRangeNodePoint(xmlNodePtr start, xmlXPathObjectPtr end) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 464  :     xmlXPathObjectPtr ret;
; 465  : 
; 466  :     if (start == NULL)

	cmp	DWORD PTR _start$[ebp], 0
	jne	SHORT $LN2@xmlXPtrNew

; 467  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN2@xmlXPtrNew:

; 468  :     if (end == NULL)

	cmp	DWORD PTR _end$[ebp], 0
	jne	SHORT $LN3@xmlXPtrNew

; 469  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN3@xmlXPtrNew:

; 470  :     if (end->type != XPATH_POINT)

	mov	eax, DWORD PTR _end$[ebp]
	cmp	DWORD PTR [eax], 5
	je	SHORT $LN4@xmlXPtrNew

; 471  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN4@xmlXPtrNew:

; 472  : 
; 473  :     ret = xmlXPtrNewRangeInternal(start, -1, end->user, end->index);

	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_xmlXPtrNewRangeInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 474  :     xmlXPtrRangeCheckOrder(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_xmlXPtrRangeCheckOrder
	add	esp, 4

; 475  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 476  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewRangeNodePoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRangePoints
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_xmlXPtrNewRangePoints PROC				; COMDAT

; 410  : xmlXPtrNewRangePoints(xmlXPathObjectPtr start, xmlXPathObjectPtr end) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 411  :     xmlXPathObjectPtr ret;
; 412  : 
; 413  :     if (start == NULL)

	cmp	DWORD PTR _start$[ebp], 0
	jne	SHORT $LN2@xmlXPtrNew

; 414  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN2@xmlXPtrNew:

; 415  :     if (end == NULL)

	cmp	DWORD PTR _end$[ebp], 0
	jne	SHORT $LN3@xmlXPtrNew

; 416  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN3@xmlXPtrNew:

; 417  :     if (start->type != XPATH_POINT)

	mov	eax, DWORD PTR _start$[ebp]
	cmp	DWORD PTR [eax], 5
	je	SHORT $LN4@xmlXPtrNew

; 418  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN4@xmlXPtrNew:

; 419  :     if (end->type != XPATH_POINT)

	mov	ecx, DWORD PTR _end$[ebp]
	cmp	DWORD PTR [ecx], 5
	je	SHORT $LN5@xmlXPtrNew

; 420  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN5@xmlXPtrNew:

; 421  : 
; 422  :     ret = xmlXPtrNewRangeInternal(start->user, start->index, end->user,

	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	_xmlXPtrNewRangeInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 423  :                                   end->index);
; 424  :     xmlXPtrRangeCheckOrder(ret);

	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlXPtrRangeCheckOrder
	add	esp, 4

; 425  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 426  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewRangePoints ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrNewRange
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_start$ = 8						; size = 4
_startindex$ = 12					; size = 4
_end$ = 16						; size = 4
_endindex$ = 20						; size = 4
_xmlXPtrNewRange PROC					; COMDAT

; 383  : 	        xmlNodePtr end, int endindex) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 384  :     xmlXPathObjectPtr ret;
; 385  : 
; 386  :     if (start == NULL)

	cmp	DWORD PTR _start$[ebp], 0
	jne	SHORT $LN2@xmlXPtrNew

; 387  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN2@xmlXPtrNew:

; 388  :     if (end == NULL)

	cmp	DWORD PTR _end$[ebp], 0
	jne	SHORT $LN3@xmlXPtrNew

; 389  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN3@xmlXPtrNew:

; 390  :     if (startindex < 0)

	cmp	DWORD PTR _startindex$[ebp], 0
	jge	SHORT $LN4@xmlXPtrNew

; 391  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN4@xmlXPtrNew:

; 392  :     if (endindex < 0)

	cmp	DWORD PTR _endindex$[ebp], 0
	jge	SHORT $LN5@xmlXPtrNew

; 393  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrNew
$LN5@xmlXPtrNew:

; 394  : 
; 395  :     ret = xmlXPtrNewRangeInternal(start, startindex, end, endindex);

	mov	eax, DWORD PTR _endindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _startindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_xmlXPtrNewRangeInternal
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$[ebp], eax

; 396  :     xmlXPtrRangeCheckOrder(ret);

	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlXPtrRangeCheckOrder
	add	esp, 4

; 397  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrNew:

; 398  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrNewRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrLocationSetMerge
_TEXT	SEGMENT
_i$ = -4						; size = 4
_val1$ = 8						; size = 4
_val2$ = 12						; size = 4
_xmlXPtrLocationSetMerge PROC				; COMDAT

; 665  : xmlXPtrLocationSetMerge(xmlLocationSetPtr val1, xmlLocationSetPtr val2) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 666  :     int i;
; 667  : 
; 668  :     if (val1 == NULL) return(NULL);

	cmp	DWORD PTR _val1$[ebp], 0
	jne	SHORT $LN5@xmlXPtrLoc
	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrLoc
$LN5@xmlXPtrLoc:

; 669  :     if (val2 == NULL) return(val1);

	cmp	DWORD PTR _val2$[ebp], 0
	jne	SHORT $LN6@xmlXPtrLoc
	mov	eax, DWORD PTR _val1$[ebp]
	jmp	SHORT $LN1@xmlXPtrLoc
$LN6@xmlXPtrLoc:

; 670  : 
; 671  :     /*
; 672  :      * !!!!! this can be optimized a lot, knowing that both
; 673  :      *       val1 and val2 already have unicity of their values.
; 674  :      */
; 675  : 
; 676  :     for (i = 0;i < val2->locNr;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlXPtrLoc
$LN2@xmlXPtrLoc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlXPtrLoc:
	mov	ecx, DWORD PTR _val2$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN3@xmlXPtrLoc

; 677  :         xmlXPtrLocationSetAdd(val1, val2->locTab[i]);

	mov	eax, DWORD PTR _val2$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _val1$[ebp]
	push	ecx
	call	_xmlXPtrLocationSetAdd
	add	esp, 8
	jmp	SHORT $LN2@xmlXPtrLoc
$LN3@xmlXPtrLoc:

; 678  : 
; 679  :     return(val1);

	mov	eax, DWORD PTR _val1$[ebp]
$LN1@xmlXPtrLoc:

; 680  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrLocationSetMerge ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrFreeLocationSet
_TEXT	SEGMENT
_i$ = -4						; size = 4
_obj$ = 8						; size = 4
_xmlXPtrFreeLocationSet PROC				; COMDAT

; 739  : xmlXPtrFreeLocationSet(xmlLocationSetPtr obj) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 740  :     int i;
; 741  : 
; 742  :     if (obj == NULL) return;

	cmp	DWORD PTR _obj$[ebp], 0
	jne	SHORT $LN5@xmlXPtrFre
	jmp	SHORT $LN1@xmlXPtrFre
$LN5@xmlXPtrFre:

; 743  :     if (obj->locTab != NULL) {

	mov	eax, DWORD PTR _obj$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN6@xmlXPtrFre

; 744  : 	for (i = 0;i < obj->locNr; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlXPtrFre
$LN2@xmlXPtrFre:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlXPtrFre:
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN3@xmlXPtrFre

; 745  :             xmlXPathFreeObject(obj->locTab[i]);

	mov	ecx, DWORD PTR _obj$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 746  : 	}

	jmp	SHORT $LN2@xmlXPtrFre
$LN3@xmlXPtrFre:

; 747  : 	xmlFree(obj->locTab);

	mov	esi, esp
	mov	edx, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlXPtrFre:

; 748  :     }
; 749  :     xmlFree(obj);

	mov	esi, esp
	mov	ecx, DWORD PTR _obj$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlXPtrFre:

; 750  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrFreeLocationSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xpointer.c
;	COMDAT _xmlXPtrLocationSetCreate
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_val$ = 8						; size = 4
_xmlXPtrLocationSetCreate PROC				; COMDAT

; 578  : xmlXPtrLocationSetCreate(xmlXPathObjectPtr val) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __BEF3E6F7_xpointer@c
	call	@__CheckForDebuggerJustMyCode@4

; 579  :     xmlLocationSetPtr ret;
; 580  : 
; 581  :     ret = (xmlLocationSetPtr) xmlMalloc(sizeof(xmlLocationSet));

	mov	esi, esp
	push	12					; 0000000cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 582  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlXPtrLoc

; 583  :         xmlXPtrErrMemory("allocating locationset");

	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 584  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlXPtrLoc
$LN2@xmlXPtrLoc:

; 585  :     }
; 586  :     memset(ret, 0 , (size_t) sizeof(xmlLocationSet));

	xor	eax, eax
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax

; 587  :     if (val != NULL) {

	cmp	DWORD PTR _val$[ebp], 0
	je	$LN3@xmlXPtrLoc

; 588  :         ret->locTab = (xmlXPathObjectPtr *) xmlMalloc(XML_RANGESET_DEFAULT *

	mov	esi, esp
	push	40					; 00000028H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+8], eax

; 589  : 					     sizeof(xmlXPathObjectPtr));
; 590  : 	if (ret->locTab == NULL) {

	mov	eax, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN4@xmlXPtrLoc

; 591  : 	    xmlXPtrErrMemory("allocating locationset");

	push	OFFSET ??_C@_0BH@HNICMPAH@allocating?5locationset@
	call	_xmlXPtrErrMemory
	add	esp, 4

; 592  : 	    xmlFree(ret);

	mov	esi, esp
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 593  : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlXPtrLoc
$LN4@xmlXPtrLoc:

; 594  : 	}
; 595  : 	memset(ret->locTab, 0 ,

	xor	edx, edx
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [ecx+12], edx
	mov	DWORD PTR [ecx+16], edx
	mov	DWORD PTR [ecx+20], edx
	mov	DWORD PTR [ecx+24], edx
	mov	DWORD PTR [ecx+28], edx
	mov	DWORD PTR [ecx+32], edx
	mov	DWORD PTR [ecx+36], edx

; 596  : 	       XML_RANGESET_DEFAULT * (size_t) sizeof(xmlXPathObjectPtr));
; 597  :         ret->locMax = XML_RANGESET_DEFAULT;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+4], 10			; 0000000aH

; 598  : 	ret->locTab[ret->locNr++] = val;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@xmlXPtrLoc:

; 599  :     }
; 600  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlXPtrLoc:

; 601  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlXPtrLocationSetCreate ENDP
_TEXT	ENDS
END
