; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\entities.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_02KCAKIFL@lt@				; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM@				; `string'
PUBLIC	??_C@_02GHFEHLK@gt@				; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO@				; `string'
PUBLIC	??_C@_03DCBBJBAA@amp@				; `string'
PUBLIC	??_C@_01HNPIGOCE@?$CG@				; `string'
PUBLIC	??_C@_04KJFGKBNM@quot@				; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_04LBCJFAKL@apos@				; `string'
PUBLIC	??_C@_01GEODFPGF@?8@				; `string'
_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_xmlIsBaseCharGroup:BYTE:010H
COMM	_xmlIsCharGroup:BYTE:010H
COMM	_xmlIsCombiningGroup:BYTE:010H
COMM	_xmlIsDigitGroup:BYTE:010H
COMM	_xmlIsExtenderGroup:BYTE:010H
COMM	_xmlIsIdeographicGroup:BYTE:010H
COMM	_xmlIsPubidChar_tab:BYTE:0100H
COMM	_xmlParserMaxDepth:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__128F40C8_entities@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8@
CONST	SEGMENT
??_C@_01GEODFPGF@?8@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBCJFAKL@apos@
CONST	SEGMENT
??_C@_04LBCJFAKL@apos@ DB 'apos', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KJFGKBNM@quot@
CONST	SEGMENT
??_C@_04KJFGKBNM@quot@ DB 'quot', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HNPIGOCE@?$CG@
CONST	SEGMENT
??_C@_01HNPIGOCE@?$CG@ DB '&', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DCBBJBAA@amp@
CONST	SEGMENT
??_C@_03DCBBJBAA@amp@ DB 'amp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GHFEHLK@gt@
CONST	SEGMENT
??_C@_02GHFEHLK@gt@ DB 'gt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCAKIFL@lt@
CONST	SEGMENT
??_C@_02KCAKIFL@lt@ DB 'lt', 00H			; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_snprintf
PUBLIC	_xmlNewEntity
PUBLIC	_xmlAddDocEntity
PUBLIC	_xmlAddDtdEntity
PUBLIC	_xmlGetPredefinedEntity
PUBLIC	_xmlGetDocEntity
PUBLIC	_xmlGetDtdEntity
PUBLIC	_xmlGetParameterEntity
PUBLIC	_xmlEncodeEntitiesReentrant
PUBLIC	_xmlEncodeSpecialChars
PUBLIC	_xmlCreateEntitiesTable
PUBLIC	_xmlCopyEntitiesTable
PUBLIC	_xmlFreeEntitiesTable
PUBLIC	_xmlDumpEntitiesTable
PUBLIC	_xmlDumpEntityDecl
PUBLIC	_xmlEncodeAttributeEntities
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BP@DHPODGDH@xmlCreateEntity?3?5malloc?5failed@ ; `string'
PUBLIC	??_C@_0CC@DMDBCNC@xmlAddDtdEntity?3?5document?5is?5NU@ ; `string'
PUBLIC	??_C@_0DC@JLIKFHBI@xmlAddDtdEntity?3?5document?5witho@ ; `string'
PUBLIC	??_C@_0CC@PEGCDJOI@xmlAddDocEntity?3?5document?5is?5NU@ ; `string'
PUBLIC	??_C@_0DC@LNFPIBEF@xmlAddDocEntity?3?5document?5witho@ ; `string'
PUBLIC	??_C@_0CB@KNMFEFGD@xmlEncodeEntities?3?5malloc?5faile@ ; `string'
PUBLIC	??_C@_03PNLDJJMO@?9?9?$DO@			; `string'
PUBLIC	??_C@_0CD@NODHNPMI@xmlEncodeEntities?3?5input?5not?5UT@ ; `string'
PUBLIC	??_C@_0L@GJIJNDEK@ISO?98859?91@			; `string'
PUBLIC	??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@		; `string'
PUBLIC	??_C@_0CG@BLNNOKKO@xmlEncodeEntities?3?5char?5out?5of?5@ ; `string'
PUBLIC	??_C@_06EPJFDPIN@?$CG?$CDx?$CFX?$DL@		; `string'
PUBLIC	??_C@_0CC@INAAIMLK@xmlEncodeEntities?3?5realloc?5fail@ ; `string'
PUBLIC	??_C@_0CF@FLMLIOHD@xmlEncodeSpecialChars?3?5malloc?5f@ ; `string'
PUBLIC	??_C@_0CG@JAEBJCBF@xmlEncodeSpecialChars?3?5realloc?5@ ; `string'
PUBLIC	??_C@_0BO@CKONHBAN@xmlCopyEntity?3?3?5malloc?5failed@ ; `string'
PUBLIC	??_C@_06DDLNFFBN@?$CGquot?$DL@			; `string'
PUBLIC	??_C@_06MCFEAINI@?$CG?$CDx25?$DL@		; `string'
PUBLIC	??_C@_09POADHIMD@?$DM?$CBENTITY?5@		; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_02NEKEAGPN@?$DO?6@			; `string'
PUBLIC	??_C@_08GBBLECIH@?5PUBLIC?5@			; `string'
PUBLIC	??_C@_08PAGGLANP@?5SYSTEM?5@			; `string'
PUBLIC	??_C@_07CGHGCOMH@?5NDATA?5@			; `string'
PUBLIC	??_C@_0M@BFALCDCJ@?$DM?$CBENTITY?5?$CF?5@	; `string'
PUBLIC	??_C@_0DI@PPMLKPJL@xmlDumpEntitiesDecl?3?5internal?3?5@ ; `string'
EXTRN	_xmlStrdup:PROC
EXTRN	_xmlStrndup:PROC
EXTRN	_xmlStrchr:PROC
EXTRN	_xmlStrstr:PROC
EXTRN	_xmlStrEqual:PROC
EXTRN	_xmlStrlen:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_strchr:PROC
EXTRN	_xmlDictLookup:PROC
EXTRN	_xmlDictOwns:PROC
EXTRN	_xmlBufferAdd:PROC
EXTRN	_xmlBufferCCat:PROC
EXTRN	_xmlFreeNodeList:PROC
EXTRN	_xmlBufferWriteCHAR:PROC
EXTRN	_xmlBufferWriteChar:PROC
EXTRN	_xmlBufferWriteQuotedString:PROC
EXTRN	_xmlHashCreate:PROC
EXTRN	_xmlHashCreateDict:PROC
EXTRN	_xmlHashFree:PROC
EXTRN	_xmlHashAddEntry:PROC
EXTRN	_xmlHashLookup:PROC
EXTRN	_xmlHashCopy:PROC
EXTRN	_xmlHashScan:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memset:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DI@PPMLKPJL@xmlDumpEntitiesDecl?3?5internal?3?5@
CONST	SEGMENT
??_C@_0DI@PPMLKPJL@xmlDumpEntitiesDecl?3?5internal?3?5@ DB 'xmlDumpEntiti'
	DB	'esDecl: internal: unknown type entity type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BFALCDCJ@?$DM?$CBENTITY?5?$CF?5@
CONST	SEGMENT
??_C@_0M@BFALCDCJ@?$DM?$CBENTITY?5?$CF?5@ DB '<!ENTITY % ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CGHGCOMH@?5NDATA?5@
CONST	SEGMENT
??_C@_07CGHGCOMH@?5NDATA?5@ DB ' NDATA ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PAGGLANP@?5SYSTEM?5@
CONST	SEGMENT
??_C@_08PAGGLANP@?5SYSTEM?5@ DB ' SYSTEM ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBBLECIH@?5PUBLIC?5@
CONST	SEGMENT
??_C@_08GBBLECIH@?5PUBLIC?5@ DB ' PUBLIC ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NEKEAGPN@?$DO?6@
CONST	SEGMENT
??_C@_02NEKEAGPN@?$DO?6@ DB '>', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09POADHIMD@?$DM?$CBENTITY?5@
CONST	SEGMENT
??_C@_09POADHIMD@?$DM?$CBENTITY?5@ DB '<!ENTITY ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MCFEAINI@?$CG?$CDx25?$DL@
CONST	SEGMENT
??_C@_06MCFEAINI@?$CG?$CDx25?$DL@ DB '&#x25;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDLNFFBN@?$CGquot?$DL@
CONST	SEGMENT
??_C@_06DDLNFFBN@?$CGquot?$DL@ DB '&quot;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CKONHBAN@xmlCopyEntity?3?3?5malloc?5failed@
CONST	SEGMENT
??_C@_0BO@CKONHBAN@xmlCopyEntity?3?3?5malloc?5failed@ DB 'xmlCopyEntity::'
	DB	' malloc failed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JAEBJCBF@xmlEncodeSpecialChars?3?5realloc?5@
CONST	SEGMENT
??_C@_0CG@JAEBJCBF@xmlEncodeSpecialChars?3?5realloc?5@ DB 'xmlEncodeSpeci'
	DB	'alChars: realloc failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FLMLIOHD@xmlEncodeSpecialChars?3?5malloc?5f@
CONST	SEGMENT
??_C@_0CF@FLMLIOHD@xmlEncodeSpecialChars?3?5malloc?5f@ DB 'xmlEncodeSpeci'
	DB	'alChars: malloc failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@INAAIMLK@xmlEncodeEntities?3?5realloc?5fail@
CONST	SEGMENT
??_C@_0CC@INAAIMLK@xmlEncodeEntities?3?5realloc?5fail@ DB 'xmlEncodeEntit'
	DB	'ies: realloc failed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EPJFDPIN@?$CG?$CDx?$CFX?$DL@
CONST	SEGMENT
??_C@_06EPJFDPIN@?$CG?$CDx?$CFX?$DL@ DB '&#x%X;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BLNNOKKO@xmlEncodeEntities?3?5char?5out?5of?5@
CONST	SEGMENT
??_C@_0CG@BLNNOKKO@xmlEncodeEntities?3?5char?5out?5of?5@ DB 'xmlEncodeEnt'
	DB	'ities: char out of range', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@
CONST	SEGMENT
??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@ DB '&#%d;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GJIJNDEK@ISO?98859?91@
CONST	SEGMENT
??_C@_0L@GJIJNDEK@ISO?98859?91@ DB 'ISO-8859-1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NODHNPMI@xmlEncodeEntities?3?5input?5not?5UT@
CONST	SEGMENT
??_C@_0CD@NODHNPMI@xmlEncodeEntities?3?5input?5not?5UT@ DB 'xmlEncodeEnti'
	DB	'ties: input not UTF-8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PNLDJJMO@?9?9?$DO@
CONST	SEGMENT
??_C@_03PNLDJJMO@?9?9?$DO@ DB '-->', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KNMFEFGD@xmlEncodeEntities?3?5malloc?5faile@
CONST	SEGMENT
??_C@_0CB@KNMFEFGD@xmlEncodeEntities?3?5malloc?5faile@ DB 'xmlEncodeEntit'
	DB	'ies: malloc failed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LNFPIBEF@xmlAddDocEntity?3?5document?5witho@
CONST	SEGMENT
??_C@_0DC@LNFPIBEF@xmlAddDocEntity?3?5document?5witho@ DB 'xmlAddDocEntit'
	DB	'y: document without internal subset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PEGCDJOI@xmlAddDocEntity?3?5document?5is?5NU@
CONST	SEGMENT
??_C@_0CC@PEGCDJOI@xmlAddDocEntity?3?5document?5is?5NU@ DB 'xmlAddDocEnti'
	DB	'ty: document is NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@JLIKFHBI@xmlAddDtdEntity?3?5document?5witho@
CONST	SEGMENT
??_C@_0DC@JLIKFHBI@xmlAddDtdEntity?3?5document?5witho@ DB 'xmlAddDtdEntit'
	DB	'y: document without external subset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DMDBCNC@xmlAddDtdEntity?3?5document?5is?5NU@
CONST	SEGMENT
??_C@_0CC@DMDBCNC@xmlAddDtdEntity?3?5document?5is?5NU@ DB 'xmlAddDtdEntit'
	DB	'y: document is NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DHPODGDH@xmlCreateEntity?3?5malloc?5failed@
CONST	SEGMENT
??_C@_0BP@DHPODGDH@xmlCreateEntity?3?5malloc?5failed@ DB 'xmlCreateEntity'
	DB	': malloc failed', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlEntityLt DD	00H
	DD	011H
	DD	FLAT:??_C@_02KCAKIFL@lt@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_01MNNFJEPP@?$DM@
	DD	FLAT:??_C@_01MNNFJEPP@?$DM@
	DD	01H
	DD	06H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	ORG $+4
_xmlEntityGt DD	00H
	DD	011H
	DD	FLAT:??_C@_02GHFEHLK@gt@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_01PPODPGHN@?$DO@
	DD	FLAT:??_C@_01PPODPGHN@?$DO@
	DD	01H
	DD	06H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	ORG $+4
_xmlEntityAmp DD 00H
	DD	011H
	DD	FLAT:??_C@_03DCBBJBAA@amp@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_01HNPIGOCE@?$CG@
	DD	FLAT:??_C@_01HNPIGOCE@?$CG@
	DD	01H
	DD	06H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	ORG $+4
_xmlEntityQuot DD 00H
	DD	011H
	DD	FLAT:??_C@_04KJFGKBNM@quot@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_01BJJEKLCA@?$CC@
	DD	FLAT:??_C@_01BJJEKLCA@?$CC@
	DD	01H
	DD	06H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	ORG $+4
_xmlEntityApos DD 00H
	DD	011H
	DD	FLAT:??_C@_04LBCJFAKL@apos@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_01GEODFPGF@?8@
	DD	FLAT:??_C@_01GEODFPGF@?8@
	DD	01H
	DD	06H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlDumpEntityDeclScan
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_buf$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlDumpEntityDeclScan PROC				; COMDAT

; 1094 :                       const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 1095 :     xmlDumpEntityDecl((xmlBufferPtr) buf, (xmlEntityPtr) ent);

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlDumpEntityDecl
	add	esp, 8

; 1096 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDumpEntityDeclScan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlDumpEntityContent
_TEXT	SEGMENT
_cur$1 = -8						; size = 4
_base$2 = -4						; size = 4
_buf$ = 8						; size = 4
_content$ = 12						; size = 4
_xmlDumpEntityContent PROC				; COMDAT

; 967  : xmlDumpEntityContent(xmlBufferPtr buf, const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 968  :     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return;

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax+12], 2
	jne	SHORT $LN4@xmlDumpEnt
	jmp	$LN1@xmlDumpEnt
$LN4@xmlDumpEnt:

; 969  :     if (xmlStrchr(content, '%')) {

	push	37					; 00000025H
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	call	_xmlStrchr
	add	esp, 8
	test	eax, eax
	je	$LN5@xmlDumpEnt

; 970  :         const xmlChar * base, *cur;
; 971  : 
; 972  : 	xmlBufferCCat(buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferCCat
	add	esp, 8

; 973  : 	base = cur = content;

	mov	eax, DWORD PTR _content$[ebp]
	mov	DWORD PTR _cur$1[ebp], eax
	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR _base$2[ebp], ecx
$LN2@xmlDumpEnt:

; 974  : 	while (*cur != 0) {

	mov	edx, DWORD PTR _cur$1[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@xmlDumpEnt

; 975  : 	    if (*cur == '"') {

	mov	ecx, DWORD PTR _cur$1[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN7@xmlDumpEnt

; 976  : 		if (base != cur)

	mov	eax, DWORD PTR _base$2[ebp]
	cmp	eax, DWORD PTR _cur$1[ebp]
	je	SHORT $LN9@xmlDumpEnt

; 977  : 		    xmlBufferAdd(buf, base, cur - base);

	mov	ecx, DWORD PTR _cur$1[ebp]
	sub	ecx, DWORD PTR _base$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$2[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferAdd
	add	esp, 12					; 0000000cH
$LN9@xmlDumpEnt:

; 978  : 		xmlBufferAdd(buf, BAD_CAST "&quot;", 6);

	push	6
	push	OFFSET ??_C@_06DDLNFFBN@?$CGquot?$DL@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferAdd
	add	esp, 12					; 0000000cH

; 979  : 		cur++;

	mov	edx, DWORD PTR _cur$1[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$1[ebp], edx

; 980  : 		base = cur;

	mov	eax, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR _base$2[ebp], eax
	jmp	SHORT $LN8@xmlDumpEnt
$LN7@xmlDumpEnt:

; 981  : 	    } else if (*cur == '%') {

	mov	ecx, DWORD PTR _cur$1[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	SHORT $LN10@xmlDumpEnt

; 982  : 		if (base != cur)

	mov	eax, DWORD PTR _base$2[ebp]
	cmp	eax, DWORD PTR _cur$1[ebp]
	je	SHORT $LN12@xmlDumpEnt

; 983  : 		    xmlBufferAdd(buf, base, cur - base);

	mov	ecx, DWORD PTR _cur$1[ebp]
	sub	ecx, DWORD PTR _base$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$2[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferAdd
	add	esp, 12					; 0000000cH
$LN12@xmlDumpEnt:

; 984  : 		xmlBufferAdd(buf, BAD_CAST "&#x25;", 6);

	push	6
	push	OFFSET ??_C@_06MCFEAINI@?$CG?$CDx25?$DL@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferAdd
	add	esp, 12					; 0000000cH

; 985  : 		cur++;

	mov	edx, DWORD PTR _cur$1[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$1[ebp], edx

; 986  : 		base = cur;

	mov	eax, DWORD PTR _cur$1[ebp]
	mov	DWORD PTR _base$2[ebp], eax

; 987  : 	    } else {

	jmp	SHORT $LN8@xmlDumpEnt
$LN10@xmlDumpEnt:

; 988  : 		cur++;

	mov	ecx, DWORD PTR _cur$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$1[ebp], ecx
$LN8@xmlDumpEnt:

; 989  : 	    }
; 990  : 	}

	jmp	$LN2@xmlDumpEnt
$LN3@xmlDumpEnt:

; 991  : 	if (base != cur)

	mov	edx, DWORD PTR _base$2[ebp]
	cmp	edx, DWORD PTR _cur$1[ebp]
	je	SHORT $LN13@xmlDumpEnt

; 992  : 	    xmlBufferAdd(buf, base, cur - base);

	mov	eax, DWORD PTR _cur$1[ebp]
	sub	eax, DWORD PTR _base$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _base$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferAdd
	add	esp, 12					; 0000000cH
$LN13@xmlDumpEnt:

; 993  : 	xmlBufferCCat(buf, "\"");

	push	OFFSET ??_C@_01BJJEKLCA@?$CC@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferCCat
	add	esp, 8

; 994  :     } else {

	jmp	SHORT $LN1@xmlDumpEnt
$LN5@xmlDumpEnt:

; 995  :         xmlBufferWriteQuotedString(buf, content);

	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteQuotedString
	add	esp, 8
$LN1@xmlDumpEnt:

; 996  :     }
; 997  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDumpEntityContent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlCopyEntity
_TEXT	SEGMENT
_cur$ = -8						; size = 4
_ent$ = -4						; size = 4
_payload$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlCopyEntity PROC					; COMDAT

; 914  : xmlCopyEntity(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 915  :     xmlEntityPtr ent = (xmlEntityPtr) payload;

	mov	eax, DWORD PTR _payload$[ebp]
	mov	DWORD PTR _ent$[ebp], eax

; 916  :     xmlEntityPtr cur;
; 917  : 
; 918  :     cur = (xmlEntityPtr) xmlMalloc(sizeof(xmlEntity));

	mov	esi, esp
	push	76					; 0000004cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cur$[ebp], eax

; 919  :     if (cur == NULL) {

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN2@xmlCopyEnt

; 920  :         xmlEntitiesErrMemory("xmlCopyEntity:: malloc failed");

	push	OFFSET ??_C@_0BO@CKONHBAN@xmlCopyEntity?3?3?5malloc?5failed@
	call	_xmlEntitiesErrMemory
	add	esp, 4

; 921  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCopyEnt
$LN2@xmlCopyEnt:

; 922  :     }
; 923  :     memset(cur, 0, sizeof(xmlEntity));

	push	76					; 0000004cH
	push	0
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 924  :     cur->type = XML_ENTITY_DECL;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+4], 17			; 00000011H

; 925  : 
; 926  :     cur->etype = ent->etype;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx

; 927  :     if (ent->name != NULL)

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@xmlCopyEnt

; 928  : 	cur->name = xmlStrdup(ent->name);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN3@xmlCopyEnt:

; 929  :     if (ent->ExternalID != NULL)

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN4@xmlCopyEnt

; 930  : 	cur->ExternalID = xmlStrdup(ent->ExternalID);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+52], eax
$LN4@xmlCopyEnt:

; 931  :     if (ent->SystemID != NULL)

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN5@xmlCopyEnt

; 932  : 	cur->SystemID = xmlStrdup(ent->SystemID);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+56], eax
$LN5@xmlCopyEnt:

; 933  :     if (ent->content != NULL)

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN6@xmlCopyEnt

; 934  : 	cur->content = xmlStrdup(ent->content);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN6@xmlCopyEnt:

; 935  :     if (ent->orig != NULL)

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN7@xmlCopyEnt

; 936  : 	cur->orig = xmlStrdup(ent->orig);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN7@xmlCopyEnt:

; 937  :     if (ent->URI != NULL)

	mov	edx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $LN8@xmlCopyEnt

; 938  : 	cur->URI = xmlStrdup(ent->URI);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+64], eax
$LN8@xmlCopyEnt:

; 939  :     return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
$LN1@xmlCopyEnt:

; 940  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCopyEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlFreeEntityWrapper
_TEXT	SEGMENT
_entity$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlFreeEntityWrapper PROC				; COMDAT

; 888  : xmlFreeEntityWrapper(void *entity, const xmlChar *name ATTRIBUTE_UNUSED) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 889  :     if (entity != NULL)

	cmp	DWORD PTR _entity$[ebp], 0
	je	SHORT $LN1@xmlFreeEnt

; 890  : 	xmlFreeEntity((xmlEntityPtr) entity);

	mov	eax, DWORD PTR _entity$[ebp]
	push	eax
	call	_xmlFreeEntity
	add	esp, 4
$LN1@xmlFreeEnt:

; 891  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFreeEntityWrapper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlEncodeEntitiesInternal
_TEXT	SEGMENT
tv307 = -124						; size = 4
tv309 = -120						; size = 4
tv308 = -116						; size = 4
tv68 = -112						; size = 4
_ptr$1 = -108						; size = 4
_buf$2 = -100						; size = 11
_l$3 = -84						; size = 4
_val$4 = -80						; size = 4
_ptr$5 = -76						; size = 4
_buf$6 = -68						; size = 11
_new_size$7 = -52					; size = 4
_tmp$8 = -48						; size = 4
_new_size$9 = -44					; size = 4
_tmp$10 = -40						; size = 4
_end$11 = -36						; size = 4
_new_size$12 = -32					; size = 4
_tmp$13 = -28						; size = 4
_indx$14 = -24						; size = 4
_html$ = -20						; size = 4
_buffer_size$ = -16					; size = 4
_out$ = -12						; size = 4
_buffer$ = -8						; size = 4
_cur$ = -4						; size = 4
_doc$ = 8						; size = 4
_input$ = 12						; size = 4
_attr$ = 16						; size = 4
_xmlEncodeEntitiesInternal PROC				; COMDAT

; 561  : xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input, int attr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 31					; 0000001fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 562  :     const xmlChar *cur = input;

	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 563  :     xmlChar *buffer = NULL;

	mov	DWORD PTR _buffer$[ebp], 0

; 564  :     xmlChar *out = NULL;

	mov	DWORD PTR _out$[ebp], 0

; 565  :     size_t buffer_size = 0;

	mov	DWORD PTR _buffer_size$[ebp], 0

; 566  :     int html = 0;

	mov	DWORD PTR _html$[ebp], 0

; 567  : 
; 568  :     if (input == NULL) return(NULL);

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN16@xmlEncodeE
	xor	eax, eax
	jmp	$LN1@xmlEncodeE
$LN16@xmlEncodeE:

; 569  :     if (doc != NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN17@xmlEncodeE

; 570  :         html = (doc->type == XML_HTML_DOCUMENT_NODE);

	mov	ecx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	jne	SHORT $LN61@xmlEncodeE
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN62@xmlEncodeE
$LN61@xmlEncodeE:
	mov	DWORD PTR tv68[ebp], 0
$LN62@xmlEncodeE:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _html$[ebp], edx
$LN17@xmlEncodeE:

; 571  : 
; 572  :     /*
; 573  :      * allocate an translation buffer.
; 574  :      */
; 575  :     buffer_size = 1000;

	mov	DWORD PTR _buffer_size$[ebp], 1000	; 000003e8H

; 576  :     buffer = (xmlChar *) xmlMalloc(buffer_size * sizeof(xmlChar));

	mov	esi, esp
	mov	eax, DWORD PTR _buffer_size$[ebp]
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buffer$[ebp], eax

; 577  :     if (buffer == NULL) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN18@xmlEncodeE

; 578  :         xmlEntitiesErrMemory("xmlEncodeEntities: malloc failed");

	push	OFFSET ??_C@_0CB@KNMFEFGD@xmlEncodeEntities?3?5malloc?5faile@
	call	_xmlEntitiesErrMemory
	add	esp, 4

; 579  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlEncodeE
$LN18@xmlEncodeE:

; 580  :     }
; 581  :     out = buffer;

	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _out$[ebp], ecx
$LN2@xmlEncodeE:

; 582  : 
; 583  :     while (*cur != '\0') {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@xmlEncodeE

; 584  :         size_t indx = out - buffer;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _indx$14[ebp], ecx

; 585  :         if (indx + 100 > buffer_size) {

	mov	edx, DWORD PTR _indx$14[ebp]
	add	edx, 100				; 00000064H
	cmp	edx, DWORD PTR _buffer_size$[ebp]
	jbe	SHORT $LN19@xmlEncodeE

; 586  : 
; 587  : 	    growBufferReentrant();

	mov	eax, DWORD PTR _buffer_size$[ebp]
	shl	eax, 1
	mov	DWORD PTR _new_size$12[ebp], eax
	mov	ecx, DWORD PTR _new_size$12[ebp]
	cmp	ecx, DWORD PTR _buffer_size$[ebp]
	jae	SHORT $LN20@xmlEncodeE
	jmp	$mem_error$82
$LN20@xmlEncodeE:
	mov	esi, esp
	mov	edx, DWORD PTR _new_size$12[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$13[ebp], eax
	cmp	DWORD PTR _tmp$13[ebp], 0
	jne	SHORT $LN21@xmlEncodeE
	jmp	$mem_error$82
$LN21@xmlEncodeE:
	mov	ecx, DWORD PTR _tmp$13[ebp]
	mov	DWORD PTR _buffer$[ebp], ecx
	mov	edx, DWORD PTR _new_size$12[ebp]
	mov	DWORD PTR _buffer_size$[ebp], edx

; 588  : 	    out = &buffer[indx];

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _indx$14[ebp]
	mov	DWORD PTR _out$[ebp], eax
$LN19@xmlEncodeE:

; 589  : 	}
; 590  : 
; 591  : 	/*
; 592  : 	 * By default one have to encode at least '<', '>', '"' and '&' !
; 593  : 	 */
; 594  : 	if (*cur == '<') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 60					; 0000003cH
	jne	$LN22@xmlEncodeE

; 595  : 	    const xmlChar *end;
; 596  : 
; 597  : 	    /*
; 598  : 	     * Special handling of server side include in HTML attributes
; 599  : 	     */
; 600  : 	    if (html && attr &&
; 601  : 	        (cur[1] == '!') && (cur[2] == '-') && (cur[3] == '-') &&

	cmp	DWORD PTR _html$[ebp], 0
	je	$LN24@xmlEncodeE
	cmp	DWORD PTR _attr$[ebp], 0
	je	$LN24@xmlEncodeE
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 33					; 00000021H
	jne	$LN24@xmlEncodeE
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 45					; 0000002dH
	jne	$LN24@xmlEncodeE
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	jne	$LN24@xmlEncodeE
	push	OFFSET ??_C@_03PNLDJJMO@?9?9?$DO@
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlStrstr
	add	esp, 8
	mov	DWORD PTR _end$11[ebp], eax
	cmp	DWORD PTR _end$11[ebp], 0
	je	$LN24@xmlEncodeE
$LN4@xmlEncodeE:

; 602  : 	        ((end = xmlStrstr(cur, BAD_CAST "-->")) != NULL)) {
; 603  : 	        while (cur != end) {

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	edx, DWORD PTR _end$11[ebp]
	je	$LN5@xmlEncodeE

; 604  : 		    *out++ = *cur++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 605  : 		    indx = out - buffer;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _indx$14[ebp], edx

; 606  : 		    if (indx + 100 > buffer_size) {

	mov	eax, DWORD PTR _indx$14[ebp]
	add	eax, 100				; 00000064H
	cmp	eax, DWORD PTR _buffer_size$[ebp]
	jbe	SHORT $LN25@xmlEncodeE

; 607  : 			growBufferReentrant();

	mov	ecx, DWORD PTR _buffer_size$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _new_size$9[ebp], ecx
	mov	edx, DWORD PTR _new_size$9[ebp]
	cmp	edx, DWORD PTR _buffer_size$[ebp]
	jae	SHORT $LN26@xmlEncodeE
	jmp	$mem_error$82
$LN26@xmlEncodeE:
	mov	esi, esp
	mov	eax, DWORD PTR _new_size$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$10[ebp], eax
	cmp	DWORD PTR _tmp$10[ebp], 0
	jne	SHORT $LN27@xmlEncodeE
	jmp	$mem_error$82
$LN27@xmlEncodeE:
	mov	edx, DWORD PTR _tmp$10[ebp]
	mov	DWORD PTR _buffer$[ebp], edx
	mov	eax, DWORD PTR _new_size$9[ebp]
	mov	DWORD PTR _buffer_size$[ebp], eax

; 608  : 			out = &buffer[indx];

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _indx$14[ebp]
	mov	DWORD PTR _out$[ebp], ecx
$LN25@xmlEncodeE:

; 609  : 		    }
; 610  : 		}

	jmp	$LN4@xmlEncodeE
$LN5@xmlEncodeE:

; 611  : 		*out++ = *cur++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 612  : 		*out++ = *cur++;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 613  : 		*out++ = *cur++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 614  : 		continue;

	jmp	$LN2@xmlEncodeE
$LN24@xmlEncodeE:

; 615  : 	    }
; 616  : 	    *out++ = '&';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 617  : 	    *out++ = 'l';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 108			; 0000006cH
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 618  : 	    *out++ = 't';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 116			; 00000074H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 619  : 	    *out++ = ';';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	jmp	$LN23@xmlEncodeE
$LN22@xmlEncodeE:

; 620  : 	} else if (*cur == '>') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	jne	SHORT $LN28@xmlEncodeE

; 621  : 	    *out++ = '&';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 622  : 	    *out++ = 'g';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 103			; 00000067H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 623  : 	    *out++ = 't';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 116			; 00000074H
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 624  : 	    *out++ = ';';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 59			; 0000003bH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	jmp	$LN23@xmlEncodeE
$LN28@xmlEncodeE:

; 625  : 	} else if (*cur == '&') {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 38					; 00000026H
	jne	$LN30@xmlEncodeE

; 626  : 	    /*
; 627  : 	     * Special handling of &{...} construct from HTML 4, see
; 628  : 	     * http://www.w3.org/TR/html401/appendix/notes.html#h-B.7.1
; 629  : 	     */
; 630  : 	    if (html && attr && (cur[1] == '{') &&

	cmp	DWORD PTR _html$[ebp], 0
	je	$LN32@xmlEncodeE
	cmp	DWORD PTR _attr$[ebp], 0
	je	$LN32@xmlEncodeE
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 123				; 0000007bH
	jne	$LN32@xmlEncodeE
	push	125					; 0000007dH
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	$LN32@xmlEncodeE
$LN6@xmlEncodeE:

; 631  : 	        (strchr((const char *) cur, '}'))) {
; 632  : 	        while (*cur != '}') {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 125				; 0000007dH
	je	$LN7@xmlEncodeE

; 633  : 		    *out++ = *cur++;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, 1
	mov	DWORD PTR _cur$[ebp], edx

; 634  : 		    indx = out - buffer;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _indx$14[ebp], eax

; 635  : 		    if (indx + 100 > buffer_size) {

	mov	ecx, DWORD PTR _indx$14[ebp]
	add	ecx, 100				; 00000064H
	cmp	ecx, DWORD PTR _buffer_size$[ebp]
	jbe	SHORT $LN33@xmlEncodeE

; 636  : 			growBufferReentrant();

	mov	edx, DWORD PTR _buffer_size$[ebp]
	shl	edx, 1
	mov	DWORD PTR _new_size$7[ebp], edx
	mov	eax, DWORD PTR _new_size$7[ebp]
	cmp	eax, DWORD PTR _buffer_size$[ebp]
	jae	SHORT $LN34@xmlEncodeE
	jmp	$mem_error$82
$LN34@xmlEncodeE:
	mov	esi, esp
	mov	ecx, DWORD PTR _new_size$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$8[ebp], eax
	cmp	DWORD PTR _tmp$8[ebp], 0
	jne	SHORT $LN35@xmlEncodeE
	jmp	$mem_error$82
$LN35@xmlEncodeE:
	mov	eax, DWORD PTR _tmp$8[ebp]
	mov	DWORD PTR _buffer$[ebp], eax
	mov	ecx, DWORD PTR _new_size$7[ebp]
	mov	DWORD PTR _buffer_size$[ebp], ecx

; 637  : 			out = &buffer[indx];

	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _indx$14[ebp]
	mov	DWORD PTR _out$[ebp], edx
$LN33@xmlEncodeE:

; 638  : 		    }
; 639  : 		}

	jmp	$LN6@xmlEncodeE
$LN7@xmlEncodeE:

; 640  : 		*out++ = *cur++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 641  : 		continue;

	jmp	$LN2@xmlEncodeE
$LN32@xmlEncodeE:

; 642  : 	    }
; 643  : 	    *out++ = '&';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 644  : 	    *out++ = 'a';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 97			; 00000061H
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 645  : 	    *out++ = 'm';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 109			; 0000006dH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 646  : 	    *out++ = 'p';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 112			; 00000070H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 647  : 	    *out++ = ';';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 648  : 	} else if (((*cur >= 0x20) && (*cur < 0x80)) ||

	jmp	$LN23@xmlEncodeE
$LN30@xmlEncodeE:

; 649  : 	    (*cur == '\n') || (*cur == '\t') || ((html) && (*cur == '\r'))) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN39@xmlEncodeE
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 128				; 00000080H
	jl	SHORT $LN38@xmlEncodeE
$LN39@xmlEncodeE:
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN38@xmlEncodeE
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	je	SHORT $LN38@xmlEncodeE
	cmp	DWORD PTR _html$[ebp], 0
	je	SHORT $LN36@xmlEncodeE
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN36@xmlEncodeE
$LN38@xmlEncodeE:

; 650  : 	    /*
; 651  : 	     * default case, just copy !
; 652  : 	     */
; 653  : 	    *out++ = *cur;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	jmp	$LN23@xmlEncodeE
$LN36@xmlEncodeE:

; 654  : 	} else if (*cur >= 0x80) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 128				; 00000080H
	jl	$LN40@xmlEncodeE

; 655  : 	    if (((doc != NULL) && (doc->encoding != NULL)) || (html)) {

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN45@xmlEncodeE
	mov	ecx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	jne	SHORT $LN44@xmlEncodeE
$LN45@xmlEncodeE:
	cmp	DWORD PTR _html$[ebp], 0
	je	SHORT $LN42@xmlEncodeE
$LN44@xmlEncodeE:

; 656  : 		/*
; 657  : 		 * Bjørn Reese <br@sseusa.com> provided the patch
; 658  : 	        xmlChar xc;
; 659  : 	        xc = (*cur & 0x3F) << 6;
; 660  : 	        if (cur[1] != 0) {
; 661  : 		    xc += *(++cur) & 0x3F;
; 662  : 		    *out++ = xc;
; 663  : 	        } else
; 664  : 		 */
; 665  : 		*out++ = *cur;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 666  : 	    } else {

	jmp	$LN43@xmlEncodeE
$LN42@xmlEncodeE:

; 667  : 		/*
; 668  : 		 * We assume we have UTF-8 input.
; 669  : 		 */
; 670  : 		char buf[11], *ptr;
; 671  : 		int val = 0, l = 1;

	mov	DWORD PTR _val$4[ebp], 0
	mov	DWORD PTR _l$3[ebp], 1

; 672  : 
; 673  : 		if (*cur < 0xC0) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 192				; 000000c0H
	jge	$LN46@xmlEncodeE

; 674  : 		    xmlEntitiesErr(XML_CHECK_NOT_UTF8,

	push	OFFSET ??_C@_0CD@NODHNPMI@xmlEncodeEntities?3?5input?5not?5UT@
	push	5032					; 000013a8H
	call	_xmlEntitiesErr
	add	esp, 8

; 675  : 			    "xmlEncodeEntities: input not UTF-8");
; 676  : 		    if (doc != NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN48@xmlEncodeE

; 677  : 			doc->encoding = xmlStrdup(BAD_CAST "ISO-8859-1");

	push	OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [edx+60], eax
$LN48@xmlEncodeE:

; 678  : 		    snprintf(buf, sizeof(buf), "&#%d;", *cur);

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	push	OFFSET ??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@
	push	11					; 0000000bH
	lea	edx, DWORD PTR _buf$6[ebp]
	push	edx
	call	_snprintf
	add	esp, 16					; 00000010H

; 679  : 		    buf[sizeof(buf) - 1] = 0;

	mov	eax, 1
	imul	ecx, eax, 10
	mov	BYTE PTR _buf$6[ebp+ecx], 0

; 680  : 		    ptr = buf;

	lea	edx, DWORD PTR _buf$6[ebp]
	mov	DWORD PTR _ptr$5[ebp], edx
$LN8@xmlEncodeE:

; 681  : 		    while (*ptr != 0) *out++ = *ptr++;

	mov	eax, DWORD PTR _ptr$5[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN9@xmlEncodeE
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _ptr$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _ptr$5[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$5[ebp], eax
	jmp	SHORT $LN8@xmlEncodeE
$LN9@xmlEncodeE:

; 682  : 		    cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 683  : 		    continue;

	jmp	$LN2@xmlEncodeE
	jmp	$LN47@xmlEncodeE
$LN46@xmlEncodeE:

; 684  : 		} else if (*cur < 0xE0) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 224				; 000000e0H
	jge	SHORT $LN49@xmlEncodeE

; 685  :                     val = (cur[0]) & 0x1F;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _val$4[ebp], ecx

; 686  : 		    val <<= 6;

	mov	edx, DWORD PTR _val$4[ebp]
	shl	edx, 6
	mov	DWORD PTR _val$4[ebp], edx

; 687  : 		    val |= (cur[1]) & 0x3F;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	or	edx, DWORD PTR _val$4[ebp]
	mov	DWORD PTR _val$4[ebp], edx

; 688  : 		    l = 2;

	mov	DWORD PTR _l$3[ebp], 2
	jmp	$LN47@xmlEncodeE
$LN49@xmlEncodeE:

; 689  : 		} else if (*cur < 0xF0) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 240				; 000000f0H
	jge	SHORT $LN51@xmlEncodeE

; 690  :                     val = (cur[0]) & 0x0F;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _val$4[ebp], edx

; 691  : 		    val <<= 6;

	mov	eax, DWORD PTR _val$4[ebp]
	shl	eax, 6
	mov	DWORD PTR _val$4[ebp], eax

; 692  : 		    val |= (cur[1]) & 0x3F;

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _val$4[ebp]
	mov	DWORD PTR _val$4[ebp], eax

; 693  : 		    val <<= 6;

	mov	ecx, DWORD PTR _val$4[ebp]
	shl	ecx, 6
	mov	DWORD PTR _val$4[ebp], ecx

; 694  : 		    val |= (cur[2]) & 0x3F;

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _val$4[ebp]
	mov	DWORD PTR _val$4[ebp], ecx

; 695  : 		    l = 3;

	mov	DWORD PTR _l$3[ebp], 3
	jmp	$LN47@xmlEncodeE
$LN51@xmlEncodeE:

; 696  : 		} else if (*cur < 0xF8) {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 248				; 000000f8H
	jge	SHORT $LN47@xmlEncodeE

; 697  :                     val = (cur[0]) & 0x07;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 7
	mov	DWORD PTR _val$4[ebp], ecx

; 698  : 		    val <<= 6;

	mov	edx, DWORD PTR _val$4[ebp]
	shl	edx, 6
	mov	DWORD PTR _val$4[ebp], edx

; 699  : 		    val |= (cur[1]) & 0x3F;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	or	edx, DWORD PTR _val$4[ebp]
	mov	DWORD PTR _val$4[ebp], edx

; 700  : 		    val <<= 6;

	mov	eax, DWORD PTR _val$4[ebp]
	shl	eax, 6
	mov	DWORD PTR _val$4[ebp], eax

; 701  : 		    val |= (cur[2]) & 0x3F;

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _val$4[ebp]
	mov	DWORD PTR _val$4[ebp], eax

; 702  : 		    val <<= 6;

	mov	ecx, DWORD PTR _val$4[ebp]
	shl	ecx, 6
	mov	DWORD PTR _val$4[ebp], ecx

; 703  : 		    val |= (cur[3]) & 0x3F;

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	or	edx, DWORD PTR _val$4[ebp]
	mov	DWORD PTR _val$4[ebp], edx

; 704  : 		    l = 4;

	mov	DWORD PTR _l$3[ebp], 4
$LN47@xmlEncodeE:

; 705  : 		}
; 706  : 		if ((l == 1) || (!IS_CHAR(val))) {

	cmp	DWORD PTR _l$3[ebp], 1
	je	$LN55@xmlEncodeE
	cmp	DWORD PTR _val$4[ebp], 256		; 00000100H
	jge	SHORT $LN71@xmlEncodeE
	cmp	DWORD PTR _val$4[ebp], 9
	jl	SHORT $LN63@xmlEncodeE
	cmp	DWORD PTR _val$4[ebp], 10		; 0000000aH
	jle	SHORT $LN64@xmlEncodeE
$LN63@xmlEncodeE:
	cmp	DWORD PTR _val$4[ebp], 13		; 0000000dH
	je	SHORT $LN64@xmlEncodeE
	cmp	DWORD PTR _val$4[ebp], 32		; 00000020H
	jge	SHORT $LN64@xmlEncodeE
	mov	DWORD PTR tv308[ebp], 0
	jmp	SHORT $LN70@xmlEncodeE
$LN64@xmlEncodeE:
	mov	DWORD PTR tv308[ebp], 1
$LN70@xmlEncodeE:
	mov	eax, DWORD PTR tv308[ebp]
	mov	DWORD PTR tv309[ebp], eax
	jmp	SHORT $LN72@xmlEncodeE
$LN71@xmlEncodeE:
	cmp	DWORD PTR _val$4[ebp], 256		; 00000100H
	jl	SHORT $LN65@xmlEncodeE
	cmp	DWORD PTR _val$4[ebp], 55295		; 0000d7ffH
	jle	SHORT $LN67@xmlEncodeE
$LN65@xmlEncodeE:
	cmp	DWORD PTR _val$4[ebp], 57344		; 0000e000H
	jl	SHORT $LN66@xmlEncodeE
	cmp	DWORD PTR _val$4[ebp], 65533		; 0000fffdH
	jle	SHORT $LN67@xmlEncodeE
$LN66@xmlEncodeE:
	cmp	DWORD PTR _val$4[ebp], 65536		; 00010000H
	jl	SHORT $LN68@xmlEncodeE
	cmp	DWORD PTR _val$4[ebp], 1114111		; 0010ffffH
	jle	SHORT $LN67@xmlEncodeE
$LN68@xmlEncodeE:
	mov	DWORD PTR tv307[ebp], 0
	jmp	SHORT $LN69@xmlEncodeE
$LN67@xmlEncodeE:
	mov	DWORD PTR tv307[ebp], 1
$LN69@xmlEncodeE:
	mov	ecx, DWORD PTR tv307[ebp]
	mov	DWORD PTR tv309[ebp], ecx
$LN72@xmlEncodeE:
	cmp	DWORD PTR tv309[ebp], 0
	jne	$LN54@xmlEncodeE
$LN55@xmlEncodeE:

; 707  : 		    xmlEntitiesErr(XML_ERR_INVALID_CHAR,

	push	OFFSET ??_C@_0CG@BLNNOKKO@xmlEncodeEntities?3?5char?5out?5of?5@
	push	9
	call	_xmlEntitiesErr
	add	esp, 8

; 708  : 			"xmlEncodeEntities: char out of range\n");
; 709  : 		    if (doc != NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN56@xmlEncodeE

; 710  : 			doc->encoding = xmlStrdup(BAD_CAST "ISO-8859-1");

	push	OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@
	call	_xmlStrdup
	add	esp, 4
	mov	edx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [edx+60], eax
$LN56@xmlEncodeE:

; 711  : 		    snprintf(buf, sizeof(buf), "&#%d;", *cur);

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	push	OFFSET ??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@
	push	11					; 0000000bH
	lea	edx, DWORD PTR _buf$6[ebp]
	push	edx
	call	_snprintf
	add	esp, 16					; 00000010H

; 712  : 		    buf[sizeof(buf) - 1] = 0;

	mov	eax, 1
	imul	ecx, eax, 10
	mov	BYTE PTR _buf$6[ebp+ecx], 0

; 713  : 		    ptr = buf;

	lea	edx, DWORD PTR _buf$6[ebp]
	mov	DWORD PTR _ptr$5[ebp], edx
$LN10@xmlEncodeE:

; 714  : 		    while (*ptr != 0) *out++ = *ptr++;

	mov	eax, DWORD PTR _ptr$5[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN11@xmlEncodeE
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _ptr$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _ptr$5[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$5[ebp], eax
	jmp	SHORT $LN10@xmlEncodeE
$LN11@xmlEncodeE:

; 715  : 		    cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 716  : 		    continue;

	jmp	$LN2@xmlEncodeE
$LN54@xmlEncodeE:

; 717  : 		}
; 718  : 		/*
; 719  : 		 * We could do multiple things here. Just save as a char ref
; 720  : 		 */
; 721  : 		snprintf(buf, sizeof(buf), "&#x%X;", val);

	mov	edx, DWORD PTR _val$4[ebp]
	push	edx
	push	OFFSET ??_C@_06EPJFDPIN@?$CG?$CDx?$CFX?$DL@
	push	11					; 0000000bH
	lea	eax, DWORD PTR _buf$6[ebp]
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H

; 722  : 		buf[sizeof(buf) - 1] = 0;

	mov	ecx, 1
	imul	edx, ecx, 10
	mov	BYTE PTR _buf$6[ebp+edx], 0

; 723  : 		ptr = buf;

	lea	eax, DWORD PTR _buf$6[ebp]
	mov	DWORD PTR _ptr$5[ebp], eax
$LN12@xmlEncodeE:

; 724  : 		while (*ptr != 0) *out++ = *ptr++;

	mov	ecx, DWORD PTR _ptr$5[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN13@xmlEncodeE
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _ptr$5[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _ptr$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _ptr$5[ebp], ecx
	jmp	SHORT $LN12@xmlEncodeE
$LN13@xmlEncodeE:

; 725  : 		cur += l;

	mov	edx, DWORD PTR _cur$[ebp]
	add	edx, DWORD PTR _l$3[ebp]
	mov	DWORD PTR _cur$[ebp], edx

; 726  : 		continue;

	jmp	$LN2@xmlEncodeE
$LN43@xmlEncodeE:

; 727  : 	    }

	jmp	$LN23@xmlEncodeE
$LN40@xmlEncodeE:

; 728  : 	} else if (IS_BYTE_CHAR(*cur)) {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 9
	jl	SHORT $LN59@xmlEncodeE
	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN58@xmlEncodeE
$LN59@xmlEncodeE:
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN58@xmlEncodeE
	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN23@xmlEncodeE
$LN58@xmlEncodeE:

; 729  : 	    char buf[11], *ptr;
; 730  : 
; 731  : 	    snprintf(buf, sizeof(buf), "&#%d;", *cur);

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	push	OFFSET ??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@
	push	11					; 0000000bH
	lea	ecx, DWORD PTR _buf$2[ebp]
	push	ecx
	call	_snprintf
	add	esp, 16					; 00000010H

; 732  : 	    buf[sizeof(buf) - 1] = 0;

	mov	edx, 1
	imul	eax, edx, 10
	mov	BYTE PTR _buf$2[ebp+eax], 0

; 733  :             ptr = buf;

	lea	ecx, DWORD PTR _buf$2[ebp]
	mov	DWORD PTR _ptr$1[ebp], ecx
$LN14@xmlEncodeE:

; 734  : 	    while (*ptr != 0) *out++ = *ptr++;

	mov	edx, DWORD PTR _ptr$1[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN23@xmlEncodeE
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _ptr$1[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _ptr$1[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$1[ebp], edx
	jmp	SHORT $LN14@xmlEncodeE
$LN23@xmlEncodeE:

; 735  : 	}
; 736  : 	cur++;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$[ebp], eax

; 737  :     }

	jmp	$LN2@xmlEncodeE
$LN3@xmlEncodeE:

; 738  :     *out = 0;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 0

; 739  :     return(buffer);

	mov	eax, DWORD PTR _buffer$[ebp]
	jmp	SHORT $LN1@xmlEncodeE
$mem_error$82:

; 740  : 
; 741  : mem_error:
; 742  :     xmlEntitiesErrMemory("xmlEncodeEntities: realloc failed");

	push	OFFSET ??_C@_0CC@INAAIMLK@xmlEncodeEntities?3?5realloc?5fail@
	call	_xmlEntitiesErrMemory
	add	esp, 4

; 743  :     xmlFree(buffer);

	mov	esi, esp
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 744  :     return(NULL);

	xor	eax, eax
$LN1@xmlEncodeE:

; 745  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN81@xmlEncodeE
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 124				; 0000007cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN81@xmlEncodeE:
	DD	2
	DD	$LN80@xmlEncodeE
$LN80@xmlEncodeE:
	DD	-68					; ffffffbcH
	DD	11					; 0000000bH
	DD	$LN78@xmlEncodeE
	DD	-100					; ffffff9cH
	DD	11					; 0000000bH
	DD	$LN79@xmlEncodeE
$LN79@xmlEncodeE:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN78@xmlEncodeE:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlEncodeEntitiesInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlGetEntityFromTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlGetEntityFromTable PROC				; COMDAT

; 440  : xmlGetEntityFromTable(xmlEntitiesTablePtr table, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 441  :     return((xmlEntityPtr) xmlHashLookup(table, name));

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlHashLookup
	add	esp, 8

; 442  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlGetEntityFromTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlAddEntity
_TEXT	SEGMENT
tv70 = -16						; size = 4
_ret$ = -12						; size = 4
_table$ = -8						; size = 4
_dict$ = -4						; size = 4
_dtd$ = 8						; size = 4
_name$ = 12						; size = 4
_type$ = 16						; size = 4
_ExternalID$ = 20					; size = 4
_SystemID$ = 24						; size = 4
_content$ = 28						; size = 4
_xmlAddEntity PROC					; COMDAT

; 210  : 	  const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 211  :     xmlDictPtr dict = NULL;

	mov	DWORD PTR _dict$[ebp], 0

; 212  :     xmlEntitiesTablePtr table = NULL;

	mov	DWORD PTR _table$[ebp], 0

; 213  :     xmlEntityPtr ret;
; 214  : 
; 215  :     if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN4@xmlAddEnti

; 216  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAddEnti
$LN4@xmlAddEnti:

; 217  :     if (dtd == NULL)

	cmp	DWORD PTR _dtd$[ebp], 0
	jne	SHORT $LN5@xmlAddEnti

; 218  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAddEnti
$LN5@xmlAddEnti:

; 219  :     if (dtd->doc != NULL)

	mov	eax, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN6@xmlAddEnti

; 220  :         dict = dtd->doc->dict;

	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _dict$[ebp], eax
$LN6@xmlAddEnti:

; 221  : 
; 222  :     switch (type) {

	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	mov	edx, DWORD PTR tv70[ebp]
	sub	edx, 1
	mov	DWORD PTR tv70[ebp], edx
	cmp	DWORD PTR tv70[ebp], 5
	ja	SHORT $LN2@xmlAddEnti
	mov	eax, DWORD PTR tv70[ebp]
	jmp	DWORD PTR $LN16@xmlAddEnti[eax*4]
$LN7@xmlAddEnti:

; 223  :         case XML_INTERNAL_GENERAL_ENTITY:
; 224  :         case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 225  :         case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 226  : 	    if (dtd->entities == NULL)

	mov	ecx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN8@xmlAddEnti

; 227  : 		dtd->entities = xmlHashCreateDict(0, dict);

	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	push	0
	call	_xmlHashCreateDict
	add	esp, 8
	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	DWORD PTR [ecx+48], eax
$LN8@xmlAddEnti:

; 228  : 	    table = dtd->entities;

	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR _table$[ebp], eax

; 229  : 	    break;

	jmp	SHORT $LN2@xmlAddEnti
$LN9@xmlAddEnti:

; 230  :         case XML_INTERNAL_PARAMETER_ENTITY:
; 231  :         case XML_EXTERNAL_PARAMETER_ENTITY:
; 232  : 	    if (dtd->pentities == NULL)

	mov	ecx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	jne	SHORT $LN10@xmlAddEnti

; 233  : 		dtd->pentities = xmlHashCreateDict(0, dict);

	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	push	0
	call	_xmlHashCreateDict
	add	esp, 8
	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	DWORD PTR [ecx+60], eax
$LN10@xmlAddEnti:

; 234  : 	    table = dtd->pentities;

	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _table$[ebp], eax

; 235  : 	    break;

	jmp	SHORT $LN2@xmlAddEnti
$LN11@xmlAddEnti:

; 236  :         case XML_INTERNAL_PREDEFINED_ENTITY:
; 237  : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAddEnti
$LN2@xmlAddEnti:

; 238  :     }
; 239  :     if (table == NULL)

	cmp	DWORD PTR _table$[ebp], 0
	jne	SHORT $LN12@xmlAddEnti

; 240  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAddEnti
$LN12@xmlAddEnti:

; 241  :     ret = xmlCreateEntity(dict, name, type, ExternalID, SystemID, content);

	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SystemID$[ebp]
	push	edx
	mov	eax, DWORD PTR _ExternalID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _dict$[ebp]
	push	eax
	call	_xmlCreateEntity
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 242  :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN13@xmlAddEnti

; 243  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAddEnti
$LN13@xmlAddEnti:

; 244  :     ret->doc = dtd->doc;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax

; 245  : 
; 246  :     if (xmlHashAddEntry(table, name, ret)) {

	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashAddEntry
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@xmlAddEnti

; 247  : 	/*
; 248  : 	 * entity was already defined at another level.
; 249  : 	 */
; 250  :         xmlFreeEntity(ret);

	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	call	_xmlFreeEntity
	add	esp, 4

; 251  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAddEnti
$LN14@xmlAddEnti:

; 252  :     }
; 253  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlAddEnti:

; 254  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN16@xmlAddEnti:
	DD	$LN7@xmlAddEnti
	DD	$LN7@xmlAddEnti
	DD	$LN7@xmlAddEnti
	DD	$LN9@xmlAddEnti
	DD	$LN9@xmlAddEnti
	DD	$LN11@xmlAddEnti
_xmlAddEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlCreateEntity
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_dict$ = 8						; size = 4
_name$ = 12						; size = 4
_type$ = 16						; size = 4
_ExternalID$ = 20					; size = 4
_SystemID$ = 24						; size = 4
_content$ = 28						; size = 4
_xmlCreateEntity PROC					; COMDAT

; 156  : 	        const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 157  :     xmlEntityPtr ret;
; 158  : 
; 159  :     ret = (xmlEntityPtr) xmlMalloc(sizeof(xmlEntity));

	mov	esi, esp
	push	76					; 0000004cH
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 160  :     if (ret == NULL) {

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN2@xmlCreateE

; 161  :         xmlEntitiesErrMemory("xmlCreateEntity: malloc failed");

	push	OFFSET ??_C@_0BP@DHPODGDH@xmlCreateEntity?3?5malloc?5failed@
	call	_xmlEntitiesErrMemory
	add	esp, 4

; 162  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlCreateE
$LN2@xmlCreateE:

; 163  :     }
; 164  :     memset(ret, 0, sizeof(xmlEntity));

	push	76					; 0000004cH
	push	0
	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 165  :     ret->type = XML_ENTITY_DECL;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+4], 17			; 00000011H

; 166  :     ret->checked = 0;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+72], 0

; 167  : 
; 168  :     /*
; 169  :      * fill the structure.
; 170  :      */
; 171  :     ret->etype = (xmlEntityType) type;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 172  :     if (dict == NULL) {

	cmp	DWORD PTR _dict$[ebp], 0
	jne	SHORT $LN3@xmlCreateE

; 173  : 	ret->name = xmlStrdup(name);

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 174  : 	if (ExternalID != NULL)

	cmp	DWORD PTR _ExternalID$[ebp], 0
	je	SHORT $LN5@xmlCreateE

; 175  : 	    ret->ExternalID = xmlStrdup(ExternalID);

	mov	edx, DWORD PTR _ExternalID$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+52], eax
$LN5@xmlCreateE:

; 176  : 	if (SystemID != NULL)

	cmp	DWORD PTR _SystemID$[ebp], 0
	je	SHORT $LN6@xmlCreateE

; 177  : 	    ret->SystemID = xmlStrdup(SystemID);

	mov	edx, DWORD PTR _SystemID$[ebp]
	push	edx
	call	_xmlStrdup
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+56], eax
$LN6@xmlCreateE:

; 178  :     } else {

	jmp	SHORT $LN4@xmlCreateE
$LN3@xmlCreateE:

; 179  :         ret->name = xmlDictLookup(dict, name, -1);

	push	-1
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _dict$[ebp]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 180  : 	if (ExternalID != NULL)

	cmp	DWORD PTR _ExternalID$[ebp], 0
	je	SHORT $LN7@xmlCreateE

; 181  : 	    ret->ExternalID = xmlDictLookup(dict, ExternalID, -1);

	push	-1
	mov	edx, DWORD PTR _ExternalID$[ebp]
	push	edx
	mov	eax, DWORD PTR _dict$[ebp]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+52], eax
$LN7@xmlCreateE:

; 182  : 	if (SystemID != NULL)

	cmp	DWORD PTR _SystemID$[ebp], 0
	je	SHORT $LN4@xmlCreateE

; 183  : 	    ret->SystemID = xmlDictLookup(dict, SystemID, -1);

	push	-1
	mov	edx, DWORD PTR _SystemID$[ebp]
	push	edx
	mov	eax, DWORD PTR _dict$[ebp]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+56], eax
$LN4@xmlCreateE:

; 184  :     }
; 185  :     if (content != NULL) {

	cmp	DWORD PTR _content$[ebp], 0
	je	SHORT $LN9@xmlCreateE

; 186  :         ret->length = xmlStrlen(content);

	mov	edx, DWORD PTR _content$[ebp]
	push	edx
	call	_xmlStrlen
	add	esp, 4
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 187  : 	if ((dict != NULL) && (ret->length < 5))

	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN11@xmlCreateE
	mov	edx, DWORD PTR _ret$[ebp]
	cmp	DWORD PTR [edx+44], 5
	jge	SHORT $LN11@xmlCreateE

; 188  : 	    ret->content = (xmlChar *)

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	edx, DWORD PTR _content$[ebp]
	push	edx
	mov	eax, DWORD PTR _dict$[ebp]
	push	eax
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+40], eax
	jmp	SHORT $LN12@xmlCreateE
$LN11@xmlCreateE:

; 189  : 	                   xmlDictLookup(dict, content, ret->length);
; 190  : 	else
; 191  : 	    ret->content = xmlStrndup(content, ret->length);

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	call	_xmlStrndup
	add	esp, 8
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN12@xmlCreateE:

; 192  :      } else {

	jmp	SHORT $LN10@xmlCreateE
$LN9@xmlCreateE:

; 193  :         ret->length = 0;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+44], 0

; 194  :         ret->content = NULL;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+40], 0
$LN10@xmlCreateE:

; 195  :     }
; 196  :     ret->URI = NULL; /* to be computed by the layer knowing

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+64], 0

; 197  : 			the defining entity */
; 198  :     ret->orig = NULL;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+36], 0

; 199  :     ret->owner = 0;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 200  : 
; 201  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCreateE:

; 202  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCreateEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlFreeEntity
_TEXT	SEGMENT
_dict$ = -4						; size = 4
_entity$ = 8						; size = 4
_xmlFreeEntity PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 103  :     xmlDictPtr dict = NULL;

	mov	DWORD PTR _dict$[ebp], 0

; 104  : 
; 105  :     if (entity == NULL)

	cmp	DWORD PTR _entity$[ebp], 0
	jne	SHORT $LN2@xmlFreeEnt

; 106  :         return;

	jmp	$LN1@xmlFreeEnt
$LN2@xmlFreeEnt:

; 107  : 
; 108  :     if (entity->doc != NULL)

	mov	eax, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN3@xmlFreeEnt

; 109  :         dict = entity->doc->dict;

	mov	ecx, DWORD PTR _entity$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _dict$[ebp], eax
$LN3@xmlFreeEnt:

; 110  : 
; 111  : 
; 112  :     if ((entity->children) && (entity->owner == 1) &&

	mov	ecx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN4@xmlFreeEnt
	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+68], 1
	jne	SHORT $LN4@xmlFreeEnt
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _entity$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN4@xmlFreeEnt

; 113  :         (entity == (xmlEntityPtr) entity->children->parent))
; 114  :         xmlFreeNodeList(entity->children);

	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlFreeNodeList
	add	esp, 4
$LN4@xmlFreeEnt:

; 115  :     if (dict != NULL) {

	cmp	DWORD PTR _dict$[ebp], 0
	je	$LN5@xmlFreeEnt

; 116  :         if ((entity->name != NULL) && (!xmlDictOwns(dict, entity->name)))

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN7@xmlFreeEnt
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@xmlFreeEnt

; 117  :             xmlFree((char *) entity->name);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlFreeEnt:

; 118  :         if ((entity->ExternalID != NULL) &&

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN8@xmlFreeEnt
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@xmlFreeEnt

; 119  : 	    (!xmlDictOwns(dict, entity->ExternalID)))
; 120  :             xmlFree((char *) entity->ExternalID);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xmlFreeEnt:

; 121  :         if ((entity->SystemID != NULL) &&

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+56], 0
	je	SHORT $LN9@xmlFreeEnt
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@xmlFreeEnt

; 122  : 	    (!xmlDictOwns(dict, entity->SystemID)))
; 123  :             xmlFree((char *) entity->SystemID);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@xmlFreeEnt:

; 124  :         if ((entity->URI != NULL) && (!xmlDictOwns(dict, entity->URI)))

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $LN10@xmlFreeEnt
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@xmlFreeEnt

; 125  :             xmlFree((char *) entity->URI);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@xmlFreeEnt:

; 126  :         if ((entity->content != NULL)
; 127  :             && (!xmlDictOwns(dict, entity->content)))

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN11@xmlFreeEnt
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@xmlFreeEnt

; 128  :             xmlFree((char *) entity->content);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xmlFreeEnt:

; 129  :         if ((entity->orig != NULL) && (!xmlDictOwns(dict, entity->orig)))

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN12@xmlFreeEnt
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	call	_xmlDictOwns
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@xmlFreeEnt

; 130  :             xmlFree((char *) entity->orig);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xmlFreeEnt:

; 131  :     } else {

	jmp	$LN6@xmlFreeEnt
$LN5@xmlFreeEnt:

; 132  :         if (entity->name != NULL)

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN13@xmlFreeEnt

; 133  :             xmlFree((char *) entity->name);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@xmlFreeEnt:

; 134  :         if (entity->ExternalID != NULL)

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN14@xmlFreeEnt

; 135  :             xmlFree((char *) entity->ExternalID);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlFreeEnt:

; 136  :         if (entity->SystemID != NULL)

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+56], 0
	je	SHORT $LN15@xmlFreeEnt

; 137  :             xmlFree((char *) entity->SystemID);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlFreeEnt:

; 138  :         if (entity->URI != NULL)

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $LN16@xmlFreeEnt

; 139  :             xmlFree((char *) entity->URI);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlFreeEnt:

; 140  :         if (entity->content != NULL)

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN17@xmlFreeEnt

; 141  :             xmlFree((char *) entity->content);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@xmlFreeEnt:

; 142  :         if (entity->orig != NULL)

	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN6@xmlFreeEnt

; 143  :             xmlFree((char *) entity->orig);

	mov	esi, esp
	mov	eax, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlFreeEnt:

; 144  :     }
; 145  :     xmlFree(entity);

	mov	esi, esp
	mov	edx, DWORD PTR _entity$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlFreeEnt:

; 146  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlFreeEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlEntitiesErr
_TEXT	SEGMENT
_code$ = 8						; size = 4
_msg$ = 12						; size = 4
_xmlEntitiesErr PROC					; COMDAT

; 93   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 94   :     __xmlSimpleError(XML_FROM_TREE, code, NULL, msg, NULL);

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _code$[ebp]
	push	ecx
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 95   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlEntitiesErr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlEntitiesErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlEntitiesErrMemory PROC				; COMDAT

; 80   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 81   :     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	0
	push	0
	push	2
	push	2
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 82   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlEntitiesErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlEncodeAttributeEntities
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_input$ = 12						; size = 4
_xmlEncodeAttributeEntities PROC			; COMDAT

; 759  : xmlEncodeAttributeEntities(xmlDocPtr doc, const xmlChar *input) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 760  :     return xmlEncodeEntitiesInternal(doc, input, 1);

	push	1
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlEncodeEntitiesInternal
	add	esp, 12					; 0000000cH

; 761  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlEncodeAttributeEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlDumpEntityDecl
_TEXT	SEGMENT
tv67 = -4						; size = 4
_buf$ = 8						; size = 4
_ent$ = 12						; size = 4
_xmlDumpEntityDecl PROC					; COMDAT

; 1007 : xmlDumpEntityDecl(xmlBufferPtr buf, xmlEntityPtr ent) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 1008 :     if ((buf == NULL) || (ent == NULL)) return;

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN5@xmlDumpEnt
	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN4@xmlDumpEnt
$LN5@xmlDumpEnt:
	jmp	$LN1@xmlDumpEnt
$LN4@xmlDumpEnt:

; 1009 :     switch (ent->etype) {

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR tv67[ebp], ecx
	mov	edx, DWORD PTR tv67[ebp]
	sub	edx, 1
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 4
	ja	$LN24@xmlDumpEnt
	mov	eax, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN26@xmlDumpEnt[eax*4]
$LN6@xmlDumpEnt:

; 1010 : 	case XML_INTERNAL_GENERAL_ENTITY:
; 1011 : 	    xmlBufferWriteChar(buf, "<!ENTITY ");

	push	OFFSET ??_C@_09POADHIMD@?$DM?$CBENTITY?5@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1012 : 	    xmlBufferWriteCHAR(buf, ent->name);

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteCHAR
	add	esp, 8

; 1013 : 	    xmlBufferWriteChar(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1014 : 	    if (ent->orig != NULL)

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN7@xmlDumpEnt

; 1015 : 		xmlBufferWriteQuotedString(buf, ent->orig);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteQuotedString
	add	esp, 8
	jmp	SHORT $LN8@xmlDumpEnt
$LN7@xmlDumpEnt:

; 1016 : 	    else
; 1017 : 		xmlDumpEntityContent(buf, ent->content);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlDumpEntityContent
	add	esp, 8
$LN8@xmlDumpEnt:

; 1018 : 	    xmlBufferWriteChar(buf, ">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1019 : 	    break;

	jmp	$LN1@xmlDumpEnt
$LN9@xmlDumpEnt:

; 1020 : 	case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
; 1021 : 	    xmlBufferWriteChar(buf, "<!ENTITY ");

	push	OFFSET ??_C@_09POADHIMD@?$DM?$CBENTITY?5@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1022 : 	    xmlBufferWriteCHAR(buf, ent->name);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteCHAR
	add	esp, 8

; 1023 : 	    if (ent->ExternalID != NULL) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN10@xmlDumpEnt

; 1024 : 		 xmlBufferWriteChar(buf, " PUBLIC ");

	push	OFFSET ??_C@_08GBBLECIH@?5PUBLIC?5@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1025 : 		 xmlBufferWriteQuotedString(buf, ent->ExternalID);

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteQuotedString
	add	esp, 8

; 1026 : 		 xmlBufferWriteChar(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1027 : 		 xmlBufferWriteQuotedString(buf, ent->SystemID);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteQuotedString
	add	esp, 8

; 1028 : 	    } else {

	jmp	SHORT $LN11@xmlDumpEnt
$LN10@xmlDumpEnt:

; 1029 : 		 xmlBufferWriteChar(buf, " SYSTEM ");

	push	OFFSET ??_C@_08PAGGLANP@?5SYSTEM?5@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteChar
	add	esp, 8

; 1030 : 		 xmlBufferWriteQuotedString(buf, ent->SystemID);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteQuotedString
	add	esp, 8
$LN11@xmlDumpEnt:

; 1031 : 	    }
; 1032 : 	    xmlBufferWriteChar(buf, ">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1033 : 	    break;

	jmp	$LN1@xmlDumpEnt
$LN12@xmlDumpEnt:

; 1034 : 	case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
; 1035 : 	    xmlBufferWriteChar(buf, "<!ENTITY ");

	push	OFFSET ??_C@_09POADHIMD@?$DM?$CBENTITY?5@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1036 : 	    xmlBufferWriteCHAR(buf, ent->name);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteCHAR
	add	esp, 8

; 1037 : 	    if (ent->ExternalID != NULL) {

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN13@xmlDumpEnt

; 1038 : 		 xmlBufferWriteChar(buf, " PUBLIC ");

	push	OFFSET ??_C@_08GBBLECIH@?5PUBLIC?5@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1039 : 		 xmlBufferWriteQuotedString(buf, ent->ExternalID);

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteQuotedString
	add	esp, 8

; 1040 : 		 xmlBufferWriteChar(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1041 : 		 xmlBufferWriteQuotedString(buf, ent->SystemID);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteQuotedString
	add	esp, 8

; 1042 : 	    } else {

	jmp	SHORT $LN14@xmlDumpEnt
$LN13@xmlDumpEnt:

; 1043 : 		 xmlBufferWriteChar(buf, " SYSTEM ");

	push	OFFSET ??_C@_08PAGGLANP@?5SYSTEM?5@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteChar
	add	esp, 8

; 1044 : 		 xmlBufferWriteQuotedString(buf, ent->SystemID);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteQuotedString
	add	esp, 8
$LN14@xmlDumpEnt:

; 1045 : 	    }
; 1046 : 	    if (ent->content != NULL) { /* Should be true ! */

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN15@xmlDumpEnt

; 1047 : 		xmlBufferWriteChar(buf, " NDATA ");

	push	OFFSET ??_C@_07CGHGCOMH@?5NDATA?5@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1048 : 		if (ent->orig != NULL)

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN16@xmlDumpEnt

; 1049 : 		    xmlBufferWriteCHAR(buf, ent->orig);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteCHAR
	add	esp, 8
	jmp	SHORT $LN15@xmlDumpEnt
$LN16@xmlDumpEnt:

; 1050 : 		else
; 1051 : 		    xmlBufferWriteCHAR(buf, ent->content);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteCHAR
	add	esp, 8
$LN15@xmlDumpEnt:

; 1052 : 	    }
; 1053 : 	    xmlBufferWriteChar(buf, ">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1054 : 	    break;

	jmp	$LN1@xmlDumpEnt
$LN18@xmlDumpEnt:

; 1055 : 	case XML_INTERNAL_PARAMETER_ENTITY:
; 1056 : 	    xmlBufferWriteChar(buf, "<!ENTITY % ");

	push	OFFSET ??_C@_0M@BFALCDCJ@?$DM?$CBENTITY?5?$CF?5@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1057 : 	    xmlBufferWriteCHAR(buf, ent->name);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteCHAR
	add	esp, 8

; 1058 : 	    xmlBufferWriteChar(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteChar
	add	esp, 8

; 1059 : 	    if (ent->orig == NULL)

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN19@xmlDumpEnt

; 1060 : 		xmlDumpEntityContent(buf, ent->content);

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlDumpEntityContent
	add	esp, 8
	jmp	SHORT $LN20@xmlDumpEnt
$LN19@xmlDumpEnt:

; 1061 : 	    else
; 1062 : 		xmlBufferWriteQuotedString(buf, ent->orig);

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteQuotedString
	add	esp, 8
$LN20@xmlDumpEnt:

; 1063 : 	    xmlBufferWriteChar(buf, ">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1064 : 	    break;

	jmp	$LN1@xmlDumpEnt
$LN21@xmlDumpEnt:

; 1065 : 	case XML_EXTERNAL_PARAMETER_ENTITY:
; 1066 : 	    xmlBufferWriteChar(buf, "<!ENTITY % ");

	push	OFFSET ??_C@_0M@BFALCDCJ@?$DM?$CBENTITY?5?$CF?5@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteChar
	add	esp, 8

; 1067 : 	    xmlBufferWriteCHAR(buf, ent->name);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteCHAR
	add	esp, 8

; 1068 : 	    if (ent->ExternalID != NULL) {

	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN22@xmlDumpEnt

; 1069 : 		 xmlBufferWriteChar(buf, " PUBLIC ");

	push	OFFSET ??_C@_08GBBLECIH@?5PUBLIC?5@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1070 : 		 xmlBufferWriteQuotedString(buf, ent->ExternalID);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteQuotedString
	add	esp, 8

; 1071 : 		 xmlBufferWriteChar(buf, " ");

	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteChar
	add	esp, 8

; 1072 : 		 xmlBufferWriteQuotedString(buf, ent->SystemID);

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_xmlBufferWriteQuotedString
	add	esp, 8

; 1073 : 	    } else {

	jmp	SHORT $LN23@xmlDumpEnt
$LN22@xmlDumpEnt:

; 1074 : 		 xmlBufferWriteChar(buf, " SYSTEM ");

	push	OFFSET ??_C@_08PAGGLANP@?5SYSTEM?5@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1075 : 		 xmlBufferWriteQuotedString(buf, ent->SystemID);

	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_xmlBufferWriteQuotedString
	add	esp, 8
$LN23@xmlDumpEnt:

; 1076 : 	    }
; 1077 : 	    xmlBufferWriteChar(buf, ">\n");

	push	OFFSET ??_C@_02NEKEAGPN@?$DO?6@
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_xmlBufferWriteChar
	add	esp, 8

; 1078 : 	    break;

	jmp	SHORT $LN1@xmlDumpEnt
$LN24@xmlDumpEnt:

; 1079 : 	default:
; 1080 : 	    xmlEntitiesErr(XML_DTD_UNKNOWN_ENTITY,

	push	OFFSET ??_C@_0DI@PPMLKPJL@xmlDumpEntitiesDecl?3?5internal?3?5@
	push	535					; 00000217H
	call	_xmlEntitiesErr
	add	esp, 8
$LN1@xmlDumpEnt:

; 1081 : 		"xmlDumpEntitiesDecl: internal: unknown type entity type");
; 1082 :     }
; 1083 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN26@xmlDumpEnt:
	DD	$LN6@xmlDumpEnt
	DD	$LN9@xmlDumpEnt
	DD	$LN12@xmlDumpEnt
	DD	$LN18@xmlDumpEnt
	DD	$LN21@xmlDumpEnt
_xmlDumpEntityDecl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlDumpEntitiesTable
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_table$ = 12						; size = 4
_xmlDumpEntitiesTable PROC				; COMDAT

; 1106 : xmlDumpEntitiesTable(xmlBufferPtr buf, xmlEntitiesTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 1107 :     xmlHashScan(table, xmlDumpEntityDeclScan, buf);

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	OFFSET _xmlDumpEntityDeclScan
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlHashScan
	add	esp, 12					; 0000000cH

; 1108 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDumpEntitiesTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlFreeEntitiesTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlFreeEntitiesTable PROC				; COMDAT

; 900  : xmlFreeEntitiesTable(xmlEntitiesTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 901  :     xmlHashFree(table, xmlFreeEntityWrapper);

	push	OFFSET _xmlFreeEntityWrapper
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashFree
	add	esp, 8

; 902  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlFreeEntitiesTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlCopyEntitiesTable
_TEXT	SEGMENT
_table$ = 8						; size = 4
_xmlCopyEntitiesTable PROC				; COMDAT

; 951  : xmlCopyEntitiesTable(xmlEntitiesTablePtr table) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 952  :     return(xmlHashCopy(table, xmlCopyEntity));

	push	OFFSET _xmlCopyEntity
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlHashCopy
	add	esp, 8

; 953  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCopyEntitiesTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlCreateEntitiesTable
_TEXT	SEGMENT
_xmlCreateEntitiesTable PROC				; COMDAT

; 876  : xmlCreateEntitiesTable(void) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 877  :     return((xmlEntitiesTablePtr) xmlHashCreate(0));

	push	0
	call	_xmlHashCreate
	add	esp, 4

; 878  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCreateEntitiesTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlEncodeSpecialChars
_TEXT	SEGMENT
_new_size$1 = -28					; size = 4
_tmp$2 = -24						; size = 4
_indx$3 = -20						; size = 4
_buffer_size$ = -16					; size = 4
_out$ = -12						; size = 4
_buffer$ = -8						; size = 4
_cur$ = -4						; size = 4
_doc$ = 8						; size = 4
_input$ = 12						; size = 4
_xmlEncodeSpecialChars PROC				; COMDAT

; 791  : xmlEncodeSpecialChars(const xmlDoc *doc ATTRIBUTE_UNUSED, const xmlChar *input) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 792  :     const xmlChar *cur = input;

	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 793  :     xmlChar *buffer = NULL;

	mov	DWORD PTR _buffer$[ebp], 0

; 794  :     xmlChar *out = NULL;

	mov	DWORD PTR _out$[ebp], 0

; 795  :     size_t buffer_size = 0;

	mov	DWORD PTR _buffer_size$[ebp], 0

; 796  :     if (input == NULL) return(NULL);

	cmp	DWORD PTR _input$[ebp], 0
	jne	SHORT $LN4@xmlEncodeS
	xor	eax, eax
	jmp	$LN1@xmlEncodeS
$LN4@xmlEncodeS:

; 797  : 
; 798  :     /*
; 799  :      * allocate an translation buffer.
; 800  :      */
; 801  :     buffer_size = 1000;

	mov	DWORD PTR _buffer_size$[ebp], 1000	; 000003e8H

; 802  :     buffer = (xmlChar *) xmlMalloc(buffer_size * sizeof(xmlChar));

	mov	esi, esp
	mov	ecx, DWORD PTR _buffer_size$[ebp]
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buffer$[ebp], eax

; 803  :     if (buffer == NULL) {

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN5@xmlEncodeS

; 804  :         xmlEntitiesErrMemory("xmlEncodeSpecialChars: malloc failed");

	push	OFFSET ??_C@_0CF@FLMLIOHD@xmlEncodeSpecialChars?3?5malloc?5f@
	call	_xmlEntitiesErrMemory
	add	esp, 4

; 805  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlEncodeS
$LN5@xmlEncodeS:

; 806  :     }
; 807  :     out = buffer;

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _out$[ebp], edx
$LN2@xmlEncodeS:

; 808  : 
; 809  :     while (*cur != '\0') {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@xmlEncodeS

; 810  :         size_t indx = out - buffer;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _indx$3[ebp], edx

; 811  :         if (indx + 10 > buffer_size) {

	mov	eax, DWORD PTR _indx$3[ebp]
	add	eax, 10					; 0000000aH
	cmp	eax, DWORD PTR _buffer_size$[ebp]
	jbe	SHORT $LN6@xmlEncodeS

; 812  : 
; 813  : 	    growBufferReentrant();

	mov	ecx, DWORD PTR _buffer_size$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _new_size$1[ebp], ecx
	mov	edx, DWORD PTR _new_size$1[ebp]
	cmp	edx, DWORD PTR _buffer_size$[ebp]
	jae	SHORT $LN7@xmlEncodeS
	jmp	$mem_error$20
$LN7@xmlEncodeS:
	mov	esi, esp
	mov	eax, DWORD PTR _new_size$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$2[ebp], eax
	cmp	DWORD PTR _tmp$2[ebp], 0
	jne	SHORT $LN8@xmlEncodeS
	jmp	$mem_error$20
$LN8@xmlEncodeS:
	mov	edx, DWORD PTR _tmp$2[ebp]
	mov	DWORD PTR _buffer$[ebp], edx
	mov	eax, DWORD PTR _new_size$1[ebp]
	mov	DWORD PTR _buffer_size$[ebp], eax

; 814  : 	    out = &buffer[indx];

	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _indx$3[ebp]
	mov	DWORD PTR _out$[ebp], ecx
$LN6@xmlEncodeS:

; 815  : 	}
; 816  : 
; 817  : 	/*
; 818  : 	 * By default one have to encode at least '<', '>', '"' and '&' !
; 819  : 	 */
; 820  : 	if (*cur == '<') {

	mov	edx, DWORD PTR _cur$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN9@xmlEncodeS

; 821  : 	    *out++ = '&';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 38			; 00000026H
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 822  : 	    *out++ = 'l';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 108			; 0000006cH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 823  : 	    *out++ = 't';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 116			; 00000074H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 824  : 	    *out++ = ';';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	jmp	$LN10@xmlEncodeS
$LN9@xmlEncodeS:

; 825  : 	} else if (*cur == '>') {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 62					; 0000003eH
	jne	SHORT $LN11@xmlEncodeS

; 826  : 	    *out++ = '&';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 827  : 	    *out++ = 'g';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 103			; 00000067H
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 828  : 	    *out++ = 't';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 116			; 00000074H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 829  : 	    *out++ = ';';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	jmp	$LN10@xmlEncodeS
$LN11@xmlEncodeS:

; 830  : 	} else if (*cur == '&') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 38					; 00000026H
	jne	SHORT $LN13@xmlEncodeS

; 831  : 	    *out++ = '&';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 832  : 	    *out++ = 'a';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 97			; 00000061H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 833  : 	    *out++ = 'm';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 109			; 0000006dH
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 834  : 	    *out++ = 'p';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 112			; 00000070H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 835  : 	    *out++ = ';';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	jmp	$LN10@xmlEncodeS
$LN13@xmlEncodeS:

; 836  : 	} else if (*cur == '"') {

	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN15@xmlEncodeS

; 837  : 	    *out++ = '&';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 838  : 	    *out++ = 'q';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 113			; 00000071H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 839  : 	    *out++ = 'u';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 117			; 00000075H
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 840  : 	    *out++ = 'o';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 111			; 0000006fH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 841  : 	    *out++ = 't';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 116			; 00000074H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 842  : 	    *out++ = ';';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	jmp	SHORT $LN10@xmlEncodeS
$LN15@xmlEncodeS:

; 843  : 	} else if (*cur == '\r') {

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN17@xmlEncodeS

; 844  : 	    *out++ = '&';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 845  : 	    *out++ = '#';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 35			; 00000023H
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 846  : 	    *out++ = '1';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 49			; 00000031H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 847  : 	    *out++ = '3';

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 51			; 00000033H
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 848  : 	    *out++ = ';';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 849  : 	} else {

	jmp	SHORT $LN10@xmlEncodeS
$LN17@xmlEncodeS:

; 850  : 	    /*
; 851  : 	     * Works because on UTF-8, all extended sequences cannot
; 852  : 	     * result in bytes in the ASCII range.
; 853  : 	     */
; 854  : 	    *out++ = *cur;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
$LN10@xmlEncodeS:

; 855  : 	}
; 856  : 	cur++;

	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cur$[ebp], ecx

; 857  :     }

	jmp	$LN2@xmlEncodeS
$LN3@xmlEncodeS:

; 858  :     *out = 0;

	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], 0

; 859  :     return(buffer);

	mov	eax, DWORD PTR _buffer$[ebp]
	jmp	SHORT $LN1@xmlEncodeS
$mem_error$20:

; 860  : 
; 861  : mem_error:
; 862  :     xmlEntitiesErrMemory("xmlEncodeSpecialChars: realloc failed");

	push	OFFSET ??_C@_0CG@JAEBJCBF@xmlEncodeSpecialChars?3?5realloc?5@
	call	_xmlEntitiesErrMemory
	add	esp, 4

; 863  :     xmlFree(buffer);

	mov	esi, esp
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 864  :     return(NULL);

	xor	eax, eax
$LN1@xmlEncodeS:

; 865  : }

	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlEncodeSpecialChars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlEncodeEntitiesReentrant
_TEXT	SEGMENT
_doc$ = 8						; size = 4
_input$ = 12						; size = 4
_xmlEncodeEntitiesReentrant PROC			; COMDAT

; 776  : xmlEncodeEntitiesReentrant(xmlDocPtr doc, const xmlChar *input) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 777  :     return xmlEncodeEntitiesInternal(doc, input, 0);

	push	0
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlEncodeEntitiesInternal
	add	esp, 12					; 0000000cH

; 778  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlEncodeEntitiesReentrant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlGetParameterEntity
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_table$ = -4						; size = 4
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlGetParameterEntity PROC				; COMDAT

; 455  : xmlGetParameterEntity(xmlDocPtr doc, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 456  :     xmlEntitiesTablePtr table;
; 457  :     xmlEntityPtr ret;
; 458  : 
; 459  :     if (doc == NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN2@xmlGetPara

; 460  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlGetPara
$LN2@xmlGetPara:

; 461  :     if ((doc->intSubset != NULL) && (doc->intSubset->pentities != NULL)) {

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN3@xmlGetPara
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR [edx+60], 0
	je	SHORT $LN3@xmlGetPara

; 462  : 	table = (xmlEntitiesTablePtr) doc->intSubset->pentities;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _table$[ebp], edx

; 463  : 	ret = xmlGetEntityFromTable(table, name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlGetEntityFromTable
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 464  : 	if (ret != NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN3@xmlGetPara

; 465  : 	    return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
	jmp	SHORT $LN1@xmlGetPara
$LN3@xmlGetPara:

; 466  :     }
; 467  :     if ((doc->extSubset != NULL) && (doc->extSubset->pentities != NULL)) {

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN5@xmlGetPara
	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	DWORD PTR [ecx+60], 0
	je	SHORT $LN5@xmlGetPara

; 468  : 	table = (xmlEntitiesTablePtr) doc->extSubset->pentities;

	mov	edx, DWORD PTR _doc$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _table$[ebp], ecx

; 469  : 	return(xmlGetEntityFromTable(table, name));

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _table$[ebp]
	push	eax
	call	_xmlGetEntityFromTable
	add	esp, 8
	jmp	SHORT $LN1@xmlGetPara
$LN5@xmlGetPara:

; 470  :     }
; 471  :     return(NULL);

	xor	eax, eax
$LN1@xmlGetPara:

; 472  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetParameterEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlGetDtdEntity
_TEXT	SEGMENT
_table$ = -4						; size = 4
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlGetDtdEntity PROC					; COMDAT

; 486  : xmlGetDtdEntity(xmlDocPtr doc, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 487  :     xmlEntitiesTablePtr table;
; 488  : 
; 489  :     if (doc == NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN2@xmlGetDtdE

; 490  : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlGetDtdE
$LN2@xmlGetDtdE:

; 491  :     if ((doc->extSubset != NULL) && (doc->extSubset->entities != NULL)) {

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN3@xmlGetDtdE
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN3@xmlGetDtdE

; 492  : 	table = (xmlEntitiesTablePtr) doc->extSubset->entities;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _table$[ebp], edx

; 493  : 	return(xmlGetEntityFromTable(table, name));

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlGetEntityFromTable
	add	esp, 8
	jmp	SHORT $LN1@xmlGetDtdE
$LN3@xmlGetDtdE:

; 494  :     }
; 495  :     return(NULL);

	xor	eax, eax
$LN1@xmlGetDtdE:

; 496  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetDtdEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlGetDocEntity
_TEXT	SEGMENT
_table$ = -8						; size = 4
_cur$ = -4						; size = 4
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_xmlGetDocEntity PROC					; COMDAT

; 510  : xmlGetDocEntity(const xmlDoc *doc, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 511  :     xmlEntityPtr cur;
; 512  :     xmlEntitiesTablePtr table;
; 513  : 
; 514  :     if (doc != NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	je	$LN2@xmlGetDocE

; 515  : 	if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN3@xmlGetDocE
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN3@xmlGetDocE

; 516  : 	    table = (xmlEntitiesTablePtr) doc->intSubset->entities;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _table$[ebp], edx

; 517  : 	    cur = xmlGetEntityFromTable(table, name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlGetEntityFromTable
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 518  : 	    if (cur != NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@xmlGetDocE

; 519  : 		return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	jmp	SHORT $LN1@xmlGetDocE
$LN3@xmlGetDocE:

; 520  : 	}
; 521  : 	if (doc->standalone != 1) {

	mov	edx, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [edx+40], 1
	je	SHORT $LN2@xmlGetDocE

; 522  : 	    if ((doc->extSubset != NULL) &&

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN2@xmlGetDocE
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN2@xmlGetDocE

; 523  : 		(doc->extSubset->entities != NULL)) {
; 524  : 		table = (xmlEntitiesTablePtr) doc->extSubset->entities;

	mov	eax, DWORD PTR _doc$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _table$[ebp], edx

; 525  : 		cur = xmlGetEntityFromTable(table, name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _table$[ebp]
	push	ecx
	call	_xmlGetEntityFromTable
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 526  : 		if (cur != NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@xmlGetDocE

; 527  : 		    return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	jmp	SHORT $LN1@xmlGetDocE
$LN2@xmlGetDocE:

; 528  : 	    }
; 529  : 	}
; 530  :     }
; 531  :     return(xmlGetPredefinedEntity(name));

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlGetPredefinedEntity
	add	esp, 4
$LN1@xmlGetDocE:

; 532  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlGetDocEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlGetPredefinedEntity
_TEXT	SEGMENT
tv68 = -4						; size = 4
_name$ = 8						; size = 4
_xmlGetPredefinedEntity PROC				; COMDAT

; 265  : xmlGetPredefinedEntity(const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 266  :     if (name == NULL) return(NULL);

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN4@xmlGetPred
	xor	eax, eax
	jmp	$LN1@xmlGetPred
$LN4@xmlGetPred:

; 267  :     switch (name[0]) {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	sub	ecx, 97					; 00000061H
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 16			; 00000010H
	ja	$LN2@xmlGetPred
	mov	edx, DWORD PTR tv68[ebp]
	movzx	eax, BYTE PTR $LN16@xmlGetPred[edx]
	jmp	DWORD PTR $LN17@xmlGetPred[eax*4]
$LN5@xmlGetPred:

; 268  :         case 'l':
; 269  : 	    if (xmlStrEqual(name, BAD_CAST "lt"))

	push	OFFSET ??_C@_02KCAKIFL@lt@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@xmlGetPred

; 270  : 	        return(&xmlEntityLt);

	mov	eax, OFFSET _xmlEntityLt
	jmp	SHORT $LN1@xmlGetPred
$LN6@xmlGetPred:

; 271  : 	    break;

	jmp	SHORT $LN2@xmlGetPred
$LN7@xmlGetPred:

; 272  :         case 'g':
; 273  : 	    if (xmlStrEqual(name, BAD_CAST "gt"))

	push	OFFSET ??_C@_02GHFEHLK@gt@
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@xmlGetPred

; 274  : 	        return(&xmlEntityGt);

	mov	eax, OFFSET _xmlEntityGt
	jmp	SHORT $LN1@xmlGetPred
$LN8@xmlGetPred:

; 275  : 	    break;

	jmp	SHORT $LN2@xmlGetPred
$LN9@xmlGetPred:

; 276  :         case 'a':
; 277  : 	    if (xmlStrEqual(name, BAD_CAST "amp"))

	push	OFFSET ??_C@_03DCBBJBAA@amp@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@xmlGetPred

; 278  : 	        return(&xmlEntityAmp);

	mov	eax, OFFSET _xmlEntityAmp
	jmp	SHORT $LN1@xmlGetPred
$LN10@xmlGetPred:

; 279  : 	    if (xmlStrEqual(name, BAD_CAST "apos"))

	push	OFFSET ??_C@_04LBCJFAKL@apos@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@xmlGetPred

; 280  : 	        return(&xmlEntityApos);

	mov	eax, OFFSET _xmlEntityApos
	jmp	SHORT $LN1@xmlGetPred
$LN11@xmlGetPred:

; 281  : 	    break;

	jmp	SHORT $LN2@xmlGetPred
$LN12@xmlGetPred:

; 282  :         case 'q':
; 283  : 	    if (xmlStrEqual(name, BAD_CAST "quot"))

	push	OFFSET ??_C@_04KJFGKBNM@quot@
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlStrEqual
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@xmlGetPred

; 284  : 	        return(&xmlEntityQuot);

	mov	eax, OFFSET _xmlEntityQuot
	jmp	SHORT $LN1@xmlGetPred
$LN2@xmlGetPred:

; 285  : 	    break;
; 286  : 	default:
; 287  : 	    break;
; 288  :     }
; 289  :     return(NULL);

	xor	eax, eax
$LN1@xmlGetPred:

; 290  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN17@xmlGetPred:
	DD	$LN9@xmlGetPred
	DD	$LN7@xmlGetPred
	DD	$LN5@xmlGetPred
	DD	$LN12@xmlGetPred
	DD	$LN2@xmlGetPred
$LN16@xmlGetPred:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_xmlGetPredefinedEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlAddDtdEntity
_TEXT	SEGMENT
_dtd$ = -8						; size = 4
_ret$ = -4						; size = 4
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_type$ = 16						; size = 4
_ExternalID$ = 20					; size = 4
_SystemID$ = 24						; size = 4
_content$ = 28						; size = 4
_xmlAddDtdEntity PROC					; COMDAT

; 308  : 		const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 309  :     xmlEntityPtr ret;
; 310  :     xmlDtdPtr dtd;
; 311  : 
; 312  :     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN2@xmlAddDtdE

; 313  : 	xmlEntitiesErr(XML_DTD_NO_DOC,

	push	OFFSET ??_C@_0CC@DMDBCNC@xmlAddDtdEntity?3?5document?5is?5NU@
	push	521					; 00000209H
	call	_xmlEntitiesErr
	add	esp, 8

; 314  : 	        "xmlAddDtdEntity: document is NULL");
; 315  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAddDtdE
$LN2@xmlAddDtdE:

; 316  :     }
; 317  :     if (doc->extSubset == NULL) {

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN3@xmlAddDtdE

; 318  : 	xmlEntitiesErr(XML_DTD_NO_DTD,

	push	OFFSET ??_C@_0DC@JLIKFHBI@xmlAddDtdEntity?3?5document?5witho@
	push	522					; 0000020aH
	call	_xmlEntitiesErr
	add	esp, 8

; 319  : 	        "xmlAddDtdEntity: document without external subset");
; 320  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAddDtdE
$LN3@xmlAddDtdE:

; 321  :     }
; 322  :     dtd = doc->extSubset;

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR _dtd$[ebp], edx

; 323  :     ret = xmlAddEntity(dtd, name, type, ExternalID, SystemID, content);

	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SystemID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ExternalID$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dtd$[ebp]
	push	edx
	call	_xmlAddEntity
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 324  :     if (ret == NULL) return(NULL);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN4@xmlAddDtdE
	xor	eax, eax
	jmp	SHORT $LN1@xmlAddDtdE
$LN4@xmlAddDtdE:

; 325  : 
; 326  :     /*
; 327  :      * Link it to the DTD
; 328  :      */
; 329  :     ret->parent = dtd;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 330  :     ret->doc = dtd->doc;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _dtd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx

; 331  :     if (dtd->last == NULL) {

	mov	edx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN5@xmlAddDtdE

; 332  : 	dtd->children = dtd->last = (xmlNodePtr) ret;

	mov	eax, DWORD PTR _dtd$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+12], eax

; 333  :     } else {

	jmp	SHORT $LN6@xmlAddDtdE
$LN5@xmlAddDtdE:

; 334  :         dtd->last->next = (xmlNodePtr) ret;

	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+24], eax

; 335  : 	ret->prev = dtd->last;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+28], eax

; 336  : 	dtd->last = (xmlNodePtr) ret;

	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+16], edx
$LN6@xmlAddDtdE:

; 337  :     }
; 338  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlAddDtdE:

; 339  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAddDtdEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlAddDocEntity
_TEXT	SEGMENT
_dtd$ = -8						; size = 4
_ret$ = -4						; size = 4
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_type$ = 16						; size = 4
_ExternalID$ = 20					; size = 4
_SystemID$ = 24						; size = 4
_content$ = 28						; size = 4
_xmlAddDocEntity PROC					; COMDAT

; 357  : 	        const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 358  :     xmlEntityPtr ret;
; 359  :     xmlDtdPtr dtd;
; 360  : 
; 361  :     if (doc == NULL) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $LN2@xmlAddDocE

; 362  : 	xmlEntitiesErr(XML_DTD_NO_DOC,

	push	OFFSET ??_C@_0CC@PEGCDJOI@xmlAddDocEntity?3?5document?5is?5NU@
	push	521					; 00000209H
	call	_xmlEntitiesErr
	add	esp, 8

; 363  : 	        "xmlAddDocEntity: document is NULL");
; 364  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAddDocE
$LN2@xmlAddDocE:

; 365  :     }
; 366  :     if (doc->intSubset == NULL) {

	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN3@xmlAddDocE

; 367  : 	xmlEntitiesErr(XML_DTD_NO_DTD,

	push	OFFSET ??_C@_0DC@LNFPIBEF@xmlAddDocEntity?3?5document?5witho@
	push	522					; 0000020aH
	call	_xmlEntitiesErr
	add	esp, 8

; 368  : 	        "xmlAddDocEntity: document without internal subset");
; 369  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlAddDocE
$LN3@xmlAddDocE:

; 370  :     }
; 371  :     dtd = doc->intSubset;

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _dtd$[ebp], edx

; 372  :     ret = xmlAddEntity(dtd, name, type, ExternalID, SystemID, content);

	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SystemID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ExternalID$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dtd$[ebp]
	push	edx
	call	_xmlAddEntity
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 373  :     if (ret == NULL) return(NULL);

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN4@xmlAddDocE
	xor	eax, eax
	jmp	SHORT $LN1@xmlAddDocE
$LN4@xmlAddDocE:

; 374  : 
; 375  :     /*
; 376  :      * Link it to the DTD
; 377  :      */
; 378  :     ret->parent = dtd;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 379  :     ret->doc = dtd->doc;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _dtd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx

; 380  :     if (dtd->last == NULL) {

	mov	edx, DWORD PTR _dtd$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN5@xmlAddDocE

; 381  : 	dtd->children = dtd->last = (xmlNodePtr) ret;

	mov	eax, DWORD PTR _dtd$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+12], eax

; 382  :     } else {

	jmp	SHORT $LN6@xmlAddDocE
$LN5@xmlAddDocE:

; 383  : 	dtd->last->next = (xmlNodePtr) ret;

	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [edx+24], eax

; 384  : 	ret->prev = dtd->last;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _dtd$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+28], eax

; 385  : 	dtd->last = (xmlNodePtr) ret;

	mov	ecx, DWORD PTR _dtd$[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+16], edx
$LN6@xmlAddDocE:

; 386  :     }
; 387  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlAddDocE:

; 388  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlAddDocEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\entities.c
;	COMDAT _xmlNewEntity
_TEXT	SEGMENT
_dict$ = -8						; size = 4
_ret$ = -4						; size = 4
_doc$ = 8						; size = 4
_name$ = 12						; size = 4
_type$ = 16						; size = 4
_ExternalID$ = 20					; size = 4
_SystemID$ = 24						; size = 4
_content$ = 28						; size = 4
_xmlNewEntity PROC					; COMDAT

; 410  : 	     const xmlChar *content) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __128F40C8_entities@c
	call	@__CheckForDebuggerJustMyCode@4

; 411  :     xmlEntityPtr ret;
; 412  :     xmlDictPtr dict;
; 413  : 
; 414  :     if ((doc != NULL) && (doc->intSubset != NULL)) {

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN2@xmlNewEnti
	mov	eax, DWORD PTR _doc$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN2@xmlNewEnti

; 415  : 	return(xmlAddDocEntity(doc, name, type, ExternalID, SystemID, content));

	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SystemID$[ebp]
	push	edx
	mov	eax, DWORD PTR _ExternalID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlAddDocEntity
	add	esp, 24					; 00000018H
	jmp	SHORT $LN1@xmlNewEnti
$LN2@xmlNewEnti:

; 416  :     }
; 417  :     if (doc != NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN3@xmlNewEnti

; 418  :         dict = doc->dict;

	mov	ecx, DWORD PTR _doc$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR _dict$[ebp], edx
	jmp	SHORT $LN4@xmlNewEnti
$LN3@xmlNewEnti:

; 419  :     else
; 420  :         dict = NULL;

	mov	DWORD PTR _dict$[ebp], 0
$LN4@xmlNewEnti:

; 421  :     ret = xmlCreateEntity(dict, name, type, ExternalID, SystemID, content);

	mov	eax, DWORD PTR _content$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SystemID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ExternalID$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	call	_xmlCreateEntity
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 422  :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN5@xmlNewEnti

; 423  :         return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewEnti
$LN5@xmlNewEnti:

; 424  :     ret->doc = doc;

	mov	eax, DWORD PTR _ret$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 425  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlNewEnti:

; 426  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlNewEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
