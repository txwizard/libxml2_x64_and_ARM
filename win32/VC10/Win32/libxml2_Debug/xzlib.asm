; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\xzlib.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__A40A425D_stat@h DB 01H
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__6B55C7C2_xzlib@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	___libxml2_xzopen
PUBLIC	___libxml2_xzdopen
PUBLIC	___libxml2_xzread
PUBLIC	___libxml2_xzclose
PUBLIC	___libxml2_xzcompressed
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory@		; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@		; `string'
PUBLIC	??_C@_05NCEJLKCD@?$PN7zXZ@			; `string'
PUBLIC	??_C@_06CJNJFBNP@1?42?411@			; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@	; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error@	; `string'
PUBLIC	??_C@_0BC@NKDLBFJI@compression?5error@		; `string'
PUBLIC	??_C@_0L@BFJCHCMP@lzma?5error@			; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
PUBLIC	??_C@_0BB@LGIBDOHL@trailing?5garbage@		; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ ; `string'
EXTRN	__imp__close:PROC
EXTRN	__imp__lseek:PROC
EXTRN	__imp__open:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__strerror:PROC
EXTRN	__imp__free:PROC
EXTRN	_inflate@8:PROC
EXTRN	_inflateEnd@4:PROC
EXTRN	_inflateReset@4:PROC
EXTRN	_crc32@12:PROC
EXTRN	_inflateInit2_@16:PROC
EXTRN	__imp__lzma_code:PROC
EXTRN	__imp__lzma_end:PROC
EXTRN	__imp__lzma_properties_decode:PROC
EXTRN	__imp__lzma_auto_decoder:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allshl:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ DB 'requested le'
	DB	'ngth does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LGIBDOHL@trailing?5garbage@
CONST	SEGMENT
??_C@_0BB@LGIBDOHL@trailing?5garbage@ DB 'trailing garbage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BFJCHCMP@lzma?5error@
CONST	SEGMENT
??_C@_0L@BFJCHCMP@lzma?5error@ DB 'lzma error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NKDLBFJI@compression?5error@
CONST	SEGMENT
??_C@_0BC@NKDLBFJI@compression?5error@ DB 'compression error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error@ DB 'compressed data error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ DB 'internal err'
	DB	'or: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@ DB 'unexpected end of file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06CJNJFBNP@1?42?411@
CONST	SEGMENT
??_C@_06CJNJFBNP@1?42?411@ DB '1.2.11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCEJLKCD@?$PN7zXZ@
CONST	SEGMENT
??_C@_05NCEJLKCD@?$PN7zXZ@ DB 0fdH, '7zXZ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@ DB '<fd:%d>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory@ DB 'out of memory', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_skip
_TEXT	SEGMENT
tv72 = -16						; size = 4
tv133 = -12						; size = 8
_n$ = -4						; size = 4
_state$ = 8						; size = 4
_len$ = 12						; size = 8
_xz_skip PROC						; COMDAT

; 669  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@xz_skip:

; 670  :     unsigned n;
; 671  : 
; 672  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 673  :     while (len)

	mov	eax, DWORD PTR _len$[ebp]
	or	eax, DWORD PTR _len$[ebp+4]
	je	$LN3@xz_skip

; 674  :         /* skip over whatever is in output buffer */
; 675  :         if (state->have) {

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	$LN4@xz_skip

; 676  :             n = (uint64_t) state->have > len ?

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+44]
	xor	ecx, ecx
	mov	DWORD PTR tv133[ebp], eax
	mov	DWORD PTR tv133[ebp+4], ecx
	mov	edx, DWORD PTR tv133[ebp+4]
	cmp	edx, DWORD PTR _len$[ebp+4]
	jb	SHORT $LN10@xz_skip
	ja	SHORT $LN12@xz_skip
	mov	eax, DWORD PTR tv133[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jbe	SHORT $LN10@xz_skip
$LN12@xz_skip:
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN11@xz_skip
$LN10@xz_skip:
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR tv72[ebp], eax
$LN11@xz_skip:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 677  :                 (unsigned) len : state->have;
; 678  :             state->have -= n;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+44]
	sub	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 679  :             state->next += n;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+40]
	add	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 680  :             state->pos += n;

	mov	edx, DWORD PTR _n$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR [ecx+16]
	adc	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+16], edx
	mov	DWORD PTR [ecx+20], eax

; 681  :             len -= n;

	xor	edx, edx
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _len$[ebp+4]
	sbb	ecx, edx
	mov	DWORD PTR _len$[ebp], eax
	mov	DWORD PTR _len$[ebp+4], ecx

; 682  :         }

	jmp	SHORT $LN5@xz_skip
$LN4@xz_skip:

; 683  : 
; 684  :     /* output buffer empty -- return if we're at the end of the input */
; 685  :         else if (state->eof && state->strm.avail_in == 0)

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+48], 0
	je	SHORT $LN6@xz_skip
	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+108], 0
	jne	SHORT $LN6@xz_skip

; 686  :             break;

	jmp	SHORT $LN3@xz_skip
	jmp	SHORT $LN5@xz_skip
$LN6@xz_skip:

; 687  : 
; 688  :     /* need more data to skip -- load up output buffer */
; 689  :         else {
; 690  :             /* get more output, looking for header if required */
; 691  :             if (xz_make(state) == -1)

	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_make
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN5@xz_skip

; 692  :                 return -1;

	or	eax, -1
	jmp	SHORT $LN1@xz_skip
$LN5@xz_skip:

; 693  :         }

	jmp	$LN2@xz_skip
$LN3@xz_skip:

; 694  :     return 0;

	xor	eax, eax
$LN1@xz_skip:

; 695  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xz_skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_make
_TEXT	SEGMENT
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_xz_make PROC						; COMDAT

; 644  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 645  :     lzma_stream *strm = &(state->strm);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 104				; 00000068H
	mov	DWORD PTR _strm$[ebp], eax

; 646  : 
; 647  :     if (state->how == LOOK) {   /* look for lzma / gzip header */

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	jne	SHORT $LN2@xz_make

; 648  :         if (xz_head(state) == -1)

	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_head
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN3@xz_make

; 649  :             return -1;

	or	eax, -1
	jmp	$LN1@xz_make
$LN3@xz_make:

; 650  :         if (state->have)        /* got some data from xz_head() */

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN2@xz_make

; 651  :             return 0;

	xor	eax, eax
	jmp	$LN1@xz_make
$LN2@xz_make:

; 652  :     }
; 653  :     if (state->how == COPY) {   /* straight copy */

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+72], 1
	jne	SHORT $LN5@xz_make

; 654  :         if (xz_load(state, state->out, state->size << 1, &(state->have)) ==

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_load
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $LN7@xz_make

; 655  :             -1)
; 656  :             return -1;

	or	eax, -1
	jmp	SHORT $LN1@xz_make
$LN7@xz_make:

; 657  :         state->next = state->out;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+40], ecx
	jmp	SHORT $LN6@xz_make
$LN5@xz_make:

; 658  :     } else if (state->how == LZMA || state->how == GZIP) {      /* decompress */

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+72], 3
	je	SHORT $LN9@xz_make
	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+72], 2
	jne	SHORT $LN6@xz_make
$LN9@xz_make:

; 659  :         strm->avail_out = state->size << 1;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	shl	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax+20], edx

; 660  :         strm->next_out = state->out;

	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+16], eax

; 661  :         if (xz_decomp(state) == -1)

	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_decomp
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN6@xz_make

; 662  :             return -1;

	or	eax, -1
	jmp	SHORT $LN1@xz_make
$LN6@xz_make:

; 663  :     }
; 664  :     return 0;

	xor	eax, eax
$LN1@xz_make:

; 665  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xz_make ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_decomp
_TEXT	SEGMENT
_action$ = -40						; size = 4
_strm$ = -36						; size = 4
_len$ = -28						; size = 4
_crc$ = -16						; size = 4
_had$ = -8						; size = 4
_ret$ = -4						; size = 4
_state$ = 8						; size = 4
_xz_decomp PROC						; COMDAT

; 531  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 532  :     int ret;
; 533  :     unsigned had;
; 534  :     unsigned long crc, len;
; 535  :     lzma_stream *strm = &(state->strm);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 104				; 00000068H
	mov	DWORD PTR _strm$[ebp], eax

; 536  : 
; 537  :     lzma_action action = LZMA_RUN;

	mov	DWORD PTR _action$[ebp], 0

; 538  : 
; 539  :     /* fill output buffer up to end of deflate stream */
; 540  :     had = strm->avail_out;

	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _had$[ebp], edx
$LN4@xz_decomp:

; 541  :     do {
; 542  :         /* get more input for inflate() */
; 543  :         if (strm->avail_in == 0 && xz_avail(state) == -1)

	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN5@xz_decomp
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN5@xz_decomp

; 544  :             return -1;

	or	eax, -1
	jmp	$LN1@xz_decomp
$LN5@xz_decomp:

; 545  :         if (strm->avail_in == 0) {

	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN6@xz_decomp

; 546  :             xz_error(state, LZMA_DATA_ERROR, "unexpected end of file");

	push	OFFSET ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
	push	9
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_error
	add	esp, 12					; 0000000cH

; 547  :             return -1;

	or	eax, -1
	jmp	$LN1@xz_decomp
$LN6@xz_decomp:

; 548  :         }
; 549  :         if (state->eof)

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN7@xz_decomp

; 550  :             action = LZMA_FINISH;

	mov	DWORD PTR _action$[ebp], 3
$LN7@xz_decomp:

; 551  : 
; 552  :         /* decompress and handle errors */
; 553  : #ifdef LIBXML_ZLIB_ENABLED
; 554  :         if (state->how == GZIP) {

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+72], 2
	jne	$LN8@xz_decomp

; 555  :             state->zstrm.avail_in = (uInt) state->strm.avail_in;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax+228], edx

; 556  :             state->zstrm.next_in = (Bytef *) state->strm.next_in;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+224], edx

; 557  :             state->zstrm.avail_out = (uInt) state->strm.avail_out;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax+240], edx

; 558  :             state->zstrm.next_out = (Bytef *) state->strm.next_out;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR [eax+236], edx

; 559  :             ret = inflate(&state->zstrm, Z_NO_FLUSH);

	push	0
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	call	_inflate@8
	mov	DWORD PTR _ret$[ebp], eax

; 560  :             if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

	cmp	DWORD PTR _ret$[ebp], -2		; fffffffeH
	je	SHORT $LN11@xz_decomp
	cmp	DWORD PTR _ret$[ebp], 2
	jne	SHORT $LN10@xz_decomp
$LN11@xz_decomp:

; 561  :                 xz_error(state, Z_STREAM_ERROR,

	push	OFFSET ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 562  :                          "internal error: inflate stream corrupt");
; 563  :                 return -1;

	or	eax, -1
	jmp	$LN1@xz_decomp
$LN10@xz_decomp:

; 564  :             }
; 565  :             /*
; 566  :              * FIXME: Remapping a couple of error codes and falling through
; 567  :              * to the LZMA error handling looks fragile.
; 568  :              */
; 569  :             if (ret == Z_MEM_ERROR)

	cmp	DWORD PTR _ret$[ebp], -4		; fffffffcH
	jne	SHORT $LN12@xz_decomp

; 570  :                 ret = LZMA_MEM_ERROR;

	mov	DWORD PTR _ret$[ebp], 5
$LN12@xz_decomp:

; 571  :             if (ret == Z_DATA_ERROR)

	cmp	DWORD PTR _ret$[ebp], -3		; fffffffdH
	jne	SHORT $LN13@xz_decomp

; 572  :                 ret = LZMA_DATA_ERROR;

	mov	DWORD PTR _ret$[ebp], 9
$LN13@xz_decomp:

; 573  :             if (ret == Z_STREAM_END)

	cmp	DWORD PTR _ret$[ebp], 1
	jne	SHORT $LN14@xz_decomp

; 574  :                 ret = LZMA_STREAM_END;

	mov	DWORD PTR _ret$[ebp], 1
$LN14@xz_decomp:

; 575  :             state->strm.avail_in = state->zstrm.avail_in;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+228]
	mov	DWORD PTR [edx+108], ecx

; 576  :             state->strm.next_in = state->zstrm.next_in;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	mov	DWORD PTR [edx+104], ecx

; 577  :             state->strm.avail_out = state->zstrm.avail_out;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	mov	DWORD PTR [edx+124], ecx

; 578  :             state->strm.next_out = state->zstrm.next_out;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	mov	DWORD PTR [edx+120], ecx

; 579  :         } else                  /* state->how == LZMA */

	jmp	SHORT $LN9@xz_decomp
$LN8@xz_decomp:

; 580  : #endif
; 581  :             ret = lzma_code(strm, action);

	mov	esi, esp
	mov	edx, DWORD PTR _action$[ebp]
	push	edx
	mov	eax, DWORD PTR _strm$[ebp]
	push	eax
	call	DWORD PTR __imp__lzma_code
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax
$LN9@xz_decomp:

; 582  :         if (ret == LZMA_MEM_ERROR) {

	cmp	DWORD PTR _ret$[ebp], 5
	jne	SHORT $LN15@xz_decomp

; 583  :             xz_error(state, LZMA_MEM_ERROR, "out of memory");

	push	OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
	push	5
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 584  :             return -1;

	or	eax, -1
	jmp	$LN1@xz_decomp
$LN15@xz_decomp:

; 585  :         }
; 586  :         if (ret == LZMA_DATA_ERROR) {

	cmp	DWORD PTR _ret$[ebp], 9
	jne	SHORT $LN16@xz_decomp

; 587  :             xz_error(state, LZMA_DATA_ERROR, "compressed data error");

	push	OFFSET ??_C@_0BG@HCKBMIHF@compressed?5data?5error@
	push	9
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 588  :             return -1;

	or	eax, -1
	jmp	$LN1@xz_decomp
$LN16@xz_decomp:

; 589  :         }
; 590  :         if (ret == LZMA_PROG_ERROR) {

	cmp	DWORD PTR _ret$[ebp], 11		; 0000000bH
	jne	SHORT $LN17@xz_decomp

; 591  :             xz_error(state, LZMA_PROG_ERROR, "compression error");

	push	OFFSET ??_C@_0BC@NKDLBFJI@compression?5error@
	push	11					; 0000000bH
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_error
	add	esp, 12					; 0000000cH

; 592  :             return -1;

	or	eax, -1
	jmp	$LN1@xz_decomp
$LN17@xz_decomp:

; 593  :         }
; 594  :         if ((state->how != GZIP) &&
; 595  :             (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+72], 2
	je	SHORT $LN2@xz_decomp
	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN2@xz_decomp
	cmp	DWORD PTR _ret$[ebp], 1
	je	SHORT $LN2@xz_decomp

; 596  :             xz_error(state, ret, "lzma error");

	push	OFFSET ??_C@_0L@BFJCHCMP@lzma?5error@
	mov	edx, DWORD PTR _ret$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_error
	add	esp, 12					; 0000000cH

; 597  :             return -1;

	or	eax, -1
	jmp	$LN1@xz_decomp
$LN2@xz_decomp:

; 598  :         }
; 599  :     } while (strm->avail_out && ret != LZMA_STREAM_END);

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN3@xz_decomp
	cmp	DWORD PTR _ret$[ebp], 1
	jne	$LN4@xz_decomp
$LN3@xz_decomp:

; 600  : 
; 601  :     /* update available output and crc check value */
; 602  :     state->have = had - strm->avail_out;

	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR _had$[ebp]
	sub	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 603  :     state->next = strm->next_out - state->have;

	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 604  : #ifdef LIBXML_ZLIB_ENABLED
; 605  :     state->zstrm.adler =

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	push	edx
	call	_crc32@12
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+272], eax

; 606  :         crc32(state->zstrm.adler, state->next, state->have);
; 607  : #endif
; 608  : 
; 609  :     if (ret == LZMA_STREAM_END) {

	cmp	DWORD PTR _ret$[ebp], 1
	jne	$LN20@xz_decomp

; 610  : #ifdef LIBXML_ZLIB_ENABLED
; 611  :         if (state->how == GZIP) {

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+72], 2
	jne	$LN21@xz_decomp

; 612  :             if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {

	lea	eax, DWORD PTR _crc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_gz_next4
	add	esp, 8
	cmp	eax, -1
	je	SHORT $LN24@xz_decomp
	lea	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_gz_next4
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN23@xz_decomp
$LN24@xz_decomp:

; 613  :                 xz_error(state, LZMA_DATA_ERROR, "unexpected end of file");

	push	OFFSET ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
	push	9
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 614  :                 return -1;

	or	eax, -1
	jmp	$LN1@xz_decomp
$LN23@xz_decomp:

; 615  :             }
; 616  :             if (crc != state->zstrm.adler) {

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _crc$[ebp]
	cmp	eax, DWORD PTR [edx+272]
	je	SHORT $LN25@xz_decomp

; 617  :                 xz_error(state, LZMA_DATA_ERROR, "incorrect data check");

	push	OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
	push	9
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 618  :                 return -1;

	or	eax, -1
	jmp	$LN1@xz_decomp
$LN25@xz_decomp:

; 619  :             }
; 620  :             if (len != (state->zstrm.total_out & 0xffffffffL)) {

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR [edx+244]
	je	SHORT $LN26@xz_decomp

; 621  :                 xz_error(state, LZMA_DATA_ERROR, "incorrect length check");

	push	OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
	push	9
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 622  :                 return -1;

	or	eax, -1
	jmp	SHORT $LN1@xz_decomp
$LN26@xz_decomp:

; 623  :             }
; 624  :             state->strm.avail_in = 0;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+108], 0

; 625  :             state->strm.next_in = NULL;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+104], 0

; 626  :             state->strm.avail_out = 0;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 627  :             state->strm.next_out = NULL;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+120], 0

; 628  :         } else

	jmp	SHORT $LN22@xz_decomp
$LN21@xz_decomp:

; 629  : #endif
; 630  :         if (strm->avail_in != 0 || !state->eof) {

	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN28@xz_decomp
	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN22@xz_decomp
$LN28@xz_decomp:

; 631  :             xz_error(state, LZMA_DATA_ERROR, "trailing garbage");

	push	OFFSET ??_C@_0BB@LGIBDOHL@trailing?5garbage@
	push	9
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 632  :             return -1;

	or	eax, -1
	jmp	SHORT $LN1@xz_decomp
$LN22@xz_decomp:

; 633  :         }
; 634  :         state->how = LOOK;      /* ready for next stream, once have is 0 (leave

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+72], 0
$LN20@xz_decomp:

; 635  :                                  * state->direct unchanged to remember how) */
; 636  :     }
; 637  : 
; 638  :     /* good decompression */
; 639  :     return 0;

	xor	eax, eax
$LN1@xz_decomp:

; 640  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN33@xz_decomp
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@xz_decomp:
	DD	2
	DD	$LN32@xz_decomp
$LN32@xz_decomp:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN30@xz_decomp
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN31@xz_decomp
$LN31@xz_decomp:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN30@xz_decomp:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
_xz_decomp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_head
_TEXT	SEGMENT
tv553 = -232						; size = 4
tv554 = -228						; size = 4
tv534 = -224						; size = 4
tv535 = -220						; size = 4
tv512 = -216						; size = 4
tv513 = -212						; size = 4
tv490 = -208						; size = 4
tv491 = -204						; size = 4
tv468 = -200						; size = 4
tv469 = -196						; size = 4
tv449 = -192						; size = 4
tv444 = -188						; size = 4
tv445 = -184						; size = 4
tv425 = -180						; size = 4
tv426 = -176						; size = 4
tv404 = -172						; size = 4
tv405 = -168						; size = 4
tv385 = -164						; size = 4
tv386 = -160						; size = 4
tv366 = -156						; size = 4
tv367 = -152						; size = 4
tv347 = -148						; size = 4
tv348 = -144						; size = 4
tv328 = -140						; size = 4
tv329 = -136						; size = 4
tv309 = -132						; size = 4
tv310 = -128						; size = 4
tv285 = -124						; size = 4
tv286 = -120						; size = 4
tv262 = -116						; size = 4
tv263 = -112						; size = 4
_len$ = -108						; size = 4
_flags$ = -104						; size = 4
_init$ = -96						; size = 88
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_xz_head PROC						; COMDAT

; 386  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 387  :     lzma_stream *strm = &(state->strm);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 104				; 00000068H
	mov	DWORD PTR _strm$[ebp], eax

; 388  :     lzma_stream init = LZMA_STREAM_INIT;

	mov	DWORD PTR _init$[ebp], 0
	mov	DWORD PTR _init$[ebp+4], 0
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _init$[ebp+8], xmm0
	mov	DWORD PTR _init$[ebp+16], 0
	mov	DWORD PTR _init$[ebp+20], 0
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _init$[ebp+24], xmm0
	mov	DWORD PTR _init$[ebp+32], 0
	mov	DWORD PTR _init$[ebp+36], 0
	mov	DWORD PTR _init$[ebp+40], 0
	mov	DWORD PTR _init$[ebp+44], 0
	mov	DWORD PTR _init$[ebp+48], 0
	mov	DWORD PTR _init$[ebp+52], 0
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _init$[ebp+56], xmm0
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _init$[ebp+64], xmm0
	mov	DWORD PTR _init$[ebp+72], 0
	mov	DWORD PTR _init$[ebp+76], 0
	mov	DWORD PTR _init$[ebp+80], 0
	mov	DWORD PTR _init$[ebp+84], 0

; 389  :     int flags;
; 390  :     unsigned len;
; 391  : 
; 392  :     /* allocate read buffers and inflate memory */
; 393  :     if (state->size == 0) {

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	$LN8@xz_head

; 394  :         /* allocate buffers */
; 395  :         state->in = xmlMalloc(state->want);

	mov	esi, esp
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 396  :         state->out = xmlMalloc(state->want << 1);

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+28]
	shl	eax, 1
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 397  :         if (state->in == NULL || state->out == NULL) {

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN10@xz_head
	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN9@xz_head
$LN10@xz_head:

; 398  :             if (state->out != NULL)

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN11@xz_head

; 399  :                 xmlFree(state->out);

	mov	esi, esp
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@xz_head:

; 400  :             if (state->in != NULL)

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN12@xz_head

; 401  :                 xmlFree(state->in);

	mov	esi, esp
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@xz_head:

; 402  :             xz_error(state, LZMA_MEM_ERROR, "out of memory");

	push	OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
	push	5
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 403  :             return -1;

	or	eax, -1
	jmp	$LN1@xz_head
$LN9@xz_head:

; 404  :         }
; 405  :         state->size = state->want;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+24], ecx

; 406  : 
; 407  :         /* allocate decoder memory */
; 408  :         state->strm = init;

	mov	edi, DWORD PTR _state$[ebp]
	add	edi, 104				; 00000068H
	mov	ecx, 22					; 00000016H
	lea	esi, DWORD PTR _init$[ebp]
	rep movsd

; 409  :         state->strm.avail_in = 0;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+108], 0

; 410  :         state->strm.next_in = NULL;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+104], 0

; 411  :         if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {

	mov	esi, esp
	push	0
	push	0
	push	100000000				; 05f5e100H
	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	call	DWORD PTR __imp__lzma_auto_decoder
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN13@xz_head

; 412  :             xmlFree(state->out);

	mov	esi, esp
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 413  :             xmlFree(state->in);

	mov	esi, esp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 414  :             state->size = 0;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+24], 0

; 415  :             xz_error(state, LZMA_MEM_ERROR, "out of memory");

	push	OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
	push	5
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 416  :             return -1;

	or	eax, -1
	jmp	$LN1@xz_head
$LN13@xz_head:

; 417  :         }
; 418  : #ifdef LIBXML_ZLIB_ENABLED
; 419  :         /* allocate inflate memory */
; 420  :         state->zstrm.zalloc = Z_NULL;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+256], 0

; 421  :         state->zstrm.zfree = Z_NULL;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+260], 0

; 422  :         state->zstrm.opaque = Z_NULL;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+264], 0

; 423  :         state->zstrm.avail_in = 0;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+228], 0

; 424  :         state->zstrm.next_in = Z_NULL;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+224], 0

; 425  :         if (state->init == 0) {

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+100], 0
	jne	SHORT $LN8@xz_head

; 426  :             if (inflateInit2(&(state->zstrm), -15) != Z_OK) {/* raw inflate */

	push	56					; 00000038H
	push	OFFSET ??_C@_06CJNJFBNP@1?42?411@
	push	-15					; fffffff1H
	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 224				; 000000e0H
	push	edx
	call	_inflateInit2_@16
	test	eax, eax
	je	SHORT $LN15@xz_head

; 427  :                 xmlFree(state->out);

	mov	esi, esp
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 428  :                 xmlFree(state->in);

	mov	esi, esp
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 429  :                 state->size = 0;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 430  :                 xz_error(state, LZMA_MEM_ERROR, "out of memory");

	push	OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
	push	5
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 431  :                 return -1;

	or	eax, -1
	jmp	$LN1@xz_head
$LN15@xz_head:

; 432  :             }
; 433  :             state->init = 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+100], 1
$LN8@xz_head:

; 434  :         }
; 435  : #endif
; 436  :     }
; 437  : 
; 438  :     /* get some data in the input buffer */
; 439  :     if (strm->avail_in == 0) {

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN16@xz_head

; 440  :         if (xz_avail(state) == -1)

	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN17@xz_head

; 441  :             return -1;

	or	eax, -1
	jmp	$LN1@xz_head
$LN17@xz_head:

; 442  :         if (strm->avail_in == 0)

	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN16@xz_head

; 443  :             return 0;

	xor	eax, eax
	jmp	$LN1@xz_head
$LN16@xz_head:

; 444  :     }
; 445  : 
; 446  :     /* look for the xz magic header bytes */
; 447  :     if (is_format_xz(state) || is_format_lzma(state)) {

	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_is_format_xz
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN20@xz_head
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_is_format_lzma
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@xz_head
$LN20@xz_head:

; 448  :         state->how = LZMA;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+72], 3

; 449  :         state->direct = 0;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+76], 0

; 450  :         return 0;

	xor	eax, eax
	jmp	$LN1@xz_head
$LN19@xz_head:

; 451  :     }
; 452  : #ifdef LIBXML_ZLIB_ENABLED
; 453  :     /* look for the gzip magic header bytes 31 and 139 */
; 454  :     if (strm->next_in[0] == 31) {

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+eax]
	cmp	eax, 31					; 0000001fH
	jne	$LN21@xz_head

; 455  :         strm->avail_in--;

	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax+4], edx

; 456  :         strm->next_in++;

	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax], edx

; 457  :         if (strm->avail_in == 0 && xz_avail(state) == -1)

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN22@xz_head
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN22@xz_head

; 458  :             return -1;

	or	eax, -1
	jmp	$LN1@xz_head
$LN22@xz_head:

; 459  :         if (strm->avail_in && strm->next_in[0] == 139) {

	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN23@xz_head
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 139				; 0000008bH
	jne	$LN23@xz_head

; 460  :             /* we have a gzip header, woo hoo! */
; 461  :             strm->avail_in--;

	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 462  :             strm->next_in++;

	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx], ecx

; 463  : 
; 464  :             /* skip rest of header */
; 465  :             if (NEXT() != 8) {  /* compression method */

	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN34@xz_head
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN34@xz_head
	mov	DWORD PTR tv263[ebp], -1
	jmp	SHORT $LN37@xz_head
$LN34@xz_head:
	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN35@xz_head
	mov	DWORD PTR tv262[ebp], -1
	jmp	SHORT $LN36@xz_head
$LN35@xz_head:
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv262[ebp], edx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx], ecx
$LN36@xz_head:
	mov	eax, DWORD PTR tv262[ebp]
	mov	DWORD PTR tv263[ebp], eax
$LN37@xz_head:
	cmp	DWORD PTR tv263[ebp], 8
	je	SHORT $LN25@xz_head

; 466  :                 xz_error(state, LZMA_DATA_ERROR,

	push	OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
	push	9
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 467  :                          "unknown compression method");
; 468  :                 return -1;

	or	eax, -1
	jmp	$LN1@xz_head
$LN25@xz_head:

; 469  :             }
; 470  :             flags = NEXT();

	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN38@xz_head
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN38@xz_head
	mov	DWORD PTR tv286[ebp], -1
	jmp	SHORT $LN41@xz_head
$LN38@xz_head:
	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN39@xz_head
	mov	DWORD PTR tv285[ebp], -1
	jmp	SHORT $LN40@xz_head
$LN39@xz_head:
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv285[ebp], ecx
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx], eax
$LN40@xz_head:
	mov	edx, DWORD PTR tv285[ebp]
	mov	DWORD PTR tv286[ebp], edx
$LN41@xz_head:
	mov	eax, DWORD PTR tv286[ebp]
	mov	DWORD PTR _flags$[ebp], eax

; 471  :             if (flags & 0xe0) { /* reserved flag bits */

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 224				; 000000e0H
	je	SHORT $LN26@xz_head

; 472  :                 xz_error(state, LZMA_DATA_ERROR,

	push	OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
	push	9
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 473  :                          "unknown header flags set");
; 474  :                 return -1;

	or	eax, -1
	jmp	$LN1@xz_head
$LN26@xz_head:

; 475  :             }
; 476  :             NEXT();             /* modification time */

	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN42@xz_head
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN42@xz_head
	mov	DWORD PTR tv310[ebp], -1
	jmp	SHORT $LN45@xz_head
$LN42@xz_head:
	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN43@xz_head
	mov	DWORD PTR tv309[ebp], -1
	jmp	SHORT $LN44@xz_head
$LN43@xz_head:
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv309[ebp], edx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx], ecx
$LN44@xz_head:
	mov	eax, DWORD PTR tv309[ebp]
	mov	DWORD PTR tv310[ebp], eax
$LN45@xz_head:

; 477  :             NEXT();

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN46@xz_head
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN46@xz_head
	mov	DWORD PTR tv329[ebp], -1
	jmp	SHORT $LN49@xz_head
$LN46@xz_head:
	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN47@xz_head
	mov	DWORD PTR tv328[ebp], -1
	jmp	SHORT $LN48@xz_head
$LN47@xz_head:
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv328[ebp], eax
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax], edx
$LN48@xz_head:
	mov	ecx, DWORD PTR tv328[ebp]
	mov	DWORD PTR tv329[ebp], ecx
$LN49@xz_head:

; 478  :             NEXT();

	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN50@xz_head
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN50@xz_head
	mov	DWORD PTR tv348[ebp], -1
	jmp	SHORT $LN53@xz_head
$LN50@xz_head:
	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN51@xz_head
	mov	DWORD PTR tv347[ebp], -1
	jmp	SHORT $LN52@xz_head
$LN51@xz_head:
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv347[ebp], ecx
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx], eax
$LN52@xz_head:
	mov	edx, DWORD PTR tv347[ebp]
	mov	DWORD PTR tv348[ebp], edx
$LN53@xz_head:

; 479  :             NEXT();

	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN54@xz_head
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN54@xz_head
	mov	DWORD PTR tv367[ebp], -1
	jmp	SHORT $LN57@xz_head
$LN54@xz_head:
	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN55@xz_head
	mov	DWORD PTR tv366[ebp], -1
	jmp	SHORT $LN56@xz_head
$LN55@xz_head:
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv366[ebp], edx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx], ecx
$LN56@xz_head:
	mov	eax, DWORD PTR tv366[ebp]
	mov	DWORD PTR tv367[ebp], eax
$LN57@xz_head:

; 480  :             NEXT();             /* extra flags */

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN58@xz_head
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN58@xz_head
	mov	DWORD PTR tv386[ebp], -1
	jmp	SHORT $LN61@xz_head
$LN58@xz_head:
	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN59@xz_head
	mov	DWORD PTR tv385[ebp], -1
	jmp	SHORT $LN60@xz_head
$LN59@xz_head:
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv385[ebp], eax
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax], edx
$LN60@xz_head:
	mov	ecx, DWORD PTR tv385[ebp]
	mov	DWORD PTR tv386[ebp], ecx
$LN61@xz_head:

; 481  :             NEXT();             /* operating system */

	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN62@xz_head
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN62@xz_head
	mov	DWORD PTR tv405[ebp], -1
	jmp	SHORT $LN65@xz_head
$LN62@xz_head:
	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN63@xz_head
	mov	DWORD PTR tv404[ebp], -1
	jmp	SHORT $LN64@xz_head
$LN63@xz_head:
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv404[ebp], ecx
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx], eax
$LN64@xz_head:
	mov	edx, DWORD PTR tv404[ebp]
	mov	DWORD PTR tv405[ebp], edx
$LN65@xz_head:

; 482  :             if (flags & 4) {    /* extra field */

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	je	$LN27@xz_head

; 483  :                 len = (unsigned) NEXT();

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN66@xz_head
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN66@xz_head
	mov	DWORD PTR tv426[ebp], -1
	jmp	SHORT $LN69@xz_head
$LN66@xz_head:
	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN67@xz_head
	mov	DWORD PTR tv425[ebp], -1
	jmp	SHORT $LN68@xz_head
$LN67@xz_head:
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv425[ebp], eax
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax], edx
$LN68@xz_head:
	mov	ecx, DWORD PTR tv425[ebp]
	mov	DWORD PTR tv426[ebp], ecx
$LN69@xz_head:
	mov	edx, DWORD PTR tv426[ebp]
	mov	DWORD PTR _len$[ebp], edx

; 484  :                 len += (unsigned) NEXT() << 8;

	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN70@xz_head
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN70@xz_head
	mov	DWORD PTR tv445[ebp], -1
	jmp	SHORT $LN73@xz_head
$LN70@xz_head:
	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN71@xz_head
	mov	DWORD PTR tv444[ebp], -1
	jmp	SHORT $LN72@xz_head
$LN71@xz_head:
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv444[ebp], edx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx], ecx
$LN72@xz_head:
	mov	eax, DWORD PTR tv444[ebp]
	mov	DWORD PTR tv445[ebp], eax
$LN73@xz_head:
	mov	ecx, DWORD PTR tv445[ebp]
	shl	ecx, 8
	add	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], ecx
$LN2@xz_head:

; 485  :                 while (len--)

	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv449[ebp], edx
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax
	cmp	DWORD PTR tv449[ebp], 0
	je	$LN27@xz_head

; 486  :                     if (NEXT() < 0)

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN74@xz_head
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN74@xz_head
	mov	DWORD PTR tv469[ebp], -1
	jmp	SHORT $LN77@xz_head
$LN74@xz_head:
	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN75@xz_head
	mov	DWORD PTR tv468[ebp], -1
	jmp	SHORT $LN76@xz_head
$LN75@xz_head:
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv468[ebp], eax
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax], edx
$LN76@xz_head:
	mov	ecx, DWORD PTR tv468[ebp]
	mov	DWORD PTR tv469[ebp], ecx
$LN77@xz_head:
	cmp	DWORD PTR tv469[ebp], 0
	jge	SHORT $LN28@xz_head

; 487  :                         break;

	jmp	SHORT $LN27@xz_head
$LN28@xz_head:
	jmp	$LN2@xz_head
$LN27@xz_head:

; 488  :             }
; 489  :             if (flags & 8)      /* file name */

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 8
	je	SHORT $LN29@xz_head
$LN4@xz_head:

; 490  :                 while (NEXT() > 0) ;

	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN78@xz_head
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN78@xz_head
	mov	DWORD PTR tv491[ebp], -1
	jmp	SHORT $LN81@xz_head
$LN78@xz_head:
	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN79@xz_head
	mov	DWORD PTR tv490[ebp], -1
	jmp	SHORT $LN80@xz_head
$LN79@xz_head:
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv490[ebp], edx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx], ecx
$LN80@xz_head:
	mov	eax, DWORD PTR tv490[ebp]
	mov	DWORD PTR tv491[ebp], eax
$LN81@xz_head:
	cmp	DWORD PTR tv491[ebp], 0
	jle	SHORT $LN29@xz_head
	jmp	SHORT $LN4@xz_head
$LN29@xz_head:

; 491  :             if (flags & 16)     /* comment */

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 16					; 00000010H
	je	SHORT $LN30@xz_head
$LN6@xz_head:

; 492  :                 while (NEXT() > 0) ;

	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN82@xz_head
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN82@xz_head
	mov	DWORD PTR tv513[ebp], -1
	jmp	SHORT $LN85@xz_head
$LN82@xz_head:
	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN83@xz_head
	mov	DWORD PTR tv512[ebp], -1
	jmp	SHORT $LN84@xz_head
$LN83@xz_head:
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv512[ebp], ecx
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx], eax
$LN84@xz_head:
	mov	edx, DWORD PTR tv512[ebp]
	mov	DWORD PTR tv513[ebp], edx
$LN85@xz_head:
	cmp	DWORD PTR tv513[ebp], 0
	jle	SHORT $LN30@xz_head
	jmp	SHORT $LN6@xz_head
$LN30@xz_head:

; 493  :             if (flags & 2) {    /* header crc */

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	$LN31@xz_head

; 494  :                 NEXT();

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN86@xz_head
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN86@xz_head
	mov	DWORD PTR tv535[ebp], -1
	jmp	SHORT $LN89@xz_head
$LN86@xz_head:
	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN87@xz_head
	mov	DWORD PTR tv534[ebp], -1
	jmp	SHORT $LN88@xz_head
$LN87@xz_head:
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv534[ebp], eax
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax], edx
$LN88@xz_head:
	mov	ecx, DWORD PTR tv534[ebp]
	mov	DWORD PTR tv535[ebp], ecx
$LN89@xz_head:

; 495  :                 NEXT();

	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN90@xz_head
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_avail
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN90@xz_head
	mov	DWORD PTR tv554[ebp], -1
	jmp	SHORT $LN31@xz_head
$LN90@xz_head:
	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN91@xz_head
	mov	DWORD PTR tv553[ebp], -1
	jmp	SHORT $LN92@xz_head
$LN91@xz_head:
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv553[ebp], ecx
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx], eax
$LN92@xz_head:
	mov	edx, DWORD PTR tv553[ebp]
	mov	DWORD PTR tv554[ebp], edx
$LN31@xz_head:

; 496  :             }
; 497  :             /* an unexpected end of file is not checked for here -- it will be
; 498  :              * noticed on the first request for uncompressed data */
; 499  : 
; 500  :             /* set up for decompression */
; 501  :             inflateReset(&state->zstrm);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	call	_inflateReset@4

; 502  :             state->zstrm.adler = crc32(0L, Z_NULL, 0);

	push	0
	push	0
	push	0
	call	_crc32@12
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+272], eax

; 503  :             state->how = GZIP;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+72], 2

; 504  :             state->direct = 0;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+76], 0

; 505  :             return 0;

	xor	eax, eax
	jmp	$LN1@xz_head

; 506  :         } else {

	jmp	SHORT $LN21@xz_head
$LN23@xz_head:

; 507  :             /* not a gzip file -- save first byte (31) and fall to raw i/o */
; 508  :             state->out[0] = 31;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	BYTE PTR [edx+ecx], 31			; 0000001fH

; 509  :             state->have = 1;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+44], 1
$LN21@xz_head:

; 510  :         }
; 511  :     }
; 512  : #endif
; 513  : 
; 514  :     /* doing raw i/o, save start of raw data for seeking, copy any leftover
; 515  :      * input to output -- this assumes that the output buffer is larger than
; 516  :      * the input buffer, which also assures space for gzungetc() */
; 517  :     state->raw = state->pos;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+64], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+68], ecx

; 518  :     state->next = state->out;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+40], ecx

; 519  :     if (strm->avail_in) {

	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN32@xz_head

; 520  :         memcpy(state->next + state->have, strm->next_in, strm->avail_in);

	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR [eax+44]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 521  :         state->have += strm->avail_in;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _strm$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 522  :         strm->avail_in = 0;

	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx+4], 0
$LN32@xz_head:

; 523  :     }
; 524  :     state->how = COPY;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+72], 1

; 525  :     state->direct = 1;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+76], 1

; 526  :     return 0;

	xor	eax, eax
$LN1@xz_head:

; 527  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN96@xz_head
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN96@xz_head:
	DD	1
	DD	$LN95@xz_head
$LN95@xz_head:
	DD	-96					; ffffffa0H
	DD	88					; 00000058H
	DD	$LN94@xz_head
$LN94@xz_head:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	0
_xz_head ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _gz_next4
_TEXT	SEGMENT
tv175 = -44						; size = 4
tv176 = -40						; size = 4
tv154 = -36						; size = 4
tv155 = -32						; size = 4
tv133 = -28						; size = 4
tv134 = -24						; size = 4
tv82 = -20						; size = 4
tv83 = -16						; size = 4
_strm$ = -12						; size = 4
_val$ = -8						; size = 4
_ch$ = -4						; size = 4
_state$ = 8						; size = 4
_ret$ = 12						; size = 4
_gz_next4 PROC						; COMDAT

; 367  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 368  :     int ch;
; 369  :     unsigned long val;
; 370  :     z_streamp strm = &(state->zstrm);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 224				; 000000e0H
	mov	DWORD PTR _strm$[ebp], eax

; 371  : 
; 372  :     val = NEXTZ();

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN4@gz_next4
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_avail_zstrm
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN4@gz_next4
	mov	DWORD PTR tv83[ebp], -1
	jmp	SHORT $LN7@gz_next4
$LN4@gz_next4:
	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN5@gz_next4
	mov	DWORD PTR tv82[ebp], -1
	jmp	SHORT $LN6@gz_next4
$LN5@gz_next4:
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax], edx
$LN6@gz_next4:
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv83[ebp], ecx
$LN7@gz_next4:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _val$[ebp], edx

; 373  :     val += (unsigned) NEXTZ() << 8;

	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN8@gz_next4
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_avail_zstrm
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN8@gz_next4
	mov	DWORD PTR tv134[ebp], -1
	jmp	SHORT $LN11@gz_next4
$LN8@gz_next4:
	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@gz_next4
	mov	DWORD PTR tv133[ebp], -1
	jmp	SHORT $LN10@gz_next4
$LN9@gz_next4:
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv133[ebp], edx
	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [edx], ecx
$LN10@gz_next4:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv134[ebp], eax
$LN11@gz_next4:
	mov	ecx, DWORD PTR tv134[ebp]
	shl	ecx, 8
	add	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], ecx

; 374  :     val += (unsigned long) NEXTZ() << 16;

	mov	edx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN12@gz_next4
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_avail_zstrm
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN12@gz_next4
	mov	DWORD PTR tv155[ebp], -1
	jmp	SHORT $LN15@gz_next4
$LN12@gz_next4:
	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN13@gz_next4
	mov	DWORD PTR tv154[ebp], -1
	jmp	SHORT $LN14@gz_next4
$LN13@gz_next4:
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv154[ebp], ecx
	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [ecx], eax
$LN14@gz_next4:
	mov	edx, DWORD PTR tv154[ebp]
	mov	DWORD PTR tv155[ebp], edx
$LN15@gz_next4:
	mov	eax, DWORD PTR tv155[ebp]
	shl	eax, 16					; 00000010H
	add	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 375  :     ch = NEXTZ();

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN16@gz_next4
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_avail_zstrm
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN16@gz_next4
	mov	DWORD PTR tv176[ebp], -1
	jmp	SHORT $LN19@gz_next4
$LN16@gz_next4:
	mov	eax, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN17@gz_next4
	mov	DWORD PTR tv175[ebp], -1
	jmp	SHORT $LN18@gz_next4
$LN17@gz_next4:
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv175[ebp], eax
	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _strm$[ebp]
	mov	DWORD PTR [eax], edx
$LN18@gz_next4:
	mov	ecx, DWORD PTR tv175[ebp]
	mov	DWORD PTR tv176[ebp], ecx
$LN19@gz_next4:
	mov	edx, DWORD PTR tv176[ebp]
	mov	DWORD PTR _ch$[ebp], edx

; 376  :     if (ch == -1)

	cmp	DWORD PTR _ch$[ebp], -1
	jne	SHORT $LN2@gz_next4

; 377  :         return -1;

	or	eax, -1
	jmp	SHORT $LN1@gz_next4
$LN2@gz_next4:

; 378  :     val += (unsigned long) ch << 24;

	mov	eax, DWORD PTR _ch$[ebp]
	shl	eax, 24					; 00000018H
	add	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 379  :     *ret = val;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	edx, DWORD PTR _val$[ebp]
	mov	DWORD PTR [ecx], edx

; 380  :     return 0;

	xor	eax, eax
$LN1@gz_next4:

; 381  : }

	pop	edi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_gz_next4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _is_format_lzma
_TEXT	SEGMENT
_d$1 = -52						; size = 4
_i$ = -48						; size = 4
_uncompressed_size$ = -44				; size = 8
_dict_size$ = -36					; size = 4
_opt$ = -32						; size = 4
_filter$ = -24						; size = 16
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_is_format_lzma PROC					; COMDAT

; 299  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 300  :     lzma_stream *strm = &(state->strm);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 104				; 00000068H
	mov	DWORD PTR _strm$[ebp], eax

; 301  : 
; 302  :     lzma_filter filter;
; 303  :     lzma_options_lzma *opt;
; 304  :     uint32_t dict_size;
; 305  :     uint64_t uncompressed_size;
; 306  :     size_t i;
; 307  : 
; 308  :     if (strm->avail_in < 13)

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 13			; 0000000dH
	jae	SHORT $LN5@is_format_

; 309  :         return 0;

	xor	eax, eax
	jmp	$LN1@is_format_
$LN5@is_format_:

; 310  : 
; 311  :     filter.id = LZMA_FILTER_LZMA1;

	mov	DWORD PTR _filter$[ebp], 1
	mov	DWORD PTR _filter$[ebp+4], 1073741824	; 40000000H

; 312  :     if (lzma_properties_decode(&filter, NULL, state->in, 5) != LZMA_OK)

	mov	esi, esp
	push	5
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	push	0
	lea	ecx, DWORD PTR _filter$[ebp]
	push	ecx
	call	DWORD PTR __imp__lzma_properties_decode
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN6@is_format_

; 313  :         return 0;

	xor	eax, eax
	jmp	$LN1@is_format_
$LN6@is_format_:

; 314  : 
; 315  :     opt = filter.options;

	mov	edx, DWORD PTR _filter$[ebp+8]
	mov	DWORD PTR _opt$[ebp], edx

; 316  :     dict_size = opt->dict_size;

	mov	eax, DWORD PTR _opt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dict_size$[ebp], ecx

; 317  :     free(opt); /* we can't use xmlFree on a string returned by zlib */

	mov	esi, esp
	mov	edx, DWORD PTR _opt$[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 318  : 
; 319  :     /* A hack to ditch tons of false positives: We allow only dictionary
; 320  :      * sizes that are 2^n or 2^n + 2^(n-1) or UINT32_MAX. LZMA_Alone
; 321  :      * created only files with 2^n, but accepts any dictionary size.
; 322  :      * If someone complains, this will be reconsidered.
; 323  :      */
; 324  :     if (dict_size != UINT32_MAX) {

	cmp	DWORD PTR _dict_size$[ebp], -1
	je	SHORT $LN7@is_format_

; 325  :         uint32_t d = dict_size - 1;

	mov	eax, DWORD PTR _dict_size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _d$1[ebp], eax

; 326  : 
; 327  :         d |= d >> 2;

	mov	ecx, DWORD PTR _d$1[ebp]
	shr	ecx, 2
	or	ecx, DWORD PTR _d$1[ebp]
	mov	DWORD PTR _d$1[ebp], ecx

; 328  :         d |= d >> 3;

	mov	edx, DWORD PTR _d$1[ebp]
	shr	edx, 3
	or	edx, DWORD PTR _d$1[ebp]
	mov	DWORD PTR _d$1[ebp], edx

; 329  :         d |= d >> 4;

	mov	eax, DWORD PTR _d$1[ebp]
	shr	eax, 4
	or	eax, DWORD PTR _d$1[ebp]
	mov	DWORD PTR _d$1[ebp], eax

; 330  :         d |= d >> 8;

	mov	ecx, DWORD PTR _d$1[ebp]
	shr	ecx, 8
	or	ecx, DWORD PTR _d$1[ebp]
	mov	DWORD PTR _d$1[ebp], ecx

; 331  :         d |= d >> 16;

	mov	edx, DWORD PTR _d$1[ebp]
	shr	edx, 16					; 00000010H
	or	edx, DWORD PTR _d$1[ebp]
	mov	DWORD PTR _d$1[ebp], edx

; 332  :         ++d;

	mov	eax, DWORD PTR _d$1[ebp]
	add	eax, 1
	mov	DWORD PTR _d$1[ebp], eax

; 333  :         if (d != dict_size || dict_size == 0)

	mov	ecx, DWORD PTR _d$1[ebp]
	cmp	ecx, DWORD PTR _dict_size$[ebp]
	jne	SHORT $LN9@is_format_
	cmp	DWORD PTR _dict_size$[ebp], 0
	jne	SHORT $LN7@is_format_
$LN9@is_format_:

; 334  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@is_format_
$LN7@is_format_:

; 335  :     }
; 336  : 
; 337  :     /* Another hack to ditch false positives: Assume that if the
; 338  :      * uncompressed size is known, it must be less than 256 GiB.
; 339  :      * Again, if someone complains, this will be reconsidered.
; 340  :      */
; 341  :     uncompressed_size = 0;

	xorps	xmm0, xmm0
	movlpd	QWORD PTR _uncompressed_size$[ebp], xmm0

; 342  :     for (i = 0; i < 8; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@is_format_
$LN2@is_format_:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@is_format_:
	cmp	DWORD PTR _i$[ebp], 8
	jae	SHORT $LN3@is_format_

; 343  :         uncompressed_size |= (uint64_t) (state->in[5 + i]) << (i * 8);

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+5]
	cdq
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 3
	call	__allshl
	or	eax, DWORD PTR _uncompressed_size$[ebp]
	or	edx, DWORD PTR _uncompressed_size$[ebp+4]
	mov	DWORD PTR _uncompressed_size$[ebp], eax
	mov	DWORD PTR _uncompressed_size$[ebp+4], edx
	jmp	SHORT $LN2@is_format_
$LN3@is_format_:

; 344  : 
; 345  :     if (uncompressed_size != UINT64_MAX
; 346  :         && uncompressed_size > (UINT64_C(1) << 38))

	mov	eax, DWORD PTR _uncompressed_size$[ebp]
	and	eax, DWORD PTR _uncompressed_size$[ebp+4]
	cmp	eax, -1
	je	SHORT $LN10@is_format_
	cmp	DWORD PTR _uncompressed_size$[ebp+4], 64 ; 00000040H
	jb	SHORT $LN10@is_format_
	ja	SHORT $LN12@is_format_
	cmp	DWORD PTR _uncompressed_size$[ebp], 0
	jbe	SHORT $LN10@is_format_
$LN12@is_format_:

; 347  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@is_format_
$LN10@is_format_:

; 348  : 
; 349  :     return 1;

	mov	eax, 1
$LN1@is_format_:

; 350  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@is_format_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN15@is_format_:
	DD	1
	DD	$LN14@is_format_
$LN14@is_format_:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN13@is_format_
$LN13@is_format_:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_is_format_lzma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _is_format_xz
_TEXT	SEGMENT
tv74 = -12						; size = 4
tv72 = -8						; size = 4
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_is_format_xz PROC					; COMDAT

; 291  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 292  :     lzma_stream *strm = &(state->strm);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 104				; 00000068H
	mov	DWORD PTR _strm$[ebp], eax

; 293  : 
; 294  :     return strm->avail_in >= 6 && memcmp(state->in, "\3757zXZ", 6) == 0;

	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 6
	jb	SHORT $LN3@is_format_
	push	6
	push	OFFSET ??_C@_05NCEJLKCD@?$PN7zXZ@
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 0
	jne	SHORT $LN3@is_format_
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@is_format_
$LN3@is_format_:
	mov	DWORD PTR tv74[ebp], 0
$LN4@is_format_:
	mov	eax, DWORD PTR tv74[ebp]

; 295  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_is_format_xz ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_avail_zstrm
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_state$ = 8						; size = 4
_xz_avail_zstrm PROC					; COMDAT

; 278  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 279  :     int ret;
; 280  :     state->strm.avail_in = state->zstrm.avail_in;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	DWORD PTR [eax+108], edx

; 281  :     state->strm.next_in = state->zstrm.next_in;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	mov	DWORD PTR [eax+104], edx

; 282  :     ret = xz_avail(state);

	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_avail
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 283  :     state->zstrm.avail_in = (uInt) state->strm.avail_in;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR [ecx+228], eax

; 284  :     state->zstrm.next_in = (Bytef *) state->strm.next_in;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	DWORD PTR [ecx+224], eax

; 285  :     return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 286  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xz_avail_zstrm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_avail
_TEXT	SEGMENT
_tmp$1 = -12						; size = 4
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_xz_avail PROC						; COMDAT

; 256  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 257  :     lzma_stream *strm = &(state->strm);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 104				; 00000068H
	mov	DWORD PTR _strm$[ebp], eax

; 258  : 
; 259  :     if (state->err != LZMA_OK)

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN2@xz_avail

; 260  :         return -1;

	or	eax, -1
	jmp	SHORT $LN1@xz_avail
$LN2@xz_avail:

; 261  :     if (state->eof == 0) {

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN3@xz_avail

; 262  :         /* avail_in is size_t, which is not necessary sizeof(unsigned) */
; 263  :         unsigned tmp = strm->avail_in;

	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _tmp$1[ebp], ecx

; 264  : 
; 265  :         if (xz_load(state, state->in, state->size, &tmp) == -1) {

	lea	edx, DWORD PTR _tmp$1[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_load
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $LN4@xz_avail

; 266  :             strm->avail_in = tmp;

	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [edx+4], eax

; 267  :             return -1;

	or	eax, -1
	jmp	SHORT $LN1@xz_avail
$LN4@xz_avail:

; 268  :         }
; 269  :         strm->avail_in = tmp;

	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [ecx+4], edx

; 270  :         strm->next_in = state->in;

	mov	eax, DWORD PTR _strm$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax], edx
$LN3@xz_avail:

; 271  :     }
; 272  :     return 0;

	xor	eax, eax
$LN1@xz_avail:

; 273  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@xz_avail
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@xz_avail:
	DD	1
	DD	$LN7@xz_avail
$LN7@xz_avail:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN6@xz_avail
$LN6@xz_avail:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_xz_avail ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_load
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_state$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_have$ = 20						; size = 4
_xz_load PROC						; COMDAT

; 235  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 236  :     int ret;
; 237  : 
; 238  :     *have = 0;

	mov	eax, DWORD PTR _have$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@xz_load:

; 239  :     do {
; 240  :         ret = read(state->fd, buf + *have, len - *have);

	mov	ecx, DWORD PTR _have$[ebp]
	mov	edx, DWORD PTR _len$[ebp]
	sub	edx, DWORD PTR [ecx]
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _have$[ebp]
	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__read
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 241  :         if (ret <= 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jg	SHORT $LN5@xz_load

; 242  :             break;

	jmp	SHORT $LN3@xz_load
$LN5@xz_load:

; 243  :         *have += ret;

	mov	ecx, DWORD PTR _have$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _ret$[ebp]
	mov	eax, DWORD PTR _have$[ebp]
	mov	DWORD PTR [eax], edx

; 244  :     } while (*have < len);

	mov	ecx, DWORD PTR _have$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _len$[ebp]
	jb	SHORT $LN4@xz_load
$LN3@xz_load:

; 245  :     if (ret < 0) {

	cmp	DWORD PTR _ret$[ebp], 0
	jge	SHORT $LN6@xz_load

; 246  :         xz_error(state, -1, strerror(errno));

	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp__strerror
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	push	-1
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 247  :         return -1;

	or	eax, -1
	jmp	SHORT $LN1@xz_load
$LN6@xz_load:

; 248  :     }
; 249  :     if (ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN7@xz_load

; 250  :         state->eof = 1;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+48], 1
$LN7@xz_load:

; 251  :     return 0;

	xor	eax, eax
$LN1@xz_load:

; 252  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xz_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_compressed
_TEXT	SEGMENT
tv68 = -8						; size = 4
_state$ = -4						; size = 4
_f$ = 8							; size = 4
_xz_compressed PROC					; COMDAT

; 188  : xz_compressed(xzFile f) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 189  :     xz_statep state;
; 190  : 
; 191  :     if (f == NULL)

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN4@xz_compres

; 192  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xz_compres
$LN4@xz_compres:

; 193  :     state = (xz_statep) f;

	mov	eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR _state$[ebp], eax

; 194  :     if (state->init <= 0)

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+100], 0
	jg	SHORT $LN5@xz_compres

; 195  :         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xz_compres
$LN5@xz_compres:

; 196  : 
; 197  :     switch (state->how) {

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 1
	je	SHORT $LN6@xz_compres
	cmp	DWORD PTR tv68[ebp], 1
	jle	SHORT $LN2@xz_compres
	cmp	DWORD PTR tv68[ebp], 3
	jle	SHORT $LN7@xz_compres
	jmp	SHORT $LN2@xz_compres
$LN6@xz_compres:

; 198  :         case COPY:
; 199  : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xz_compres
$LN7@xz_compres:

; 200  : 	case GZIP:
; 201  : 	case LZMA:
; 202  : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xz_compres
$LN2@xz_compres:

; 203  :     }
; 204  :     return(-1);

	or	eax, -1
$LN1@xz_compres:

; 205  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xz_compressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_open
_TEXT	SEGMENT
tv215 = -44						; size = 4
tv128 = -40						; size = 4
tv86 = -33						; size = 1
tv85 = -32						; size = 4
tv84 = -28						; size = 4
tv82 = -24						; size = 4
tv75 = -20						; size = 4
tv161 = -13						; size = 1
tv158 = -12						; size = 4
tv155 = -8						; size = 4
_state$ = -4						; size = 4
_path$ = 8						; size = 4
_fd$ = 12						; size = 4
_mode$ = 16						; size = 4
_xz_open PROC						; COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 141  :     xz_statep state;
; 142  : 
; 143  :     /* allocate xzFile structure to return */
; 144  :     state = xmlMalloc(sizeof(xz_state));

	mov	esi, esp
	push	312					; 00000138H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _state$[ebp], eax

; 145  :     if (state == NULL)

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN2@xz_open

; 146  :         return NULL;

	xor	eax, eax
	jmp	$LN1@xz_open
$LN2@xz_open:

; 147  :     state->size = 0;            /* no buffers allocated yet */

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+24], 0

; 148  :     state->want = BUFSIZ;       /* requested buffer size */

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+28], 512			; 00000200H

; 149  :     state->msg = NULL;          /* no error message yet */

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+96], 0

; 150  :     state->init = 0;            /* initialization of zlib data */

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+100], 0

; 151  : 
; 152  :     /* save the path name for error messages */
; 153  :     state->path = xmlMalloc(strlen(path) + 1);

	mov	ecx, DWORD PTR _path$[ebp]
	mov	DWORD PTR tv155[ebp], ecx
	mov	edx, DWORD PTR tv155[ebp]
	add	edx, 1
	mov	DWORD PTR tv158[ebp], edx
$LL10@xz_open:
	mov	eax, DWORD PTR tv155[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv161[ebp], cl
	add	DWORD PTR tv155[ebp], 1
	cmp	BYTE PTR tv161[ebp], 0
	jne	SHORT $LL10@xz_open
	mov	edx, DWORD PTR tv155[ebp]
	sub	edx, DWORD PTR tv158[ebp]
	mov	DWORD PTR tv75[ebp], edx
	mov	eax, DWORD PTR tv75[ebp]
	add	eax, 1
	mov	esi, esp
	push	eax
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 154  :     if (state->path == NULL) {

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN3@xz_open

; 155  :         xmlFree(state);

	mov	esi, esp
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 156  :         return NULL;

	xor	eax, eax
	jmp	$LN1@xz_open
$LN3@xz_open:

; 157  :     }
; 158  :     strcpy(state->path, path);

	mov	ecx, DWORD PTR _path$[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv84[ebp], eax
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv85[ebp], ecx
$LN7@xz_open:
	mov	edx, DWORD PTR tv82[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv86[ebp], al
	mov	ecx, DWORD PTR tv84[ebp]
	mov	dl, BYTE PTR tv86[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR tv82[ebp]
	add	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR tv84[ebp]
	add	ecx, 1
	mov	DWORD PTR tv84[ebp], ecx
	cmp	BYTE PTR tv86[ebp], 0
	jne	SHORT $LN7@xz_open

; 159  : 
; 160  :     /* open the file with the appropriate mode (or just use fd) */
; 161  :     state->fd = fd != -1 ? fd : open(path,

	cmp	DWORD PTR _fd$[ebp], -1
	je	SHORT $LN8@xz_open
	mov	edx, DWORD PTR _fd$[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN9@xz_open
$LN8@xz_open:
	mov	esi, esp
	push	438					; 000001b6H
	push	32768					; 00008000H
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	DWORD PTR __imp__open
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv128[ebp], eax
$LN9@xz_open:
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR tv128[ebp]
	mov	DWORD PTR [ecx+4], edx

; 162  : #ifdef O_LARGEFILE
; 163  :                                      O_LARGEFILE |
; 164  : #endif
; 165  : #ifdef O_BINARY
; 166  :                                      O_BINARY |
; 167  : #endif
; 168  :                                      O_RDONLY, 0666);
; 169  :     if (state->fd == -1) {

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+4], -1
	jne	SHORT $LN4@xz_open

; 170  :         xmlFree(state->path);

	mov	esi, esp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 171  :         xmlFree(state);

	mov	esi, esp
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 172  :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@xz_open
$LN4@xz_open:

; 173  :     }
; 174  : 
; 175  :     /* save the current position for rewinding (only if reading) */
; 176  :     state->start = lseek(state->fd, 0, SEEK_CUR);

	mov	esi, esp
	push	1
	push	0
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	cdq
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+56], eax
	mov	DWORD PTR [ecx+60], edx

; 177  :     if (state->start == (uint64_t) - 1)

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR tv215[ebp], edx
	mov	eax, DWORD PTR tv215[ebp]
	mov	ecx, DWORD PTR tv215[ebp]
	mov	edx, DWORD PTR [eax+56]
	and	edx, DWORD PTR [ecx+60]
	cmp	edx, -1
	jne	SHORT $LN5@xz_open

; 178  :         state->start = 0;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+56], 0
	mov	DWORD PTR [eax+60], 0
$LN5@xz_open:

; 179  : 
; 180  :     /* initialize stream */
; 181  :     xz_reset(state);

	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_reset
	add	esp, 4

; 182  : 
; 183  :     /* return stream */
; 184  :     return (xzFile) state;

	mov	eax, DWORD PTR _state$[ebp]
$LN1@xz_open:

; 185  : }

	pop	edi
	pop	esi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xz_open ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_xz_reset PROC						; COMDAT

; 124  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 125  :     state->have = 0;            /* no output data available */

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+44], 0

; 126  :     state->eof = 0;             /* not at end of file */

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 127  :     state->how = LOOK;          /* look for gzip header */

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+72], 0

; 128  :     state->direct = 1;          /* default for empty file */

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+76], 1

; 129  :     state->seek = 0;            /* no seek request pending */

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 130  :     xz_error(state, LZMA_OK, NULL);     /* clear error */

	push	0
	push	0
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_error
	add	esp, 12					; 0000000cH

; 131  :     state->pos = 0;             /* no uncompressed data yet */

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0

; 132  :     state->strm.avail_in = 0;   /* no input data yet */

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+108], 0

; 133  : #ifdef LIBXML_ZLIB_ENABLED
; 134  :     state->zstrm.avail_in = 0;  /* no input data yet */

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+228], 0

; 135  : #endif
; 136  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xz_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT _xz_error
_TEXT	SEGMENT
tv231 = -85						; size = 1
tv228 = -84						; size = 4
tv225 = -80						; size = 4
tv224 = -76						; size = 4
tv219 = -69						; size = 1
tv216 = -68						; size = 4
tv214 = -64						; size = 4
tv204 = -57						; size = 1
tv201 = -56						; size = 4
tv128 = -49						; size = 1
tv95 = -48						; size = 4
tv94 = -44						; size = 4
tv92 = -40						; size = 4
tv76 = -36						; size = 4
tv83 = -32						; size = 4
tv173 = -25						; size = 1
tv170 = -24						; size = 4
tv167 = -20						; size = 4
tv80 = -16						; size = 4
tv162 = -9						; size = 1
tv159 = -8						; size = 4
tv156 = -4						; size = 4
_state$ = 8						; size = 4
_err$ = 12						; size = 4
_msg$ = 16						; size = 4
_xz_error PROC						; COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 22					; 00000016H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 91   :     /* free previously allocated message and clear */
; 92   :     if (state->msg != NULL) {

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+96], 0
	je	SHORT $LN2@xz_error

; 93   :         if (state->err != LZMA_MEM_ERROR)

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+92], 5
	je	SHORT $LN3@xz_error

; 94   :             xmlFree(state->msg);

	mov	esi, esp
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@xz_error:

; 95   :         state->msg = NULL;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+96], 0
$LN2@xz_error:

; 96   :     }
; 97   : 
; 98   :     /* set error code, and if no message, then done */
; 99   :     state->err = err;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _err$[ebp]
	mov	DWORD PTR [edx+92], eax

; 100  :     if (msg == NULL)

	cmp	DWORD PTR _msg$[ebp], 0
	jne	SHORT $LN4@xz_error

; 101  :         return;

	jmp	$LN1@xz_error
$LN4@xz_error:

; 102  : 
; 103  :     /* for an out of memory error, save as static string */
; 104  :     if (err == LZMA_MEM_ERROR) {

	cmp	DWORD PTR _err$[ebp], 5
	jne	SHORT $LN5@xz_error

; 105  :         state->msg = (char *) msg;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR [ecx+96], edx

; 106  :         return;

	jmp	$LN1@xz_error
$LN5@xz_error:

; 107  :     }
; 108  : 
; 109  :     /* construct error message with path */
; 110  :     if ((state->msg =
; 111  :          xmlMalloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv156[ebp], ecx
	mov	edx, DWORD PTR tv156[ebp]
	add	edx, 1
	mov	DWORD PTR tv159[ebp], edx
$LL9@xz_error:
	mov	eax, DWORD PTR tv156[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv162[ebp], cl
	add	DWORD PTR tv156[ebp], 1
	cmp	BYTE PTR tv162[ebp], 0
	jne	SHORT $LL9@xz_error
	mov	edx, DWORD PTR tv156[ebp]
	sub	edx, DWORD PTR tv159[ebp]
	mov	DWORD PTR tv80[ebp], edx
	mov	eax, DWORD PTR _msg$[ebp]
	mov	DWORD PTR tv167[ebp], eax
	mov	ecx, DWORD PTR tv167[ebp]
	add	ecx, 1
	mov	DWORD PTR tv170[ebp], ecx
$LL10@xz_error:
	mov	edx, DWORD PTR tv167[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv173[ebp], al
	add	DWORD PTR tv167[ebp], 1
	cmp	BYTE PTR tv173[ebp], 0
	jne	SHORT $LL10@xz_error
	mov	ecx, DWORD PTR tv167[ebp]
	sub	ecx, DWORD PTR tv170[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	mov	edx, DWORD PTR tv83[ebp]
	mov	eax, DWORD PTR tv80[ebp]
	lea	ecx, DWORD PTR [eax+edx+3]
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv76[ebp], eax
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR [edx+96], eax
	cmp	DWORD PTR tv76[ebp], 0
	jne	SHORT $LN6@xz_error

; 112  :         state->err = LZMA_MEM_ERROR;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+92], 5

; 113  :         state->msg = (char *) "out of memory";

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+96], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@

; 114  :         return;

	jmp	$LN1@xz_error
$LN6@xz_error:

; 115  :     }
; 116  :     strcpy(state->msg, state->path);

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv92[ebp], ecx
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv95[ebp], ecx
$LN8@xz_error:
	mov	edx, DWORD PTR tv92[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv128[ebp], al
	mov	ecx, DWORD PTR tv94[ebp]
	mov	dl, BYTE PTR tv128[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR tv92[ebp]
	add	eax, 1
	mov	DWORD PTR tv92[ebp], eax
	mov	ecx, DWORD PTR tv94[ebp]
	add	ecx, 1
	mov	DWORD PTR tv94[ebp], ecx
	cmp	BYTE PTR tv128[ebp], 0
	jne	SHORT $LN8@xz_error

; 117  :     strcat(state->msg, ": ");

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+96]
	add	eax, -1
	mov	DWORD PTR tv201[ebp], eax
$LL11@xz_error:
	mov	ecx, DWORD PTR tv201[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv204[ebp], dl
	add	DWORD PTR tv201[ebp], 1
	cmp	BYTE PTR tv204[ebp], 0
	jne	SHORT $LL11@xz_error
	mov	edi, DWORD PTR tv201[ebp]
	mov	ax, WORD PTR ??_C@_02LMMGGCAJ@?3?5@
	mov	WORD PTR [edi], ax
	mov	cl, BYTE PTR ??_C@_02LMMGGCAJ@?3?5@+2
	mov	BYTE PTR [edi+2], cl

; 118  :     strcat(state->msg, msg);

	mov	edx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR tv214[ebp], edx
	mov	eax, DWORD PTR tv214[ebp]
	mov	DWORD PTR tv216[ebp], eax
$LL12@xz_error:
	mov	ecx, DWORD PTR tv214[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv219[ebp], dl
	add	DWORD PTR tv214[ebp], 1
	cmp	BYTE PTR tv219[ebp], 0
	jne	SHORT $LL12@xz_error
	mov	eax, DWORD PTR tv214[ebp]
	sub	eax, DWORD PTR tv216[ebp]
	mov	ecx, DWORD PTR tv216[ebp]
	mov	DWORD PTR tv224[ebp], ecx
	mov	DWORD PTR tv225[ebp], eax
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+96]
	add	eax, -1
	mov	DWORD PTR tv228[ebp], eax
$LL13@xz_error:
	mov	ecx, DWORD PTR tv228[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv231[ebp], dl
	add	DWORD PTR tv228[ebp], 1
	cmp	BYTE PTR tv231[ebp], 0
	jne	SHORT $LL13@xz_error
	mov	edi, DWORD PTR tv228[ebp]
	mov	esi, DWORD PTR tv224[ebp]
	mov	eax, DWORD PTR tv225[ebp]
	mov	ecx, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb
$LN1@xz_error:

; 119  :     return;
; 120  : }

	pop	edi
	pop	esi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xz_error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT ___libxml2_xzcompressed
_TEXT	SEGMENT
_f$ = 8							; size = 4
___libxml2_xzcompressed PROC				; COMDAT

; 214  : __libxml2_xzcompressed(xzFile f) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 215  :     return xz_compressed(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_xz_compressed
	add	esp, 4

; 216  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___libxml2_xzcompressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT ___libxml2_xzclose
_TEXT	SEGMENT
tv91 = -12						; size = 4
_state$ = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
___libxml2_xzclose PROC					; COMDAT

; 788  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 789  :     int ret;
; 790  :     xz_statep state;
; 791  : 
; 792  :     /* get internal structure */
; 793  :     if (file == NULL)

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@libxml2_xz

; 794  :         return LZMA_DATA_ERROR;

	mov	eax, 9
	jmp	$LN1@libxml2_xz
$LN2@libxml2_xz:

; 795  :     state = (xz_statep) file;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR _state$[ebp], eax

; 796  : 
; 797  :     /* free memory and close file */
; 798  :     if (state->size) {

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN3@libxml2_xz

; 799  :         lzma_end(&(state->strm));

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 104				; 00000068H
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__lzma_end
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 800  : #ifdef LIBXML_ZLIB_ENABLED
; 801  :         if (state->init == 1)

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+100], 1
	jne	SHORT $LN4@libxml2_xz

; 802  :             inflateEnd(&(state->zstrm));

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 224				; 000000e0H
	push	ecx
	call	_inflateEnd@4
$LN4@libxml2_xz:

; 803  :         state->init = 0;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+100], 0

; 804  : #endif
; 805  :         xmlFree(state->out);

	mov	esi, esp
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 806  :         xmlFree(state->in);

	mov	esi, esp
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@libxml2_xz:

; 807  :     }
; 808  :     xmlFree(state->path);

	mov	esi, esp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 809  :     if ((state->msg != NULL) && (state->err != LZMA_MEM_ERROR))

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+96], 0
	je	SHORT $LN5@libxml2_xz
	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+92], 5
	je	SHORT $LN5@libxml2_xz

; 810  :         xmlFree(state->msg);

	mov	esi, esp
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@libxml2_xz:

; 811  :     ret = close(state->fd);

	mov	esi, esp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__close
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 812  :     xmlFree(state);

	mov	esi, esp
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 813  :     return ret ? ret : LZMA_OK;

	cmp	DWORD PTR _ret$[ebp], 0
	je	SHORT $LN7@libxml2_xz
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR tv91[ebp], ecx
	jmp	SHORT $LN8@libxml2_xz
$LN7@libxml2_xz:
	mov	DWORD PTR tv91[ebp], 0
$LN8@libxml2_xz:
	mov	eax, DWORD PTR tv91[ebp]
$LN1@libxml2_xz:

; 814  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___libxml2_xzclose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT ___libxml2_xzread
_TEXT	SEGMENT
tv86 = -28						; size = 4
_strm$ = -24						; size = 4
_state$ = -20						; size = 4
_n$ = -12						; size = 4
_got$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
___libxml2_xzread PROC					; COMDAT

; 699  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 700  :     unsigned got, n;
; 701  :     xz_statep state;
; 702  :     lzma_stream *strm;
; 703  : 
; 704  :     /* get internal structure */
; 705  :     if (file == NULL)

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN5@libxml2_xz

; 706  :         return -1;

	or	eax, -1
	jmp	$LN1@libxml2_xz
$LN5@libxml2_xz:

; 707  :     state = (xz_statep) file;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR _state$[ebp], eax

; 708  :     strm = &(state->strm);

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 104				; 00000068H
	mov	DWORD PTR _strm$[ebp], ecx

; 709  : 
; 710  :     /* check that we're reading and that there's no error */
; 711  :     if (state->err != LZMA_OK)

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN6@libxml2_xz

; 712  :         return -1;

	or	eax, -1
	jmp	$LN1@libxml2_xz
$LN6@libxml2_xz:

; 713  : 
; 714  :     /* since an int is returned, make sure len fits in one, otherwise return
; 715  :      * with an error (this avoids the flaw in the interface) */
; 716  :     if ((int) len < 0) {

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN7@libxml2_xz

; 717  :         xz_error(state, LZMA_BUF_ERROR,

	push	OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
	push	10					; 0000000aH
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_error
	add	esp, 12					; 0000000cH

; 718  :                  "requested length does not fit in int");
; 719  :         return -1;

	or	eax, -1
	jmp	$LN1@libxml2_xz
$LN7@libxml2_xz:

; 720  :     }
; 721  : 
; 722  :     /* if len is zero, avoid unnecessary operations */
; 723  :     if (len == 0)

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN8@libxml2_xz

; 724  :         return 0;

	xor	eax, eax
	jmp	$LN1@libxml2_xz
$LN8@libxml2_xz:

; 725  : 
; 726  :     /* process a skip request */
; 727  :     if (state->seek) {

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+88], 0
	je	SHORT $LN9@libxml2_xz

; 728  :         state->seek = 0;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+88], 0

; 729  :         if (xz_skip(state, state->skip) == -1)

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	mov	edx, DWORD PTR [eax+80]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_skip
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN9@libxml2_xz

; 730  :             return -1;

	or	eax, -1
	jmp	$LN1@libxml2_xz
$LN9@libxml2_xz:

; 731  :     }
; 732  : 
; 733  :     /* get len bytes to buf, or less than len if at the end */
; 734  :     got = 0;

	mov	DWORD PTR _got$[ebp], 0
$LN4@libxml2_xz:

; 735  :     do {
; 736  :         /* first just try copying data from the output buffer */
; 737  :         if (state->have) {

	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN11@libxml2_xz

; 738  :             n = state->have > len ? len : state->have;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, DWORD PTR _len$[ebp]
	jbe	SHORT $LN24@libxml2_xz
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN25@libxml2_xz
$LN24@libxml2_xz:
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR tv86[ebp], eax
$LN25@libxml2_xz:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 739  :             memcpy(buf, state->next, n);

	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 740  :             state->next += n;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	add	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 741  :             state->have -= n;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	sub	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+44], ecx

; 742  :         }

	jmp	$LN12@libxml2_xz
$LN11@libxml2_xz:

; 743  : 
; 744  :         /* output buffer empty -- return if we're at the end of the input */
; 745  :         else if (state->eof && strm->avail_in == 0)

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN13@libxml2_xz
	mov	ecx, DWORD PTR _strm$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN13@libxml2_xz

; 746  :             break;

	jmp	$LN3@libxml2_xz
	jmp	$LN12@libxml2_xz
$LN13@libxml2_xz:

; 747  : 
; 748  :         /* need output data -- for small len or new stream load up our output
; 749  :          * buffer */
; 750  :         else if (state->how == LOOK || len < (state->size << 1)) {

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+72], 0
	je	SHORT $LN17@libxml2_xz
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shl	ecx, 1
	cmp	DWORD PTR _len$[ebp], ecx
	jae	SHORT $LN15@libxml2_xz
$LN17@libxml2_xz:

; 751  :             /* get more output, looking for header if required */
; 752  :             if (xz_make(state) == -1)

	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_xz_make
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN18@libxml2_xz

; 753  :                 return -1;

	or	eax, -1
	jmp	$LN1@libxml2_xz
$LN18@libxml2_xz:

; 754  :             continue;           /* no progress yet -- go back to memcpy() above */

	jmp	$LN2@libxml2_xz

; 755  :             /* the copy above assures that we will leave with space in the
; 756  :              * output buffer, allowing at least one gzungetc() to succeed */
; 757  :         }

	jmp	SHORT $LN12@libxml2_xz
$LN15@libxml2_xz:

; 758  : 
; 759  :         /* large len -- read directly into user buffer */
; 760  :         else if (state->how == COPY) {  /* read directly */

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+72], 1
	jne	SHORT $LN19@libxml2_xz

; 761  :             if (xz_load(state, buf, len, &n) == -1)

	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_xz_load
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $LN21@libxml2_xz

; 762  :                 return -1;

	or	eax, -1
	jmp	SHORT $LN1@libxml2_xz
$LN21@libxml2_xz:

; 763  :         }

	jmp	SHORT $LN12@libxml2_xz
$LN19@libxml2_xz:

; 764  : 
; 765  :         /* large len -- decompress directly into user buffer */
; 766  :         else {                  /* state->how == LZMA */
; 767  :             strm->avail_out = len;

	mov	edx, DWORD PTR _strm$[ebp]
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx+20], eax

; 768  :             strm->next_out = buf;

	mov	ecx, DWORD PTR _strm$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 769  :             if (xz_decomp(state) == -1)

	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_xz_decomp
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN22@libxml2_xz

; 770  :                 return -1;

	or	eax, -1
	jmp	SHORT $LN1@libxml2_xz
$LN22@libxml2_xz:

; 771  :             n = state->have;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _n$[ebp], edx

; 772  :             state->have = 0;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+44], 0
$LN12@libxml2_xz:

; 773  :         }
; 774  : 
; 775  :         /* update progress */
; 776  :         len -= n;

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _len$[ebp], ecx

; 777  :         buf = (char *) buf + n;

	mov	edx, DWORD PTR _buf$[ebp]
	add	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _buf$[ebp], edx

; 778  :         got += n;

	mov	eax, DWORD PTR _got$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _got$[ebp], eax

; 779  :         state->pos += n;

	mov	ecx, DWORD PTR _n$[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR [eax+16]
	adc	edx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx
$LN2@libxml2_xz:

; 780  :     } while (len);

	cmp	DWORD PTR _len$[ebp], 0
	jne	$LN4@libxml2_xz
$LN3@libxml2_xz:

; 781  : 
; 782  :     /* return number of bytes read into user buffer (will fit in int) */
; 783  :     return (int) got;

	mov	eax, DWORD PTR _got$[ebp]
$LN1@libxml2_xz:

; 784  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@libxml2_xz
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN28@libxml2_xz:
	DD	1
	DD	$LN27@libxml2_xz
$LN27@libxml2_xz:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN26@libxml2_xz
$LN26@libxml2_xz:
	DB	110					; 0000006eH
	DB	0
___libxml2_xzread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT ___libxml2_xzdopen
_TEXT	SEGMENT
_xz$ = -8						; size = 4
_path$ = -4						; size = 4
_fd$ = 8						; size = 4
_mode$ = 12						; size = 4
___libxml2_xzdopen PROC					; COMDAT

; 220  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 221  :     char *path;                 /* identifier for error messages */
; 222  :     xzFile xz;
; 223  : 
; 224  :     if (fd == -1 || (path = xmlMalloc(7 + 3 * sizeof(int))) == NULL)

	cmp	DWORD PTR _fd$[ebp], -1
	je	SHORT $LN3@libxml2_xz
	mov	esi, esp
	push	19					; 00000013H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _path$[ebp], eax
	cmp	DWORD PTR _path$[ebp], 0
	jne	SHORT $LN2@libxml2_xz
$LN3@libxml2_xz:

; 225  :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@libxml2_xz
$LN2@libxml2_xz:

; 226  :     sprintf(path, "<fd:%d>", fd);       /* for debugging */

	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	push	OFFSET ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 227  :     xz = xz_open(path, fd, mode);

	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	mov	eax, DWORD PTR _fd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_xz_open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xz$[ebp], eax

; 228  :     xmlFree(path);

	mov	esi, esp
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 229  :     return xz;

	mov	eax, DWORD PTR _xz$[ebp]
$LN1@libxml2_xz:

; 230  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___libxml2_xzdopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\xzlib.c
;	COMDAT ___libxml2_xzopen
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
___libxml2_xzopen PROC					; COMDAT

; 209  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __6B55C7C2_xzlib@c
	call	@__CheckForDebuggerJustMyCode@4

; 210  :     return xz_open(path, -1, mode);

	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_xz_open
	add	esp, 12					; 0000000cH

; 211  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___libxml2_xzopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
tv87 = -20						; size = 4
__Format$ = -16						; size = 4
__Result$1 = -12					; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1390 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN7@sprintf
	mov	DWORD PTR tv87[ebp], -1
	jmp	SHORT $LN3@sprintf
$LN7@sprintf:
	mov	ecx, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv87[ebp], ecx
$LN3@sprintf:

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR __Result$[ebp], edx

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1793 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
