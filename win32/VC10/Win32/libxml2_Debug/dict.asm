; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\dict.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__C0802A2B_corecrt_wtime@h DB 01H
__04AA828A_time@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__75FE04D0_dict@c DB 01H
msvcjmc	ENDS
PUBLIC	___xmlInitializeDict
PUBLIC	_xmlInitializeDict
PUBLIC	_xmlDictCreate
PUBLIC	_xmlDictSetLimit
PUBLIC	_xmlDictGetUsage
PUBLIC	_xmlDictCreateSub
PUBLIC	_xmlDictReference
PUBLIC	_xmlDictFree
PUBLIC	_xmlDictLookup
PUBLIC	_xmlDictExists
PUBLIC	_xmlDictQLookup
PUBLIC	_xmlDictOwns
PUBLIC	_xmlDictSize
PUBLIC	_xmlDictCleanup
PUBLIC	__JustMyCode_Default
EXTRN	_xmlStrncmp:PROC
EXTRN	_xmlStrQEqual:PROC
EXTRN	_xmlNewRMutex:PROC
EXTRN	_xmlRMutexLock:PROC
EXTRN	_xmlRMutexUnlock:PROC
EXTRN	_xmlFreeRMutex:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_xmlDictMutex DD 01H DUP (?)
_xmlDictInitialized DD 01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictGrow
_TEXT	SEGMENT
tv223 = -48						; size = 4
tv150 = -44						; size = 4
_entry$1 = -40						; size = 4
_keep_keys$ = -36					; size = 4
_ret$ = -32						; size = 4
_olddict$ = -28						; size = 4
_next$ = -24						; size = 4
_iter$ = -20						; size = 4
_i$ = -16						; size = 4
_oldsize$ = -12						; size = 4
_okey$ = -8						; size = 4
_key$ = -4						; size = 4
_dict$ = 8						; size = 4
_size$ = 12						; size = 4
_xmlDictGrow PROC					; COMDAT

; 660  : xmlDictGrow(xmlDictPtr dict, size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 661  :     unsigned long key, okey;
; 662  :     size_t oldsize, i;
; 663  :     xmlDictEntryPtr iter, next;
; 664  :     struct _xmlDictEntry *olddict;
; 665  : #ifdef DEBUG_GROW
; 666  :     unsigned long nbElem = 0;
; 667  : #endif
; 668  :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 669  :     int keep_keys = 1;

	mov	DWORD PTR _keep_keys$[ebp], 1

; 670  : 
; 671  :     if (dict == NULL)

	cmp	DWORD PTR _dict$[ebp], 0
	jne	SHORT $LN10@xmlDictGro

; 672  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlDictGro
$LN10@xmlDictGro:

; 673  :     if (size < 8)

	cmp	DWORD PTR _size$[ebp], 8
	jae	SHORT $LN11@xmlDictGro

; 674  :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlDictGro
$LN11@xmlDictGro:

; 675  :     if (size > 8 * 2048)

	cmp	DWORD PTR _size$[ebp], 16384		; 00004000H
	jbe	SHORT $LN12@xmlDictGro

; 676  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlDictGro
$LN12@xmlDictGro:

; 677  : 
; 678  : #ifdef DICT_DEBUG_PATTERNS
; 679  :     fprintf(stderr, "*");
; 680  : #endif
; 681  : 
; 682  :     oldsize = dict->size;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _oldsize$[ebp], ecx

; 683  :     olddict = dict->dict;

	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _olddict$[ebp], eax

; 684  :     if (olddict == NULL)

	cmp	DWORD PTR _olddict$[ebp], 0
	jne	SHORT $LN13@xmlDictGro

; 685  :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlDictGro
$LN13@xmlDictGro:

; 686  :     if (oldsize == MIN_DICT_SIZE)

	cmp	DWORD PTR _oldsize$[ebp], 128		; 00000080H
	jne	SHORT $LN14@xmlDictGro

; 687  :         keep_keys = 0;

	mov	DWORD PTR _keep_keys$[ebp], 0
$LN14@xmlDictGro:

; 688  : 
; 689  :     dict->dict = xmlMalloc(size * sizeof(xmlDictEntry));

	imul	ecx, DWORD PTR _size$[ebp], 20
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [edx+4], eax

; 690  :     if (dict->dict == NULL) {

	mov	eax, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN15@xmlDictGro

; 691  : 	dict->dict = olddict;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR _olddict$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 692  : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlDictGro
$LN15@xmlDictGro:

; 693  :     }
; 694  :     memset(dict->dict, 0, size * sizeof(xmlDictEntry));

	imul	eax, DWORD PTR _size$[ebp], 20
	push	eax
	push	0
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 695  :     dict->size = size;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 696  : 
; 697  :     /*	If the two loops are merged, there would be situations where
; 698  : 	a new entry needs to allocated and data copied into it from
; 699  : 	the main dict. It is nicer to run through the array twice, first
; 700  : 	copying all the elements in the main array (less probability of
; 701  : 	allocate) and then the rest, so we only free in the second loop.
; 702  :     */
; 703  :     for (i = 0; i < oldsize; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlDictGro
$LN2@xmlDictGro:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@xmlDictGro:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _oldsize$[ebp]
	jae	$LN3@xmlDictGro

; 704  : 	if (olddict[i].valid == 0)

	imul	ecx, DWORD PTR _i$[ebp], 20
	mov	edx, DWORD PTR _olddict$[ebp]
	cmp	DWORD PTR [edx+ecx+12], 0
	jne	SHORT $LN16@xmlDictGro

; 705  : 	    continue;

	jmp	SHORT $LN2@xmlDictGro
$LN16@xmlDictGro:

; 706  : 
; 707  : 	if (keep_keys)

	cmp	DWORD PTR _keep_keys$[ebp], 0
	je	SHORT $LN17@xmlDictGro

; 708  : 	    okey = olddict[i].okey;

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _olddict$[ebp]
	mov	edx, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR _okey$[ebp], edx
	jmp	SHORT $LN18@xmlDictGro
$LN17@xmlDictGro:

; 709  : 	else
; 710  : 	    okey = xmlDictComputeKey(dict, olddict[i].name, olddict[i].len);

	mov	eax, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [eax+8], 128			; 00000080H
	jne	SHORT $LN28@xmlDictGro
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _olddict$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _olddict$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	push	edx
	call	_xmlDictComputeFastKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $LN29@xmlDictGro
$LN28@xmlDictGro:
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 20
	mov	eax, DWORD PTR _olddict$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 20
	mov	eax, DWORD PTR _olddict$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	_xmlDictComputeBigKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv150[ebp], eax
$LN29@xmlDictGro:
	mov	edx, DWORD PTR tv150[ebp]
	mov	DWORD PTR _okey$[ebp], edx
$LN18@xmlDictGro:

; 711  : 	key = okey % dict->size;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _okey$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR _key$[ebp], edx

; 712  : 
; 713  : 	if (dict->dict[key].valid == 0) {

	imul	edx, DWORD PTR _key$[ebp], 20
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+edx+12], 0
	jne	SHORT $LN19@xmlDictGro

; 714  : 	    memcpy(&(dict->dict[key]), &(olddict[i]), sizeof(xmlDictEntry));

	imul	edx, DWORD PTR _i$[ebp], 20
	add	edx, DWORD PTR _olddict$[ebp]
	imul	eax, DWORD PTR _key$[ebp], 20
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], edx

; 715  : 	    dict->dict[key].next = NULL;

	imul	eax, DWORD PTR _key$[ebp], 20
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax], 0

; 716  : 	    dict->dict[key].okey = okey;

	imul	eax, DWORD PTR _key$[ebp], 20
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _okey$[ebp]
	mov	DWORD PTR [edx+eax+16], ecx

; 717  : 	} else {

	jmp	SHORT $LN20@xmlDictGro
$LN19@xmlDictGro:

; 718  : 	    xmlDictEntryPtr entry;
; 719  : 
; 720  : 	    entry = xmlMalloc(sizeof(xmlDictEntry));

	mov	esi, esp
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _entry$1[ebp], eax

; 721  : 	    if (entry != NULL) {

	cmp	DWORD PTR _entry$1[ebp], 0
	je	SHORT $LN21@xmlDictGro

; 722  : 		entry->name = olddict[i].name;

	imul	edx, DWORD PTR _i$[ebp], 20
	mov	eax, DWORD PTR _entry$1[ebp]
	mov	ecx, DWORD PTR _olddict$[ebp]
	mov	edx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR [eax+4], edx

; 723  : 		entry->len = olddict[i].len;

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _entry$1[ebp]
	mov	edx, DWORD PTR _olddict$[ebp]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [ecx+8], eax

; 724  : 		entry->okey = okey;

	mov	ecx, DWORD PTR _entry$1[ebp]
	mov	edx, DWORD PTR _okey$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 725  : 		entry->next = dict->dict[key].next;

	imul	eax, DWORD PTR _key$[ebp], 20
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _entry$1[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx], edx

; 726  : 		entry->valid = 1;

	mov	eax, DWORD PTR _entry$1[ebp]
	mov	DWORD PTR [eax+12], 1

; 727  : 		dict->dict[key].next = entry;

	imul	ecx, DWORD PTR _key$[ebp], 20
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _entry$1[ebp]
	mov	DWORD PTR [eax+ecx], edx

; 728  : 	    } else {

	jmp	SHORT $LN20@xmlDictGro
$LN21@xmlDictGro:

; 729  : 	        /*
; 730  : 		 * we don't have much ways to alert from herei
; 731  : 		 * result is losing an entry and unicity guarantee
; 732  : 		 */
; 733  : 	        ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
$LN20@xmlDictGro:

; 734  : 	    }
; 735  : 	}
; 736  : #ifdef DEBUG_GROW
; 737  : 	nbElem++;
; 738  : #endif
; 739  :     }

	jmp	$LN2@xmlDictGro
$LN3@xmlDictGro:

; 740  : 
; 741  :     for (i = 0; i < oldsize; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@xmlDictGro
$LN5@xmlDictGro:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@xmlDictGro:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _oldsize$[ebp]
	jae	$LN6@xmlDictGro

; 742  : 	iter = olddict[i].next;

	imul	edx, DWORD PTR _i$[ebp], 20
	mov	eax, DWORD PTR _olddict$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR _iter$[ebp], ecx
$LN8@xmlDictGro:

; 743  : 	while (iter) {

	cmp	DWORD PTR _iter$[ebp], 0
	je	$LN9@xmlDictGro

; 744  : 	    next = iter->next;

	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _next$[ebp], eax

; 745  : 
; 746  : 	    /*
; 747  : 	     * put back the entry in the new dict
; 748  : 	     */
; 749  : 
; 750  : 	    if (keep_keys)

	cmp	DWORD PTR _keep_keys$[ebp], 0
	je	SHORT $LN23@xmlDictGro

; 751  : 		okey = iter->okey;

	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _okey$[ebp], edx
	jmp	SHORT $LN24@xmlDictGro
$LN23@xmlDictGro:

; 752  : 	    else
; 753  : 		okey = xmlDictComputeKey(dict, iter->name, iter->len);

	mov	eax, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [eax+8], 128			; 00000080H
	jne	SHORT $LN30@xmlDictGro
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_xmlDictComputeFastKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv223[ebp], eax
	jmp	SHORT $LN31@xmlDictGro
$LN30@xmlDictGro:
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_xmlDictComputeBigKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv223[ebp], eax
$LN31@xmlDictGro:
	mov	ecx, DWORD PTR tv223[ebp]
	mov	DWORD PTR _okey$[ebp], ecx
$LN24@xmlDictGro:

; 754  : 	    key = okey % dict->size;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _okey$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR _key$[ebp], edx

; 755  : 	    if (dict->dict[key].valid == 0) {

	imul	edx, DWORD PTR _key$[ebp], 20
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+edx+12], 0
	jne	SHORT $LN25@xmlDictGro

; 756  : 		memcpy(&(dict->dict[key]), iter, sizeof(xmlDictEntry));

	imul	edx, DWORD PTR _key$[ebp], 20
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	mov	edx, DWORD PTR _iter$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], edx

; 757  : 		dict->dict[key].next = NULL;

	imul	eax, DWORD PTR _key$[ebp], 20
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax], 0

; 758  : 		dict->dict[key].valid = 1;

	imul	eax, DWORD PTR _key$[ebp], 20
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax+12], 1

; 759  : 		dict->dict[key].okey = okey;

	imul	eax, DWORD PTR _key$[ebp], 20
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _okey$[ebp]
	mov	DWORD PTR [edx+eax+16], ecx

; 760  : 		xmlFree(iter);

	mov	esi, esp
	mov	edx, DWORD PTR _iter$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 761  : 	    } else {

	jmp	SHORT $LN26@xmlDictGro
$LN25@xmlDictGro:

; 762  : 		iter->next = dict->dict[key].next;

	imul	eax, DWORD PTR _key$[ebp], 20
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _iter$[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx], edx

; 763  : 		iter->okey = okey;

	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR _okey$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 764  : 		dict->dict[key].next = iter;

	imul	edx, DWORD PTR _key$[ebp], 20
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _iter$[ebp]
	mov	DWORD PTR [ecx+edx], eax
$LN26@xmlDictGro:

; 765  : 	    }
; 766  : 
; 767  : #ifdef DEBUG_GROW
; 768  : 	    nbElem++;
; 769  : #endif
; 770  : 
; 771  : 	    iter = next;

	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _iter$[ebp], ecx

; 772  : 	}

	jmp	$LN8@xmlDictGro
$LN9@xmlDictGro:

; 773  :     }

	jmp	$LN5@xmlDictGro
$LN6@xmlDictGro:

; 774  : 
; 775  :     xmlFree(olddict);

	mov	esi, esp
	mov	edx, DWORD PTR _olddict$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 776  : 
; 777  : #ifdef DEBUG_GROW
; 778  :     xmlGenericError(xmlGenericErrorContext,
; 779  : 	    "xmlDictGrow : from %lu to %lu, %u elems\n", oldsize, size, nbElem);
; 780  : #endif
; 781  : 
; 782  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlDictGro:

; 783  : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictGrow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictComputeFastQKey
_TEXT	SEGMENT
tv159 = -16						; size = 4
tv80 = -12						; size = 4
_offset$1 = -8						; size = 4
_value$ = -4						; size = 4
_prefix$ = 8						; size = 4
_plen$ = 12						; size = 4
_name$ = 16						; size = 4
_len$ = 20						; size = 4
_seed$ = 24						; size = 4
_xmlDictComputeFastQKey PROC				; COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 490  :     unsigned long value = (unsigned long) seed;

	mov	eax, DWORD PTR _seed$[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 491  : 
; 492  :     if (plen == 0)

	cmp	DWORD PTR _plen$[ebp], 0
	jne	SHORT $LN6@xmlDictCom

; 493  : 	value += 30 * (unsigned long) ':';

	mov	ecx, DWORD PTR _value$[ebp]
	add	ecx, 1740				; 000006ccH
	mov	DWORD PTR _value$[ebp], ecx
	jmp	SHORT $LN7@xmlDictCom
$LN6@xmlDictCom:

; 494  :     else
; 495  : 	value += 30 * (*prefix);

	mov	edx, DWORD PTR _prefix$[ebp]
	movzx	eax, BYTE PTR [edx]
	imul	ecx, eax, 30
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN7@xmlDictCom:

; 496  : 
; 497  :     if (len > 10) {

	cmp	DWORD PTR _len$[ebp], 10		; 0000000aH
	jle	SHORT $LN8@xmlDictCom

; 498  :         int offset = len - (plen + 1 + 1);

	mov	edx, DWORD PTR _plen$[ebp]
	add	edx, 2
	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, edx
	mov	DWORD PTR _offset$1[ebp], eax

; 499  : 	if (offset < 0)

	jns	SHORT $LN9@xmlDictCom

; 500  : 	    offset = len - (10 + 1);

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 11					; 0000000bH
	mov	DWORD PTR _offset$1[ebp], ecx
$LN9@xmlDictCom:

; 501  : 	value += name[offset];

	mov	edx, DWORD PTR _name$[ebp]
	add	edx, DWORD PTR _offset$1[ebp]
	movzx	eax, BYTE PTR [edx]
	add	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 502  :         len = 10;

	mov	DWORD PTR _len$[ebp], 10		; 0000000aH

; 503  : 	if (plen > 10)

	cmp	DWORD PTR _plen$[ebp], 10		; 0000000aH
	jle	SHORT $LN8@xmlDictCom

; 504  : 	    plen = 10;

	mov	DWORD PTR _plen$[ebp], 10		; 0000000aH
$LN8@xmlDictCom:

; 505  :     }
; 506  :     switch (plen) {

	mov	ecx, DWORD PTR _plen$[ebp]
	mov	DWORD PTR tv80[ebp], ecx
	mov	edx, DWORD PTR tv80[ebp]
	sub	edx, 1
	mov	DWORD PTR tv80[ebp], edx
	cmp	DWORD PTR tv80[ebp], 9
	ja	$LN2@xmlDictCom
	mov	eax, DWORD PTR tv80[ebp]
	jmp	DWORD PTR $LN35@xmlDictCom[eax*4]
$LN11@xmlDictCom:

; 507  :         case 10: value += prefix[9];

	mov	ecx, 1
	imul	edx, ecx, 9
	mov	eax, DWORD PTR _prefix$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN12@xmlDictCom:

; 508  :         /* Falls through. */
; 509  :         case 9: value += prefix[8];

	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR _prefix$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN13@xmlDictCom:

; 510  :         /* Falls through. */
; 511  :         case 8: value += prefix[7];

	mov	edx, 1
	imul	eax, edx, 7
	mov	ecx, DWORD PTR _prefix$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN14@xmlDictCom:

; 512  :         /* Falls through. */
; 513  :         case 7: value += prefix[6];

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _prefix$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	add	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN15@xmlDictCom:

; 514  :         /* Falls through. */
; 515  :         case 6: value += prefix[5];

	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _prefix$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN16@xmlDictCom:

; 516  :         /* Falls through. */
; 517  :         case 5: value += prefix[4];

	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _prefix$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN17@xmlDictCom:

; 518  :         /* Falls through. */
; 519  :         case 4: value += prefix[3];

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _prefix$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN18@xmlDictCom:

; 520  :         /* Falls through. */
; 521  :         case 3: value += prefix[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _prefix$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN19@xmlDictCom:

; 522  :         /* Falls through. */
; 523  :         case 2: value += prefix[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _prefix$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN20@xmlDictCom:

; 524  :         /* Falls through. */
; 525  :         case 1: value += prefix[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _prefix$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	add	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN2@xmlDictCom:

; 526  :         /* Falls through. */
; 527  :         default: break;
; 528  :     }
; 529  :     len -= plen;

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, DWORD PTR _plen$[ebp]
	mov	DWORD PTR _len$[ebp], ecx

; 530  :     if (len > 0) {

	cmp	DWORD PTR _len$[ebp], 0
	jle	SHORT $LN22@xmlDictCom

; 531  :         value += (unsigned long) ':';

	mov	edx, DWORD PTR _value$[ebp]
	add	edx, 58					; 0000003aH
	mov	DWORD PTR _value$[ebp], edx

; 532  : 	len--;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _len$[ebp], eax
$LN22@xmlDictCom:

; 533  :     }
; 534  :     switch (len) {

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv159[ebp], ecx
	mov	edx, DWORD PTR tv159[ebp]
	sub	edx, 1
	mov	DWORD PTR tv159[ebp], edx
	cmp	DWORD PTR tv159[ebp], 9
	ja	$LN4@xmlDictCom
	mov	eax, DWORD PTR tv159[ebp]
	jmp	DWORD PTR $LN36@xmlDictCom[eax*4]
$LN23@xmlDictCom:

; 535  :         case 10: value += name[9];

	mov	ecx, 1
	imul	edx, ecx, 9
	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN24@xmlDictCom:

; 536  :         /* Falls through. */
; 537  :         case 9: value += name[8];

	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN25@xmlDictCom:

; 538  :         /* Falls through. */
; 539  :         case 8: value += name[7];

	mov	edx, 1
	imul	eax, edx, 7
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN26@xmlDictCom:

; 540  :         /* Falls through. */
; 541  :         case 7: value += name[6];

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	add	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN27@xmlDictCom:

; 542  :         /* Falls through. */
; 543  :         case 6: value += name[5];

	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN28@xmlDictCom:

; 544  :         /* Falls through. */
; 545  :         case 5: value += name[4];

	mov	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN29@xmlDictCom:

; 546  :         /* Falls through. */
; 547  :         case 4: value += name[3];

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN30@xmlDictCom:

; 548  :         /* Falls through. */
; 549  :         case 3: value += name[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN31@xmlDictCom:

; 550  :         /* Falls through. */
; 551  :         case 2: value += name[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN32@xmlDictCom:

; 552  :         /* Falls through. */
; 553  :         case 1: value += name[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	add	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN4@xmlDictCom:

; 554  :         /* Falls through. */
; 555  :         default: break;
; 556  :     }
; 557  :     return(value);

	mov	eax, DWORD PTR _value$[ebp]

; 558  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN35@xmlDictCom:
	DD	$LN20@xmlDictCom
	DD	$LN19@xmlDictCom
	DD	$LN18@xmlDictCom
	DD	$LN17@xmlDictCom
	DD	$LN16@xmlDictCom
	DD	$LN15@xmlDictCom
	DD	$LN14@xmlDictCom
	DD	$LN13@xmlDictCom
	DD	$LN12@xmlDictCom
	DD	$LN11@xmlDictCom
$LN36@xmlDictCom:
	DD	$LN32@xmlDictCom
	DD	$LN31@xmlDictCom
	DD	$LN30@xmlDictCom
	DD	$LN29@xmlDictCom
	DD	$LN28@xmlDictCom
	DD	$LN27@xmlDictCom
	DD	$LN26@xmlDictCom
	DD	$LN25@xmlDictCom
	DD	$LN24@xmlDictCom
	DD	$LN23@xmlDictCom
_xmlDictComputeFastQKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictComputeFastKey
_TEXT	SEGMENT
tv73 = -8						; size = 4
_value$ = -4						; size = 4
_name$ = 8						; size = 4
_namelen$ = 12						; size = 4
_seed$ = 16						; size = 4
_xmlDictComputeFastKey PROC				; COMDAT

; 444  : xmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 445  :     unsigned long value = seed;

	mov	eax, DWORD PTR _seed$[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 446  : 
; 447  :     if (name == NULL) return(0);

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN4@xmlDictCom
	xor	eax, eax
	jmp	$LN1@xmlDictCom
$LN4@xmlDictCom:

; 448  :     value = *name;

	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _value$[ebp], edx

; 449  :     value <<= 5;

	mov	eax, DWORD PTR _value$[ebp]
	shl	eax, 5
	mov	DWORD PTR _value$[ebp], eax

; 450  :     if (namelen > 10) {

	cmp	DWORD PTR _namelen$[ebp], 10		; 0000000aH
	jle	SHORT $LN5@xmlDictCom

; 451  :         value += name[namelen - 1];

	mov	ecx, DWORD PTR _name$[ebp]
	add	ecx, DWORD PTR _namelen$[ebp]
	movzx	edx, BYTE PTR [ecx-1]
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx

; 452  :         namelen = 10;

	mov	DWORD PTR _namelen$[ebp], 10		; 0000000aH
$LN5@xmlDictCom:

; 453  :     }
; 454  :     switch (namelen) {

	mov	eax, DWORD PTR _namelen$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv73[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 8
	ja	$LN2@xmlDictCom
	mov	edx, DWORD PTR tv73[ebp]
	jmp	DWORD PTR $LN17@xmlDictCom[edx*4]
$LN6@xmlDictCom:

; 455  :         case 10: value += name[9];

	mov	eax, 1
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	add	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN7@xmlDictCom:

; 456  :         /* Falls through. */
; 457  :         case 9: value += name[8];

	mov	ecx, 1
	shl	ecx, 3
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	add	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN8@xmlDictCom:

; 458  :         /* Falls through. */
; 459  :         case 8: value += name[7];

	mov	ecx, 1
	imul	edx, ecx, 7
	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN9@xmlDictCom:

; 460  :         /* Falls through. */
; 461  :         case 7: value += name[6];

	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], edx
$LN10@xmlDictCom:

; 462  :         /* Falls through. */
; 463  :         case 6: value += name[5];

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	add	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN11@xmlDictCom:

; 464  :         /* Falls through. */
; 465  :         case 5: value += name[4];

	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _name$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	add	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], eax
$LN12@xmlDictCom:

; 466  :         /* Falls through. */
; 467  :         case 4: value += name[3];

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN13@xmlDictCom:

; 468  :         /* Falls through. */
; 469  :         case 3: value += name[2];

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN14@xmlDictCom:

; 470  :         /* Falls through. */
; 471  :         case 2: value += name[1];

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _name$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	add	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN2@xmlDictCom:

; 472  :         /* Falls through. */
; 473  :         default: break;
; 474  :     }
; 475  :     return(value);

	mov	eax, DWORD PTR _value$[ebp]
$LN1@xmlDictCom:

; 476  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@xmlDictCom:
	DD	$LN14@xmlDictCom
	DD	$LN13@xmlDictCom
	DD	$LN12@xmlDictCom
	DD	$LN11@xmlDictCom
	DD	$LN10@xmlDictCom
	DD	$LN9@xmlDictCom
	DD	$LN8@xmlDictCom
	DD	$LN7@xmlDictCom
	DD	$LN6@xmlDictCom
_xmlDictComputeFastKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictComputeBigQKey
_TEXT	SEGMENT
_i$ = -8						; size = 4
_hash$ = -4						; size = 4
_prefix$ = 8						; size = 4
_plen$ = 12						; size = 4
_name$ = 16						; size = 4
_len$ = 20						; size = 4
_seed$ = 24						; size = 4
_xmlDictComputeBigQKey PROC				; COMDAT

; 409  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 410  :     uint32_t hash;
; 411  :     int i;
; 412  : 
; 413  :     hash = seed;

	mov	eax, DWORD PTR _seed$[ebp]
	mov	DWORD PTR _hash$[ebp], eax

; 414  : 
; 415  :     for (i = 0;i < plen; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlDictCom
$LN2@xmlDictCom:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlDictCom:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _plen$[ebp]
	jge	SHORT $LN3@xmlDictCom

; 416  :         hash += prefix[i];

	mov	eax, DWORD PTR _prefix$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], ecx

; 417  : 	hash += (hash << 10);

	mov	edx, DWORD PTR _hash$[ebp]
	shl	edx, 10					; 0000000aH
	add	edx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], edx

; 418  : 	hash ^= (hash >> 6);

	mov	eax, DWORD PTR _hash$[ebp]
	shr	eax, 6
	xor	eax, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], eax

; 419  :     }

	jmp	SHORT $LN2@xmlDictCom
$LN3@xmlDictCom:

; 420  :     hash += ':';

	mov	ecx, DWORD PTR _hash$[ebp]
	add	ecx, 58					; 0000003aH
	mov	DWORD PTR _hash$[ebp], ecx

; 421  :     hash += (hash << 10);

	mov	edx, DWORD PTR _hash$[ebp]
	shl	edx, 10					; 0000000aH
	add	edx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], edx

; 422  :     hash ^= (hash >> 6);

	mov	eax, DWORD PTR _hash$[ebp]
	shr	eax, 6
	xor	eax, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], eax

; 423  : 
; 424  :     for (i = 0;i < len; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@xmlDictCom
$LN5@xmlDictCom:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@xmlDictCom:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jge	SHORT $LN6@xmlDictCom

; 425  :         hash += name[i];

	mov	eax, DWORD PTR _name$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], ecx

; 426  : 	hash += (hash << 10);

	mov	edx, DWORD PTR _hash$[ebp]
	shl	edx, 10					; 0000000aH
	add	edx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], edx

; 427  : 	hash ^= (hash >> 6);

	mov	eax, DWORD PTR _hash$[ebp]
	shr	eax, 6
	xor	eax, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], eax

; 428  :     }

	jmp	SHORT $LN5@xmlDictCom
$LN6@xmlDictCom:

; 429  :     hash += (hash << 3);

	mov	ecx, DWORD PTR _hash$[ebp]
	mov	edx, DWORD PTR _hash$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _hash$[ebp], eax

; 430  :     hash ^= (hash >> 11);

	mov	ecx, DWORD PTR _hash$[ebp]
	shr	ecx, 11					; 0000000bH
	xor	ecx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], ecx

; 431  :     hash += (hash << 15);

	mov	edx, DWORD PTR _hash$[ebp]
	shl	edx, 15					; 0000000fH
	add	edx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], edx

; 432  : 
; 433  :     return hash;

	mov	eax, DWORD PTR _hash$[ebp]

; 434  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictComputeBigQKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictComputeBigKey
_TEXT	SEGMENT
_i$ = -8						; size = 4
_hash$ = -4						; size = 4
_data$ = 8						; size = 4
_namelen$ = 12						; size = 4
_seed$ = 16						; size = 4
_xmlDictComputeBigKey PROC				; COMDAT

; 375  : xmlDictComputeBigKey(const xmlChar* data, int namelen, int seed) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 376  :     uint32_t hash;
; 377  :     int i;
; 378  : 
; 379  :     if (namelen <= 0 || data == NULL) return(0);

	cmp	DWORD PTR _namelen$[ebp], 0
	jle	SHORT $LN6@xmlDictCom
	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN5@xmlDictCom
$LN6@xmlDictCom:
	xor	eax, eax
	jmp	SHORT $LN1@xmlDictCom
$LN5@xmlDictCom:

; 380  : 
; 381  :     hash = seed;

	mov	eax, DWORD PTR _seed$[ebp]
	mov	DWORD PTR _hash$[ebp], eax

; 382  : 
; 383  :     for (i = 0;i < namelen; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlDictCom
$LN2@xmlDictCom:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlDictCom:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _namelen$[ebp]
	jge	SHORT $LN3@xmlDictCom

; 384  :         hash += data[i];

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], ecx

; 385  : 	hash += (hash << 10);

	mov	edx, DWORD PTR _hash$[ebp]
	shl	edx, 10					; 0000000aH
	add	edx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], edx

; 386  : 	hash ^= (hash >> 6);

	mov	eax, DWORD PTR _hash$[ebp]
	shr	eax, 6
	xor	eax, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], eax

; 387  :     }

	jmp	SHORT $LN2@xmlDictCom
$LN3@xmlDictCom:

; 388  :     hash += (hash << 3);

	mov	ecx, DWORD PTR _hash$[ebp]
	mov	edx, DWORD PTR _hash$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _hash$[ebp], eax

; 389  :     hash ^= (hash >> 11);

	mov	ecx, DWORD PTR _hash$[ebp]
	shr	ecx, 11					; 0000000bH
	xor	ecx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], ecx

; 390  :     hash += (hash << 15);

	mov	edx, DWORD PTR _hash$[ebp]
	shl	edx, 15					; 0000000fH
	add	edx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], edx

; 391  : 
; 392  :     return hash;

	mov	eax, DWORD PTR _hash$[ebp]
$LN1@xmlDictCom:

; 393  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictComputeBigKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictAddQString
_TEXT	SEGMENT
_limit$ = -16						; size = 4
_size$ = -12						; size = 4
_ret$ = -8						; size = 4
_pool$ = -4						; size = 4
_dict$ = 8						; size = 4
_prefix$ = 12						; size = 4
_plen$ = 16						; size = 4
_name$ = 20						; size = 4
_namelen$ = 24						; size = 4
_xmlDictAddQString PROC					; COMDAT

; 307  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 308  :     xmlDictStringsPtr pool;
; 309  :     const xmlChar *ret;
; 310  :     size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */

	mov	DWORD PTR _size$[ebp], 0

; 311  :     size_t limit = 0;

	mov	DWORD PTR _limit$[ebp], 0

; 312  : 
; 313  :     if (prefix == NULL) return(xmlDictAddString(dict, name, namelen));

	cmp	DWORD PTR _prefix$[ebp], 0
	jne	SHORT $LN4@xmlDictAdd
	mov	eax, DWORD PTR _namelen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	call	_xmlDictAddString
	add	esp, 12					; 0000000cH
	jmp	$LN1@xmlDictAdd
$LN4@xmlDictAdd:

; 314  : 
; 315  : #ifdef DICT_DEBUG_PATTERNS
; 316  :     fprintf(stderr, "=");
; 317  : #endif
; 318  :     pool = dict->strings;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pool$[ebp], ecx
$LN2@xmlDictAdd:

; 319  :     while (pool != NULL) {

	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN3@xmlDictAdd

; 320  : 	if ((size_t)(pool->end - pool->free) > namelen + plen + 1)

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _plen$[ebp]
	mov	eax, DWORD PTR _namelen$[ebp]
	lea	edx, DWORD PTR [eax+edx+1]
	cmp	ecx, edx
	jbe	SHORT $LN5@xmlDictAdd

; 321  : 	    goto found_pool;

	jmp	$found_pool$14
$LN5@xmlDictAdd:

; 322  : 	if (pool->size > size) size = pool->size;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _size$[ebp]
	jbe	SHORT $LN6@xmlDictAdd
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _size$[ebp], eax
$LN6@xmlDictAdd:

; 323  :         limit += pool->size;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR _limit$[ebp]
	add	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _limit$[ebp], edx

; 324  : 	pool = pool->next;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pool$[ebp], ecx

; 325  :     }

	jmp	SHORT $LN2@xmlDictAdd
$LN3@xmlDictAdd:

; 326  :     /*
; 327  :      * Not found, need to allocate
; 328  :      */
; 329  :     if (pool == NULL) {

	cmp	DWORD PTR _pool$[ebp], 0
	jne	$found_pool$14

; 330  :         if ((dict->limit > 0) && (limit > dict->limit)) {

	mov	edx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jbe	SHORT $LN8@xmlDictAdd
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR _limit$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jbe	SHORT $LN8@xmlDictAdd

; 331  :             return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictAdd
$LN8@xmlDictAdd:

; 332  :         }
; 333  : 
; 334  :         if (size == 0) size = 1000;

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN9@xmlDictAdd
	mov	DWORD PTR _size$[ebp], 1000		; 000003e8H
	jmp	SHORT $LN10@xmlDictAdd
$LN9@xmlDictAdd:

; 335  : 	else size *= 4; /* exponential growth */

	mov	edx, DWORD PTR _size$[ebp]
	shl	edx, 2
	mov	DWORD PTR _size$[ebp], edx
$LN10@xmlDictAdd:

; 336  :         if (size < 4 * (namelen + plen + 1))

	mov	eax, DWORD PTR _namelen$[ebp]
	add	eax, DWORD PTR _plen$[ebp]
	lea	ecx, DWORD PTR [eax*4+4]
	cmp	DWORD PTR _size$[ebp], ecx
	jae	SHORT $LN11@xmlDictAdd

; 337  : 	    size = 4 * (namelen + plen + 1); /* just in case ! */

	mov	edx, DWORD PTR _namelen$[ebp]
	add	edx, DWORD PTR _plen$[ebp]
	lea	eax, DWORD PTR [edx*4+4]
	mov	DWORD PTR _size$[ebp], eax
$LN11@xmlDictAdd:

; 338  : 	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 24					; 00000018H
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pool$[ebp], eax

; 339  : 	if (pool == NULL)

	cmp	DWORD PTR _pool$[ebp], 0
	jne	SHORT $LN12@xmlDictAdd

; 340  : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictAdd
$LN12@xmlDictAdd:

; 341  : 	pool->size = size;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+12], eax

; 342  : 	pool->nbStrings = 0;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 343  : 	pool->free = &pool->array[0];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pool$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+4], edx

; 344  : 	pool->end = &pool->array[size];

	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _pool$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 345  : 	pool->next = dict->strings;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx], ecx

; 346  : 	dict->strings = pool;

	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+16], eax
$found_pool$14:

; 347  : #ifdef DICT_DEBUG_PATTERNS
; 348  :         fprintf(stderr, "+");
; 349  : #endif
; 350  :     }
; 351  : found_pool:
; 352  :     ret = pool->free;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _ret$[ebp], edx

; 353  :     memcpy(pool->free, prefix, plen);

	mov	eax, DWORD PTR _plen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 354  :     pool->free += plen;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _plen$[ebp]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+4], edx

; 355  :     *(pool->free++) = ':';

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx], 58			; 0000003aH
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 356  :     memcpy(pool->free, name, namelen);

	mov	eax, DWORD PTR _namelen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 357  :     pool->free += namelen;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _namelen$[ebp]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+4], edx

; 358  :     *(pool->free++) = 0;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  :     pool->nbStrings++;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 360  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlDictAdd:

; 361  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictAddQString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictAddString
_TEXT	SEGMENT
_limit$ = -16						; size = 4
_size$ = -12						; size = 4
_ret$ = -8						; size = 4
_pool$ = -4						; size = 4
_dict$ = 8						; size = 4
_name$ = 12						; size = 4
_namelen$ = 16						; size = 4
_xmlDictAddString PROC					; COMDAT

; 241  : xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 242  :     xmlDictStringsPtr pool;
; 243  :     const xmlChar *ret;
; 244  :     size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */

	mov	DWORD PTR _size$[ebp], 0

; 245  :     size_t limit = 0;

	mov	DWORD PTR _limit$[ebp], 0

; 246  : 
; 247  : #ifdef DICT_DEBUG_PATTERNS
; 248  :     fprintf(stderr, "-");
; 249  : #endif
; 250  :     pool = dict->strings;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pool$[ebp], ecx
$LN2@xmlDictAdd:

; 251  :     while (pool != NULL) {

	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN3@xmlDictAdd

; 252  : 	if ((size_t)(pool->end - pool->free) > namelen)

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _namelen$[ebp]
	jbe	SHORT $LN4@xmlDictAdd

; 253  : 	    goto found_pool;

	jmp	$found_pool$13
$LN4@xmlDictAdd:

; 254  : 	if (pool->size > size) size = pool->size;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _size$[ebp]
	jbe	SHORT $LN5@xmlDictAdd
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _size$[ebp], edx
$LN5@xmlDictAdd:

; 255  :         limit += pool->size;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _limit$[ebp]
	add	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _limit$[ebp], ecx

; 256  : 	pool = pool->next;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pool$[ebp], eax

; 257  :     }

	jmp	SHORT $LN2@xmlDictAdd
$LN3@xmlDictAdd:

; 258  :     /*
; 259  :      * Not found, need to allocate
; 260  :      */
; 261  :     if (pool == NULL) {

	cmp	DWORD PTR _pool$[ebp], 0
	jne	$found_pool$13

; 262  :         if ((dict->limit > 0) && (limit > dict->limit)) {

	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jbe	SHORT $LN7@xmlDictAdd
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _limit$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jbe	SHORT $LN7@xmlDictAdd

; 263  :             return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictAdd
$LN7@xmlDictAdd:

; 264  :         }
; 265  : 
; 266  :         if (size == 0) size = 1000;

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN8@xmlDictAdd
	mov	DWORD PTR _size$[ebp], 1000		; 000003e8H
	jmp	SHORT $LN9@xmlDictAdd
$LN8@xmlDictAdd:

; 267  : 	else size *= 4; /* exponential growth */

	mov	ecx, DWORD PTR _size$[ebp]
	shl	ecx, 2
	mov	DWORD PTR _size$[ebp], ecx
$LN9@xmlDictAdd:

; 268  :         if (size < 4 * namelen)

	mov	edx, DWORD PTR _namelen$[ebp]
	shl	edx, 2
	cmp	DWORD PTR _size$[ebp], edx
	jae	SHORT $LN10@xmlDictAdd

; 269  : 	    size = 4 * namelen; /* just in case ! */

	mov	eax, DWORD PTR _namelen$[ebp]
	shl	eax, 2
	mov	DWORD PTR _size$[ebp], eax
$LN10@xmlDictAdd:

; 270  : 	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 24					; 00000018H
	mov	esi, esp
	push	ecx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pool$[ebp], eax

; 271  : 	if (pool == NULL)

	cmp	DWORD PTR _pool$[ebp], 0
	jne	SHORT $LN11@xmlDictAdd

; 272  : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictAdd
$LN11@xmlDictAdd:

; 273  : 	pool->size = size;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+12], eax

; 274  : 	pool->nbStrings = 0;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 275  : 	pool->free = &pool->array[0];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pool$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+4], edx

; 276  : 	pool->end = &pool->array[size];

	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _pool$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 277  : 	pool->next = dict->strings;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx], ecx

; 278  : 	dict->strings = pool;

	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+16], eax
$found_pool$13:

; 279  : #ifdef DICT_DEBUG_PATTERNS
; 280  :         fprintf(stderr, "+");
; 281  : #endif
; 282  :     }
; 283  : found_pool:
; 284  :     ret = pool->free;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _ret$[ebp], edx

; 285  :     memcpy(pool->free, name, namelen);

	mov	eax, DWORD PTR _namelen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 286  :     pool->free += namelen;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _namelen$[ebp]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+4], edx

; 287  :     *(pool->free++) = 0;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 288  :     pool->nbStrings++;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 289  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlDictAdd:

; 290  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictAddString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictCleanup
_TEXT	SEGMENT
_xmlDictCleanup PROC					; COMDAT

; 221  : xmlDictCleanup(void) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 222  :     if (!xmlDictInitialized)

	cmp	DWORD PTR _xmlDictInitialized, 0
	jne	SHORT $LN2@xmlDictCle

; 223  :         return;

	jmp	SHORT $LN1@xmlDictCle
$LN2@xmlDictCle:

; 224  : 
; 225  :     xmlFreeRMutex(xmlDictMutex);

	mov	eax, DWORD PTR _xmlDictMutex
	push	eax
	call	_xmlFreeRMutex
	add	esp, 4

; 226  : 
; 227  :     xmlDictInitialized = 0;

	mov	DWORD PTR _xmlDictInitialized, 0
$LN1@xmlDictCle:

; 228  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDictCleanup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictSize
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_xmlDictSize PROC					; COMDAT

; 1237 : xmlDictSize(xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 1238 :     if (dict == NULL)

	cmp	DWORD PTR _dict$[ebp], 0
	jne	SHORT $LN2@xmlDictSiz

; 1239 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlDictSiz
$LN2@xmlDictSiz:

; 1240 :     if (dict->subdict)

	mov	eax, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN3@xmlDictSiz

; 1241 :         return(dict->nbElems + dict->subdict->nbElems);

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [eax+12]
	add	eax, DWORD PTR [edx+12]
	jmp	SHORT $LN1@xmlDictSiz
$LN3@xmlDictSiz:

; 1242 :     return(dict->nbElems);

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [ecx+12]
$LN1@xmlDictSiz:

; 1243 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDictSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictOwns
_TEXT	SEGMENT
_pool$ = -4						; size = 4
_dict$ = 8						; size = 4
_str$ = 12						; size = 4
_xmlDictOwns PROC					; COMDAT

; 1211 : xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 1212 :     xmlDictStringsPtr pool;
; 1213 : 
; 1214 :     if ((dict == NULL) || (str == NULL))

	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN5@xmlDictOwn
	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN4@xmlDictOwn
$LN5@xmlDictOwn:

; 1215 : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlDictOwn
$LN4@xmlDictOwn:

; 1216 :     pool = dict->strings;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pool$[ebp], ecx
$LN2@xmlDictOwn:

; 1217 :     while (pool != NULL) {

	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN3@xmlDictOwn

; 1218 :         if ((str >= &pool->array[0]) && (str <= pool->free))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pool$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	cmp	DWORD PTR _str$[ebp], edx
	jb	SHORT $LN6@xmlDictOwn
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _str$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	ja	SHORT $LN6@xmlDictOwn

; 1219 : 	    return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlDictOwn
$LN6@xmlDictOwn:

; 1220 : 	pool = pool->next;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pool$[ebp], eax

; 1221 :     }

	jmp	SHORT $LN2@xmlDictOwn
$LN3@xmlDictOwn:

; 1222 :     if (dict->subdict)

	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN7@xmlDictOwn

; 1223 :         return(xmlDictOwns(dict->subdict, str));

	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_xmlDictOwns
	add	esp, 8
	jmp	SHORT $LN1@xmlDictOwn
$LN7@xmlDictOwn:

; 1224 :     return(0);

	xor	eax, eax
$LN1@xmlDictOwn:

; 1225 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictOwns ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictQLookup
_TEXT	SEGMENT
tv227 = -100						; size = 4
tv228 = -96						; size = 4
tv207 = -92						; size = 4
tv141 = -88						; size = 4
tv142 = -84						; size = 4
tv92 = -80						; size = 4
tv76 = -76						; size = 4
tv345 = -69						; size = 1
tv342 = -68						; size = 4
tv339 = -64						; size = 4
tv73 = -60						; size = 4
tv332 = -53						; size = 1
tv329 = -52						; size = 4
tv326 = -48						; size = 4
_tmp$1 = -44						; size = 4
_skey$2 = -40						; size = 4
_l$ = -36						; size = 4
_plen$ = -32						; size = 4
_len$ = -28						; size = 4
_ret$ = -24						; size = 4
_insert$ = -20						; size = 4
_entry$ = -16						; size = 4
_nbi$ = -12						; size = 4
_key$ = -8						; size = 4
_okey$ = -4						; size = 4
_dict$ = 8						; size = 4
_prefix$ = 12						; size = 4
_name$ = 16						; size = 4
_xmlDictQLookup PROC					; COMDAT

; 1106 : xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 25					; 00000019H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 1107 :     unsigned long okey, key, nbi = 0;

	mov	DWORD PTR _nbi$[ebp], 0

; 1108 :     xmlDictEntryPtr entry;
; 1109 :     xmlDictEntryPtr insert;
; 1110 :     const xmlChar *ret;
; 1111 :     unsigned int len, plen, l;
; 1112 : 
; 1113 :     if ((dict == NULL) || (name == NULL))

	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN9@xmlDictQLo
	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN8@xmlDictQLo
$LN9@xmlDictQLo:

; 1114 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictQLo
$LN8@xmlDictQLo:

; 1115 :     if (prefix == NULL)

	cmp	DWORD PTR _prefix$[ebp], 0
	jne	SHORT $LN10@xmlDictQLo

; 1116 :         return(xmlDictLookup(dict, name, -1));

	push	-1
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dict$[ebp]
	push	ecx
	call	_xmlDictLookup
	add	esp, 12					; 0000000cH
	jmp	$LN1@xmlDictQLo
$LN10@xmlDictQLo:

; 1117 : 
; 1118 :     l = len = strlen((const char *) name);

	mov	edx, DWORD PTR _name$[ebp]
	mov	DWORD PTR tv326[ebp], edx
	mov	eax, DWORD PTR tv326[ebp]
	add	eax, 1
	mov	DWORD PTR tv329[ebp], eax
$LL42@xmlDictQLo:
	mov	ecx, DWORD PTR tv326[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv332[ebp], dl
	add	DWORD PTR tv326[ebp], 1
	cmp	BYTE PTR tv332[ebp], 0
	jne	SHORT $LL42@xmlDictQLo
	mov	eax, DWORD PTR tv326[ebp]
	sub	eax, DWORD PTR tv329[ebp]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _len$[ebp], ecx
	mov	edx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _l$[ebp], edx

; 1119 :     plen = strlen((const char *) prefix);

	mov	eax, DWORD PTR _prefix$[ebp]
	mov	DWORD PTR tv339[ebp], eax
	mov	ecx, DWORD PTR tv339[ebp]
	add	ecx, 1
	mov	DWORD PTR tv342[ebp], ecx
$LL43@xmlDictQLo:
	mov	edx, DWORD PTR tv339[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv345[ebp], al
	add	DWORD PTR tv339[ebp], 1
	cmp	BYTE PTR tv345[ebp], 0
	jne	SHORT $LL43@xmlDictQLo
	mov	ecx, DWORD PTR tv339[ebp]
	sub	ecx, DWORD PTR tv342[ebp]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _plen$[ebp], edx

; 1120 :     len += 1 + plen;

	mov	eax, DWORD PTR _plen$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _len$[ebp], edx

; 1121 : 
; 1122 :     /*
; 1123 :      * Check for duplicate and insertion location.
; 1124 :      */
; 1125 :     okey = xmlDictComputeQKey(dict, prefix, plen, name, l);

	cmp	DWORD PTR _prefix$[ebp], 0
	jne	SHORT $LN34@xmlDictQLo
	mov	eax, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [eax+8], 128			; 00000080H
	jne	SHORT $LN30@xmlDictQLo
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_xmlDictComputeFastKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN31@xmlDictQLo
$LN30@xmlDictQLo:
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlDictComputeBigKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv92[ebp], eax
$LN31@xmlDictQLo:
	mov	eax, DWORD PTR tv92[ebp]
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN35@xmlDictQLo
$LN34@xmlDictQLo:
	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx+8], 128			; 00000080H
	jne	SHORT $LN32@xmlDictQLo
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _plen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	call	_xmlDictComputeFastQKey
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv141[ebp], eax
	jmp	SHORT $LN33@xmlDictQLo
$LN32@xmlDictQLo:
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _plen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	call	_xmlDictComputeBigQKey
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv141[ebp], eax
$LN33@xmlDictQLo:
	mov	edx, DWORD PTR tv141[ebp]
	mov	DWORD PTR tv142[ebp], edx
$LN35@xmlDictQLo:
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR _okey$[ebp], eax

; 1126 :     key = okey % dict->size;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _okey$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR _key$[ebp], edx

; 1127 :     if (dict->dict[key].valid == 0) {

	imul	edx, DWORD PTR _key$[ebp], 20
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+edx+12], 0
	jne	SHORT $LN11@xmlDictQLo

; 1128 : 	insert = NULL;

	mov	DWORD PTR _insert$[ebp], 0

; 1129 :     } else {

	jmp	$LN12@xmlDictQLo
$LN11@xmlDictQLo:

; 1130 : 	for (insert = &(dict->dict[key]); insert->next != NULL;

	imul	edx, DWORD PTR _key$[ebp], 20
	mov	eax, DWORD PTR _dict$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _insert$[ebp], edx
	jmp	SHORT $LN4@xmlDictQLo
$LN2@xmlDictQLo:

; 1131 : 	     insert = insert->next) {

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _insert$[ebp], edx
$LN4@xmlDictQLo:

; 1130 : 	for (insert = &(dict->dict[key]); insert->next != NULL;

	mov	eax, DWORD PTR _insert$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlDictQLo

; 1132 : 	    if ((insert->okey == okey) && (insert->len == len) &&

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _okey$[ebp]
	jne	SHORT $LN13@xmlDictQLo
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _len$[ebp]
	jne	SHORT $LN13@xmlDictQLo
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN13@xmlDictQLo

; 1133 : 	        (xmlStrQEqual(prefix, name, insert->name)))
; 1134 : 		return(insert->name);

	mov	eax, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [eax+4]
	jmp	$LN1@xmlDictQLo
$LN13@xmlDictQLo:

; 1135 : 	    nbi++;

	mov	ecx, DWORD PTR _nbi$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbi$[ebp], ecx

; 1136 : 	}

	jmp	SHORT $LN2@xmlDictQLo
$LN3@xmlDictQLo:

; 1137 : 	if ((insert->okey == okey) && (insert->len == len) &&

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _okey$[ebp]
	jne	SHORT $LN12@xmlDictQLo
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _len$[ebp]
	jne	SHORT $LN12@xmlDictQLo
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _prefix$[ebp]
	push	eax
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@xmlDictQLo

; 1138 : 	    (xmlStrQEqual(prefix, name, insert->name)))
; 1139 : 	    return(insert->name);

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	jmp	$LN1@xmlDictQLo
$LN12@xmlDictQLo:

; 1140 :     }
; 1141 : 
; 1142 :     if (dict->subdict) {

	mov	edx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	$LN15@xmlDictQLo

; 1143 :         unsigned long skey;
; 1144 : 
; 1145 :         /* we cannot always reuse the same okey for the subdict */
; 1146 :         if (((dict->size == MIN_DICT_SIZE) &&
; 1147 : 	     (dict->subdict->size != MIN_DICT_SIZE)) ||

	mov	eax, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [eax+8], 128			; 00000080H
	jne	SHORT $LN19@xmlDictQLo
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+8], 128			; 00000080H
	jne	SHORT $LN18@xmlDictQLo
$LN19@xmlDictQLo:
	mov	eax, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [eax+8], 128			; 00000080H
	je	$LN16@xmlDictQLo
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+8], 128			; 00000080H
	jne	$LN16@xmlDictQLo
$LN18@xmlDictQLo:

; 1148 :             ((dict->size != MIN_DICT_SIZE) &&
; 1149 : 	     (dict->subdict->size == MIN_DICT_SIZE)))
; 1150 : 	    skey = xmlDictComputeQKey(dict->subdict, prefix, plen, name, l);

	cmp	DWORD PTR _prefix$[ebp], 0
	jne	SHORT $LN40@xmlDictQLo
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	DWORD PTR [ecx+8], 128			; 00000080H
	jne	SHORT $LN36@xmlDictQLo
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlDictComputeFastKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv207[ebp], eax
	jmp	SHORT $LN37@xmlDictQLo
$LN36@xmlDictQLo:
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlDictComputeBigKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv207[ebp], eax
$LN37@xmlDictQLo:
	mov	eax, DWORD PTR tv207[ebp]
	mov	DWORD PTR tv228[ebp], eax
	jmp	SHORT $LN41@xmlDictQLo
$LN40@xmlDictQLo:
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+8], 128			; 00000080H
	jne	SHORT $LN38@xmlDictQLo
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _plen$[ebp]
	push	edx
	mov	eax, DWORD PTR _prefix$[ebp]
	push	eax
	call	_xmlDictComputeFastQKey
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv227[ebp], eax
	jmp	SHORT $LN39@xmlDictQLo
$LN38@xmlDictQLo:
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _plen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	call	_xmlDictComputeBigQKey
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv227[ebp], eax
$LN39@xmlDictQLo:
	mov	edx, DWORD PTR tv227[ebp]
	mov	DWORD PTR tv228[ebp], edx
$LN41@xmlDictQLo:
	mov	eax, DWORD PTR tv228[ebp]
	mov	DWORD PTR _skey$2[ebp], eax
	jmp	SHORT $LN17@xmlDictQLo
$LN16@xmlDictQLo:

; 1151 : 	else
; 1152 : 	    skey = okey;

	mov	ecx, DWORD PTR _okey$[ebp]
	mov	DWORD PTR _skey$2[ebp], ecx
$LN17@xmlDictQLo:

; 1153 : 
; 1154 : 	key = skey % dict->subdict->size;

	mov	edx, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _skey$2[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR _key$[ebp], edx

; 1155 : 	if (dict->subdict->dict[key].valid != 0) {

	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	ecx, DWORD PTR _key$[ebp], 20
	mov	edx, DWORD PTR [eax+4]
	cmp	DWORD PTR [edx+ecx+12], 0
	je	$LN20@xmlDictQLo

; 1156 : 	    xmlDictEntryPtr tmp;
; 1157 : 	    for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	edx, DWORD PTR _key$[ebp], 20
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _tmp$1[ebp], edx
	jmp	SHORT $LN7@xmlDictQLo
$LN5@xmlDictQLo:

; 1158 : 		 tmp = tmp->next) {

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tmp$1[ebp], ecx
$LN7@xmlDictQLo:

; 1156 : 	    xmlDictEntryPtr tmp;
; 1157 : 	    for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;

	mov	edx, DWORD PTR _tmp$1[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN6@xmlDictQLo

; 1159 : 		if ((tmp->okey == skey) && (tmp->len == len) &&

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _skey$2[ebp]
	jne	SHORT $LN21@xmlDictQLo
	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _len$[ebp]
	jne	SHORT $LN21@xmlDictQLo
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prefix$[ebp]
	push	ecx
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@xmlDictQLo

; 1160 : 		    (xmlStrQEqual(prefix, name, tmp->name)))
; 1161 : 		    return(tmp->name);

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	$LN1@xmlDictQLo
$LN21@xmlDictQLo:

; 1162 : 		nbi++;

	mov	eax, DWORD PTR _nbi$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbi$[ebp], eax

; 1163 : 	    }

	jmp	SHORT $LN5@xmlDictQLo
$LN6@xmlDictQLo:

; 1164 : 	    if ((tmp->okey == skey) && (tmp->len == len) &&

	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _skey$2[ebp]
	jne	SHORT $LN20@xmlDictQLo
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _len$[ebp]
	jne	SHORT $LN20@xmlDictQLo
	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	call	_xmlStrQEqual
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@xmlDictQLo

; 1165 : 		(xmlStrQEqual(prefix, name, tmp->name)))
; 1166 : 		return(tmp->name);

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [eax+4]
	jmp	$LN1@xmlDictQLo
$LN20@xmlDictQLo:

; 1167 : 	}
; 1168 : 	key = okey % dict->size;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _okey$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR _key$[ebp], edx
$LN15@xmlDictQLo:

; 1169 :     }
; 1170 : 
; 1171 :     ret = xmlDictAddQString(dict, prefix, plen, name, l);

	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _plen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prefix$[ebp]
	push	edx
	mov	eax, DWORD PTR _dict$[ebp]
	push	eax
	call	_xmlDictAddQString
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$[ebp], eax

; 1172 :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN23@xmlDictQLo

; 1173 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictQLo
$LN23@xmlDictQLo:

; 1174 :     if (insert == NULL) {

	cmp	DWORD PTR _insert$[ebp], 0
	jne	SHORT $LN24@xmlDictQLo

; 1175 : 	entry = &(dict->dict[key]);

	imul	ecx, DWORD PTR _key$[ebp], 20
	mov	edx, DWORD PTR _dict$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _entry$[ebp], ecx

; 1176 :     } else {

	jmp	SHORT $LN25@xmlDictQLo
$LN24@xmlDictQLo:

; 1177 : 	entry = xmlMalloc(sizeof(xmlDictEntry));

	mov	esi, esp
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _entry$[ebp], eax

; 1178 : 	if (entry == NULL)

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN25@xmlDictQLo

; 1179 : 	     return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlDictQLo
$LN25@xmlDictQLo:

; 1180 :     }
; 1181 :     entry->name = ret;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1182 :     entry->len = len;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1183 :     entry->next = NULL;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [ecx], 0

; 1184 :     entry->valid = 1;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1185 :     entry->okey = okey;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _okey$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1186 : 
; 1187 :     if (insert != NULL)

	cmp	DWORD PTR _insert$[ebp], 0
	je	SHORT $LN27@xmlDictQLo

; 1188 : 	insert->next = entry;

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx], eax
$LN27@xmlDictQLo:

; 1189 : 
; 1190 :     dict->nbElems++;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	eax, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1191 : 
; 1192 :     if ((nbi > MAX_HASH_LEN) &&

	cmp	DWORD PTR _nbi$[ebp], 3
	jbe	SHORT $LN28@xmlDictQLo
	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx+8], 2730			; 00000aaaH
	ja	SHORT $LN28@xmlDictQLo

; 1193 :         (dict->size <= ((MAX_DICT_HASH / 2) / MAX_HASH_LEN)))
; 1194 : 	xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict->size);

	mov	edx, DWORD PTR _dict$[ebp]
	imul	eax, DWORD PTR [edx+8], 6
	push	eax
	mov	ecx, DWORD PTR _dict$[ebp]
	push	ecx
	call	_xmlDictGrow
	add	esp, 8
$LN28@xmlDictQLo:

; 1195 :     /* Note that entry may have been freed at this point by xmlDictGrow */
; 1196 : 
; 1197 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlDictQLo:

; 1198 : }

	pop	edi
	pop	esi
	add	esp, 100				; 00000064H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictQLookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictExists
_TEXT	SEGMENT
tv183 = -52						; size = 4
tv87 = -48						; size = 4
tv69 = -44						; size = 4
tv244 = -37						; size = 1
tv241 = -36						; size = 4
tv238 = -32						; size = 4
_tmp$1 = -28						; size = 4
_skey$2 = -24						; size = 4
_l$ = -20						; size = 4
_insert$ = -16						; size = 4
_nbi$ = -12						; size = 4
_okey$ = -8						; size = 4
_key$ = -4						; size = 4
_dict$ = 8						; size = 4
_name$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlDictExists PROC					; COMDAT

; 998  : xmlDictExists(xmlDictPtr dict, const xmlChar *name, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 999  :     unsigned long key, okey, nbi = 0;

	mov	DWORD PTR _nbi$[ebp], 0

; 1000 :     xmlDictEntryPtr insert;
; 1001 :     unsigned int l;
; 1002 : 
; 1003 :     if ((dict == NULL) || (name == NULL))

	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN9@xmlDictExi
	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN8@xmlDictExi
$LN9@xmlDictExi:

; 1004 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictExi
$LN8@xmlDictExi:

; 1005 : 
; 1006 :     if (len < 0)

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN10@xmlDictExi

; 1007 :         l = strlen((const char *) name);

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR tv238[ebp], eax
	mov	ecx, DWORD PTR tv238[ebp]
	add	ecx, 1
	mov	DWORD PTR tv241[ebp], ecx
$LL32@xmlDictExi:
	mov	edx, DWORD PTR tv238[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv244[ebp], al
	add	DWORD PTR tv238[ebp], 1
	cmp	BYTE PTR tv244[ebp], 0
	jne	SHORT $LL32@xmlDictExi
	mov	ecx, DWORD PTR tv238[ebp]
	sub	ecx, DWORD PTR tv241[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _l$[ebp], edx
	jmp	SHORT $LN11@xmlDictExi
$LN10@xmlDictExi:

; 1008 :     else
; 1009 :         l = len;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$LN11@xmlDictExi:

; 1010 :     if (((dict->limit > 0) && (l >= dict->limit)) ||

	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jbe	SHORT $LN14@xmlDictExi
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jae	SHORT $LN13@xmlDictExi
$LN14@xmlDictExi:
	cmp	DWORD PTR _l$[ebp], 1073741823		; 3fffffffH
	jbe	SHORT $LN12@xmlDictExi
$LN13@xmlDictExi:

; 1011 :         (l > INT_MAX / 2))
; 1012 :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictExi
$LN12@xmlDictExi:

; 1013 : 
; 1014 :     /*
; 1015 :      * Check for duplicate and insertion location.
; 1016 :      */
; 1017 :     okey = xmlDictComputeKey(dict, name, l);

	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx+8], 128			; 00000080H
	jne	SHORT $LN28@xmlDictExi
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlDictComputeFastKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN29@xmlDictExi
$LN28@xmlDictExi:
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlDictComputeBigKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv87[ebp], eax
$LN29@xmlDictExi:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR _okey$[ebp], ecx

; 1018 :     key = okey % dict->size;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _okey$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR _key$[ebp], edx

; 1019 :     if (dict->dict[key].valid == 0) {

	imul	edx, DWORD PTR _key$[ebp], 20
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+edx+12], 0
	jne	SHORT $LN15@xmlDictExi

; 1020 : 	insert = NULL;

	mov	DWORD PTR _insert$[ebp], 0

; 1021 :     } else {

	jmp	$LN16@xmlDictExi
$LN15@xmlDictExi:

; 1022 : 	for (insert = &(dict->dict[key]); insert->next != NULL;

	imul	edx, DWORD PTR _key$[ebp], 20
	mov	eax, DWORD PTR _dict$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _insert$[ebp], edx
	jmp	SHORT $LN4@xmlDictExi
$LN2@xmlDictExi:

; 1023 : 	     insert = insert->next) {

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _insert$[ebp], edx
$LN4@xmlDictExi:

; 1022 : 	for (insert = &(dict->dict[key]); insert->next != NULL;

	mov	eax, DWORD PTR _insert$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlDictExi

; 1024 : #ifdef __GNUC__
; 1025 : 	    if ((insert->okey == okey) && (insert->len == l)) {
; 1026 : 		if (!memcmp(insert->name, name, l))
; 1027 : 		    return(insert->name);
; 1028 : 	    }
; 1029 : #else
; 1030 : 	    if ((insert->okey == okey) && (insert->len == l) &&

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _okey$[ebp]
	jne	SHORT $LN17@xmlDictExi
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _l$[ebp]
	jne	SHORT $LN17@xmlDictExi
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@xmlDictExi

; 1031 : 	        (!xmlStrncmp(insert->name, name, l)))
; 1032 : 		return(insert->name);

	mov	eax, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [eax+4]
	jmp	$LN1@xmlDictExi
$LN17@xmlDictExi:

; 1033 : #endif
; 1034 : 	    nbi++;

	mov	ecx, DWORD PTR _nbi$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbi$[ebp], ecx

; 1035 : 	}

	jmp	SHORT $LN2@xmlDictExi
$LN3@xmlDictExi:

; 1036 : #ifdef __GNUC__
; 1037 : 	if ((insert->okey == okey) && (insert->len == l)) {
; 1038 : 	    if (!memcmp(insert->name, name, l))
; 1039 : 		return(insert->name);
; 1040 : 	}
; 1041 : #else
; 1042 : 	if ((insert->okey == okey) && (insert->len == l) &&

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _okey$[ebp]
	jne	SHORT $LN16@xmlDictExi
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _l$[ebp]
	jne	SHORT $LN16@xmlDictExi
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@xmlDictExi

; 1043 : 	    (!xmlStrncmp(insert->name, name, l)))
; 1044 : 	    return(insert->name);

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	jmp	$LN1@xmlDictExi
$LN16@xmlDictExi:

; 1045 : #endif
; 1046 :     }
; 1047 : 
; 1048 :     if (dict->subdict) {

	mov	edx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	$LN19@xmlDictExi

; 1049 :         unsigned long skey;
; 1050 : 
; 1051 :         /* we cannot always reuse the same okey for the subdict */
; 1052 :         if (((dict->size == MIN_DICT_SIZE) &&
; 1053 : 	     (dict->subdict->size != MIN_DICT_SIZE)) ||

	mov	eax, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [eax+8], 128			; 00000080H
	jne	SHORT $LN23@xmlDictExi
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+8], 128			; 00000080H
	jne	SHORT $LN22@xmlDictExi
$LN23@xmlDictExi:
	mov	eax, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [eax+8], 128			; 00000080H
	je	SHORT $LN20@xmlDictExi
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+8], 128			; 00000080H
	jne	SHORT $LN20@xmlDictExi
$LN22@xmlDictExi:

; 1054 :             ((dict->size != MIN_DICT_SIZE) &&
; 1055 : 	     (dict->subdict->size == MIN_DICT_SIZE)))
; 1056 : 	    skey = xmlDictComputeKey(dict->subdict, name, l);

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	DWORD PTR [ecx+8], 128			; 00000080H
	jne	SHORT $LN30@xmlDictExi
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlDictComputeFastKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv183[ebp], eax
	jmp	SHORT $LN31@xmlDictExi
$LN30@xmlDictExi:
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlDictComputeBigKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv183[ebp], eax
$LN31@xmlDictExi:
	mov	eax, DWORD PTR tv183[ebp]
	mov	DWORD PTR _skey$2[ebp], eax
	jmp	SHORT $LN21@xmlDictExi
$LN20@xmlDictExi:

; 1057 : 	else
; 1058 : 	    skey = okey;

	mov	ecx, DWORD PTR _okey$[ebp]
	mov	DWORD PTR _skey$2[ebp], ecx
$LN21@xmlDictExi:

; 1059 : 
; 1060 : 	key = skey % dict->subdict->size;

	mov	edx, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _skey$2[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR _key$[ebp], edx

; 1061 : 	if (dict->subdict->dict[key].valid != 0) {

	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	ecx, DWORD PTR _key$[ebp], 20
	mov	edx, DWORD PTR [eax+4]
	cmp	DWORD PTR [edx+ecx+12], 0
	je	$LN19@xmlDictExi

; 1062 : 	    xmlDictEntryPtr tmp;
; 1063 : 
; 1064 : 	    for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	edx, DWORD PTR _key$[ebp], 20
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _tmp$1[ebp], edx
	jmp	SHORT $LN7@xmlDictExi
$LN5@xmlDictExi:

; 1065 : 		 tmp = tmp->next) {

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tmp$1[ebp], ecx
$LN7@xmlDictExi:

; 1062 : 	    xmlDictEntryPtr tmp;
; 1063 : 
; 1064 : 	    for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;

	mov	edx, DWORD PTR _tmp$1[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN6@xmlDictExi

; 1066 : #ifdef __GNUC__
; 1067 : 		if ((tmp->okey == skey) && (tmp->len == l)) {
; 1068 : 		    if (!memcmp(tmp->name, name, l))
; 1069 : 			return(tmp->name);
; 1070 : 		}
; 1071 : #else
; 1072 : 		if ((tmp->okey == skey) && (tmp->len == l) &&

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _skey$2[ebp]
	jne	SHORT $LN25@xmlDictExi
	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _l$[ebp]
	jne	SHORT $LN25@xmlDictExi
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@xmlDictExi

; 1073 : 		    (!xmlStrncmp(tmp->name, name, l)))
; 1074 : 		    return(tmp->name);

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN1@xmlDictExi
$LN25@xmlDictExi:

; 1075 : #endif
; 1076 : 		nbi++;

	mov	eax, DWORD PTR _nbi$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbi$[ebp], eax

; 1077 : 	    }

	jmp	SHORT $LN5@xmlDictExi
$LN6@xmlDictExi:

; 1078 : #ifdef __GNUC__
; 1079 : 	    if ((tmp->okey == skey) && (tmp->len == l)) {
; 1080 : 		if (!memcmp(tmp->name, name, l))
; 1081 : 		    return(tmp->name);
; 1082 : 	    }
; 1083 : #else
; 1084 : 	    if ((tmp->okey == skey) && (tmp->len == l) &&

	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _skey$2[ebp]
	jne	SHORT $LN19@xmlDictExi
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _l$[ebp]
	jne	SHORT $LN19@xmlDictExi
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@xmlDictExi

; 1085 : 		(!xmlStrncmp(tmp->name, name, l)))
; 1086 : 		return(tmp->name);

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN1@xmlDictExi
$LN19@xmlDictExi:

; 1087 : #endif
; 1088 : 	}
; 1089 :     }
; 1090 : 
; 1091 :     /* not found */
; 1092 :     return(NULL);

	xor	eax, eax
$LN1@xmlDictExi:

; 1093 : }

	pop	edi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictExists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictLookup
_TEXT	SEGMENT
tv183 = -60						; size = 4
tv87 = -56						; size = 4
tv69 = -52						; size = 4
tv280 = -45						; size = 1
tv277 = -44						; size = 4
tv274 = -40						; size = 4
_tmp$1 = -36						; size = 4
_skey$2 = -32						; size = 4
_l$ = -28						; size = 4
_ret$ = -24						; size = 4
_insert$ = -20						; size = 4
_entry$ = -16						; size = 4
_nbi$ = -12						; size = 4
_okey$ = -8						; size = 4
_key$ = -4						; size = 4
_dict$ = 8						; size = 4
_name$ = 12						; size = 4
_len$ = 16						; size = 4
_xmlDictLookup PROC					; COMDAT

; 858  : xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 859  :     unsigned long key, okey, nbi = 0;

	mov	DWORD PTR _nbi$[ebp], 0

; 860  :     xmlDictEntryPtr entry;
; 861  :     xmlDictEntryPtr insert;
; 862  :     const xmlChar *ret;
; 863  :     unsigned int l;
; 864  : 
; 865  :     if ((dict == NULL) || (name == NULL))

	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN9@xmlDictLoo
	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN8@xmlDictLoo
$LN9@xmlDictLoo:

; 866  : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictLoo
$LN8@xmlDictLoo:

; 867  : 
; 868  :     if (len < 0)

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN10@xmlDictLoo

; 869  :         l = strlen((const char *) name);

	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR tv274[ebp], eax
	mov	ecx, DWORD PTR tv274[ebp]
	add	ecx, 1
	mov	DWORD PTR tv277[ebp], ecx
$LL39@xmlDictLoo:
	mov	edx, DWORD PTR tv274[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv280[ebp], al
	add	DWORD PTR tv274[ebp], 1
	cmp	BYTE PTR tv280[ebp], 0
	jne	SHORT $LL39@xmlDictLoo
	mov	ecx, DWORD PTR tv274[ebp]
	sub	ecx, DWORD PTR tv277[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _l$[ebp], edx
	jmp	SHORT $LN11@xmlDictLoo
$LN10@xmlDictLoo:

; 870  :     else
; 871  :         l = len;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$LN11@xmlDictLoo:

; 872  : 
; 873  :     if (((dict->limit > 0) && (l >= dict->limit)) ||

	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jbe	SHORT $LN14@xmlDictLoo
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jae	SHORT $LN13@xmlDictLoo
$LN14@xmlDictLoo:
	cmp	DWORD PTR _l$[ebp], 1073741823		; 3fffffffH
	jbe	SHORT $LN12@xmlDictLoo
$LN13@xmlDictLoo:

; 874  :         (l > INT_MAX / 2))
; 875  :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictLoo
$LN12@xmlDictLoo:

; 876  : 
; 877  :     /*
; 878  :      * Check for duplicate and insertion location.
; 879  :      */
; 880  :     okey = xmlDictComputeKey(dict, name, l);

	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx+8], 128			; 00000080H
	jne	SHORT $LN35@xmlDictLoo
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlDictComputeFastKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN36@xmlDictLoo
$LN35@xmlDictLoo:
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlDictComputeBigKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv87[ebp], eax
$LN36@xmlDictLoo:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR _okey$[ebp], ecx

; 881  :     key = okey % dict->size;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _okey$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR _key$[ebp], edx

; 882  :     if (dict->dict[key].valid == 0) {

	imul	edx, DWORD PTR _key$[ebp], 20
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+edx+12], 0
	jne	SHORT $LN15@xmlDictLoo

; 883  : 	insert = NULL;

	mov	DWORD PTR _insert$[ebp], 0

; 884  :     } else {

	jmp	$LN16@xmlDictLoo
$LN15@xmlDictLoo:

; 885  : 	for (insert = &(dict->dict[key]); insert->next != NULL;

	imul	edx, DWORD PTR _key$[ebp], 20
	mov	eax, DWORD PTR _dict$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _insert$[ebp], edx
	jmp	SHORT $LN4@xmlDictLoo
$LN2@xmlDictLoo:

; 886  : 	     insert = insert->next) {

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _insert$[ebp], edx
$LN4@xmlDictLoo:

; 885  : 	for (insert = &(dict->dict[key]); insert->next != NULL;

	mov	eax, DWORD PTR _insert$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@xmlDictLoo

; 887  : #ifdef __GNUC__
; 888  : 	    if ((insert->okey == okey) && (insert->len == l)) {
; 889  : 		if (!memcmp(insert->name, name, l))
; 890  : 		    return(insert->name);
; 891  : 	    }
; 892  : #else
; 893  : 	    if ((insert->okey == okey) && (insert->len == l) &&

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _okey$[ebp]
	jne	SHORT $LN17@xmlDictLoo
	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _l$[ebp]
	jne	SHORT $LN17@xmlDictLoo
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@xmlDictLoo

; 894  : 	        (!xmlStrncmp(insert->name, name, l)))
; 895  : 		return(insert->name);

	mov	eax, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [eax+4]
	jmp	$LN1@xmlDictLoo
$LN17@xmlDictLoo:

; 896  : #endif
; 897  : 	    nbi++;

	mov	ecx, DWORD PTR _nbi$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nbi$[ebp], ecx

; 898  : 	}

	jmp	SHORT $LN2@xmlDictLoo
$LN3@xmlDictLoo:

; 899  : #ifdef __GNUC__
; 900  : 	if ((insert->okey == okey) && (insert->len == l)) {
; 901  : 	    if (!memcmp(insert->name, name, l))
; 902  : 		return(insert->name);
; 903  : 	}
; 904  : #else
; 905  : 	if ((insert->okey == okey) && (insert->len == l) &&

	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _okey$[ebp]
	jne	SHORT $LN16@xmlDictLoo
	mov	ecx, DWORD PTR _insert$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _l$[ebp]
	jne	SHORT $LN16@xmlDictLoo
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@xmlDictLoo

; 906  : 	    (!xmlStrncmp(insert->name, name, l)))
; 907  : 	    return(insert->name);

	mov	ecx, DWORD PTR _insert$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	jmp	$LN1@xmlDictLoo
$LN16@xmlDictLoo:

; 908  : #endif
; 909  :     }
; 910  : 
; 911  :     if (dict->subdict) {

	mov	edx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	$LN19@xmlDictLoo

; 912  :         unsigned long skey;
; 913  : 
; 914  :         /* we cannot always reuse the same okey for the subdict */
; 915  :         if (((dict->size == MIN_DICT_SIZE) &&
; 916  : 	     (dict->subdict->size != MIN_DICT_SIZE)) ||

	mov	eax, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [eax+8], 128			; 00000080H
	jne	SHORT $LN23@xmlDictLoo
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+8], 128			; 00000080H
	jne	SHORT $LN22@xmlDictLoo
$LN23@xmlDictLoo:
	mov	eax, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [eax+8], 128			; 00000080H
	je	SHORT $LN20@xmlDictLoo
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	DWORD PTR [edx+8], 128			; 00000080H
	jne	SHORT $LN20@xmlDictLoo
$LN22@xmlDictLoo:

; 917  :             ((dict->size != MIN_DICT_SIZE) &&
; 918  : 	     (dict->subdict->size == MIN_DICT_SIZE)))
; 919  : 	    skey = xmlDictComputeKey(dict->subdict, name, l);

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	DWORD PTR [ecx+8], 128			; 00000080H
	jne	SHORT $LN37@xmlDictLoo
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlDictComputeFastKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv183[ebp], eax
	jmp	SHORT $LN38@xmlDictLoo
$LN37@xmlDictLoo:
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlDictComputeBigKey
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv183[ebp], eax
$LN38@xmlDictLoo:
	mov	eax, DWORD PTR tv183[ebp]
	mov	DWORD PTR _skey$2[ebp], eax
	jmp	SHORT $LN21@xmlDictLoo
$LN20@xmlDictLoo:

; 920  : 	else
; 921  : 	    skey = okey;

	mov	ecx, DWORD PTR _okey$[ebp]
	mov	DWORD PTR _skey$2[ebp], ecx
$LN21@xmlDictLoo:

; 922  : 
; 923  : 	key = skey % dict->subdict->size;

	mov	edx, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _skey$2[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR _key$[ebp], edx

; 924  : 	if (dict->subdict->dict[key].valid != 0) {

	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	ecx, DWORD PTR _key$[ebp], 20
	mov	edx, DWORD PTR [eax+4]
	cmp	DWORD PTR [edx+ecx+12], 0
	je	$LN24@xmlDictLoo

; 925  : 	    xmlDictEntryPtr tmp;
; 926  : 
; 927  : 	    for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	edx, DWORD PTR _key$[ebp], 20
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _tmp$1[ebp], edx
	jmp	SHORT $LN7@xmlDictLoo
$LN5@xmlDictLoo:

; 928  : 		 tmp = tmp->next) {

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tmp$1[ebp], ecx
$LN7@xmlDictLoo:

; 925  : 	    xmlDictEntryPtr tmp;
; 926  : 
; 927  : 	    for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;

	mov	edx, DWORD PTR _tmp$1[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN6@xmlDictLoo

; 929  : #ifdef __GNUC__
; 930  : 		if ((tmp->okey == skey) && (tmp->len == l)) {
; 931  : 		    if (!memcmp(tmp->name, name, l))
; 932  : 			return(tmp->name);
; 933  : 		}
; 934  : #else
; 935  : 		if ((tmp->okey == skey) && (tmp->len == l) &&

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _skey$2[ebp]
	jne	SHORT $LN25@xmlDictLoo
	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _l$[ebp]
	jne	SHORT $LN25@xmlDictLoo
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@xmlDictLoo

; 936  : 		    (!xmlStrncmp(tmp->name, name, l)))
; 937  : 		    return(tmp->name);

	mov	edx, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	$LN1@xmlDictLoo
$LN25@xmlDictLoo:

; 938  : #endif
; 939  : 		nbi++;

	mov	eax, DWORD PTR _nbi$[ebp]
	add	eax, 1
	mov	DWORD PTR _nbi$[ebp], eax

; 940  : 	    }

	jmp	SHORT $LN5@xmlDictLoo
$LN6@xmlDictLoo:

; 941  : #ifdef __GNUC__
; 942  : 	    if ((tmp->okey == skey) && (tmp->len == l)) {
; 943  : 		if (!memcmp(tmp->name, name, l))
; 944  : 		    return(tmp->name);
; 945  : 	    }
; 946  : #else
; 947  : 	    if ((tmp->okey == skey) && (tmp->len == l) &&

	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _skey$2[ebp]
	jne	SHORT $LN24@xmlDictLoo
	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _l$[ebp]
	jne	SHORT $LN24@xmlDictLoo
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_xmlStrncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN24@xmlDictLoo

; 948  : 		(!xmlStrncmp(tmp->name, name, l)))
; 949  : 		return(tmp->name);

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	eax, DWORD PTR [eax+4]
	jmp	$LN1@xmlDictLoo
$LN24@xmlDictLoo:

; 950  : #endif
; 951  : 	}
; 952  : 	key = okey % dict->size;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _okey$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	DWORD PTR _key$[ebp], edx
$LN19@xmlDictLoo:

; 953  :     }
; 954  : 
; 955  :     ret = xmlDictAddString(dict, name, l);

	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dict$[ebp]
	push	ecx
	call	_xmlDictAddString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 956  :     if (ret == NULL)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $LN27@xmlDictLoo

; 957  :         return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictLoo
$LN27@xmlDictLoo:

; 958  :     if (insert == NULL) {

	cmp	DWORD PTR _insert$[ebp], 0
	jne	SHORT $LN28@xmlDictLoo

; 959  : 	entry = &(dict->dict[key]);

	imul	edx, DWORD PTR _key$[ebp], 20
	mov	eax, DWORD PTR _dict$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _entry$[ebp], edx

; 960  :     } else {

	jmp	SHORT $LN29@xmlDictLoo
$LN28@xmlDictLoo:

; 961  : 	entry = xmlMalloc(sizeof(xmlDictEntry));

	mov	esi, esp
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _entry$[ebp], eax

; 962  : 	if (entry == NULL)

	cmp	DWORD PTR _entry$[ebp], 0
	jne	SHORT $LN29@xmlDictLoo

; 963  : 	     return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlDictLoo
$LN29@xmlDictLoo:

; 964  :     }
; 965  :     entry->name = ret;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 966  :     entry->len = l;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 967  :     entry->next = NULL;

	mov	edx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [edx], 0

; 968  :     entry->valid = 1;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax+12], 1

; 969  :     entry->okey = okey;

	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR _okey$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 970  : 
; 971  : 
; 972  :     if (insert != NULL)

	cmp	DWORD PTR _insert$[ebp], 0
	je	SHORT $LN31@xmlDictLoo

; 973  : 	insert->next = entry;

	mov	eax, DWORD PTR _insert$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	DWORD PTR [eax], ecx
$LN31@xmlDictLoo:

; 974  : 
; 975  :     dict->nbElems++;

	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 1
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 976  : 
; 977  :     if ((nbi > MAX_HASH_LEN) &&

	cmp	DWORD PTR _nbi$[ebp], 3
	jbe	SHORT $LN32@xmlDictLoo
	mov	edx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [edx+8], 2730			; 00000aaaH
	ja	SHORT $LN32@xmlDictLoo

; 978  :         (dict->size <= ((MAX_DICT_HASH / 2) / MAX_HASH_LEN))) {
; 979  : 	if (xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict->size) != 0)

	mov	eax, DWORD PTR _dict$[ebp]
	imul	ecx, DWORD PTR [eax+8], 6
	push	ecx
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	call	_xmlDictGrow
	add	esp, 8
	test	eax, eax
	je	SHORT $LN32@xmlDictLoo

; 980  : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlDictLoo
$LN32@xmlDictLoo:

; 981  :     }
; 982  :     /* Note that entry may have been freed at this point by xmlDictGrow */
; 983  : 
; 984  :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlDictLoo:

; 985  : }

	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictLookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictFree
_TEXT	SEGMENT
_nextp$ = -24						; size = 4
_pool$ = -20						; size = 4
_inside_dict$ = -16					; size = 4
_next$ = -12						; size = 4
_iter$ = -8						; size = 4
_i$ = -4						; size = 4
_dict$ = 8						; size = 4
_xmlDictFree PROC					; COMDAT

; 793  : xmlDictFree(xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 794  :     size_t i;
; 795  :     xmlDictEntryPtr iter;
; 796  :     xmlDictEntryPtr next;
; 797  :     int inside_dict = 0;

	mov	DWORD PTR _inside_dict$[ebp], 0

; 798  :     xmlDictStringsPtr pool, nextp;
; 799  : 
; 800  :     if (dict == NULL)

	cmp	DWORD PTR _dict$[ebp], 0
	jne	SHORT $LN9@xmlDictFre

; 801  : 	return;

	jmp	$LN1@xmlDictFre
$LN9@xmlDictFre:

; 802  : 
; 803  :     if (!xmlDictInitialized)

	cmp	DWORD PTR _xmlDictInitialized, 0
	jne	SHORT $LN10@xmlDictFre

; 804  :         if (!__xmlInitializeDict())

	call	___xmlInitializeDict
	test	eax, eax
	jne	SHORT $LN10@xmlDictFre

; 805  :             return;

	jmp	$LN1@xmlDictFre
$LN10@xmlDictFre:

; 806  : 
; 807  :     /* decrement the counter, it may be shared by a parser and docs */
; 808  :     xmlRMutexLock(xmlDictMutex);

	mov	eax, DWORD PTR _xmlDictMutex
	push	eax
	call	_xmlRMutexLock
	add	esp, 4

; 809  :     dict->ref_counter--;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [eax], edx

; 810  :     if (dict->ref_counter > 0) {

	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN12@xmlDictFre

; 811  :         xmlRMutexUnlock(xmlDictMutex);

	mov	edx, DWORD PTR _xmlDictMutex
	push	edx
	call	_xmlRMutexUnlock
	add	esp, 4

; 812  :         return;

	jmp	$LN1@xmlDictFre
$LN12@xmlDictFre:

; 813  :     }
; 814  : 
; 815  :     xmlRMutexUnlock(xmlDictMutex);

	mov	eax, DWORD PTR _xmlDictMutex
	push	eax
	call	_xmlRMutexUnlock
	add	esp, 4

; 816  : 
; 817  :     if (dict->subdict != NULL) {

	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN13@xmlDictFre

; 818  :         xmlDictFree(dict->subdict);

	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlDictFree
	add	esp, 4
$LN13@xmlDictFre:

; 819  :     }
; 820  : 
; 821  :     if (dict->dict) {

	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	$LN14@xmlDictFre

; 822  : 	for(i = 0; ((i < dict->size) && (dict->nbElems > 0)); i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlDictFre
$LN2@xmlDictFre:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@xmlDictFre:
	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN3@xmlDictFre
	mov	edx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jbe	SHORT $LN3@xmlDictFre

; 823  : 	    iter = &(dict->dict[i]);

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _dict$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _iter$[ebp], eax

; 824  : 	    if (iter->valid == 0)

	mov	edx, DWORD PTR _iter$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN15@xmlDictFre

; 825  : 		continue;

	jmp	SHORT $LN2@xmlDictFre
$LN15@xmlDictFre:

; 826  : 	    inside_dict = 1;

	mov	DWORD PTR _inside_dict$[ebp], 1
$LN5@xmlDictFre:

; 827  : 	    while (iter) {

	cmp	DWORD PTR _iter$[ebp], 0
	je	SHORT $LN6@xmlDictFre

; 828  : 		next = iter->next;

	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _next$[ebp], ecx

; 829  : 		if (!inside_dict)

	cmp	DWORD PTR _inside_dict$[ebp], 0
	jne	SHORT $LN16@xmlDictFre

; 830  : 		    xmlFree(iter);

	mov	esi, esp
	mov	edx, DWORD PTR _iter$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlDictFre:

; 831  : 		dict->nbElems--;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	edx, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 832  : 		inside_dict = 0;

	mov	DWORD PTR _inside_dict$[ebp], 0

; 833  : 		iter = next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _iter$[ebp], eax

; 834  : 	    }

	jmp	SHORT $LN5@xmlDictFre
$LN6@xmlDictFre:

; 835  : 	}

	jmp	$LN2@xmlDictFre
$LN3@xmlDictFre:

; 836  : 	xmlFree(dict->dict);

	mov	esi, esp
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xmlDictFre:

; 837  :     }
; 838  :     pool = dict->strings;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pool$[ebp], ecx
$LN7@xmlDictFre:

; 839  :     while (pool != NULL) {

	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN8@xmlDictFre

; 840  :         nextp = pool->next;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _nextp$[ebp], eax

; 841  : 	xmlFree(pool);

	mov	esi, esp
	mov	ecx, DWORD PTR _pool$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 842  : 	pool = nextp;

	mov	edx, DWORD PTR _nextp$[ebp]
	mov	DWORD PTR _pool$[ebp], edx

; 843  :     }

	jmp	SHORT $LN7@xmlDictFre
$LN8@xmlDictFre:

; 844  :     xmlFree(dict);

	mov	esi, esp
	mov	eax, DWORD PTR _dict$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xmlDictFre:

; 845  : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictReference
_TEXT	SEGMENT
_dict$ = 8						; size = 4
_xmlDictReference PROC					; COMDAT

; 638  : xmlDictReference(xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 639  :     if (!xmlDictInitialized)

	cmp	DWORD PTR _xmlDictInitialized, 0
	jne	SHORT $LN2@xmlDictRef

; 640  :         if (!__xmlInitializeDict())

	call	___xmlInitializeDict
	test	eax, eax
	jne	SHORT $LN2@xmlDictRef

; 641  :             return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlDictRef
$LN2@xmlDictRef:

; 642  : 
; 643  :     if (dict == NULL) return -1;

	cmp	DWORD PTR _dict$[ebp], 0
	jne	SHORT $LN4@xmlDictRef
	or	eax, -1
	jmp	SHORT $LN1@xmlDictRef
$LN4@xmlDictRef:

; 644  :     xmlRMutexLock(xmlDictMutex);

	mov	eax, DWORD PTR _xmlDictMutex
	push	eax
	call	_xmlRMutexLock
	add	esp, 4

; 645  :     dict->ref_counter++;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [eax], edx

; 646  :     xmlRMutexUnlock(xmlDictMutex);

	mov	ecx, DWORD PTR _xmlDictMutex
	push	ecx
	call	_xmlRMutexUnlock
	add	esp, 4

; 647  :     return(0);

	xor	eax, eax
$LN1@xmlDictRef:

; 648  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDictReference ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictCreateSub
_TEXT	SEGMENT
_dict$ = -4						; size = 4
_sub$ = 8						; size = 4
_xmlDictCreateSub PROC					; COMDAT

; 615  : xmlDictCreateSub(xmlDictPtr sub) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 616  :     xmlDictPtr dict = xmlDictCreate();

	call	_xmlDictCreate
	mov	DWORD PTR _dict$[ebp], eax

; 617  : 
; 618  :     if ((dict != NULL) && (sub != NULL)) {

	cmp	DWORD PTR _dict$[ebp], 0
	je	SHORT $LN2@xmlDictCre
	cmp	DWORD PTR _sub$[ebp], 0
	je	SHORT $LN2@xmlDictCre

; 619  : #ifdef DICT_DEBUG_PATTERNS
; 620  :         fprintf(stderr, "R");
; 621  : #endif
; 622  :         dict->seed = sub->seed;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR _sub$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 623  :         dict->subdict = sub;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR _sub$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 624  : 	xmlDictReference(dict->subdict);

	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_xmlDictReference
	add	esp, 4
$LN2@xmlDictCre:

; 625  :     }
; 626  :     return(dict);

	mov	eax, DWORD PTR _dict$[ebp]

; 627  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictCreateSub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictGetUsage
_TEXT	SEGMENT
_limit$ = -8						; size = 4
_pool$ = -4						; size = 4
_dict$ = 8						; size = 4
_xmlDictGetUsage PROC					; COMDAT

; 1276 : xmlDictGetUsage(xmlDictPtr dict) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 1277 :     xmlDictStringsPtr pool;
; 1278 :     size_t limit = 0;

	mov	DWORD PTR _limit$[ebp], 0

; 1279 : 
; 1280 :     if (dict == NULL)

	cmp	DWORD PTR _dict$[ebp], 0
	jne	SHORT $LN4@xmlDictGet

; 1281 : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlDictGet
$LN4@xmlDictGet:

; 1282 :     pool = dict->strings;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pool$[ebp], ecx
$LN2@xmlDictGet:

; 1283 :     while (pool != NULL) {

	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN3@xmlDictGet

; 1284 :         limit += pool->size;

	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR _limit$[ebp]
	add	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _limit$[ebp], eax

; 1285 : 	pool = pool->next;

	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pool$[ebp], edx

; 1286 :     }

	jmp	SHORT $LN2@xmlDictGet
$LN3@xmlDictGet:

; 1287 :     return(limit);

	mov	eax, DWORD PTR _limit$[ebp]
$LN1@xmlDictGet:

; 1288 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictGetUsage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictSetLimit
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_dict$ = 8						; size = 4
_limit$ = 12						; size = 4
_xmlDictSetLimit PROC					; COMDAT

; 1256 : xmlDictSetLimit(xmlDictPtr dict, size_t limit) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 1257 :     size_t ret;
; 1258 : 
; 1259 :     if (dict == NULL)

	cmp	DWORD PTR _dict$[ebp], 0
	jne	SHORT $LN2@xmlDictSet

; 1260 : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlDictSet
$LN2@xmlDictSet:

; 1261 :     ret = dict->limit;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _ret$[ebp], ecx

; 1262 :     dict->limit = limit;

	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR _limit$[ebp]
	mov	DWORD PTR [edx+28], eax

; 1263 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlDictSet:

; 1264 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictSetLimit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlDictCreate
_TEXT	SEGMENT
_dict$ = -4						; size = 4
_xmlDictCreate PROC					; COMDAT

; 568  : xmlDictCreate(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 569  :     xmlDictPtr dict;
; 570  : 
; 571  :     if (!xmlDictInitialized)

	cmp	DWORD PTR _xmlDictInitialized, 0
	jne	SHORT $LN2@xmlDictCre

; 572  :         if (!__xmlInitializeDict())

	call	___xmlInitializeDict
	test	eax, eax
	jne	SHORT $LN2@xmlDictCre

; 573  :             return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlDictCre
$LN2@xmlDictCre:

; 574  : 
; 575  : #ifdef DICT_DEBUG_PATTERNS
; 576  :     fprintf(stderr, "C");
; 577  : #endif
; 578  : 
; 579  :     dict = xmlMalloc(sizeof(xmlDict));

	mov	esi, esp
	push	32					; 00000020H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dict$[ebp], eax

; 580  :     if (dict) {

	cmp	DWORD PTR _dict$[ebp], 0
	je	$LN4@xmlDictCre

; 581  :         dict->ref_counter = 1;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [eax], 1

; 582  :         dict->limit = 0;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 583  : 
; 584  :         dict->size = MIN_DICT_SIZE;

	mov	edx, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [edx+8], 128			; 00000080H

; 585  : 	dict->nbElems = 0;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [eax+12], 0

; 586  :         dict->dict = xmlMalloc(MIN_DICT_SIZE * sizeof(xmlDictEntry));

	mov	esi, esp
	push	2560					; 00000a00H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 587  : 	dict->strings = NULL;

	mov	edx, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [edx+16], 0

; 588  : 	dict->subdict = NULL;

	mov	eax, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [eax+20], 0

; 589  :         if (dict->dict) {

	mov	ecx, DWORD PTR _dict$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@xmlDictCre

; 590  : 	    memset(dict->dict, 0, MIN_DICT_SIZE * sizeof(xmlDictEntry));

	push	2560					; 00000a00H
	push	0
	mov	edx, DWORD PTR _dict$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 591  : #ifdef DICT_RANDOMIZATION
; 592  :             dict->seed = __xmlRandom();
; 593  : #else
; 594  :             dict->seed = 0;

	mov	ecx, DWORD PTR _dict$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 595  : #endif
; 596  : 	    return(dict);

	mov	eax, DWORD PTR _dict$[ebp]
	jmp	SHORT $LN1@xmlDictCre
$LN5@xmlDictCre:

; 597  :         }
; 598  :         xmlFree(dict);

	mov	esi, esp
	mov	edx, DWORD PTR _dict$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@xmlDictCre:

; 599  :     }
; 600  :     return(NULL);

	xor	eax, eax
$LN1@xmlDictCre:

; 601  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDictCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT _xmlInitializeDict
_TEXT	SEGMENT
_xmlInitializeDict PROC					; COMDAT

; 159  : int xmlInitializeDict(void) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 160  :     return(0);

	xor	eax, eax

; 161  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlInitializeDict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\dict.c
;	COMDAT ___xmlInitializeDict
_TEXT	SEGMENT
___xmlInitializeDict PROC				; COMDAT

; 175  : int __xmlInitializeDict(void) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __75FE04D0_dict@c
	call	@__CheckForDebuggerJustMyCode@4

; 176  :     if (xmlDictInitialized)

	cmp	DWORD PTR _xmlDictInitialized, 0
	je	SHORT $LN2@xmlInitial

; 177  :         return(1);

	mov	eax, 1
	jmp	SHORT $LN1@xmlInitial
$LN2@xmlInitial:

; 178  : 
; 179  :     if ((xmlDictMutex = xmlNewRMutex()) == NULL)

	call	_xmlNewRMutex
	mov	DWORD PTR _xmlDictMutex, eax
	cmp	DWORD PTR _xmlDictMutex, 0
	jne	SHORT $LN3@xmlInitial

; 180  :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlInitial
$LN3@xmlInitial:

; 181  :     xmlRMutexLock(xmlDictMutex);

	mov	eax, DWORD PTR _xmlDictMutex
	push	eax
	call	_xmlRMutexLock
	add	esp, 4

; 182  : 
; 183  : #ifdef DICT_RANDOMIZATION
; 184  : #ifdef HAVE_RAND_R
; 185  :     rand_seed = time(NULL);
; 186  :     rand_r(& rand_seed);
; 187  : #else
; 188  :     srand(time(NULL));
; 189  : #endif
; 190  : #endif
; 191  :     xmlDictInitialized = 1;

	mov	DWORD PTR _xmlDictInitialized, 1

; 192  :     xmlRMutexUnlock(xmlDictMutex);

	mov	ecx, DWORD PTR _xmlDictMutex
	push	ecx
	call	_xmlRMutexUnlock
	add	esp, 4

; 193  :     return(1);

	mov	eax, 1
$LN1@xmlInitial:

; 194  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___xmlInitializeDict ENDP
_TEXT	ENDS
END
