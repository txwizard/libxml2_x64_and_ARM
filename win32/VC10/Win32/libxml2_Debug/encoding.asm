; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	C:\Users\DAG\Documents\_Clients\CodeProject Authors Group\Windows on ARM\libxml2\libxml2-2.9.9\encoding.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_xmlMalloc:DWORD
COMM	_xmlMallocAtomic:DWORD
COMM	_xmlRealloc:DWORD
COMM	_xmlFree:DWORD
COMM	_xmlMemStrdup:DWORD
COMM	_forbiddenExp:DWORD
COMM	_emptyExp:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__188180DA_corecrt_math@h DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__7B7A869E_ctype@h DB 01H
__C8D9C3F6_encoding@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_snprintf
PUBLIC	_xmlByteConsumed
PUBLIC	_xmlInitCharEncodingHandlers
PUBLIC	_xmlCleanupCharEncodingHandlers
PUBLIC	_xmlRegisterCharEncodingHandler
PUBLIC	_xmlGetCharEncodingHandler
PUBLIC	_xmlFindCharEncodingHandler
PUBLIC	_xmlNewCharEncodingHandler
PUBLIC	_xmlAddEncodingAlias
PUBLIC	_xmlDelEncodingAlias
PUBLIC	_xmlGetEncodingAlias
PUBLIC	_xmlCleanupEncodingAliases
PUBLIC	_xmlParseCharEncoding
PUBLIC	_xmlGetCharEncodingName
PUBLIC	_xmlDetectCharEncoding
PUBLIC	_xmlCharEncOutFunc
PUBLIC	_xmlCharEncInFunc
PUBLIC	_xmlCharEncFirstLine
PUBLIC	_xmlCharEncCloseFunc
PUBLIC	_UTF8Toisolat1
PUBLIC	_isolat1ToUTF8
PUBLIC	_xmlCharEncFirstLineInt
PUBLIC	_xmlCharEncFirstLineInput
PUBLIC	_xmlCharEncInput
PUBLIC	_xmlCharEncOutput
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_05EGJIMALK@UTF?98@			; `string'
PUBLIC	??_C@_04OOMJJNCF@UTF8@				; `string'
PUBLIC	??_C@_06KNDPGIKI@UTF?916@			; `string'
PUBLIC	??_C@_05MNCHLHCA@UTF16@				; `string'
PUBLIC	??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@		; `string'
PUBLIC	??_C@_05JHAMEAP@UCS?92@				; `string'
PUBLIC	??_C@_04MDAFHLBC@UCS2@				; `string'
PUBLIC	??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@		; `string'
PUBLIC	??_C@_05FPCKGDIJ@UCS?94@			; `string'
PUBLIC	??_C@_04JFFPNMJE@UCS4@				; `string'
PUBLIC	??_C@_0L@GJIJNDEK@ISO?98859?91@			; `string'
PUBLIC	??_C@_0M@HACBCLE@ISO?9LATIN?91@			; `string'
PUBLIC	??_C@_0M@POJFGGLA@ISO?5LATIN?51@		; `string'
PUBLIC	??_C@_0L@ECKEIAIJ@ISO?98859?92@			; `string'
PUBLIC	??_C@_0M@CMCPEBHH@ISO?9LATIN?92@		; `string'
PUBLIC	??_C@_0M@NFLIDFHD@ISO?5LATIN?52@		; `string'
PUBLIC	??_C@_0L@FLLPLBMI@ISO?98859?93@			; `string'
PUBLIC	??_C@_0L@BEPOCHAP@ISO?98859?94@			; `string'
PUBLIC	??_C@_0L@NOFBGEO@ISO?98859?95@			; `string'
PUBLIC	??_C@_0L@CGMIEFIN@ISO?98859?96@			; `string'
PUBLIC	??_C@_0L@DPNDHEMM@ISO?98859?97@			; `string'
PUBLIC	??_C@_0L@LIELGIAD@ISO?98859?98@			; `string'
PUBLIC	??_C@_0L@KBFAFJEC@ISO?98859?99@			; `string'
PUBLIC	??_C@_0M@LMIFKILO@ISO?92022?9JP@		; `string'
PUBLIC	??_C@_09NDNIACC@SHIFT_JIS@			; `string'
PUBLIC	??_C@_06KCFOODCD@EUC?9JP@			; `string'
PUBLIC	??_C@_06JJAKJGEC@EBCDIC@			; `string'
PUBLIC	??_C@_09DNLJOPNC@Shift?9JIS@			; `string'
PUBLIC	??_C@_0CH@LKFDNFFB@xmlNewCharEncodingHandler?5?3?5no?5@ ; `string'
PUBLIC	??_C@_0CN@DOLIIPJB@xmlNewCharEncodingHandler?5?3?5out@ ; `string'
PUBLIC	??_C@_0CF@BMACILLF@Odd?5problem?5at?5endianness?5detec@ ; `string'
PUBLIC	??_C@_0CP@BACAHNKC@xmlInitCharEncodingHandlers?5?3?5o@ ; `string'
PUBLIC	??_C@_08NBDJLNFA@UTF?916LE@			; `string'
PUBLIC	??_C@_08NLKHJAFK@UTF?916BE@			; `string'
PUBLIC	??_C@_05CCNLIHFO@ASCII@				; `string'
PUBLIC	??_C@_08DIBGJKBD@US?9ASCII@			; `string'
PUBLIC	??_C@_04DBLPJNAF@HTML@				; `string'
PUBLIC	??_C@_0DA@NDFKGHEJ@xmlRegisterCharEncodingHandler?3@ ; `string'
PUBLIC	??_C@_0BG@EJFNACMF@MAX_ENCODING_HANDLERS@	; `string'
PUBLIC	??_C@_0EF@MMDODKKK@xmlRegisterCharEncodingHandler?3@ ; `string'
PUBLIC	??_C@_06JNCBEIJA@ebcdic@			; `string'
PUBLIC	??_C@_09BNGJAIJK@EBCDIC?9US@			; `string'
PUBLIC	??_C@_07LDANGMFL@IBM?9037@			; `string'
PUBLIC	??_C@_09IOCPDDIN@SHIFT?9JIS@			; `string'
PUBLIC	??_C@_09LOKLFMHN@Shift_JIS@			; `string'
PUBLIC	??_C@_0CI@CIBAEANE@iconv?5?3?5problems?5with?5filters?5f@ ; `string'
PUBLIC	??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@ ; `string'
PUBLIC	??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@ ; `string'
PUBLIC	??_C@_0CJ@OOHAOGCN@xmlCharEncOutFunc?3?5no?5output?5fu@ ; `string'
PUBLIC	??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@		; `string'
PUBLIC	??_C@_0DG@MDDGIHO@output?5conversion?5failed?5due?5to@ ; `string'
EXTRN	_xmlGetUTF8Char:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__toupper:PROC
EXTRN	__imp__libiconv_open:PROC
EXTRN	__imp__libiconv:PROC
EXTRN	__imp__libiconv_close:PROC
EXTRN	_xmlBufContent:PROC
EXTRN	_xmlBufEnd:PROC
EXTRN	_xmlBufUse:PROC
EXTRN	_xmlBufShrink:PROC
EXTRN	_xmlBufferShrink:PROC
EXTRN	_xmlBufferGrow:PROC
EXTRN	___xmlRaiseError:PROC
EXTRN	___xmlSimpleError:PROC
EXTRN	_UTF8ToHtml:PROC
EXTRN	_xmlBufGetAllocationScheme:PROC
EXTRN	_xmlBufGrow:PROC
EXTRN	_xmlBufAvail:PROC
EXTRN	_xmlBufAddLen:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_xmlUTF16LEHandler DD 01H DUP (?)
_xmlUTF16BEHandler DD 01H DUP (?)
_xmlCharEncodingAliases DD 01H DUP (?)
_xmlCharEncodingAliasesNb DD 01H DUP (?)
_xmlCharEncodingAliasesMax DD 01H DUP (?)
_handlers DD	01H DUP (?)
_nbCharEncodingHandler DD 01H DUP (?)
_xmlDefaultCharEncodingHandler DD 01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DG@MDDGIHO@output?5conversion?5failed?5due?5to@
CONST	SEGMENT
??_C@_0DG@MDDGIHO@output?5conversion?5failed?5due?5to@ DB 'output convers'
	DB	'ion failed due to conv error, bytes %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@
CONST	SEGMENT
??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@ DB '&#%d;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OOHAOGCN@xmlCharEncOutFunc?3?5no?5output?5fu@
CONST	SEGMENT
??_C@_0CJ@OOHAOGCN@xmlCharEncOutFunc?3?5no?5output?5fu@ DB 'xmlCharEncOut'
	DB	'Func: no output function !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@
CONST	SEGMENT
??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@ DB 'input conver'
	DB	'sion failed due to input error, bytes %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
CONST	SEGMENT
??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@ DB '0x%02X'
	DB	' 0x%02X 0x%02X 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CIBAEANE@iconv?5?3?5problems?5with?5filters?5f@
CONST	SEGMENT
??_C@_0CI@CIBAEANE@iconv?5?3?5problems?5with?5filters?5f@ DB 'iconv : pro'
	DB	'blems with filters for ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LOKLFMHN@Shift_JIS@
CONST	SEGMENT
??_C@_09LOKLFMHN@Shift_JIS@ DB 'Shift_JIS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IOCPDDIN@SHIFT?9JIS@
CONST	SEGMENT
??_C@_09IOCPDDIN@SHIFT?9JIS@ DB 'SHIFT-JIS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDANGMFL@IBM?9037@
CONST	SEGMENT
??_C@_07LDANGMFL@IBM?9037@ DB 'IBM-037', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BNGJAIJK@EBCDIC?9US@
CONST	SEGMENT
??_C@_09BNGJAIJK@EBCDIC?9US@ DB 'EBCDIC-US', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JNCBEIJA@ebcdic@
CONST	SEGMENT
??_C@_06JNCBEIJA@ebcdic@ DB 'ebcdic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@MMDODKKK@xmlRegisterCharEncodingHandler?3@
CONST	SEGMENT
??_C@_0EF@MMDODKKK@xmlRegisterCharEncodingHandler?3@ DB 'xmlRegisterCharE'
	DB	'ncodingHandler: Too many handler registered, see %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EJFNACMF@MAX_ENCODING_HANDLERS@
CONST	SEGMENT
??_C@_0BG@EJFNACMF@MAX_ENCODING_HANDLERS@ DB 'MAX_ENCODING_HANDLERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NDFKGHEJ@xmlRegisterCharEncodingHandler?3@
CONST	SEGMENT
??_C@_0DA@NDFKGHEJ@xmlRegisterCharEncodingHandler?3@ DB 'xmlRegisterCharE'
	DB	'ncodingHandler: NULL handler !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBLPJNAF@HTML@
CONST	SEGMENT
??_C@_04DBLPJNAF@HTML@ DB 'HTML', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DIBGJKBD@US?9ASCII@
CONST	SEGMENT
??_C@_08DIBGJKBD@US?9ASCII@ DB 'US-ASCII', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCNLIHFO@ASCII@
CONST	SEGMENT
??_C@_05CCNLIHFO@ASCII@ DB 'ASCII', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLKHJAFK@UTF?916BE@
CONST	SEGMENT
??_C@_08NLKHJAFK@UTF?916BE@ DB 'UTF-16BE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NBDJLNFA@UTF?916LE@
CONST	SEGMENT
??_C@_08NBDJLNFA@UTF?916LE@ DB 'UTF-16LE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BACAHNKC@xmlInitCharEncodingHandlers?5?3?5o@
CONST	SEGMENT
??_C@_0CP@BACAHNKC@xmlInitCharEncodingHandlers?5?3?5o@ DB 'xmlInitCharEnc'
	DB	'odingHandlers : out of memory !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BMACILLF@Odd?5problem?5at?5endianness?5detec@
CONST	SEGMENT
??_C@_0CF@BMACILLF@Odd?5problem?5at?5endianness?5detec@ DB 'Odd problem a'
	DB	't endianness detection', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DOLIIPJB@xmlNewCharEncodingHandler?5?3?5out@
CONST	SEGMENT
??_C@_0CN@DOLIIPJB@xmlNewCharEncodingHandler?5?3?5out@ DB 'xmlNewCharEnco'
	DB	'dingHandler : out of memory !', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LKFDNFFB@xmlNewCharEncodingHandler?5?3?5no?5@
CONST	SEGMENT
??_C@_0CH@LKFDNFFB@xmlNewCharEncodingHandler?5?3?5no?5@ DB 'xmlNewCharEnc'
	DB	'odingHandler : no name !', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DNLJOPNC@Shift?9JIS@
CONST	SEGMENT
??_C@_09DNLJOPNC@Shift?9JIS@ DB 'Shift-JIS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJAKJGEC@EBCDIC@
CONST	SEGMENT
??_C@_06JJAKJGEC@EBCDIC@ DB 'EBCDIC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KCFOODCD@EUC?9JP@
CONST	SEGMENT
??_C@_06KCFOODCD@EUC?9JP@ DB 'EUC-JP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NDNIACC@SHIFT_JIS@
CONST	SEGMENT
??_C@_09NDNIACC@SHIFT_JIS@ DB 'SHIFT_JIS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMIFKILO@ISO?92022?9JP@
CONST	SEGMENT
??_C@_0M@LMIFKILO@ISO?92022?9JP@ DB 'ISO-2022-JP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KBFAFJEC@ISO?98859?99@
CONST	SEGMENT
??_C@_0L@KBFAFJEC@ISO?98859?99@ DB 'ISO-8859-9', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LIELGIAD@ISO?98859?98@
CONST	SEGMENT
??_C@_0L@LIELGIAD@ISO?98859?98@ DB 'ISO-8859-8', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DPNDHEMM@ISO?98859?97@
CONST	SEGMENT
??_C@_0L@DPNDHEMM@ISO?98859?97@ DB 'ISO-8859-7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CGMIEFIN@ISO?98859?96@
CONST	SEGMENT
??_C@_0L@CGMIEFIN@ISO?98859?96@ DB 'ISO-8859-6', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NOFBGEO@ISO?98859?95@
CONST	SEGMENT
??_C@_0L@NOFBGEO@ISO?98859?95@ DB 'ISO-8859-5', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BEPOCHAP@ISO?98859?94@
CONST	SEGMENT
??_C@_0L@BEPOCHAP@ISO?98859?94@ DB 'ISO-8859-4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FLLPLBMI@ISO?98859?93@
CONST	SEGMENT
??_C@_0L@FLLPLBMI@ISO?98859?93@ DB 'ISO-8859-3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NFLIDFHD@ISO?5LATIN?52@
CONST	SEGMENT
??_C@_0M@NFLIDFHD@ISO?5LATIN?52@ DB 'ISO LATIN 2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CMCPEBHH@ISO?9LATIN?92@
CONST	SEGMENT
??_C@_0M@CMCPEBHH@ISO?9LATIN?92@ DB 'ISO-LATIN-2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ECKEIAIJ@ISO?98859?92@
CONST	SEGMENT
??_C@_0L@ECKEIAIJ@ISO?98859?92@ DB 'ISO-8859-2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@POJFGGLA@ISO?5LATIN?51@
CONST	SEGMENT
??_C@_0M@POJFGGLA@ISO?5LATIN?51@ DB 'ISO LATIN 1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HACBCLE@ISO?9LATIN?91@
CONST	SEGMENT
??_C@_0M@HACBCLE@ISO?9LATIN?91@ DB 'ISO-LATIN-1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GJIJNDEK@ISO?98859?91@
CONST	SEGMENT
??_C@_0L@GJIJNDEK@ISO?98859?91@ DB 'ISO-8859-1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFFPNMJE@UCS4@
CONST	SEGMENT
??_C@_04JFFPNMJE@UCS4@ DB 'UCS4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FPCKGDIJ@UCS?94@
CONST	SEGMENT
??_C@_05FPCKGDIJ@UCS?94@ DB 'UCS-4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@
CONST	SEGMENT
??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@ DB 'ISO-10646-UCS-4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MDAFHLBC@UCS2@
CONST	SEGMENT
??_C@_04MDAFHLBC@UCS2@ DB 'UCS2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JHAMEAP@UCS?92@
CONST	SEGMENT
??_C@_05JHAMEAP@UCS?92@ DB 'UCS-2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@
CONST	SEGMENT
??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@ DB 'ISO-10646-UCS-2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNCHLHCA@UTF16@
CONST	SEGMENT
??_C@_05MNCHLHCA@UTF16@ DB 'UTF16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KNDPGIKI@UTF?916@
CONST	SEGMENT
??_C@_06KNDPGIKI@UTF?916@ DB 'UTF-16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OOMJJNCF@UTF8@
CONST	SEGMENT
??_C@_04OOMJJNCF@UTF8@ DB 'UTF8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EGJIMALK@UTF?98@
CONST	SEGMENT
??_C@_05EGJIMALK@UTF?98@ DB 'UTF-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_xmlLittleEndian DD 01H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlEncOutputChunk
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_outlen$ = 16						; size = 4
_in$ = 20						; size = 4
_inlen$ = 24						; size = 4
_xmlEncOutputChunk PROC					; COMDAT

; 1947 :                   int *outlen, const unsigned char *in, int *inlen) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1948 :     int ret;
; 1949 : 
; 1950 :     if (handler->output != NULL) {

	mov	eax, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@xmlEncOutp

; 1951 :         ret = handler->output(out, outlen, in, inlen);

	mov	esi, esp
	mov	ecx, DWORD PTR _inlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	mov	eax, DWORD PTR _outlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handler$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 1952 :     }

	jmp	SHORT $LN3@xmlEncOutp
$LN2@xmlEncOutp:

; 1953 : #ifdef LIBXML_ICONV_ENABLED
; 1954 :     else if (handler->iconv_out != NULL) {

	mov	ecx, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN4@xmlEncOutp

; 1955 :         ret = xmlIconvWrapper(handler->iconv_out, out, outlen, in, inlen);

	mov	edx, DWORD PTR _inlen$[ebp]
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	mov	eax, DWORD PTR _handler$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_xmlIconvWrapper
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$[ebp], eax

; 1956 :     }

	jmp	SHORT $LN3@xmlEncOutp
$LN4@xmlEncOutp:

; 1957 : #endif /* LIBXML_ICONV_ENABLED */
; 1958 : #ifdef LIBXML_ICU_ENABLED
; 1959 :     else if (handler->uconv_out != NULL) {
; 1960 :         ret = xmlUconvWrapper(handler->uconv_out, 0, out, outlen, in, inlen,
; 1961 :                               TRUE);
; 1962 :     }
; 1963 : #endif /* LIBXML_ICU_ENABLED */
; 1964 :     else {
; 1965 :         *outlen = 0;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], 0

; 1966 :         *inlen = 0;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], 0

; 1967 :         ret = -4;

	mov	DWORD PTR _ret$[ebp], -4		; fffffffcH
$LN3@xmlEncOutp:

; 1968 :     }
; 1969 : 
; 1970 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]

; 1971 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlEncOutputChunk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlEncInputChunk
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_outlen$ = 16						; size = 4
_in$ = 20						; size = 4
_inlen$ = 24						; size = 4
_flush$ = 28						; size = 4
_xmlEncInputChunk PROC					; COMDAT

; 1917 :                  int *outlen, const unsigned char *in, int *inlen, int flush) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1918 :     int ret;
; 1919 :     (void)flush;
; 1920 : 
; 1921 :     if (handler->input != NULL) {

	mov	eax, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@xmlEncInpu

; 1922 :         ret = handler->input(out, outlen, in, inlen);

	mov	esi, esp
	mov	ecx, DWORD PTR _inlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	mov	eax, DWORD PTR _outlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handler$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 1923 :     }

	jmp	SHORT $LN3@xmlEncInpu
$LN2@xmlEncInpu:

; 1924 : #ifdef LIBXML_ICONV_ENABLED
; 1925 :     else if (handler->iconv_in != NULL) {

	mov	ecx, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN4@xmlEncInpu

; 1926 :         ret = xmlIconvWrapper(handler->iconv_in, out, outlen, in, inlen);

	mov	edx, DWORD PTR _inlen$[ebp]
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	mov	eax, DWORD PTR _handler$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlIconvWrapper
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$[ebp], eax

; 1927 :     }

	jmp	SHORT $LN3@xmlEncInpu
$LN4@xmlEncInpu:

; 1928 : #endif /* LIBXML_ICONV_ENABLED */
; 1929 : #ifdef LIBXML_ICU_ENABLED
; 1930 :     else if (handler->uconv_in != NULL) {
; 1931 :         ret = xmlUconvWrapper(handler->uconv_in, 1, out, outlen, in, inlen,
; 1932 :                               flush);
; 1933 :     }
; 1934 : #endif /* LIBXML_ICU_ENABLED */
; 1935 :     else {
; 1936 :         *outlen = 0;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], 0

; 1937 :         *inlen = 0;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], 0

; 1938 :         ret = -2;

	mov	DWORD PTR _ret$[ebp], -2		; fffffffeH
$LN3@xmlEncInpu:

; 1939 :     }
; 1940 : 
; 1941 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]

; 1942 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlEncInputChunk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlIconvWrapper
_TEXT	SEGMENT
_ret$ = -52						; size = 4
_icv_out$ = -44						; size = 4
_icv_in$ = -32						; size = 4
_icv_outlen$ = -20					; size = 4
_icv_inlen$ = -8					; size = 4
_cd$ = 8						; size = 4
_out$ = 12						; size = 4
_outlen$ = 16						; size = 4
_in$ = 20						; size = 4
_inlen$ = 24						; size = 4
_xmlIconvWrapper PROC					; COMDAT

; 1802 :                 const unsigned char *in, int *inlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1803 :     size_t icv_inlen, icv_outlen;
; 1804 :     const char *icv_in = (const char *) in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _icv_in$[ebp], eax

; 1805 :     char *icv_out = (char *) out;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _icv_out$[ebp], ecx

; 1806 :     int ret;
; 1807 : 
; 1808 :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL)) {

	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN3@xmlIconvWr
	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN3@xmlIconvWr
	cmp	DWORD PTR _inlen$[ebp], 0
	je	SHORT $LN3@xmlIconvWr
	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN2@xmlIconvWr
$LN3@xmlIconvWr:

; 1809 :         if (outlen != NULL) *outlen = 0;

	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN4@xmlIconvWr
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], 0
$LN4@xmlIconvWr:

; 1810 :         return(-1);

	or	eax, -1
	jmp	$LN1@xmlIconvWr
$LN2@xmlIconvWr:

; 1811 :     }
; 1812 :     icv_inlen = *inlen;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _icv_inlen$[ebp], ecx

; 1813 :     icv_outlen = *outlen;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _icv_outlen$[ebp], eax

; 1814 :     ret = iconv(cd, (ICONV_CONST char **) &icv_in, &icv_inlen, &icv_out, &icv_outlen);

	mov	esi, esp
	lea	ecx, DWORD PTR _icv_outlen$[ebp]
	push	ecx
	lea	edx, DWORD PTR _icv_out$[ebp]
	push	edx
	lea	eax, DWORD PTR _icv_inlen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _icv_in$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cd$[ebp]
	push	edx
	call	DWORD PTR __imp__libiconv
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 1815 :     *inlen -= icv_inlen;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _icv_inlen$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 1816 :     *outlen -= icv_outlen;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _icv_outlen$[ebp]
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 1817 :     if ((icv_inlen != 0) || (ret == -1)) {

	cmp	DWORD PTR _icv_inlen$[ebp], 0
	jne	SHORT $LN6@xmlIconvWr
	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN5@xmlIconvWr
$LN6@xmlIconvWr:

; 1818 : #ifdef EILSEQ
; 1819 :         if (errno == EILSEQ) {

	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	DWORD PTR [eax], 42			; 0000002aH
	jne	SHORT $LN7@xmlIconvWr

; 1820 :             return -2;

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@xmlIconvWr

; 1821 :         } else

	jmp	SHORT $LN5@xmlIconvWr
$LN7@xmlIconvWr:

; 1822 : #endif
; 1823 : #ifdef E2BIG
; 1824 :         if (errno == E2BIG) {

	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	DWORD PTR [eax], 7
	jne	SHORT $LN9@xmlIconvWr

; 1825 :             return -1;

	or	eax, -1
	jmp	SHORT $LN1@xmlIconvWr

; 1826 :         } else

	jmp	SHORT $LN5@xmlIconvWr
$LN9@xmlIconvWr:

; 1827 : #endif
; 1828 : #ifdef EINVAL
; 1829 :         if (errno == EINVAL) {

	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	DWORD PTR [eax], 22			; 00000016H
	jne	SHORT $LN11@xmlIconvWr

; 1830 :             return -3;

	mov	eax, -3					; fffffffdH
	jmp	SHORT $LN1@xmlIconvWr

; 1831 :         } else

	jmp	SHORT $LN5@xmlIconvWr
$LN11@xmlIconvWr:

; 1832 : #endif
; 1833 :         {
; 1834 :             return -3;

	mov	eax, -3					; fffffffdH
	jmp	SHORT $LN1@xmlIconvWr
$LN5@xmlIconvWr:

; 1835 :         }
; 1836 :     }
; 1837 :     return 0;

	xor	eax, eax
$LN1@xmlIconvWr:

; 1838 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@xmlIconvWr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN19@xmlIconvWr:
	DD	4
	DD	$LN18@xmlIconvWr
$LN18@xmlIconvWr:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN14@xmlIconvWr
	DD	-20					; ffffffecH
	DD	4
	DD	$LN15@xmlIconvWr
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN16@xmlIconvWr
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN17@xmlIconvWr
$LN17@xmlIconvWr:
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$LN16@xmlIconvWr:
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
$LN15@xmlIconvWr:
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN14@xmlIconvWr:
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_xmlIconvWrapper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8ToUTF16BE
_TEXT	SEGMENT
tv131 = -56						; size = 4
tv130 = -52						; size = 4
_tmp2$ = -48						; size = 2
_tmp1$ = -44						; size = 2
_tmp$ = -40						; size = 4
_trailing$ = -36					; size = 4
_d$ = -32						; size = 4
_c$ = -28						; size = 4
_inend$ = -24						; size = 4
_outend$ = -20						; size = 4
_outstart$ = -16					; size = 4
_instart$ = -12						; size = 4
_processed$ = -8					; size = 4
_out$ = -4						; size = 4
_outb$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_UTF8ToUTF16BE PROC					; COMDAT

; 823  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 824  :     unsigned short* out = (unsigned short*) outb;

	mov	eax, DWORD PTR _outb$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 825  :     const unsigned char* processed = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 826  :     const unsigned char *const instart = in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _instart$[ebp], edx

; 827  :     unsigned short* outstart= out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 828  :     unsigned short* outend;
; 829  :     const unsigned char* inend;
; 830  :     unsigned int c, d;
; 831  :     int trailing;
; 832  :     unsigned char *tmp;
; 833  :     unsigned short tmp1, tmp2;
; 834  : 
; 835  :     /* UTF-16BE has no BOM */
; 836  :     if ((outb == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);

	cmp	DWORD PTR _outb$[ebp], 0
	je	SHORT $LN8@UTF8ToUTF1
	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN8@UTF8ToUTF1
	cmp	DWORD PTR _inlen$[ebp], 0
	jne	SHORT $LN7@UTF8ToUTF1
$LN8@UTF8ToUTF1:
	or	eax, -1
	jmp	$LN1@UTF8ToUTF1
$LN7@UTF8ToUTF1:

; 837  :     if (in == NULL) {

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN9@UTF8ToUTF1

; 838  : 	*outlen = 0;

	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], 0

; 839  : 	*inlen = 0;

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], 0

; 840  : 	return(0);

	xor	eax, eax
	jmp	$LN1@UTF8ToUTF1
$LN9@UTF8ToUTF1:

; 841  :     }
; 842  :     inend= in + *inlen;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _inend$[ebp], ecx

; 843  :     outend = out + (*outlen / 2);

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _outend$[ebp], edx
$LN2@UTF8ToUTF1:

; 844  :     while (in < inend) {

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jae	$LN3@UTF8ToUTF1

; 845  :       d= *in++;

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 846  :       if      (d < 0x80)  { c= d; trailing= 0; }

	cmp	DWORD PTR _d$[ebp], 128			; 00000080H
	jae	SHORT $LN10@UTF8ToUTF1
	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _trailing$[ebp], 0
	jmp	$LN11@UTF8ToUTF1
$LN10@UTF8ToUTF1:

; 847  :       else if (d < 0xC0)  {

	cmp	DWORD PTR _d$[ebp], 192			; 000000c0H
	jae	SHORT $LN12@UTF8ToUTF1

; 848  :           /* trailing byte in leading position */
; 849  : 	  *outlen = out - outstart;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	sar	edx, 1
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 850  : 	  *inlen = processed - instart;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _instart$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 851  : 	  return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF8ToUTF1
	jmp	SHORT $LN11@UTF8ToUTF1
$LN12@UTF8ToUTF1:

; 852  :       } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }

	cmp	DWORD PTR _d$[ebp], 224			; 000000e0H
	jae	SHORT $LN14@UTF8ToUTF1
	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _c$[ebp], eax
	mov	DWORD PTR _trailing$[ebp], 1
	jmp	SHORT $LN11@UTF8ToUTF1
$LN14@UTF8ToUTF1:

; 853  :       else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }

	cmp	DWORD PTR _d$[ebp], 240			; 000000f0H
	jae	SHORT $LN16@UTF8ToUTF1
	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _trailing$[ebp], 2
	jmp	SHORT $LN11@UTF8ToUTF1
$LN16@UTF8ToUTF1:

; 854  :       else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }

	cmp	DWORD PTR _d$[ebp], 248			; 000000f8H
	jae	SHORT $LN18@UTF8ToUTF1
	mov	edx, DWORD PTR _d$[ebp]
	and	edx, 7
	mov	DWORD PTR _c$[ebp], edx
	mov	DWORD PTR _trailing$[ebp], 3
	jmp	SHORT $LN11@UTF8ToUTF1
$LN18@UTF8ToUTF1:

; 855  :       else {
; 856  :           /* no chance for this in UTF-16 */
; 857  : 	  *outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	sar	eax, 1
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 858  : 	  *inlen = processed - instart;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _instart$[ebp]
	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], edx

; 859  : 	  return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF8ToUTF1
$LN11@UTF8ToUTF1:

; 860  :       }
; 861  : 
; 862  :       if (inend - in < trailing) {

	mov	ecx, DWORD PTR _inend$[ebp]
	sub	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _trailing$[ebp]
	jge	SHORT $LN20@UTF8ToUTF1

; 863  :           break;

	jmp	$LN3@UTF8ToUTF1
$LN20@UTF8ToUTF1:

; 864  :       }
; 865  : 
; 866  :       for ( ; trailing; trailing--) {

	jmp	SHORT $LN6@UTF8ToUTF1
$LN4@UTF8ToUTF1:
	mov	edx, DWORD PTR _trailing$[ebp]
	sub	edx, 1
	mov	DWORD PTR _trailing$[ebp], edx
$LN6@UTF8ToUTF1:
	cmp	DWORD PTR _trailing$[ebp], 0
	je	SHORT $LN5@UTF8ToUTF1

; 867  :           if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))  break;

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jae	SHORT $LN22@UTF8ToUTF1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 192				; 000000c0H
	mov	DWORD PTR tv130[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	cmp	DWORD PTR tv130[ebp], 128		; 00000080H
	je	SHORT $LN34@UTF8ToUTF1
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $LN35@UTF8ToUTF1
$LN34@UTF8ToUTF1:
	mov	DWORD PTR tv131[ebp], 0
$LN35@UTF8ToUTF1:
	cmp	DWORD PTR tv131[ebp], 0
	je	SHORT $LN21@UTF8ToUTF1
$LN22@UTF8ToUTF1:
	jmp	SHORT $LN5@UTF8ToUTF1
$LN21@UTF8ToUTF1:

; 868  :           c <<= 6;

	mov	edx, DWORD PTR _c$[ebp]
	shl	edx, 6
	mov	DWORD PTR _c$[ebp], edx

; 869  :           c |= d & 0x3F;

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 870  :       }

	jmp	SHORT $LN4@UTF8ToUTF1
$LN5@UTF8ToUTF1:

; 871  : 
; 872  :       /* assertion: c is a single UTF-4 value */
; 873  :         if (c < 0x10000) {

	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $LN23@UTF8ToUTF1

; 874  :             if (out >= outend)  break;

	mov	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, DWORD PTR _outend$[ebp]
	jb	SHORT $LN25@UTF8ToUTF1
	jmp	$LN3@UTF8ToUTF1
$LN25@UTF8ToUTF1:

; 875  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN26@UTF8ToUTF1

; 876  : 		tmp = (unsigned char *) out;

	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 877  : 		*tmp = c >> 8;

	mov	eax, DWORD PTR _c$[ebp]
	shr	eax, 8
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [ecx], al

; 878  : 		*(tmp + 1) = c;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx+1], al

; 879  : 		out++;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$[ebp], ecx

; 880  : 	    } else {

	jmp	SHORT $LN27@UTF8ToUTF1
$LN26@UTF8ToUTF1:

; 881  : 		*out++ = c;

	mov	edx, DWORD PTR _out$[ebp]
	mov	ax, WORD PTR _c$[ebp]
	mov	WORD PTR [edx], ax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$[ebp], ecx
$LN27@UTF8ToUTF1:

; 882  : 	    }
; 883  :         }

	jmp	$LN24@UTF8ToUTF1
$LN23@UTF8ToUTF1:

; 884  :         else if (c < 0x110000) {

	cmp	DWORD PTR _c$[ebp], 1114112		; 00110000H
	jae	$LN28@UTF8ToUTF1

; 885  :             if (out+1 >= outend)  break;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	cmp	edx, DWORD PTR _outend$[ebp]
	jb	SHORT $LN30@UTF8ToUTF1
	jmp	$LN3@UTF8ToUTF1
$LN30@UTF8ToUTF1:

; 886  :             c -= 0x10000;

	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 65536				; 00010000H
	mov	DWORD PTR _c$[ebp], eax

; 887  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN31@UTF8ToUTF1

; 888  : 		tmp1 = 0xD800 | (c >> 10);

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 10					; 0000000aH
	or	ecx, 55296				; 0000d800H
	mov	WORD PTR _tmp1$[ebp], cx

; 889  : 		tmp = (unsigned char *) out;

	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 890  : 		*tmp = tmp1 >> 8;

	movzx	eax, WORD PTR _tmp1$[ebp]
	sar	eax, 8
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [ecx], al

; 891  : 		*(tmp + 1) = (unsigned char) tmp1;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	al, BYTE PTR _tmp1$[ebp]
	mov	BYTE PTR [edx+1], al

; 892  : 		out++;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$[ebp], ecx

; 893  : 
; 894  : 		tmp2 = 0xDC00 | (c & 0x03FF);

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 1023				; 000003ffH
	or	edx, 56320				; 0000dc00H
	mov	WORD PTR _tmp2$[ebp], dx

; 895  : 		tmp = (unsigned char *) out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 896  : 		*tmp = tmp2 >> 8;

	movzx	ecx, WORD PTR _tmp2$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [edx], cl

; 897  : 		*(tmp + 1) = (unsigned char) tmp2;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	cl, BYTE PTR _tmp2$[ebp]
	mov	BYTE PTR [eax+1], cl

; 898  : 		out++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx

; 899  : 	    } else {

	jmp	SHORT $LN32@UTF8ToUTF1
$LN31@UTF8ToUTF1:

; 900  : 		*out++ = 0xD800 | (c >> 10);

	mov	eax, DWORD PTR _c$[ebp]
	shr	eax, 10					; 0000000aH
	or	eax, 55296				; 0000d800H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx

; 901  : 		*out++ = 0xDC00 | (c & 0x03FF);

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 1023				; 000003ffH
	or	eax, 56320				; 0000dc00H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx
$LN32@UTF8ToUTF1:

; 902  : 	    }
; 903  :         }

	jmp	SHORT $LN24@UTF8ToUTF1
$LN28@UTF8ToUTF1:

; 904  :         else
; 905  : 	    break;

	jmp	SHORT $LN3@UTF8ToUTF1
$LN24@UTF8ToUTF1:

; 906  : 	processed = in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], eax

; 907  :     }

	jmp	$LN2@UTF8ToUTF1
$LN3@UTF8ToUTF1:

; 908  :     *outlen = (out - outstart) * 2;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	sar	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 909  :     *inlen = processed - instart;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _instart$[ebp]
	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 910  :     return(*outlen);

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [edx]
$LN1@UTF8ToUTF1:

; 911  : }

	pop	edi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF8ToUTF16BE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF16BEToUTF8
_TEXT	SEGMENT
_bits$ = -40						; size = 4
_tmp$ = -36						; size = 4
_inlen$ = -32						; size = 4
_d$ = -28						; size = 4
_c$ = -24						; size = 4
_inend$ = -20						; size = 4
_in$ = -16						; size = 4
_outend$ = -12						; size = 4
_processed$ = -8					; size = 4
_outstart$ = -4						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_inb$ = 16						; size = 4
_inlenb$ = 20						; size = 4
_UTF16BEToUTF8 PROC					; COMDAT

; 734  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 735  :     unsigned char* outstart = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 736  :     const unsigned char* processed = inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 737  :     unsigned char* outend = out + *outlen;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _outend$[ebp], eax

; 738  :     unsigned short* in = (unsigned short*) inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _in$[ebp], ecx

; 739  :     unsigned short* inend;
; 740  :     unsigned int c, d, inlen;
; 741  :     unsigned char *tmp;
; 742  :     int bits;
; 743  : 
; 744  :     if ((*inlenb % 2) == 1)

	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN25@UTF16BEToU
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN25@UTF16BEToU:
	cmp	eax, 1
	jne	SHORT $LN7@UTF16BEToU

; 745  :         (*inlenb)--;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx
$LN7@UTF16BEToU:

; 746  :     inlen = *inlenb / 2;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _inlen$[ebp], eax

; 747  :     inend= in + inlen;

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _inend$[ebp], ecx
$LN2@UTF16BEToU:

; 748  :     while (in < inend) {

	mov	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _inend$[ebp]
	jae	$LN3@UTF16BEToU

; 749  : 	if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN8@UTF16BEToU

; 750  : 	    tmp = (unsigned char *) in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 751  : 	    c = *tmp++;

	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _c$[ebp], edx
	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$[ebp], eax

; 752  : 	    c = c << 8;

	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 8
	mov	DWORD PTR _c$[ebp], ecx

; 753  : 	    c = c | (unsigned int) *tmp;

	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	or	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 754  : 	    in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx

; 755  : 	} else {

	jmp	SHORT $LN9@UTF16BEToU
$LN8@UTF16BEToU:

; 756  : 	    c= *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx
$LN9@UTF16BEToU:

; 757  : 	}
; 758  :         if ((c & 0xFC00) == 0xD800) {    /* surrogates */

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 64512				; 0000fc00H
	cmp	edx, 55296				; 0000d800H
	jne	$LN10@UTF16BEToU

; 759  : 	    if (in >= inend) {           /* (in > inend) shouldn't happens */

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jb	SHORT $LN11@UTF16BEToU

; 760  : 		*outlen = out - outstart;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 761  : 		*inlenb = processed - inb;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _inb$[ebp]
	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [ecx], eax

; 762  : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF16BEToU
$LN11@UTF16BEToU:

; 763  : 	    }
; 764  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN12@UTF16BEToU

; 765  : 		tmp = (unsigned char *) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 766  : 		d = *tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx

; 767  : 		d = d << 8;

	mov	eax, DWORD PTR _d$[ebp]
	shl	eax, 8
	mov	DWORD PTR _d$[ebp], eax

; 768  : 		d = d | (unsigned int) *tmp;

	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _d$[ebp], edx

; 769  : 		in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 2
	mov	DWORD PTR _in$[ebp], eax

; 770  : 	    } else {

	jmp	SHORT $LN13@UTF16BEToU
$LN12@UTF16BEToU:

; 771  : 		d= *in++;

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, WORD PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 2
	mov	DWORD PTR _in$[ebp], eax
$LN13@UTF16BEToU:

; 772  : 	    }
; 773  :             if ((d & 0xFC00) == 0xDC00) {

	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 64512				; 0000fc00H
	cmp	ecx, 56320				; 0000dc00H
	jne	SHORT $LN14@UTF16BEToU

; 774  :                 c &= 0x03FF;

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 1023				; 000003ffH
	mov	DWORD PTR _c$[ebp], edx

; 775  :                 c <<= 10;

	mov	eax, DWORD PTR _c$[ebp]
	shl	eax, 10					; 0000000aH
	mov	DWORD PTR _c$[ebp], eax

; 776  :                 c |= d & 0x03FF;

	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 1023				; 000003ffH
	or	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], ecx

; 777  :                 c += 0x10000;

	mov	edx, DWORD PTR _c$[ebp]
	add	edx, 65536				; 00010000H
	mov	DWORD PTR _c$[ebp], edx

; 778  :             }

	jmp	SHORT $LN10@UTF16BEToU
$LN14@UTF16BEToU:

; 779  :             else {
; 780  : 		*outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 781  : 		*inlenb = processed - inb;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _inb$[ebp]
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx

; 782  : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF16BEToU
$LN10@UTF16BEToU:

; 783  : 	    }
; 784  :         }
; 785  : 
; 786  : 	/* assertion: c is a single UTF-4 value */
; 787  :         if (out >= outend)

	mov	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, DWORD PTR _outend$[ebp]
	jb	SHORT $LN16@UTF16BEToU

; 788  : 	    break;

	jmp	$LN3@UTF16BEToU
$LN16@UTF16BEToU:

; 789  :         if      (c <    0x80) {  *out++=  c;                bits= -6; }

	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jae	SHORT $LN17@UTF16BEToU
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], -6		; fffffffaH
	jmp	$LN18@UTF16BEToU
$LN17@UTF16BEToU:

; 790  :         else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }

	cmp	DWORD PTR _c$[ebp], 2048		; 00000800H
	jae	SHORT $LN19@UTF16BEToU
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 6
	and	edx, 31					; 0000001fH
	or	edx, 192				; 000000c0H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], 0
	jmp	SHORT $LN18@UTF16BEToU
$LN19@UTF16BEToU:

; 791  :         else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }

	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $LN21@UTF16BEToU
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 12					; 0000000cH
	and	edx, 15					; 0000000fH
	or	edx, 224				; 000000e0H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], 6
	jmp	SHORT $LN18@UTF16BEToU
$LN21@UTF16BEToU:

; 792  :         else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }

	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 18					; 00000012H
	and	edx, 7
	or	edx, 240				; 000000f0H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], 12		; 0000000cH
$LN18@UTF16BEToU:

; 793  : 
; 794  :         for ( ; bits >= 0; bits-= 6) {

	jmp	SHORT $LN6@UTF16BEToU
$LN4@UTF16BEToU:
	mov	edx, DWORD PTR _bits$[ebp]
	sub	edx, 6
	mov	DWORD PTR _bits$[ebp], edx
$LN6@UTF16BEToU:
	cmp	DWORD PTR _bits$[ebp], 0
	jl	SHORT $LN5@UTF16BEToU

; 795  :             if (out >= outend)

	mov	eax, DWORD PTR _out$[ebp]
	cmp	eax, DWORD PTR _outend$[ebp]
	jb	SHORT $LN23@UTF16BEToU

; 796  : 	        break;

	jmp	SHORT $LN5@UTF16BEToU
$LN23@UTF16BEToU:

; 797  :             *out++= ((c >> bits) & 0x3F) | 0x80;

	mov	edx, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _bits$[ebp]
	shr	edx, cl
	and	edx, 63					; 0000003fH
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 798  :         }

	jmp	SHORT $LN4@UTF16BEToU
$LN5@UTF16BEToU:

; 799  : 	processed = (const unsigned char*) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], edx

; 800  :     }

	jmp	$LN2@UTF16BEToU
$LN3@UTF16BEToU:

; 801  :     *outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 802  :     *inlenb = processed - inb;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _inb$[ebp]
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx

; 803  :     return(*outlen);

	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [ecx]
$LN1@UTF16BEToU:

; 804  : }

	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF16BEToUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8ToUTF16
_TEXT	SEGMENT
_outb$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_UTF8ToUTF16 PROC					; COMDAT

; 690  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 691  :     if (in == NULL) {

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN2@UTF8ToUTF1

; 692  : 	/*
; 693  : 	 * initialization, add the Byte Order Mark for UTF-16LE
; 694  : 	 */
; 695  :         if (*outlen >= 2) {

	mov	eax, DWORD PTR _outlen$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN3@UTF8ToUTF1

; 696  : 	    outb[0] = 0xFF;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _outb$[ebp]
	mov	BYTE PTR [eax+edx], 255			; 000000ffH

; 697  : 	    outb[1] = 0xFE;

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _outb$[ebp]
	mov	BYTE PTR [edx+ecx], 254			; 000000feH

; 698  : 	    *outlen = 2;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], 2

; 699  : 	    *inlen = 0;

	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], 0

; 700  : #ifdef DEBUG_ENCODING
; 701  :             xmlGenericError(xmlGenericErrorContext,
; 702  : 		    "Added FFFE Byte Order Mark\n");
; 703  : #endif
; 704  : 	    return(2);

	mov	eax, 2
	jmp	SHORT $LN1@UTF8ToUTF1
$LN3@UTF8ToUTF1:

; 705  : 	}
; 706  : 	*outlen = 0;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], 0

; 707  : 	*inlen = 0;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], 0

; 708  : 	return(0);

	xor	eax, eax
	jmp	SHORT $LN1@UTF8ToUTF1
$LN2@UTF8ToUTF1:

; 709  :     }
; 710  :     return (UTF8ToUTF16LE(outb, outlen, in, inlen));

	mov	ecx, DWORD PTR _inlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	mov	eax, DWORD PTR _outlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outb$[ebp]
	push	ecx
	call	_UTF8ToUTF16LE
	add	esp, 16					; 00000010H
$LN1@UTF8ToUTF1:

; 711  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_UTF8ToUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8ToUTF16LE
_TEXT	SEGMENT
tv133 = -56						; size = 4
tv132 = -52						; size = 4
_tmp2$ = -48						; size = 2
_tmp1$ = -44						; size = 2
_tmp$ = -40						; size = 4
_trailing$ = -36					; size = 4
_d$ = -32						; size = 4
_c$ = -28						; size = 4
_inend$ = -24						; size = 4
_outend$ = -20						; size = 4
_outstart$ = -16					; size = 4
_instart$ = -12						; size = 4
_processed$ = -8					; size = 4
_out$ = -4						; size = 4
_outb$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_UTF8ToUTF16LE PROC					; COMDAT

; 581  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 582  :     unsigned short* out = (unsigned short*) outb;

	mov	eax, DWORD PTR _outb$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 583  :     const unsigned char* processed = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 584  :     const unsigned char *const instart = in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _instart$[ebp], edx

; 585  :     unsigned short* outstart= out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 586  :     unsigned short* outend;
; 587  :     const unsigned char* inend;
; 588  :     unsigned int c, d;
; 589  :     int trailing;
; 590  :     unsigned char *tmp;
; 591  :     unsigned short tmp1, tmp2;
; 592  : 
; 593  :     /* UTF16LE encoding has no BOM */
; 594  :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);

	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN8@UTF8ToUTF1
	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN8@UTF8ToUTF1
	cmp	DWORD PTR _inlen$[ebp], 0
	jne	SHORT $LN7@UTF8ToUTF1
$LN8@UTF8ToUTF1:
	or	eax, -1
	jmp	$LN1@UTF8ToUTF1
$LN7@UTF8ToUTF1:

; 595  :     if (in == NULL) {

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN9@UTF8ToUTF1

; 596  : 	*outlen = 0;

	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], 0

; 597  : 	*inlen = 0;

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], 0

; 598  : 	return(0);

	xor	eax, eax
	jmp	$LN1@UTF8ToUTF1
$LN9@UTF8ToUTF1:

; 599  :     }
; 600  :     inend= in + *inlen;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _inend$[ebp], ecx

; 601  :     outend = out + (*outlen / 2);

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _outend$[ebp], edx
$LN2@UTF8ToUTF1:

; 602  :     while (in < inend) {

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jae	$LN3@UTF8ToUTF1

; 603  :       d= *in++;

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 604  :       if      (d < 0x80)  { c= d; trailing= 0; }

	cmp	DWORD PTR _d$[ebp], 128			; 00000080H
	jae	SHORT $LN10@UTF8ToUTF1
	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _trailing$[ebp], 0
	jmp	$LN11@UTF8ToUTF1
$LN10@UTF8ToUTF1:

; 605  :       else if (d < 0xC0) {

	cmp	DWORD PTR _d$[ebp], 192			; 000000c0H
	jae	SHORT $LN12@UTF8ToUTF1

; 606  :           /* trailing byte in leading position */
; 607  : 	  *outlen = (out - outstart) * 2;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	sar	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 608  : 	  *inlen = processed - instart;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _instart$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 609  : 	  return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF8ToUTF1
	jmp	SHORT $LN11@UTF8ToUTF1
$LN12@UTF8ToUTF1:

; 610  :       } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }

	cmp	DWORD PTR _d$[ebp], 224			; 000000e0H
	jae	SHORT $LN14@UTF8ToUTF1
	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _c$[ebp], eax
	mov	DWORD PTR _trailing$[ebp], 1
	jmp	SHORT $LN11@UTF8ToUTF1
$LN14@UTF8ToUTF1:

; 611  :       else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }

	cmp	DWORD PTR _d$[ebp], 240			; 000000f0H
	jae	SHORT $LN16@UTF8ToUTF1
	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _trailing$[ebp], 2
	jmp	SHORT $LN11@UTF8ToUTF1
$LN16@UTF8ToUTF1:

; 612  :       else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }

	cmp	DWORD PTR _d$[ebp], 248			; 000000f8H
	jae	SHORT $LN18@UTF8ToUTF1
	mov	edx, DWORD PTR _d$[ebp]
	and	edx, 7
	mov	DWORD PTR _c$[ebp], edx
	mov	DWORD PTR _trailing$[ebp], 3
	jmp	SHORT $LN11@UTF8ToUTF1
$LN18@UTF8ToUTF1:

; 613  :       else {
; 614  : 	/* no chance for this in UTF-16 */
; 615  : 	*outlen = (out - outstart) * 2;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	sar	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 616  : 	*inlen = processed - instart;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _instart$[ebp]
	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], edx

; 617  : 	return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF8ToUTF1
$LN11@UTF8ToUTF1:

; 618  :       }
; 619  : 
; 620  :       if (inend - in < trailing) {

	mov	ecx, DWORD PTR _inend$[ebp]
	sub	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _trailing$[ebp]
	jge	SHORT $LN20@UTF8ToUTF1

; 621  :           break;

	jmp	$LN3@UTF8ToUTF1
$LN20@UTF8ToUTF1:

; 622  :       }
; 623  : 
; 624  :       for ( ; trailing; trailing--) {

	jmp	SHORT $LN6@UTF8ToUTF1
$LN4@UTF8ToUTF1:
	mov	edx, DWORD PTR _trailing$[ebp]
	sub	edx, 1
	mov	DWORD PTR _trailing$[ebp], edx
$LN6@UTF8ToUTF1:
	cmp	DWORD PTR _trailing$[ebp], 0
	je	SHORT $LN5@UTF8ToUTF1

; 625  :           if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jae	SHORT $LN22@UTF8ToUTF1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 192				; 000000c0H
	mov	DWORD PTR tv132[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	cmp	DWORD PTR tv132[ebp], 128		; 00000080H
	je	SHORT $LN34@UTF8ToUTF1
	mov	DWORD PTR tv133[ebp], 1
	jmp	SHORT $LN35@UTF8ToUTF1
$LN34@UTF8ToUTF1:
	mov	DWORD PTR tv133[ebp], 0
$LN35@UTF8ToUTF1:
	cmp	DWORD PTR tv133[ebp], 0
	je	SHORT $LN21@UTF8ToUTF1
$LN22@UTF8ToUTF1:

; 626  : 	      break;

	jmp	SHORT $LN5@UTF8ToUTF1
$LN21@UTF8ToUTF1:

; 627  :           c <<= 6;

	mov	edx, DWORD PTR _c$[ebp]
	shl	edx, 6
	mov	DWORD PTR _c$[ebp], edx

; 628  :           c |= d & 0x3F;

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 629  :       }

	jmp	SHORT $LN4@UTF8ToUTF1
$LN5@UTF8ToUTF1:

; 630  : 
; 631  :       /* assertion: c is a single UTF-4 value */
; 632  :         if (c < 0x10000) {

	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $LN23@UTF8ToUTF1

; 633  :             if (out >= outend)

	mov	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, DWORD PTR _outend$[ebp]
	jb	SHORT $LN25@UTF8ToUTF1

; 634  : 	        break;

	jmp	$LN3@UTF8ToUTF1
$LN25@UTF8ToUTF1:

; 635  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN26@UTF8ToUTF1

; 636  : 		*out++ = c;

	mov	edx, DWORD PTR _out$[ebp]
	mov	ax, WORD PTR _c$[ebp]
	mov	WORD PTR [edx], ax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$[ebp], ecx

; 637  : 	    } else {

	jmp	SHORT $LN27@UTF8ToUTF1
$LN26@UTF8ToUTF1:

; 638  : 		tmp = (unsigned char *) out;

	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 639  : 		*tmp = c ;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl

; 640  : 		*(tmp + 1) = c >> 8 ;

	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 8
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [eax+1], dl

; 641  : 		out++;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$[ebp], ecx
$LN27@UTF8ToUTF1:

; 642  : 	    }
; 643  :         }

	jmp	$LN24@UTF8ToUTF1
$LN23@UTF8ToUTF1:

; 644  :         else if (c < 0x110000) {

	cmp	DWORD PTR _c$[ebp], 1114112		; 00110000H
	jae	$LN28@UTF8ToUTF1

; 645  :             if (out+1 >= outend)

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	cmp	edx, DWORD PTR _outend$[ebp]
	jb	SHORT $LN30@UTF8ToUTF1

; 646  : 	        break;

	jmp	$LN3@UTF8ToUTF1
$LN30@UTF8ToUTF1:

; 647  :             c -= 0x10000;

	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 65536				; 00010000H
	mov	DWORD PTR _c$[ebp], eax

; 648  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN31@UTF8ToUTF1

; 649  : 		*out++ = 0xD800 | (c >> 10);

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 10					; 0000000aH
	or	ecx, 55296				; 0000d800H
	mov	edx, DWORD PTR _out$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 2
	mov	DWORD PTR _out$[ebp], eax

; 650  : 		*out++ = 0xDC00 | (c & 0x03FF);

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, 1023				; 000003ffH
	or	ecx, 56320				; 0000dc00H
	mov	edx, DWORD PTR _out$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 2
	mov	DWORD PTR _out$[ebp], eax

; 651  : 	    } else {

	jmp	SHORT $LN32@UTF8ToUTF1
$LN31@UTF8ToUTF1:

; 652  : 		tmp1 = 0xD800 | (c >> 10);

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 10					; 0000000aH
	or	ecx, 55296				; 0000d800H
	mov	WORD PTR _tmp1$[ebp], cx

; 653  : 		tmp = (unsigned char *) out;

	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 654  : 		*tmp = (unsigned char) tmp1;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	cl, BYTE PTR _tmp1$[ebp]
	mov	BYTE PTR [eax], cl

; 655  : 		*(tmp + 1) = tmp1 >> 8;

	movzx	edx, WORD PTR _tmp1$[ebp]
	sar	edx, 8
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [eax+1], dl

; 656  : 		out++;

	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$[ebp], ecx

; 657  : 
; 658  : 		tmp2 = 0xDC00 | (c & 0x03FF);

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 1023				; 000003ffH
	or	edx, 56320				; 0000dc00H
	mov	WORD PTR _tmp2$[ebp], dx

; 659  : 		tmp = (unsigned char *) out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 660  : 		*tmp  = (unsigned char) tmp2;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	dl, BYTE PTR _tmp2$[ebp]
	mov	BYTE PTR [ecx], dl

; 661  : 		*(tmp + 1) = tmp2 >> 8;

	movzx	eax, WORD PTR _tmp2$[ebp]
	sar	eax, 8
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [ecx+1], al

; 662  : 		out++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx
$LN32@UTF8ToUTF1:

; 663  : 	    }
; 664  :         }

	jmp	SHORT $LN24@UTF8ToUTF1
$LN28@UTF8ToUTF1:

; 665  :         else
; 666  : 	    break;

	jmp	SHORT $LN3@UTF8ToUTF1
$LN24@UTF8ToUTF1:

; 667  : 	processed = in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], eax

; 668  :     }

	jmp	$LN2@UTF8ToUTF1
$LN3@UTF8ToUTF1:

; 669  :     *outlen = (out - outstart) * 2;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	sar	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 670  :     *inlen = processed - instart;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _instart$[ebp]
	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 671  :     return(*outlen);

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [edx]
$LN1@UTF8ToUTF1:

; 672  : }

	pop	edi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF8ToUTF16LE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF16LEToUTF8
_TEXT	SEGMENT
_bits$ = -40						; size = 4
_tmp$ = -36						; size = 4
_inlen$ = -32						; size = 4
_d$ = -28						; size = 4
_c$ = -24						; size = 4
_inend$ = -20						; size = 4
_in$ = -16						; size = 4
_outend$ = -12						; size = 4
_processed$ = -8					; size = 4
_outstart$ = -4						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_inb$ = 16						; size = 4
_inlenb$ = 20						; size = 4
_UTF16LEToUTF8 PROC					; COMDAT

; 496  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 497  :     unsigned char* outstart = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 498  :     const unsigned char* processed = inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 499  :     unsigned char* outend = out + *outlen;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _outend$[ebp], eax

; 500  :     unsigned short* in = (unsigned short*) inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _in$[ebp], ecx

; 501  :     unsigned short* inend;
; 502  :     unsigned int c, d, inlen;
; 503  :     unsigned char *tmp;
; 504  :     int bits;
; 505  : 
; 506  :     if ((*inlenb % 2) == 1)

	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN25@UTF16LEToU
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN25@UTF16LEToU:
	cmp	eax, 1
	jne	SHORT $LN7@UTF16LEToU

; 507  :         (*inlenb)--;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx
$LN7@UTF16LEToU:

; 508  :     inlen = *inlenb / 2;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _inlen$[ebp], eax

; 509  :     inend = in + inlen;

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _inend$[ebp], ecx
$LN2@UTF16LEToU:

; 510  :     while ((in < inend) && (out - outstart + 5 < *outlen)) {

	mov	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _inend$[ebp]
	jae	$LN3@UTF16LEToU
	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	add	eax, 5
	mov	ecx, DWORD PTR _outlen$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jge	$LN3@UTF16LEToU

; 511  :         if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN8@UTF16LEToU

; 512  : 	    c= *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx

; 513  : 	} else {

	jmp	SHORT $LN9@UTF16LEToU
$LN8@UTF16LEToU:

; 514  : 	    tmp = (unsigned char *) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 515  : 	    c = *tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx

; 516  : 	    c = c | (((unsigned int)*tmp) << 8);

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 8
	or	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], ecx

; 517  : 	    in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 2
	mov	DWORD PTR _in$[ebp], edx
$LN9@UTF16LEToU:

; 518  : 	}
; 519  :         if ((c & 0xFC00) == 0xD800) {    /* surrogates */

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 64512				; 0000fc00H
	cmp	eax, 55296				; 0000d800H
	jne	$LN10@UTF16LEToU

; 520  : 	    if (in >= inend) {           /* (in > inend) shouldn't happens */

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jb	SHORT $LN11@UTF16LEToU

; 521  : 		break;

	jmp	$LN3@UTF16LEToU
$LN11@UTF16LEToU:

; 522  : 	    }
; 523  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $LN12@UTF16LEToU

; 524  : 		d = *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx

; 525  : 	    } else {

	jmp	SHORT $LN13@UTF16LEToU
$LN12@UTF16LEToU:

; 526  : 		tmp = (unsigned char *) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 527  : 		d = *tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx

; 528  : 		d = d | (((unsigned int)*tmp) << 8);

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 8
	or	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _d$[ebp], ecx

; 529  : 		in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 2
	mov	DWORD PTR _in$[ebp], edx
$LN13@UTF16LEToU:

; 530  : 	    }
; 531  :             if ((d & 0xFC00) == 0xDC00) {

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 64512				; 0000fc00H
	cmp	eax, 56320				; 0000dc00H
	jne	SHORT $LN14@UTF16LEToU

; 532  :                 c &= 0x03FF;

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, 1023				; 000003ffH
	mov	DWORD PTR _c$[ebp], ecx

; 533  :                 c <<= 10;

	mov	edx, DWORD PTR _c$[ebp]
	shl	edx, 10					; 0000000aH
	mov	DWORD PTR _c$[ebp], edx

; 534  :                 c |= d & 0x03FF;

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 1023				; 000003ffH
	or	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 535  :                 c += 0x10000;

	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 65536				; 00010000H
	mov	DWORD PTR _c$[ebp], ecx

; 536  :             }

	jmp	SHORT $LN10@UTF16LEToU
$LN14@UTF16LEToU:

; 537  :             else {
; 538  : 		*outlen = out - outstart;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 539  : 		*inlenb = processed - inb;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _inb$[ebp]
	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [edx], ecx

; 540  : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF16LEToU
$LN10@UTF16LEToU:

; 541  : 	    }
; 542  :         }
; 543  : 
; 544  : 	/* assertion: c is a single UTF-4 value */
; 545  :         if (out >= outend)

	mov	eax, DWORD PTR _out$[ebp]
	cmp	eax, DWORD PTR _outend$[ebp]
	jb	SHORT $LN16@UTF16LEToU

; 546  : 	    break;

	jmp	$LN3@UTF16LEToU
$LN16@UTF16LEToU:

; 547  :         if      (c <    0x80) {  *out++=  c;                bits= -6; }

	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jae	SHORT $LN17@UTF16LEToU
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], -6		; fffffffaH
	jmp	$LN18@UTF16LEToU
$LN17@UTF16LEToU:

; 548  :         else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }

	cmp	DWORD PTR _c$[ebp], 2048		; 00000800H
	jae	SHORT $LN19@UTF16LEToU
	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 6
	and	ecx, 31					; 0000001fH
	or	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], 0
	jmp	SHORT $LN18@UTF16LEToU
$LN19@UTF16LEToU:

; 549  :         else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }

	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $LN21@UTF16LEToU
	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 12					; 0000000cH
	and	ecx, 15					; 0000000fH
	or	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], 6
	jmp	SHORT $LN18@UTF16LEToU
$LN21@UTF16LEToU:

; 550  :         else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 18					; 00000012H
	and	ecx, 7
	or	ecx, 240				; 000000f0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], 12		; 0000000cH
$LN18@UTF16LEToU:

; 551  : 
; 552  :         for ( ; bits >= 0; bits-= 6) {

	jmp	SHORT $LN6@UTF16LEToU
$LN4@UTF16LEToU:
	mov	ecx, DWORD PTR _bits$[ebp]
	sub	ecx, 6
	mov	DWORD PTR _bits$[ebp], ecx
$LN6@UTF16LEToU:
	cmp	DWORD PTR _bits$[ebp], 0
	jl	SHORT $LN5@UTF16LEToU

; 553  :             if (out >= outend)

	mov	edx, DWORD PTR _out$[ebp]
	cmp	edx, DWORD PTR _outend$[ebp]
	jb	SHORT $LN23@UTF16LEToU

; 554  : 	        break;

	jmp	SHORT $LN5@UTF16LEToU
$LN23@UTF16LEToU:

; 555  :             *out++= ((c >> bits) & 0x3F) | 0x80;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _bits$[ebp]
	shr	eax, cl
	and	eax, 63					; 0000003fH
	or	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 556  :         }

	jmp	SHORT $LN4@UTF16LEToU
$LN5@UTF16LEToU:

; 557  : 	processed = (const unsigned char*) in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], eax

; 558  :     }

	jmp	$LN2@UTF16LEToU
$LN3@UTF16LEToU:

; 559  :     *outlen = out - outstart;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 560  :     *inlenb = processed - inb;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _inb$[ebp]
	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [ecx], eax

; 561  :     return(*outlen);

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [edx]
$LN1@UTF16LEToU:

; 562  : }

	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF16LEToUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8ToUTF8
_TEXT	SEGMENT
_len$ = -4						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_inb$ = 16						; size = 4
_inlenb$ = 20						; size = 4
_UTF8ToUTF8 PROC					; COMDAT

; 357  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 358  :     int len;
; 359  : 
; 360  :     if ((out == NULL) || (outlen == NULL) || (inlenb == NULL))

	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN3@UTF8ToUTF8
	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN3@UTF8ToUTF8
	cmp	DWORD PTR _inlenb$[ebp], 0
	jne	SHORT $LN2@UTF8ToUTF8
$LN3@UTF8ToUTF8:

; 361  : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@UTF8ToUTF8
$LN2@UTF8ToUTF8:

; 362  :     if (inb == NULL) {

	cmp	DWORD PTR _inb$[ebp], 0
	jne	SHORT $LN4@UTF8ToUTF8

; 363  :         /* inb == NULL means output is initialized. */
; 364  :         *outlen = 0;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], 0

; 365  :         *inlenb = 0;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [ecx], 0

; 366  :         return(0);

	xor	eax, eax
	jmp	SHORT $LN1@UTF8ToUTF8
$LN4@UTF8ToUTF8:

; 367  :     }
; 368  :     if (*outlen > *inlenb) {

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@UTF8ToUTF8

; 369  : 	len = *inlenb;

	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _len$[ebp], eax

; 370  :     } else {

	jmp	SHORT $LN6@UTF8ToUTF8
$LN5@UTF8ToUTF8:

; 371  : 	len = *outlen;

	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _len$[ebp], edx
$LN6@UTF8ToUTF8:

; 372  :     }
; 373  :     if (len < 0)

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN7@UTF8ToUTF8

; 374  : 	return(-1);

	or	eax, -1
	jmp	SHORT $LN1@UTF8ToUTF8
$LN7@UTF8ToUTF8:

; 375  : 
; 376  :     memcpy(out, inb, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inb$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 377  : 
; 378  :     *outlen = len;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax], ecx

; 379  :     *inlenb = len;

	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR [edx], eax

; 380  :     return(*outlen);

	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [ecx]
$LN1@UTF8ToUTF8:

; 381  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF8ToUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8Toascii
_TEXT	SEGMENT
tv95 = -40						; size = 4
tv94 = -36						; size = 4
_trailing$ = -32					; size = 4
_d$ = -28						; size = 4
_c$ = -24						; size = 4
_inend$ = -20						; size = 4
_instart$ = -16						; size = 4
_outstart$ = -12					; size = 4
_outend$ = -8						; size = 4
_processed$ = -4					; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_UTF8Toascii PROC					; COMDAT

; 224  :               const unsigned char* in, int *inlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 225  :     const unsigned char* processed = in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], eax

; 226  :     const unsigned char* outend;
; 227  :     const unsigned char* outstart = out;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], ecx

; 228  :     const unsigned char* instart = in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _instart$[ebp], edx

; 229  :     const unsigned char* inend;
; 230  :     unsigned int c, d;
; 231  :     int trailing;
; 232  : 
; 233  :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);

	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN8@UTF8Toasci
	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN8@UTF8Toasci
	cmp	DWORD PTR _inlen$[ebp], 0
	jne	SHORT $LN7@UTF8Toasci
$LN8@UTF8Toasci:
	or	eax, -1
	jmp	$LN1@UTF8Toasci
$LN7@UTF8Toasci:

; 234  :     if (in == NULL) {

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN9@UTF8Toasci

; 235  :         /*
; 236  : 	 * initialization nothing to do
; 237  : 	 */
; 238  : 	*outlen = 0;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], 0

; 239  : 	*inlen = 0;

	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], 0

; 240  : 	return(0);

	xor	eax, eax
	jmp	$LN1@UTF8Toasci
$LN9@UTF8Toasci:

; 241  :     }
; 242  :     inend = in + (*inlen);

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _inend$[ebp], eax

; 243  :     outend = out + (*outlen);

	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _outend$[ebp], edx
$LN2@UTF8Toasci:

; 244  :     while (in < inend) {

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jae	$LN3@UTF8Toasci

; 245  : 	d = *in++;

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 246  : 	if      (d < 0x80)  { c= d; trailing= 0; }

	cmp	DWORD PTR _d$[ebp], 128			; 00000080H
	jae	SHORT $LN10@UTF8Toasci
	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _trailing$[ebp], 0
	jmp	$LN11@UTF8Toasci
$LN10@UTF8Toasci:

; 247  : 	else if (d < 0xC0) {

	cmp	DWORD PTR _d$[ebp], 192			; 000000c0H
	jae	SHORT $LN12@UTF8Toasci

; 248  : 	    /* trailing byte in leading position */
; 249  : 	    *outlen = out - outstart;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 250  : 	    *inlen = processed - instart;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _instart$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 251  : 	    return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF8Toasci
	jmp	SHORT $LN11@UTF8Toasci
$LN12@UTF8Toasci:

; 252  :         } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }

	cmp	DWORD PTR _d$[ebp], 224			; 000000e0H
	jae	SHORT $LN14@UTF8Toasci
	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _c$[ebp], eax
	mov	DWORD PTR _trailing$[ebp], 1
	jmp	SHORT $LN11@UTF8Toasci
$LN14@UTF8Toasci:

; 253  :         else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }

	cmp	DWORD PTR _d$[ebp], 240			; 000000f0H
	jae	SHORT $LN16@UTF8Toasci
	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _trailing$[ebp], 2
	jmp	SHORT $LN11@UTF8Toasci
$LN16@UTF8Toasci:

; 254  :         else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }

	cmp	DWORD PTR _d$[ebp], 248			; 000000f8H
	jae	SHORT $LN18@UTF8Toasci
	mov	edx, DWORD PTR _d$[ebp]
	and	edx, 7
	mov	DWORD PTR _c$[ebp], edx
	mov	DWORD PTR _trailing$[ebp], 3
	jmp	SHORT $LN11@UTF8Toasci
$LN18@UTF8Toasci:

; 255  : 	else {
; 256  : 	    /* no chance for this in Ascii */
; 257  : 	    *outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 258  : 	    *inlen = processed - instart;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _instart$[ebp]
	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], edx

; 259  : 	    return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF8Toasci
$LN11@UTF8Toasci:

; 260  : 	}
; 261  : 
; 262  : 	if (inend - in < trailing) {

	mov	ecx, DWORD PTR _inend$[ebp]
	sub	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _trailing$[ebp]
	jge	SHORT $LN20@UTF8Toasci

; 263  : 	    break;

	jmp	$LN3@UTF8Toasci
$LN20@UTF8Toasci:

; 264  : 	}
; 265  : 
; 266  : 	for ( ; trailing; trailing--) {

	jmp	SHORT $LN6@UTF8Toasci
$LN4@UTF8Toasci:
	mov	edx, DWORD PTR _trailing$[ebp]
	sub	edx, 1
	mov	DWORD PTR _trailing$[ebp], edx
$LN6@UTF8Toasci:
	cmp	DWORD PTR _trailing$[ebp], 0
	je	SHORT $LN5@UTF8Toasci

; 267  : 	    if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jae	SHORT $LN22@UTF8Toasci
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 192				; 000000c0H
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	cmp	DWORD PTR tv94[ebp], 128		; 00000080H
	je	SHORT $LN27@UTF8Toasci
	mov	DWORD PTR tv95[ebp], 1
	jmp	SHORT $LN28@UTF8Toasci
$LN27@UTF8Toasci:
	mov	DWORD PTR tv95[ebp], 0
$LN28@UTF8Toasci:
	cmp	DWORD PTR tv95[ebp], 0
	je	SHORT $LN21@UTF8Toasci
$LN22@UTF8Toasci:

; 268  : 		break;

	jmp	SHORT $LN5@UTF8Toasci
$LN21@UTF8Toasci:

; 269  : 	    c <<= 6;

	mov	edx, DWORD PTR _c$[ebp]
	shl	edx, 6
	mov	DWORD PTR _c$[ebp], edx

; 270  : 	    c |= d & 0x3F;

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 63					; 0000003fH
	or	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 271  : 	}

	jmp	SHORT $LN4@UTF8Toasci
$LN5@UTF8Toasci:

; 272  : 
; 273  : 	/* assertion: c is a single UTF-4 value */
; 274  : 	if (c < 0x80) {

	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jae	SHORT $LN23@UTF8Toasci

; 275  : 	    if (out >= outend)

	mov	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, DWORD PTR _outend$[ebp]
	jb	SHORT $LN25@UTF8Toasci

; 276  : 		break;

	jmp	SHORT $LN3@UTF8Toasci
$LN25@UTF8Toasci:

; 277  : 	    *out++ = c;

	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 278  : 	} else {

	jmp	SHORT $LN24@UTF8Toasci
$LN23@UTF8Toasci:

; 279  : 	    /* no chance for this in Ascii */
; 280  : 	    *outlen = out - outstart;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 281  : 	    *inlen = processed - instart;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _instart$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 282  : 	    return(-2);

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@UTF8Toasci
$LN24@UTF8Toasci:

; 283  : 	}
; 284  : 	processed = in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], eax

; 285  :     }

	jmp	$LN2@UTF8Toasci
$LN3@UTF8Toasci:

; 286  :     *outlen = out - outstart;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 287  :     *inlen = processed - instart;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _instart$[ebp]
	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 288  :     return(*outlen);

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [edx]
$LN1@UTF8Toasci:

; 289  : }

	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF8Toascii ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _asciiToUTF8
_TEXT	SEGMENT
_c$ = -24						; size = 4
_inend$ = -20						; size = 4
_outend$ = -16						; size = 4
_processed$ = -12					; size = 4
_base$ = -8						; size = 4
_outstart$ = -4						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_asciiToUTF8 PROC					; COMDAT

; 177  :               const unsigned char* in, int *inlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 178  :     unsigned char* outstart = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 179  :     const unsigned char* base = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _base$[ebp], ecx

; 180  :     const unsigned char* processed = in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], edx

; 181  :     unsigned char* outend = out + *outlen;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _outend$[ebp], ecx

; 182  :     const unsigned char* inend;
; 183  :     unsigned int c;
; 184  : 
; 185  :     inend = in + (*inlen);

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _inend$[ebp], eax
$LN2@asciiToUTF:

; 186  :     while ((in < inend) && (out - outstart + 5 < *outlen)) {

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jae	SHORT $LN3@asciiToUTF
	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	add	edx, 5
	mov	eax, DWORD PTR _outlen$[ebp]
	cmp	edx, DWORD PTR [eax]
	jge	SHORT $LN3@asciiToUTF

; 187  : 	c= *in++;

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _c$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 188  : 
; 189  :         if (out >= outend)

	mov	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, DWORD PTR _outend$[ebp]
	jb	SHORT $LN4@asciiToUTF

; 190  : 	    break;

	jmp	SHORT $LN3@asciiToUTF
$LN4@asciiToUTF:

; 191  :         if (c < 0x80) {

	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jae	SHORT $LN5@asciiToUTF

; 192  : 	    *out++ = c;

	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 193  : 	} else {

	jmp	SHORT $LN6@asciiToUTF
$LN5@asciiToUTF:

; 194  : 	    *outlen = out - outstart;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 195  : 	    *inlen = processed - base;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _base$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 196  : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@asciiToUTF
$LN6@asciiToUTF:

; 197  : 	}
; 198  : 
; 199  : 	processed = (const unsigned char*) in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], eax

; 200  :     }

	jmp	SHORT $LN2@asciiToUTF
$LN3@asciiToUTF:

; 201  :     *outlen = out - outstart;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 202  :     *inlen = processed - base;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _base$[ebp]
	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 203  :     return(*outlen);

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [edx]
$LN1@asciiToUTF:

; 204  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_asciiToUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlEncodingErr
_TEXT	SEGMENT
_error$ = 8						; size = 4
_msg$ = 12						; size = 4
_val$ = 16						; size = 4
_xmlEncodingErr PROC					; COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 99   :     __xmlRaiseError(NULL, NULL, NULL, NULL, NULL,

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	push	0
	push	0
	push	3
	mov	eax, DWORD PTR _error$[ebp]
	push	eax
	push	27					; 0000001bH
	push	0
	push	0
	push	0
	push	0
	push	0
	call	___xmlRaiseError
	add	esp, 68					; 00000044H

; 100  :                     XML_FROM_I18N, error, XML_ERR_FATAL,
; 101  :                     NULL, 0, val, NULL, NULL, 0, 0, msg, val);
; 102  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlEncodingErr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlEncodingErrMemory
_TEXT	SEGMENT
_extra$ = 8						; size = 4
_xmlEncodingErrMemory PROC				; COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 86   :     __xmlSimpleError(XML_FROM_I18N, XML_ERR_NO_MEMORY, NULL, NULL, extra);

	mov	eax, DWORD PTR _extra$[ebp]
	push	eax
	push	0
	push	0
	push	2
	push	27					; 0000001bH
	call	___xmlSimpleError
	add	esp, 20					; 00000014H

; 87   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlEncodingErrMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncOutput
_TEXT	SEGMENT
tv151 = -164						; size = 4
_buf$1 = -156						; size = 50
_charrefLen$2 = -100					; size = 4
_cur$3 = -96						; size = 4
_content$4 = -92					; size = 4
_len$5 = -84						; size = 4
_charref$6 = -72					; size = 20
_out$ = -48						; size = 4
_in$ = -44						; size = 4
_c_out$ = -36						; size = 4
_c_in$ = -24						; size = 4
_toconv$ = -16						; size = 4
_writtentot$ = -12					; size = 4
_written$ = -8						; size = 4
_ret$ = -4						; size = 4
_output$ = 8						; size = 4
_init$ = 12						; size = 4
_xmlCharEncOutput PROC					; COMDAT

; 2394 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 41					; 00000029H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 2395 :     int ret;
; 2396 :     size_t written;
; 2397 :     size_t writtentot = 0;

	mov	DWORD PTR _writtentot$[ebp], 0

; 2398 :     size_t toconv;
; 2399 :     int c_in;
; 2400 :     int c_out;
; 2401 :     xmlBufPtr in;
; 2402 :     xmlBufPtr out;
; 2403 : 
; 2404 :     if ((output == NULL) || (output->encoder == NULL) ||
; 2405 :         (output->buffer == NULL) || (output->conv == NULL))

	cmp	DWORD PTR _output$[ebp], 0
	je	SHORT $LN5@xmlCharEnc
	mov	eax, DWORD PTR _output$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@xmlCharEnc
	mov	ecx, DWORD PTR _output$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN5@xmlCharEnc
	mov	edx, DWORD PTR _output$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN4@xmlCharEnc
$LN5@xmlCharEnc:

; 2406 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN4@xmlCharEnc:

; 2407 :     out = output->conv;

	mov	eax, DWORD PTR _output$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _out$[ebp], ecx

; 2408 :     in = output->buffer;

	mov	edx, DWORD PTR _output$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _in$[ebp], eax
$retry$32:

; 2409 : 
; 2410 : retry:
; 2411 : 
; 2412 :     written = xmlBufAvail(out);

	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_xmlBufAvail
	add	esp, 4
	mov	DWORD PTR _written$[ebp], eax

; 2413 :     if (written > 0)

	cmp	DWORD PTR _written$[ebp], 0
	jbe	SHORT $LN6@xmlCharEnc

; 2414 :         written--; /* count '\0' */

	mov	edx, DWORD PTR _written$[ebp]
	sub	edx, 1
	mov	DWORD PTR _written$[ebp], edx
$LN6@xmlCharEnc:

; 2415 : 
; 2416 :     /*
; 2417 :      * First specific handling of the initialization call
; 2418 :      */
; 2419 :     if (init) {

	cmp	DWORD PTR _init$[ebp], 0
	je	SHORT $LN7@xmlCharEnc

; 2420 :         c_in = 0;

	mov	DWORD PTR _c_in$[ebp], 0

; 2421 :         c_out = written;

	mov	eax, DWORD PTR _written$[ebp]
	mov	DWORD PTR _c_out$[ebp], eax

; 2422 :         /* TODO: Check return value. */
; 2423 :         xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,

	lea	ecx, DWORD PTR _c_in$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _c_out$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_xmlBufEnd
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_xmlEncOutputChunk
	add	esp, 20					; 00000014H

; 2424 :                           NULL, &c_in);
; 2425 :         xmlBufAddLen(out, c_out);

	mov	eax, DWORD PTR _c_out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_xmlBufAddLen
	add	esp, 8

; 2426 : #ifdef DEBUG_ENCODING
; 2427 : 	xmlGenericError(xmlGenericErrorContext,
; 2428 : 		"initialized encoder\n");
; 2429 : #endif
; 2430 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCharEnc
$LN7@xmlCharEnc:

; 2431 :     }
; 2432 : 
; 2433 :     /*
; 2434 :      * Conversion itself.
; 2435 :      */
; 2436 :     toconv = xmlBufUse(in);

	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_xmlBufUse
	add	esp, 4
	mov	DWORD PTR _toconv$[ebp], eax

; 2437 :     if (toconv == 0)

	cmp	DWORD PTR _toconv$[ebp], 0
	jne	SHORT $LN8@xmlCharEnc

; 2438 :         return (0);

	xor	eax, eax
	jmp	$LN1@xmlCharEnc
$LN8@xmlCharEnc:

; 2439 :     if (toconv > 64 * 1024)

	cmp	DWORD PTR _toconv$[ebp], 65536		; 00010000H
	jbe	SHORT $LN9@xmlCharEnc

; 2440 :         toconv = 64 * 1024;

	mov	DWORD PTR _toconv$[ebp], 65536		; 00010000H
$LN9@xmlCharEnc:

; 2441 :     if (toconv * 4 >= written) {

	mov	eax, DWORD PTR _toconv$[ebp]
	shl	eax, 2
	cmp	eax, DWORD PTR _written$[ebp]
	jb	SHORT $LN10@xmlCharEnc

; 2442 :         xmlBufGrow(out, toconv * 4);

	mov	ecx, DWORD PTR _toconv$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_xmlBufGrow
	add	esp, 8

; 2443 :         written = xmlBufAvail(out) - 1;

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_xmlBufAvail
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _written$[ebp], eax
$LN10@xmlCharEnc:

; 2444 :     }
; 2445 :     if (written > 256 * 1024)

	cmp	DWORD PTR _written$[ebp], 262144	; 00040000H
	jbe	SHORT $LN11@xmlCharEnc

; 2446 :         written = 256 * 1024;

	mov	DWORD PTR _written$[ebp], 262144	; 00040000H
$LN11@xmlCharEnc:

; 2447 : 
; 2448 :     c_in = toconv;

	mov	ecx, DWORD PTR _toconv$[ebp]
	mov	DWORD PTR _c_in$[ebp], ecx

; 2449 :     c_out = written;

	mov	edx, DWORD PTR _written$[ebp]
	mov	DWORD PTR _c_out$[ebp], edx

; 2450 :     ret = xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,

	lea	eax, DWORD PTR _c_in$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_xmlBufContent
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _c_out$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_xmlBufEnd
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_xmlEncOutputChunk
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$[ebp], eax

; 2451 :                             xmlBufContent(in), &c_in);
; 2452 :     xmlBufShrink(in, c_in);

	mov	eax, DWORD PTR _c_in$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_xmlBufShrink
	add	esp, 8

; 2453 :     xmlBufAddLen(out, c_out);

	mov	edx, DWORD PTR _c_out$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_xmlBufAddLen
	add	esp, 8

; 2454 :     writtentot += c_out;

	mov	ecx, DWORD PTR _writtentot$[ebp]
	add	ecx, DWORD PTR _c_out$[ebp]
	mov	DWORD PTR _writtentot$[ebp], ecx

; 2455 :     if (ret == -1) {

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN12@xmlCharEnc

; 2456 :         if (c_out > 0) {

	cmp	DWORD PTR _c_out$[ebp], 0
	jle	SHORT $LN13@xmlCharEnc

; 2457 :             /* Can be a limitation of iconv or uconv */
; 2458 :             goto retry;

	jmp	$retry$32
$LN13@xmlCharEnc:

; 2459 :         }
; 2460 :         ret = -3;

	mov	DWORD PTR _ret$[ebp], -3		; fffffffdH
$LN12@xmlCharEnc:

; 2461 :     }
; 2462 : 
; 2463 :     /*
; 2464 :      * Attempt to handle error cases
; 2465 :      */
; 2466 :     switch (ret) {

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR tv151[ebp], edx
	cmp	DWORD PTR tv151[ebp], -4		; fffffffcH
	je	SHORT $LN17@xmlCharEnc
	cmp	DWORD PTR tv151[ebp], -2		; fffffffeH
	je	SHORT $LN18@xmlCharEnc
	jmp	$LN2@xmlCharEnc

; 2467 :         case 0:
; 2468 : #ifdef DEBUG_ENCODING
; 2469 : 	    xmlGenericError(xmlGenericErrorContext,
; 2470 : 		    "converted %d bytes to %d bytes of output\n",
; 2471 : 	            c_in, c_out);
; 2472 : #endif
; 2473 : 	    break;

	jmp	$LN2@xmlCharEnc

; 2474 :         case -1:
; 2475 : #ifdef DEBUG_ENCODING
; 2476 : 	    xmlGenericError(xmlGenericErrorContext,
; 2477 : 		    "output conversion failed by lack of space\n");
; 2478 : #endif
; 2479 : 	    break;

	jmp	$LN2@xmlCharEnc

; 2480 :         case -3:
; 2481 : #ifdef DEBUG_ENCODING
; 2482 : 	    xmlGenericError(xmlGenericErrorContext,"converted %d bytes to %d bytes of output %d left\n",
; 2483 : 	            c_in, c_out, (int) xmlBufUse(in));
; 2484 : #endif
; 2485 : 	    break;

	jmp	$LN2@xmlCharEnc
$LN17@xmlCharEnc:

; 2486 :         case -4:
; 2487 :             xmlEncodingErr(XML_I18N_NO_OUTPUT,

	push	0
	push	OFFSET ??_C@_0CJ@OOHAOGCN@xmlCharEncOutFunc?3?5no?5output?5fu@
	push	6004					; 00001774H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH

; 2488 :                            "xmlCharEncOutFunc: no output function !\n", NULL);
; 2489 :             ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 2490 :             break;

	jmp	$LN2@xmlCharEnc
$LN18@xmlCharEnc:

; 2491 :         case -2: {
; 2492 : 	    xmlChar charref[20];
; 2493 : 	    int len = (int) xmlBufUse(in);

	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_xmlBufUse
	add	esp, 4
	mov	DWORD PTR _len$5[ebp], eax

; 2494 :             xmlChar *content = xmlBufContent(in);

	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_xmlBufContent
	add	esp, 4
	mov	DWORD PTR _content$4[ebp], eax

; 2495 : 	    int cur, charrefLen;
; 2496 : 
; 2497 : 	    cur = xmlGetUTF8Char(content, &len);

	lea	edx, DWORD PTR _len$5[ebp]
	push	edx
	mov	eax, DWORD PTR _content$4[ebp]
	push	eax
	call	_xmlGetUTF8Char
	add	esp, 8
	mov	DWORD PTR _cur$3[ebp], eax

; 2498 : 	    if (cur <= 0)

	cmp	DWORD PTR _cur$3[ebp], 0
	jg	SHORT $LN19@xmlCharEnc

; 2499 :                 break;

	jmp	$LN2@xmlCharEnc
$LN19@xmlCharEnc:

; 2500 : 
; 2501 : #ifdef DEBUG_ENCODING
; 2502 :             xmlGenericError(xmlGenericErrorContext,
; 2503 :                     "handling output conversion error\n");
; 2504 :             xmlGenericError(xmlGenericErrorContext,
; 2505 :                     "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
; 2506 :                     content[0], content[1],
; 2507 :                     content[2], content[3]);
; 2508 : #endif
; 2509 :             /*
; 2510 :              * Removes the UTF8 sequence, and replace it by a charref
; 2511 :              * and continue the transcoding phase, hoping the error
; 2512 :              * did not mangle the encoder state.
; 2513 :              */
; 2514 :             charrefLen = snprintf((char *) &charref[0], sizeof(charref),

	mov	ecx, DWORD PTR _cur$3[ebp]
	push	ecx
	push	OFFSET ??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@
	push	20					; 00000014H
	mov	edx, 1
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _charref$6[ebp+eax]
	push	ecx
	call	_snprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _charrefLen$2[ebp], eax

; 2515 :                              "&#%d;", cur);
; 2516 :             xmlBufShrink(in, len);

	mov	edx, DWORD PTR _len$5[ebp]
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_xmlBufShrink
	add	esp, 8

; 2517 :             xmlBufGrow(out, charrefLen * 4);

	mov	ecx, DWORD PTR _charrefLen$2[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_xmlBufGrow
	add	esp, 8

; 2518 :             c_out = xmlBufAvail(out) - 1;

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_xmlBufAvail
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _c_out$[ebp], eax

; 2519 :             c_in = charrefLen;

	mov	ecx, DWORD PTR _charrefLen$2[ebp]
	mov	DWORD PTR _c_in$[ebp], ecx

; 2520 :             ret = xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,

	lea	edx, DWORD PTR _c_in$[ebp]
	push	edx
	lea	eax, DWORD PTR _charref$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _c_out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_xmlBufEnd
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _output$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlEncOutputChunk
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$[ebp], eax

; 2521 :                                     charref, &c_in);
; 2522 : 
; 2523 : 	    if ((ret < 0) || (c_in != charrefLen)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jl	SHORT $LN21@xmlCharEnc
	mov	edx, DWORD PTR _c_in$[ebp]
	cmp	edx, DWORD PTR _charrefLen$2[ebp]
	je	$LN20@xmlCharEnc
$LN21@xmlCharEnc:

; 2524 : 		char buf[50];
; 2525 : 
; 2526 : 		snprintf(&buf[0], 49, "0x%02X 0x%02X 0x%02X 0x%02X",

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _content$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _content$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _content$4[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _content$4[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	push	ecx
	push	OFFSET ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
	push	49					; 00000031H
	mov	edx, 1
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _buf$1[ebp+eax]
	push	ecx
	call	_snprintf
	add	esp, 28					; 0000001cH

; 2527 : 			 content[0], content[1],
; 2528 : 			 content[2], content[3]);
; 2529 : 		buf[49] = 0;

	mov	edx, 1
	imul	eax, edx, 49
	mov	BYTE PTR _buf$1[ebp+eax], 0

; 2530 : 		xmlEncodingErr(XML_I18N_CONV_FAILED,

	lea	ecx, DWORD PTR _buf$1[ebp]
	push	ecx
	push	OFFSET ??_C@_0DG@MDDGIHO@output?5conversion?5failed?5due?5to@
	push	6003					; 00001773H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH

; 2531 : 		    "output conversion failed due to conv error, bytes %s\n",
; 2532 : 			       buf);
; 2533 : 		if (xmlBufGetAllocationScheme(in) != XML_BUFFER_ALLOC_IMMUTABLE)

	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_xmlBufGetAllocationScheme
	add	esp, 4
	cmp	eax, 2
	je	SHORT $LN22@xmlCharEnc

; 2534 : 		    content[0] = ' ';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _content$4[ebp]
	mov	BYTE PTR [edx+ecx], 32			; 00000020H
$LN22@xmlCharEnc:

; 2535 :                 break;

	jmp	SHORT $LN2@xmlCharEnc
$LN20@xmlCharEnc:

; 2536 : 	    }
; 2537 : 
; 2538 :             xmlBufAddLen(out, c_out);

	mov	eax, DWORD PTR _c_out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_xmlBufAddLen
	add	esp, 8

; 2539 :             writtentot += c_out;

	mov	edx, DWORD PTR _writtentot$[ebp]
	add	edx, DWORD PTR _c_out$[ebp]
	mov	DWORD PTR _writtentot$[ebp], edx

; 2540 :             goto retry;

	jmp	$retry$32
$LN2@xmlCharEnc:

; 2541 : 	}
; 2542 :     }
; 2543 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCharEnc:

; 2544 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN31@xmlCharEnc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 164				; 000000a4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN31@xmlCharEnc:
	DD	5
	DD	$LN30@xmlCharEnc
$LN30@xmlCharEnc:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN25@xmlCharEnc
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN26@xmlCharEnc
	DD	-72					; ffffffb8H
	DD	20					; 00000014H
	DD	$LN27@xmlCharEnc
	DD	-84					; ffffffacH
	DD	4
	DD	$LN28@xmlCharEnc
	DD	-156					; ffffff64H
	DD	50					; 00000032H
	DD	$LN29@xmlCharEnc
$LN29@xmlCharEnc:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN28@xmlCharEnc:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN27@xmlCharEnc:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	0
$LN26@xmlCharEnc:
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$LN25@xmlCharEnc:
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
_xmlCharEncOutput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncInput
_TEXT	SEGMENT
tv174 = -116						; size = 4
tv142 = -112						; size = 4
_content$1 = -108					; size = 4
_buf$2 = -100						; size = 50
_out$ = -44						; size = 4
_in$ = -40						; size = 4
_c_out$ = -32						; size = 4
_c_in$ = -20						; size = 4
_toconv$ = -12						; size = 4
_written$ = -8						; size = 4
_ret$ = -4						; size = 4
_input$ = 8						; size = 4
_flush$ = 12						; size = 4
_xmlCharEncInput PROC					; COMDAT

; 2204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	edi
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 29					; 0000001dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 2205 :     int ret;
; 2206 :     size_t written;
; 2207 :     size_t toconv;
; 2208 :     int c_in;
; 2209 :     int c_out;
; 2210 :     xmlBufPtr in;
; 2211 :     xmlBufPtr out;
; 2212 : 
; 2213 :     if ((input == NULL) || (input->encoder == NULL) ||
; 2214 :         (input->buffer == NULL) || (input->raw == NULL))

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN5@xmlCharEnc
	mov	eax, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@xmlCharEnc
	mov	ecx, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN5@xmlCharEnc
	mov	edx, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN4@xmlCharEnc
$LN5@xmlCharEnc:

; 2215 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN4@xmlCharEnc:

; 2216 :     out = input->buffer;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _out$[ebp], ecx

; 2217 :     in = input->raw;

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _in$[ebp], eax

; 2218 : 
; 2219 :     toconv = xmlBufUse(in);

	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_xmlBufUse
	add	esp, 4
	mov	DWORD PTR _toconv$[ebp], eax

; 2220 :     if (toconv == 0)

	cmp	DWORD PTR _toconv$[ebp], 0
	jne	SHORT $LN6@xmlCharEnc

; 2221 :         return (0);

	xor	eax, eax
	jmp	$LN1@xmlCharEnc
$LN6@xmlCharEnc:

; 2222 :     if ((toconv > 64 * 1024) && (flush == 0))

	cmp	DWORD PTR _toconv$[ebp], 65536		; 00010000H
	jbe	SHORT $LN7@xmlCharEnc
	cmp	DWORD PTR _flush$[ebp], 0
	jne	SHORT $LN7@xmlCharEnc

; 2223 :         toconv = 64 * 1024;

	mov	DWORD PTR _toconv$[ebp], 65536		; 00010000H
$LN7@xmlCharEnc:

; 2224 :     written = xmlBufAvail(out);

	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_xmlBufAvail
	add	esp, 4
	mov	DWORD PTR _written$[ebp], eax

; 2225 :     if (written > 0)

	cmp	DWORD PTR _written$[ebp], 0
	jbe	SHORT $LN8@xmlCharEnc

; 2226 :         written--; /* count '\0' */

	mov	eax, DWORD PTR _written$[ebp]
	sub	eax, 1
	mov	DWORD PTR _written$[ebp], eax
$LN8@xmlCharEnc:

; 2227 :     if (toconv * 2 >= written) {

	mov	ecx, DWORD PTR _toconv$[ebp]
	shl	ecx, 1
	cmp	ecx, DWORD PTR _written$[ebp]
	jb	SHORT $LN9@xmlCharEnc

; 2228 :         xmlBufGrow(out, toconv * 2);

	mov	edx, DWORD PTR _toconv$[ebp]
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_xmlBufGrow
	add	esp, 8

; 2229 :         written = xmlBufAvail(out);

	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_xmlBufAvail
	add	esp, 4
	mov	DWORD PTR _written$[ebp], eax

; 2230 :         if (written > 0)

	cmp	DWORD PTR _written$[ebp], 0
	jbe	SHORT $LN9@xmlCharEnc

; 2231 :             written--; /* count '\0' */

	mov	edx, DWORD PTR _written$[ebp]
	sub	edx, 1
	mov	DWORD PTR _written$[ebp], edx
$LN9@xmlCharEnc:

; 2232 :     }
; 2233 :     if ((written > 128 * 1024) && (flush == 0))

	cmp	DWORD PTR _written$[ebp], 131072	; 00020000H
	jbe	SHORT $LN11@xmlCharEnc
	cmp	DWORD PTR _flush$[ebp], 0
	jne	SHORT $LN11@xmlCharEnc

; 2234 :         written = 128 * 1024;

	mov	DWORD PTR _written$[ebp], 131072	; 00020000H
$LN11@xmlCharEnc:

; 2235 : 
; 2236 :     c_in = toconv;

	mov	eax, DWORD PTR _toconv$[ebp]
	mov	DWORD PTR _c_in$[ebp], eax

; 2237 :     c_out = written;

	mov	ecx, DWORD PTR _written$[ebp]
	mov	DWORD PTR _c_out$[ebp], ecx

; 2238 :     ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,

	mov	edx, DWORD PTR _flush$[ebp]
	push	edx
	lea	eax, DWORD PTR _c_in$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_xmlBufContent
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _c_out$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_xmlBufEnd
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_xmlEncInputChunk
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 2239 :                            xmlBufContent(in), &c_in, flush);
; 2240 :     xmlBufShrink(in, c_in);

	mov	eax, DWORD PTR _c_in$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_xmlBufShrink
	add	esp, 8

; 2241 :     xmlBufAddLen(out, c_out);

	mov	edx, DWORD PTR _c_out$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_xmlBufAddLen
	add	esp, 8

; 2242 :     if (ret == -1)

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN12@xmlCharEnc

; 2243 :         ret = -3;

	mov	DWORD PTR _ret$[ebp], -3		; fffffffdH
$LN12@xmlCharEnc:

; 2244 : 
; 2245 :     switch (ret) {

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR tv142[ebp], ecx
	cmp	DWORD PTR tv142[ebp], -2		; fffffffeH
	je	SHORT $LN16@xmlCharEnc
	jmp	$LN2@xmlCharEnc

; 2246 :         case 0:
; 2247 : #ifdef DEBUG_ENCODING
; 2248 :             xmlGenericError(xmlGenericErrorContext,
; 2249 :                             "converted %d bytes to %d bytes of input\n",
; 2250 :                             c_in, c_out);
; 2251 : #endif
; 2252 :             break;

	jmp	$LN2@xmlCharEnc

; 2253 :         case -1:
; 2254 : #ifdef DEBUG_ENCODING
; 2255 :             xmlGenericError(xmlGenericErrorContext,
; 2256 :                          "converted %d bytes to %d bytes of input, %d left\n",
; 2257 :                             c_in, c_out, (int)xmlBufUse(in));
; 2258 : #endif
; 2259 :             break;

	jmp	$LN2@xmlCharEnc

; 2260 :         case -3:
; 2261 : #ifdef DEBUG_ENCODING
; 2262 :             xmlGenericError(xmlGenericErrorContext,
; 2263 :                         "converted %d bytes to %d bytes of input, %d left\n",
; 2264 :                             c_in, c_out, (int)xmlBufUse(in));
; 2265 : #endif
; 2266 :             break;

	jmp	$LN2@xmlCharEnc
$LN16@xmlCharEnc:

; 2267 :         case -2: {
; 2268 :             char buf[50];
; 2269 :             const xmlChar *content = xmlBufContent(in);

	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_xmlBufContent
	add	esp, 4
	mov	DWORD PTR _content$1[ebp], eax

; 2270 : 
; 2271 : 	    snprintf(&buf[0], 49, "0x%02X 0x%02X 0x%02X 0x%02X",

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _content$1[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _content$1[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _content$1[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _content$1[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	push	ecx
	push	OFFSET ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
	push	49					; 00000031H
	mov	edx, 1
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _buf$2[ebp+eax]
	push	ecx
	call	_snprintf
	add	esp, 28					; 0000001cH

; 2272 : 		     content[0], content[1],
; 2273 : 		     content[2], content[3]);
; 2274 : 	    buf[49] = 0;

	mov	edx, 1
	imul	eax, edx, 49
	mov	BYTE PTR _buf$2[ebp+eax], 0

; 2275 : 	    xmlEncodingErr(XML_I18N_CONV_FAILED,

	lea	ecx, DWORD PTR _buf$2[ebp]
	push	ecx
	push	OFFSET ??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@
	push	6003					; 00001773H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH
$LN2@xmlCharEnc:

; 2276 : 		    "input conversion failed due to input error, bytes %s\n",
; 2277 : 		           buf);
; 2278 :         }
; 2279 :     }
; 2280 :     /*
; 2281 :      * Ignore when input buffer is not on a boundary
; 2282 :      */
; 2283 :     if (ret == -3)

	cmp	DWORD PTR _ret$[ebp], -3		; fffffffdH
	jne	SHORT $LN17@xmlCharEnc

; 2284 :         ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN17@xmlCharEnc:

; 2285 :     return (c_out? c_out : ret);

	cmp	DWORD PTR _c_out$[ebp], 0
	je	SHORT $LN19@xmlCharEnc
	mov	edx, DWORD PTR _c_out$[ebp]
	mov	DWORD PTR tv174[ebp], edx
	jmp	SHORT $LN20@xmlCharEnc
$LN19@xmlCharEnc:
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR tv174[ebp], eax
$LN20@xmlCharEnc:
	mov	eax, DWORD PTR tv174[ebp]
$LN1@xmlCharEnc:

; 2286 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@xmlCharEnc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN25@xmlCharEnc:
	DD	3
	DD	$LN24@xmlCharEnc
$LN24@xmlCharEnc:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN21@xmlCharEnc
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN22@xmlCharEnc
	DD	-100					; ffffff9cH
	DD	50					; 00000032H
	DD	$LN23@xmlCharEnc
$LN23@xmlCharEnc:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN22@xmlCharEnc:
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$LN21@xmlCharEnc:
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
_xmlCharEncInput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncFirstLineInput
_TEXT	SEGMENT
tv140 = -112						; size = 4
_content$1 = -108					; size = 4
_buf$2 = -100						; size = 50
_out$ = -44						; size = 4
_in$ = -40						; size = 4
_c_out$ = -32						; size = 4
_c_in$ = -20						; size = 4
_toconv$ = -12						; size = 4
_written$ = -8						; size = 4
_ret$ = -4						; size = 4
_input$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlCharEncFirstLineInput PROC				; COMDAT

; 2097 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	edi
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 2098 :     int ret;
; 2099 :     size_t written;
; 2100 :     size_t toconv;
; 2101 :     int c_in;
; 2102 :     int c_out;
; 2103 :     xmlBufPtr in;
; 2104 :     xmlBufPtr out;
; 2105 : 
; 2106 :     if ((input == NULL) || (input->encoder == NULL) ||
; 2107 :         (input->buffer == NULL) || (input->raw == NULL))

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN5@xmlCharEnc
	mov	eax, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@xmlCharEnc
	mov	ecx, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN5@xmlCharEnc
	mov	edx, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN4@xmlCharEnc
$LN5@xmlCharEnc:

; 2108 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN4@xmlCharEnc:

; 2109 :     out = input->buffer;

	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _out$[ebp], ecx

; 2110 :     in = input->raw;

	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _in$[ebp], eax

; 2111 : 
; 2112 :     toconv = xmlBufUse(in);

	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_xmlBufUse
	add	esp, 4
	mov	DWORD PTR _toconv$[ebp], eax

; 2113 :     if (toconv == 0)

	cmp	DWORD PTR _toconv$[ebp], 0
	jne	SHORT $LN6@xmlCharEnc

; 2114 :         return (0);

	xor	eax, eax
	jmp	$LN1@xmlCharEnc
$LN6@xmlCharEnc:

; 2115 :     written = xmlBufAvail(out) - 1; /* count '\0' */

	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_xmlBufAvail
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _written$[ebp], eax

; 2116 :     /*
; 2117 :      * echo '<?xml version="1.0" encoding="UCS4"?>' | wc -c => 38
; 2118 :      * 45 chars should be sufficient to reach the end of the encoding
; 2119 :      * declaration without going too far inside the document content.
; 2120 :      * on UTF-16 this means 90bytes, on UCS4 this means 180
; 2121 :      * The actual value depending on guessed encoding is passed as @len
; 2122 :      * if provided
; 2123 :      */
; 2124 :     if (len >= 0) {

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN7@xmlCharEnc

; 2125 :         if (toconv > (unsigned int) len)

	mov	eax, DWORD PTR _toconv$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jbe	SHORT $LN9@xmlCharEnc

; 2126 :             toconv = len;

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _toconv$[ebp], ecx
$LN9@xmlCharEnc:

; 2127 :     } else {

	jmp	SHORT $LN8@xmlCharEnc
$LN7@xmlCharEnc:

; 2128 :         if (toconv > 180)

	cmp	DWORD PTR _toconv$[ebp], 180		; 000000b4H
	jbe	SHORT $LN8@xmlCharEnc

; 2129 :             toconv = 180;

	mov	DWORD PTR _toconv$[ebp], 180		; 000000b4H
$LN8@xmlCharEnc:

; 2130 :     }
; 2131 :     if (toconv * 2 >= written) {

	mov	edx, DWORD PTR _toconv$[ebp]
	shl	edx, 1
	cmp	edx, DWORD PTR _written$[ebp]
	jb	SHORT $LN11@xmlCharEnc

; 2132 :         xmlBufGrow(out, toconv * 2);

	mov	eax, DWORD PTR _toconv$[ebp]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_xmlBufGrow
	add	esp, 8

; 2133 :         written = xmlBufAvail(out) - 1;

	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_xmlBufAvail
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _written$[ebp], eax
$LN11@xmlCharEnc:

; 2134 :     }
; 2135 :     if (written > 360)

	cmp	DWORD PTR _written$[ebp], 360		; 00000168H
	jbe	SHORT $LN12@xmlCharEnc

; 2136 :         written = 360;

	mov	DWORD PTR _written$[ebp], 360		; 00000168H
$LN12@xmlCharEnc:

; 2137 : 
; 2138 :     c_in = toconv;

	mov	eax, DWORD PTR _toconv$[ebp]
	mov	DWORD PTR _c_in$[ebp], eax

; 2139 :     c_out = written;

	mov	ecx, DWORD PTR _written$[ebp]
	mov	DWORD PTR _c_out$[ebp], ecx

; 2140 :     ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,

	push	0
	lea	edx, DWORD PTR _c_in$[ebp]
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_xmlBufContent
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _c_out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_xmlBufEnd
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _input$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_xmlEncInputChunk
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 2141 :                            xmlBufContent(in), &c_in, 0);
; 2142 :     xmlBufShrink(in, c_in);

	mov	edx, DWORD PTR _c_in$[ebp]
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_xmlBufShrink
	add	esp, 8

; 2143 :     xmlBufAddLen(out, c_out);

	mov	ecx, DWORD PTR _c_out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_xmlBufAddLen
	add	esp, 8

; 2144 :     if (ret == -1)

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN13@xmlCharEnc

; 2145 :         ret = -3;

	mov	DWORD PTR _ret$[ebp], -3		; fffffffdH
$LN13@xmlCharEnc:

; 2146 : 
; 2147 :     switch (ret) {

	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR tv140[ebp], eax
	cmp	DWORD PTR tv140[ebp], -2		; fffffffeH
	je	SHORT $LN17@xmlCharEnc
	jmp	$LN2@xmlCharEnc

; 2148 :         case 0:
; 2149 : #ifdef DEBUG_ENCODING
; 2150 :             xmlGenericError(xmlGenericErrorContext,
; 2151 :                             "converted %d bytes to %d bytes of input\n",
; 2152 :                             c_in, c_out);
; 2153 : #endif
; 2154 :             break;

	jmp	$LN2@xmlCharEnc

; 2155 :         case -1:
; 2156 : #ifdef DEBUG_ENCODING
; 2157 :             xmlGenericError(xmlGenericErrorContext,
; 2158 :                          "converted %d bytes to %d bytes of input, %d left\n",
; 2159 :                             c_in, c_out, (int)xmlBufUse(in));
; 2160 : #endif
; 2161 :             break;

	jmp	$LN2@xmlCharEnc

; 2162 :         case -3:
; 2163 : #ifdef DEBUG_ENCODING
; 2164 :             xmlGenericError(xmlGenericErrorContext,
; 2165 :                         "converted %d bytes to %d bytes of input, %d left\n",
; 2166 :                             c_in, c_out, (int)xmlBufUse(in));
; 2167 : #endif
; 2168 :             break;

	jmp	$LN2@xmlCharEnc
$LN17@xmlCharEnc:

; 2169 :         case -2: {
; 2170 :             char buf[50];
; 2171 :             const xmlChar *content = xmlBufContent(in);

	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_xmlBufContent
	add	esp, 4
	mov	DWORD PTR _content$1[ebp], eax

; 2172 : 
; 2173 : 	    snprintf(&buf[0], 49, "0x%02X 0x%02X 0x%02X 0x%02X",

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _content$1[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _content$1[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _content$1[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _content$1[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
	push	49					; 00000031H
	mov	ecx, 1
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _buf$2[ebp+edx]
	push	eax
	call	_snprintf
	add	esp, 28					; 0000001cH

; 2174 : 		     content[0], content[1],
; 2175 : 		     content[2], content[3]);
; 2176 : 	    buf[49] = 0;

	mov	ecx, 1
	imul	edx, ecx, 49
	mov	BYTE PTR _buf$2[ebp+edx], 0

; 2177 : 	    xmlEncodingErr(XML_I18N_CONV_FAILED,

	lea	eax, DWORD PTR _buf$2[ebp]
	push	eax
	push	OFFSET ??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@
	push	6003					; 00001773H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH
$LN2@xmlCharEnc:

; 2178 : 		    "input conversion failed due to input error, bytes %s\n",
; 2179 : 		           buf);
; 2180 :         }
; 2181 :     }
; 2182 :     /*
; 2183 :      * Ignore when input buffer is not on a boundary
; 2184 :      */
; 2185 :     if (ret == -3) ret = 0;

	cmp	DWORD PTR _ret$[ebp], -3		; fffffffdH
	jne	SHORT $LN18@xmlCharEnc
	mov	DWORD PTR _ret$[ebp], 0
$LN18@xmlCharEnc:

; 2186 :     if (ret == -1) ret = 0;

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN19@xmlCharEnc
	mov	DWORD PTR _ret$[ebp], 0
$LN19@xmlCharEnc:

; 2187 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCharEnc:

; 2188 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@xmlCharEnc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 112				; 00000070H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN25@xmlCharEnc:
	DD	3
	DD	$LN24@xmlCharEnc
$LN24@xmlCharEnc:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN21@xmlCharEnc
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN22@xmlCharEnc
	DD	-100					; ffffff9cH
	DD	50					; 00000032H
	DD	$LN23@xmlCharEnc
$LN23@xmlCharEnc:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN22@xmlCharEnc:
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$LN21@xmlCharEnc:
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
_xmlCharEncFirstLineInput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncFirstLineInt
_TEXT	SEGMENT
_toconv$ = -24						; size = 4
_written$ = -12						; size = 4
_ret$ = -4						; size = 4
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_len$ = 20						; size = 4
_xmlCharEncFirstLineInt PROC				; COMDAT

; 1990 :                        xmlBufferPtr in, int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1991 :     int ret;
; 1992 :     int written;
; 1993 :     int toconv;
; 1994 : 
; 1995 :     if (handler == NULL) return(-1);

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN2@xmlCharEnc
	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN2@xmlCharEnc:

; 1996 :     if (out == NULL) return(-1);

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN3@xmlCharEnc
	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN3@xmlCharEnc:

; 1997 :     if (in == NULL) return(-1);

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN4@xmlCharEnc
	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN4@xmlCharEnc:

; 1998 : 
; 1999 :     /* calculate space available */
; 2000 :     written = out->size - out->use - 1; /* count '\0' */

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	DWORD PTR _written$[ebp], edx

; 2001 :     toconv = in->use;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _toconv$[ebp], ecx

; 2002 :     /*
; 2003 :      * echo '<?xml version="1.0" encoding="UCS4"?>' | wc -c => 38
; 2004 :      * 45 chars should be sufficient to reach the end of the encoding
; 2005 :      * declaration without going too far inside the document content.
; 2006 :      * on UTF-16 this means 90bytes, on UCS4 this means 180
; 2007 :      * The actual value depending on guessed encoding is passed as @len
; 2008 :      * if provided
; 2009 :      */
; 2010 :     if (len >= 0) {

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN5@xmlCharEnc

; 2011 :         if (toconv > len)

	mov	edx, DWORD PTR _toconv$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jle	SHORT $LN7@xmlCharEnc

; 2012 :             toconv = len;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _toconv$[ebp], eax
$LN7@xmlCharEnc:

; 2013 :     } else {

	jmp	SHORT $LN6@xmlCharEnc
$LN5@xmlCharEnc:

; 2014 :         if (toconv > 180)

	cmp	DWORD PTR _toconv$[ebp], 180		; 000000b4H
	jle	SHORT $LN6@xmlCharEnc

; 2015 :             toconv = 180;

	mov	DWORD PTR _toconv$[ebp], 180		; 000000b4H
$LN6@xmlCharEnc:

; 2016 :     }
; 2017 :     if (toconv * 2 >= written) {

	mov	ecx, DWORD PTR _toconv$[ebp]
	shl	ecx, 1
	cmp	ecx, DWORD PTR _written$[ebp]
	jl	SHORT $LN9@xmlCharEnc

; 2018 :         xmlBufferGrow(out, toconv * 2);

	mov	edx, DWORD PTR _toconv$[ebp]
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_xmlBufferGrow
	add	esp, 8

; 2019 : 	written = out->size - out->use - 1;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	DWORD PTR _written$[ebp], eax
$LN9@xmlCharEnc:

; 2020 :     }
; 2021 : 
; 2022 :     ret = xmlEncInputChunk(handler, &out->content[out->use], &written,

	push	0
	lea	ecx, DWORD PTR _toconv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _written$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR [ecx+4]
	push	eax
	mov	edx, DWORD PTR _handler$[ebp]
	push	edx
	call	_xmlEncInputChunk
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 2023 :                            in->content, &toconv, 0);
; 2024 :     xmlBufferShrink(in, toconv);

	mov	eax, DWORD PTR _toconv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_xmlBufferShrink
	add	esp, 8

; 2025 :     out->use += written;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _written$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 2026 :     out->content[out->use] = 0;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+eax], 0

; 2027 :     if (ret == -1) ret = -3;

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN10@xmlCharEnc
	mov	DWORD PTR _ret$[ebp], -3		; fffffffdH
$LN10@xmlCharEnc:

; 2028 : 
; 2029 : #ifdef DEBUG_ENCODING
; 2030 :     switch (ret) {
; 2031 :         case 0:
; 2032 : 	    xmlGenericError(xmlGenericErrorContext,
; 2033 : 		    "converted %d bytes to %d bytes of input\n",
; 2034 : 	            toconv, written);
; 2035 : 	    break;
; 2036 :         case -1:
; 2037 : 	    xmlGenericError(xmlGenericErrorContext,"converted %d bytes to %d bytes of input, %d left\n",
; 2038 : 	            toconv, written, in->use);
; 2039 : 	    break;
; 2040 :         case -2:
; 2041 : 	    xmlGenericError(xmlGenericErrorContext,
; 2042 : 		    "input conversion failed due to input error\n");
; 2043 : 	    break;
; 2044 :         case -3:
; 2045 : 	    xmlGenericError(xmlGenericErrorContext,"converted %d bytes to %d bytes of input, %d left\n",
; 2046 : 	            toconv, written, in->use);
; 2047 : 	    break;
; 2048 : 	default:
; 2049 : 	    xmlGenericError(xmlGenericErrorContext,"Unknown input conversion failed %d\n", ret);
; 2050 :     }
; 2051 : #endif /* DEBUG_ENCODING */
; 2052 :     /*
; 2053 :      * Ignore when input buffer is not on a boundary
; 2054 :      */
; 2055 :     if (ret == -3) ret = 0;

	cmp	DWORD PTR _ret$[ebp], -3		; fffffffdH
	jne	SHORT $LN11@xmlCharEnc
	mov	DWORD PTR _ret$[ebp], 0
$LN11@xmlCharEnc:

; 2056 :     if (ret == -1) ret = 0;

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN12@xmlCharEnc
	mov	DWORD PTR _ret$[ebp], 0
$LN12@xmlCharEnc:

; 2057 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCharEnc:

; 2058 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@xmlCharEnc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN17@xmlCharEnc:
	DD	2
	DD	$LN16@xmlCharEnc
$LN16@xmlCharEnc:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN14@xmlCharEnc
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN15@xmlCharEnc
$LN15@xmlCharEnc:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	118					; 00000076H
	DB	0
$LN14@xmlCharEnc:
	DB	119					; 00000077H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_xmlCharEncFirstLineInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _isolat1ToUTF8
_TEXT	SEGMENT
_instop$ = -20						; size = 4
_inend$ = -16						; size = 4
_outend$ = -12						; size = 4
_base$ = -8						; size = 4
_outstart$ = -4						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_isolat1ToUTF8 PROC					; COMDAT

; 308  :               const unsigned char* in, int *inlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 309  :     unsigned char* outstart = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 310  :     const unsigned char* base = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _base$[ebp], ecx

; 311  :     unsigned char* outend;
; 312  :     const unsigned char* inend;
; 313  :     const unsigned char* instop;
; 314  : 
; 315  :     if ((out == NULL) || (in == NULL) || (outlen == NULL) || (inlen == NULL))

	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN7@isolat1ToU
	cmp	DWORD PTR _in$[ebp], 0
	je	SHORT $LN7@isolat1ToU
	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN7@isolat1ToU
	cmp	DWORD PTR _inlen$[ebp], 0
	jne	SHORT $LN6@isolat1ToU
$LN7@isolat1ToU:

; 316  : 	return(-1);

	or	eax, -1
	jmp	$LN1@isolat1ToU
$LN6@isolat1ToU:

; 317  : 
; 318  :     outend = out + *outlen;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _outend$[ebp], eax

; 319  :     inend = in + (*inlen);

	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _inend$[ebp], edx

; 320  :     instop = inend;

	mov	eax, DWORD PTR _inend$[ebp]
	mov	DWORD PTR _instop$[ebp], eax
$LN2@isolat1ToU:

; 321  : 
; 322  :     while ((in < inend) && (out < outend - 1)) {

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jae	$LN3@isolat1ToU
	mov	edx, DWORD PTR _outend$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _out$[ebp], edx
	jae	$LN3@isolat1ToU

; 323  : 	if (*in >= 0x80) {

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 128				; 00000080H
	jl	SHORT $LN8@isolat1ToU

; 324  : 	    *out++ = (((*in) >>  6) & 0x1F) | 0xC0;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	sar	eax, 6
	and	eax, 31					; 0000001fH
	or	eax, 192				; 000000c0H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 325  :             *out++ = ((*in) & 0x3F) | 0x80;

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 63					; 0000003fH
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 326  : 	    ++in;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
$LN8@isolat1ToU:

; 327  : 	}
; 328  : 	if ((instop - in) > (outend - out)) instop = in + (outend - out);

	mov	edx, DWORD PTR _instop$[ebp]
	sub	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _outend$[ebp]
	sub	eax, DWORD PTR _out$[ebp]
	cmp	edx, eax
	jle	SHORT $LN4@isolat1ToU
	mov	ecx, DWORD PTR _outend$[ebp]
	sub	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _instop$[ebp], ecx
$LN4@isolat1ToU:

; 329  : 	while ((in < instop) && (*in < 0x80)) {

	mov	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _instop$[ebp]
	jae	SHORT $LN5@isolat1ToU
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 128				; 00000080H
	jge	SHORT $LN5@isolat1ToU

; 330  : 	    *out++ = *in++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 331  : 	}

	jmp	SHORT $LN4@isolat1ToU
$LN5@isolat1ToU:

; 332  :     }

	jmp	$LN2@isolat1ToU
$LN3@isolat1ToU:

; 333  :     if ((in < inend) && (out < outend) && (*in < 0x80)) {

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jae	SHORT $LN10@isolat1ToU
	mov	edx, DWORD PTR _out$[ebp]
	cmp	edx, DWORD PTR _outend$[ebp]
	jae	SHORT $LN10@isolat1ToU
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 128				; 00000080H
	jge	SHORT $LN10@isolat1ToU

; 334  :         *out++ = *in++;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax
$LN10@isolat1ToU:

; 335  :     }
; 336  :     *outlen = out - outstart;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 337  :     *inlen = in - base;

	mov	eax, DWORD PTR _in$[ebp]
	sub	eax, DWORD PTR _base$[ebp]
	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 338  :     return(*outlen);

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [edx]
$LN1@isolat1ToU:

; 339  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_isolat1ToUTF8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _UTF8Toisolat1
_TEXT	SEGMENT
tv95 = -40						; size = 4
tv94 = -36						; size = 4
_trailing$ = -32					; size = 4
_d$ = -28						; size = 4
_c$ = -24						; size = 4
_inend$ = -20						; size = 4
_instart$ = -16						; size = 4
_outstart$ = -12					; size = 4
_outend$ = -8						; size = 4
_processed$ = -4					; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
_UTF8Toisolat1 PROC					; COMDAT

; 403  :               const unsigned char* in, int *inlen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 404  :     const unsigned char* processed = in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], eax

; 405  :     const unsigned char* outend;
; 406  :     const unsigned char* outstart = out;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], ecx

; 407  :     const unsigned char* instart = in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _instart$[ebp], edx

; 408  :     const unsigned char* inend;
; 409  :     unsigned int c, d;
; 410  :     int trailing;
; 411  : 
; 412  :     if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);

	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN8@UTF8Toisol
	cmp	DWORD PTR _outlen$[ebp], 0
	je	SHORT $LN8@UTF8Toisol
	cmp	DWORD PTR _inlen$[ebp], 0
	jne	SHORT $LN7@UTF8Toisol
$LN8@UTF8Toisol:
	or	eax, -1
	jmp	$LN1@UTF8Toisol
$LN7@UTF8Toisol:

; 413  :     if (in == NULL) {

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN9@UTF8Toisol

; 414  :         /*
; 415  : 	 * initialization nothing to do
; 416  : 	 */
; 417  : 	*outlen = 0;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], 0

; 418  : 	*inlen = 0;

	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], 0

; 419  : 	return(0);

	xor	eax, eax
	jmp	$LN1@UTF8Toisol
$LN9@UTF8Toisol:

; 420  :     }
; 421  :     inend = in + (*inlen);

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _inend$[ebp], eax

; 422  :     outend = out + (*outlen);

	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _outend$[ebp], edx
$LN2@UTF8Toisol:

; 423  :     while (in < inend) {

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jae	$LN3@UTF8Toisol

; 424  : 	d = *in++;

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax

; 425  : 	if      (d < 0x80)  { c= d; trailing= 0; }

	cmp	DWORD PTR _d$[ebp], 128			; 00000080H
	jae	SHORT $LN10@UTF8Toisol
	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _trailing$[ebp], 0
	jmp	$LN11@UTF8Toisol
$LN10@UTF8Toisol:

; 426  : 	else if (d < 0xC0) {

	cmp	DWORD PTR _d$[ebp], 192			; 000000c0H
	jae	SHORT $LN12@UTF8Toisol

; 427  : 	    /* trailing byte in leading position */
; 428  : 	    *outlen = out - outstart;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 429  : 	    *inlen = processed - instart;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _instart$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 430  : 	    return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF8Toisol
	jmp	SHORT $LN11@UTF8Toisol
$LN12@UTF8Toisol:

; 431  :         } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }

	cmp	DWORD PTR _d$[ebp], 224			; 000000e0H
	jae	SHORT $LN14@UTF8Toisol
	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _c$[ebp], eax
	mov	DWORD PTR _trailing$[ebp], 1
	jmp	SHORT $LN11@UTF8Toisol
$LN14@UTF8Toisol:

; 432  :         else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }

	cmp	DWORD PTR _d$[ebp], 240			; 000000f0H
	jae	SHORT $LN16@UTF8Toisol
	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _trailing$[ebp], 2
	jmp	SHORT $LN11@UTF8Toisol
$LN16@UTF8Toisol:

; 433  :         else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }

	cmp	DWORD PTR _d$[ebp], 248			; 000000f8H
	jae	SHORT $LN18@UTF8Toisol
	mov	edx, DWORD PTR _d$[ebp]
	and	edx, 7
	mov	DWORD PTR _c$[ebp], edx
	mov	DWORD PTR _trailing$[ebp], 3
	jmp	SHORT $LN11@UTF8Toisol
$LN18@UTF8Toisol:

; 434  : 	else {
; 435  : 	    /* no chance for this in IsoLat1 */
; 436  : 	    *outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 437  : 	    *inlen = processed - instart;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _instart$[ebp]
	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], edx

; 438  : 	    return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF8Toisol
$LN11@UTF8Toisol:

; 439  : 	}
; 440  : 
; 441  : 	if (inend - in < trailing) {

	mov	ecx, DWORD PTR _inend$[ebp]
	sub	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _trailing$[ebp]
	jge	SHORT $LN20@UTF8Toisol

; 442  : 	    break;

	jmp	$LN3@UTF8Toisol
$LN20@UTF8Toisol:

; 443  : 	}
; 444  : 
; 445  : 	for ( ; trailing; trailing--) {

	jmp	SHORT $LN6@UTF8Toisol
$LN4@UTF8Toisol:
	mov	edx, DWORD PTR _trailing$[ebp]
	sub	edx, 1
	mov	DWORD PTR _trailing$[ebp], edx
$LN6@UTF8Toisol:
	cmp	DWORD PTR _trailing$[ebp], 0
	je	$LN5@UTF8Toisol

; 446  : 	    if (in >= inend)

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jb	SHORT $LN21@UTF8Toisol

; 447  : 		break;

	jmp	SHORT $LN5@UTF8Toisol
$LN21@UTF8Toisol:

; 448  : 	    if (((d= *in++) & 0xC0) != 0x80) {

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 192				; 000000c0H
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	cmp	DWORD PTR tv94[ebp], 128		; 00000080H
	je	SHORT $LN27@UTF8Toisol
	mov	DWORD PTR tv95[ebp], 1
	jmp	SHORT $LN28@UTF8Toisol
$LN27@UTF8Toisol:
	mov	DWORD PTR tv95[ebp], 0
$LN28@UTF8Toisol:
	cmp	DWORD PTR tv95[ebp], 0
	je	SHORT $LN22@UTF8Toisol

; 449  : 		*outlen = out - outstart;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 450  : 		*inlen = processed - instart;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _instart$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 451  : 		return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UTF8Toisol
$LN22@UTF8Toisol:

; 452  : 	    }
; 453  : 	    c <<= 6;

	mov	eax, DWORD PTR _c$[ebp]
	shl	eax, 6
	mov	DWORD PTR _c$[ebp], eax

; 454  : 	    c |= d & 0x3F;

	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], ecx

; 455  : 	}

	jmp	$LN4@UTF8Toisol
$LN5@UTF8Toisol:

; 456  : 
; 457  : 	/* assertion: c is a single UTF-4 value */
; 458  : 	if (c <= 0xFF) {

	cmp	DWORD PTR _c$[ebp], 255			; 000000ffH
	ja	SHORT $LN23@UTF8Toisol

; 459  : 	    if (out >= outend)

	mov	edx, DWORD PTR _out$[ebp]
	cmp	edx, DWORD PTR _outend$[ebp]
	jb	SHORT $LN25@UTF8Toisol

; 460  : 		break;

	jmp	SHORT $LN3@UTF8Toisol
$LN25@UTF8Toisol:

; 461  : 	    *out++ = c;

	mov	eax, DWORD PTR _out$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 462  : 	} else {

	jmp	SHORT $LN24@UTF8Toisol
$LN23@UTF8Toisol:

; 463  : 	    /* no chance for this in IsoLat1 */
; 464  : 	    *outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 465  : 	    *inlen = processed - instart;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _instart$[ebp]
	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], edx

; 466  : 	    return(-2);

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@UTF8Toisol
$LN24@UTF8Toisol:

; 467  : 	}
; 468  : 	processed = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 469  :     }

	jmp	$LN2@UTF8Toisol
$LN3@UTF8Toisol:

; 470  :     *outlen = out - outstart;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 471  :     *inlen = processed - instart;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _instart$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 472  :     return(*outlen);

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [eax]
$LN1@UTF8Toisol:

; 473  : }

	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_UTF8Toisolat1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncCloseFunc
_TEXT	SEGMENT
_handler_in_list$ = -16					; size = 4
_i$ = -12						; size = 4
_tofree$ = -8						; size = 4
_ret$ = -4						; size = 4
_handler$ = 8						; size = 4
_xmlCharEncCloseFunc PROC				; COMDAT

; 2720 : xmlCharEncCloseFunc(xmlCharEncodingHandler *handler) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 2721 :     int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 2722 :     int tofree = 0;

	mov	DWORD PTR _tofree$[ebp], 0

; 2723 :     int i, handler_in_list = 0;

	mov	DWORD PTR _handler_in_list$[ebp], 0

; 2724 : 
; 2725 :     if (handler == NULL) return(-1);

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN5@xmlCharEnc
	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN5@xmlCharEnc:

; 2726 :     if (handler->name == NULL) return(-1);

	mov	eax, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN6@xmlCharEnc
	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN6@xmlCharEnc:

; 2727 :     if (handlers != NULL) {

	cmp	DWORD PTR _handlers, 0
	je	SHORT $LN7@xmlCharEnc

; 2728 :         for (i = 0;i < nbCharEncodingHandler; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlCharEnc
$LN2@xmlCharEnc:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlCharEnc:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _nbCharEncodingHandler
	jge	SHORT $LN7@xmlCharEnc

; 2729 :             if (handler == handlers[i]) {

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _handlers
	mov	edx, DWORD PTR _handler$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4]
	jne	SHORT $LN8@xmlCharEnc

; 2730 : 	        handler_in_list = 1;

	mov	DWORD PTR _handler_in_list$[ebp], 1

; 2731 : 		break;

	jmp	SHORT $LN7@xmlCharEnc
$LN8@xmlCharEnc:

; 2732 : 	    }
; 2733 : 	}

	jmp	SHORT $LN2@xmlCharEnc
$LN7@xmlCharEnc:

; 2734 :     }
; 2735 : #ifdef LIBXML_ICONV_ENABLED
; 2736 :     /*
; 2737 :      * Iconv handlers can be used only once, free the whole block.
; 2738 :      * and the associated icon resources.
; 2739 :      */
; 2740 :     if ((handler_in_list == 0) &&

	cmp	DWORD PTR _handler_in_list$[ebp], 0
	jne	$LN9@xmlCharEnc
	mov	eax, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN10@xmlCharEnc
	mov	ecx, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN9@xmlCharEnc
$LN10@xmlCharEnc:

; 2741 :         ((handler->iconv_out != NULL) || (handler->iconv_in != NULL))) {
; 2742 :         tofree = 1;

	mov	DWORD PTR _tofree$[ebp], 1

; 2743 : 	if (handler->iconv_out != NULL) {

	mov	edx, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN11@xmlCharEnc

; 2744 : 	    if (iconv_close(handler->iconv_out))

	mov	esi, esp
	mov	eax, DWORD PTR _handler$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR __imp__libiconv_close
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN12@xmlCharEnc

; 2745 : 		ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
$LN12@xmlCharEnc:

; 2746 : 	    handler->iconv_out = NULL;

	mov	edx, DWORD PTR _handler$[ebp]
	mov	DWORD PTR [edx+16], 0
$LN11@xmlCharEnc:

; 2747 : 	}
; 2748 : 	if (handler->iconv_in != NULL) {

	mov	eax, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN9@xmlCharEnc

; 2749 : 	    if (iconv_close(handler->iconv_in))

	mov	esi, esp
	mov	ecx, DWORD PTR _handler$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR __imp__libiconv_close
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN14@xmlCharEnc

; 2750 : 		ret = -1;

	mov	DWORD PTR _ret$[ebp], -1
$LN14@xmlCharEnc:

; 2751 : 	    handler->iconv_in = NULL;

	mov	eax, DWORD PTR _handler$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN9@xmlCharEnc:

; 2752 : 	}
; 2753 :     }
; 2754 : #endif /* LIBXML_ICONV_ENABLED */
; 2755 : #ifdef LIBXML_ICU_ENABLED
; 2756 :     if ((handler_in_list == 0) &&
; 2757 :         ((handler->uconv_out != NULL) || (handler->uconv_in != NULL))) {
; 2758 :         tofree = 1;
; 2759 : 	if (handler->uconv_out != NULL) {
; 2760 : 	    closeIcuConverter(handler->uconv_out);
; 2761 : 	    handler->uconv_out = NULL;
; 2762 : 	}
; 2763 : 	if (handler->uconv_in != NULL) {
; 2764 : 	    closeIcuConverter(handler->uconv_in);
; 2765 : 	    handler->uconv_in = NULL;
; 2766 : 	}
; 2767 :     }
; 2768 : #endif
; 2769 :     if (tofree) {

	cmp	DWORD PTR _tofree$[ebp], 0
	je	SHORT $LN15@xmlCharEnc

; 2770 :         /* free up only dynamic handlers iconv/uconv */
; 2771 :         if (handler->name != NULL)

	mov	ecx, DWORD PTR _handler$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN16@xmlCharEnc

; 2772 :             xmlFree(handler->name);

	mov	esi, esp
	mov	edx, DWORD PTR _handler$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@xmlCharEnc:

; 2773 :         handler->name = NULL;

	mov	ecx, DWORD PTR _handler$[ebp]
	mov	DWORD PTR [ecx], 0

; 2774 :         xmlFree(handler);

	mov	esi, esp
	mov	edx, DWORD PTR _handler$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@xmlCharEnc:

; 2775 :     }
; 2776 : #ifdef DEBUG_ENCODING
; 2777 :     if (ret)
; 2778 :         xmlGenericError(xmlGenericErrorContext,
; 2779 : 		"failed to close the encoding handler\n");
; 2780 :     else
; 2781 :         xmlGenericError(xmlGenericErrorContext,
; 2782 : 		"closed the encoding handler\n");
; 2783 : #endif
; 2784 : 
; 2785 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCharEnc:

; 2786 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCharEncCloseFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncFirstLine
_TEXT	SEGMENT
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_xmlCharEncFirstLine PROC				; COMDAT

; 2076 :                  xmlBufferPtr in) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 2077 :     return(xmlCharEncFirstLineInt(handler, out, in, -1));

	push	-1
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handler$[ebp]
	push	edx
	call	_xmlCharEncFirstLineInt
	add	esp, 16					; 00000010H

; 2078 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCharEncFirstLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncInFunc
_TEXT	SEGMENT
tv172 = -96						; size = 4
tv138 = -92						; size = 4
_buf$1 = -84						; size = 50
_toconv$ = -24						; size = 4
_written$ = -12						; size = 4
_ret$ = -4						; size = 4
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_xmlCharEncInFunc PROC					; COMDAT

; 2304 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	edi
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 2305 :     int ret;
; 2306 :     int written;
; 2307 :     int toconv;
; 2308 : 
; 2309 :     if (handler == NULL)

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN4@xmlCharEnc

; 2310 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN4@xmlCharEnc:

; 2311 :     if (out == NULL)

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN5@xmlCharEnc

; 2312 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN5@xmlCharEnc:

; 2313 :     if (in == NULL)

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN6@xmlCharEnc

; 2314 :         return (-1);

	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN6@xmlCharEnc:

; 2315 : 
; 2316 :     toconv = in->use;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _toconv$[ebp], ecx

; 2317 :     if (toconv == 0)

	cmp	DWORD PTR _toconv$[ebp], 0
	jne	SHORT $LN7@xmlCharEnc

; 2318 :         return (0);

	xor	eax, eax
	jmp	$LN1@xmlCharEnc
$LN7@xmlCharEnc:

; 2319 :     written = out->size - out->use -1; /* count '\0' */

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	DWORD PTR _written$[ebp], ecx

; 2320 :     if (toconv * 2 >= written) {

	mov	edx, DWORD PTR _toconv$[ebp]
	shl	edx, 1
	cmp	edx, DWORD PTR _written$[ebp]
	jl	SHORT $LN8@xmlCharEnc

; 2321 :         xmlBufferGrow(out, out->size + toconv * 2);

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _toconv$[ebp]
	lea	eax, DWORD PTR [ecx+edx*2]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_xmlBufferGrow
	add	esp, 8

; 2322 :         written = out->size - out->use - 1;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	DWORD PTR _written$[ebp], ecx
$LN8@xmlCharEnc:

; 2323 :     }
; 2324 :     ret = xmlEncInputChunk(handler, &out->content[out->use], &written,

	push	1
	lea	edx, DWORD PTR _toconv$[ebp]
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _written$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR [edx+4]
	push	ecx
	mov	eax, DWORD PTR _handler$[ebp]
	push	eax
	call	_xmlEncInputChunk
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ret$[ebp], eax

; 2325 :                            in->content, &toconv, 1);
; 2326 :     xmlBufferShrink(in, toconv);

	mov	ecx, DWORD PTR _toconv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_xmlBufferShrink
	add	esp, 8

; 2327 :     out->use += written;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _written$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 2328 :     out->content[out->use] = 0;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+ecx], 0

; 2329 :     if (ret == -1)

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN9@xmlCharEnc

; 2330 :         ret = -3;

	mov	DWORD PTR _ret$[ebp], -3		; fffffffdH
$LN9@xmlCharEnc:

; 2331 : 
; 2332 :     switch (ret) {

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR tv138[ebp], ecx
	cmp	DWORD PTR tv138[ebp], -2		; fffffffeH
	je	SHORT $LN13@xmlCharEnc
	jmp	$LN2@xmlCharEnc

; 2333 :         case 0:
; 2334 : #ifdef DEBUG_ENCODING
; 2335 :             xmlGenericError(xmlGenericErrorContext,
; 2336 :                             "converted %d bytes to %d bytes of input\n",
; 2337 :                             toconv, written);
; 2338 : #endif
; 2339 :             break;

	jmp	$LN2@xmlCharEnc

; 2340 :         case -1:
; 2341 : #ifdef DEBUG_ENCODING
; 2342 :             xmlGenericError(xmlGenericErrorContext,
; 2343 :                          "converted %d bytes to %d bytes of input, %d left\n",
; 2344 :                             toconv, written, in->use);
; 2345 : #endif
; 2346 :             break;

	jmp	$LN2@xmlCharEnc

; 2347 :         case -3:
; 2348 : #ifdef DEBUG_ENCODING
; 2349 :             xmlGenericError(xmlGenericErrorContext,
; 2350 :                         "converted %d bytes to %d bytes of input, %d left\n",
; 2351 :                             toconv, written, in->use);
; 2352 : #endif
; 2353 :             break;

	jmp	$LN2@xmlCharEnc
$LN13@xmlCharEnc:

; 2354 :         case -2: {
; 2355 :             char buf[50];
; 2356 : 
; 2357 : 	    snprintf(&buf[0], 49, "0x%02X 0x%02X 0x%02X 0x%02X",

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+eax]
	push	eax
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+ecx]
	push	ecx
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+ecx]
	push	ecx
	push	OFFSET ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
	push	49					; 00000031H
	mov	edx, 1
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _buf$1[ebp+eax]
	push	ecx
	call	_snprintf
	add	esp, 28					; 0000001cH

; 2358 : 		     in->content[0], in->content[1],
; 2359 : 		     in->content[2], in->content[3]);
; 2360 : 	    buf[49] = 0;

	mov	edx, 1
	imul	eax, edx, 49
	mov	BYTE PTR _buf$1[ebp+eax], 0

; 2361 : 	    xmlEncodingErr(XML_I18N_CONV_FAILED,

	lea	ecx, DWORD PTR _buf$1[ebp]
	push	ecx
	push	OFFSET ??_C@_0DG@HJMOLPHI@input?5conversion?5failed?5due?5to?5@
	push	6003					; 00001773H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH
$LN2@xmlCharEnc:

; 2362 : 		    "input conversion failed due to input error, bytes %s\n",
; 2363 : 		           buf);
; 2364 :         }
; 2365 :     }
; 2366 :     /*
; 2367 :      * Ignore when input buffer is not on a boundary
; 2368 :      */
; 2369 :     if (ret == -3)

	cmp	DWORD PTR _ret$[ebp], -3		; fffffffdH
	jne	SHORT $LN14@xmlCharEnc

; 2370 :         ret = 0;

	mov	DWORD PTR _ret$[ebp], 0
$LN14@xmlCharEnc:

; 2371 :     return (written? written : ret);

	cmp	DWORD PTR _written$[ebp], 0
	je	SHORT $LN16@xmlCharEnc
	mov	edx, DWORD PTR _written$[ebp]
	mov	DWORD PTR tv172[ebp], edx
	jmp	SHORT $LN17@xmlCharEnc
$LN16@xmlCharEnc:
	mov	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR tv172[ebp], eax
$LN17@xmlCharEnc:
	mov	eax, DWORD PTR tv172[ebp]
$LN1@xmlCharEnc:

; 2372 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@xmlCharEnc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@xmlCharEnc:
	DD	3
	DD	$LN21@xmlCharEnc
$LN21@xmlCharEnc:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN18@xmlCharEnc
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN19@xmlCharEnc
	DD	-84					; ffffffacH
	DD	50					; 00000032H
	DD	$LN20@xmlCharEnc
$LN20@xmlCharEnc:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN19@xmlCharEnc:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	118					; 00000076H
	DB	0
$LN18@xmlCharEnc:
	DB	119					; 00000077H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_xmlCharEncInFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCharEncOutFunc
_TEXT	SEGMENT
tv156 = -152						; size = 4
_buf$1 = -144						; size = 50
_charrefLen$2 = -88					; size = 4
_cur$3 = -84						; size = 4
_utf$4 = -80						; size = 4
_len$5 = -72						; size = 4
_charref$6 = -60					; size = 20
_output$ = -36						; size = 4
_toconv$ = -28						; size = 4
_writtentot$ = -20					; size = 4
_written$ = -12						; size = 4
_ret$ = -4						; size = 4
_handler$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_xmlCharEncOutFunc PROC					; COMDAT

; 2567 :                   xmlBufferPtr in) {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	edi
	lea	edi, DWORD PTR [ebp-152]
	mov	ecx, 38					; 00000026H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 2568 :     int ret;
; 2569 :     int written;
; 2570 :     int writtentot = 0;

	mov	DWORD PTR _writtentot$[ebp], 0

; 2571 :     int toconv;
; 2572 :     int output = 0;

	mov	DWORD PTR _output$[ebp], 0

; 2573 : 
; 2574 :     if (handler == NULL) return(-1);

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN4@xmlCharEnc
	or	eax, -1
	jmp	$LN1@xmlCharEnc
$LN4@xmlCharEnc:

; 2575 :     if (out == NULL) return(-1);

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $retry$31
	or	eax, -1
	jmp	$LN1@xmlCharEnc
$retry$31:

; 2576 : 
; 2577 : retry:
; 2578 : 
; 2579 :     written = out->size - out->use;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _written$[ebp], edx

; 2580 : 
; 2581 :     if (written > 0)

	cmp	DWORD PTR _written$[ebp], 0
	jle	SHORT $LN6@xmlCharEnc

; 2582 : 	written--; /* Gennady: count '/0' */

	mov	eax, DWORD PTR _written$[ebp]
	sub	eax, 1
	mov	DWORD PTR _written$[ebp], eax
$LN6@xmlCharEnc:

; 2583 : 
; 2584 :     /*
; 2585 :      * First specific handling of in = NULL, i.e. the initialization call
; 2586 :      */
; 2587 :     if (in == NULL) {

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN7@xmlCharEnc

; 2588 :         toconv = 0;

	mov	DWORD PTR _toconv$[ebp], 0

; 2589 :         /* TODO: Check return value. */
; 2590 :         xmlEncOutputChunk(handler, &out->content[out->use], &written,

	lea	ecx, DWORD PTR _toconv$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _written$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR [edx+4]
	push	ecx
	mov	eax, DWORD PTR _handler$[ebp]
	push	eax
	call	_xmlEncOutputChunk
	add	esp, 20					; 00000014H

; 2591 :                           NULL, &toconv);
; 2592 :         out->use += written;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _written$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+4], edx

; 2593 :         out->content[out->use] = 0;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+edx], 0

; 2594 : #ifdef DEBUG_ENCODING
; 2595 : 	xmlGenericError(xmlGenericErrorContext,
; 2596 : 		"initialized encoder\n");
; 2597 : #endif
; 2598 :         return(0);

	xor	eax, eax
	jmp	$LN1@xmlCharEnc
$LN7@xmlCharEnc:

; 2599 :     }
; 2600 : 
; 2601 :     /*
; 2602 :      * Conversion itself.
; 2603 :      */
; 2604 :     toconv = in->use;

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _toconv$[ebp], eax

; 2605 :     if (toconv == 0)

	cmp	DWORD PTR _toconv$[ebp], 0
	jne	SHORT $LN8@xmlCharEnc

; 2606 : 	return(0);

	xor	eax, eax
	jmp	$LN1@xmlCharEnc
$LN8@xmlCharEnc:

; 2607 :     if (toconv * 4 >= written) {

	mov	ecx, DWORD PTR _toconv$[ebp]
	shl	ecx, 2
	cmp	ecx, DWORD PTR _written$[ebp]
	jl	SHORT $LN9@xmlCharEnc

; 2608 :         xmlBufferGrow(out, toconv * 4);

	mov	edx, DWORD PTR _toconv$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_xmlBufferGrow
	add	esp, 8

; 2609 : 	written = out->size - out->use - 1;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	DWORD PTR _written$[ebp], eax
$LN9@xmlCharEnc:

; 2610 :     }
; 2611 :     ret = xmlEncOutputChunk(handler, &out->content[out->use], &written,

	lea	ecx, DWORD PTR _toconv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _written$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR [ecx+4]
	push	eax
	mov	edx, DWORD PTR _handler$[ebp]
	push	edx
	call	_xmlEncOutputChunk
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$[ebp], eax

; 2612 :                             in->content, &toconv);
; 2613 :     xmlBufferShrink(in, toconv);

	mov	eax, DWORD PTR _toconv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_xmlBufferShrink
	add	esp, 8

; 2614 :     out->use += written;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _written$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 2615 :     writtentot += written;

	mov	edx, DWORD PTR _writtentot$[ebp]
	add	edx, DWORD PTR _written$[ebp]
	mov	DWORD PTR _writtentot$[ebp], edx

; 2616 :     out->content[out->use] = 0;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+ecx], 0

; 2617 :     if (ret == -1) {

	cmp	DWORD PTR _ret$[ebp], -1
	jne	SHORT $LN10@xmlCharEnc

; 2618 :         if (written > 0) {

	cmp	DWORD PTR _written$[ebp], 0
	jle	SHORT $LN11@xmlCharEnc

; 2619 :             /* Can be a limitation of iconv or uconv */
; 2620 :             goto retry;

	jmp	$retry$31
$LN11@xmlCharEnc:

; 2621 :         }
; 2622 :         ret = -3;

	mov	DWORD PTR _ret$[ebp], -3		; fffffffdH
$LN10@xmlCharEnc:

; 2623 :     }
; 2624 : 
; 2625 :     if (ret >= 0) output += ret;

	cmp	DWORD PTR _ret$[ebp], 0
	jl	SHORT $LN12@xmlCharEnc
	mov	ecx, DWORD PTR _output$[ebp]
	add	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _output$[ebp], ecx
$LN12@xmlCharEnc:

; 2626 : 
; 2627 :     /*
; 2628 :      * Attempt to handle error cases
; 2629 :      */
; 2630 :     switch (ret) {

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR tv156[ebp], edx
	cmp	DWORD PTR tv156[ebp], -4		; fffffffcH
	je	SHORT $LN16@xmlCharEnc
	cmp	DWORD PTR tv156[ebp], -2		; fffffffeH
	je	SHORT $LN17@xmlCharEnc
	jmp	$LN2@xmlCharEnc

; 2631 :         case 0:
; 2632 : #ifdef DEBUG_ENCODING
; 2633 : 	    xmlGenericError(xmlGenericErrorContext,
; 2634 : 		    "converted %d bytes to %d bytes of output\n",
; 2635 : 	            toconv, written);
; 2636 : #endif
; 2637 : 	    break;

	jmp	$LN2@xmlCharEnc

; 2638 :         case -1:
; 2639 : #ifdef DEBUG_ENCODING
; 2640 : 	    xmlGenericError(xmlGenericErrorContext,
; 2641 : 		    "output conversion failed by lack of space\n");
; 2642 : #endif
; 2643 : 	    break;

	jmp	$LN2@xmlCharEnc

; 2644 :         case -3:
; 2645 : #ifdef DEBUG_ENCODING
; 2646 : 	    xmlGenericError(xmlGenericErrorContext,"converted %d bytes to %d bytes of output %d left\n",
; 2647 : 	            toconv, written, in->use);
; 2648 : #endif
; 2649 : 	    break;

	jmp	$LN2@xmlCharEnc
$LN16@xmlCharEnc:

; 2650 :         case -4:
; 2651 : 	    xmlEncodingErr(XML_I18N_NO_OUTPUT,

	push	0
	push	OFFSET ??_C@_0CJ@OOHAOGCN@xmlCharEncOutFunc?3?5no?5output?5fu@
	push	6004					; 00001774H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH

; 2652 : 		           "xmlCharEncOutFunc: no output function !\n", NULL);
; 2653 : 	    ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 2654 :             break;

	jmp	$LN2@xmlCharEnc
$LN17@xmlCharEnc:

; 2655 :         case -2: {
; 2656 : 	    xmlChar charref[20];
; 2657 : 	    int len = in->use;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _len$5[ebp], ecx

; 2658 : 	    const xmlChar *utf = (const xmlChar *) in->content;

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _utf$4[ebp], eax

; 2659 : 	    int cur, charrefLen;
; 2660 : 
; 2661 : 	    cur = xmlGetUTF8Char(utf, &len);

	lea	ecx, DWORD PTR _len$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf$4[ebp]
	push	edx
	call	_xmlGetUTF8Char
	add	esp, 8
	mov	DWORD PTR _cur$3[ebp], eax

; 2662 : 	    if (cur <= 0)

	cmp	DWORD PTR _cur$3[ebp], 0
	jg	SHORT $LN18@xmlCharEnc

; 2663 :                 break;

	jmp	$LN2@xmlCharEnc
$LN18@xmlCharEnc:

; 2664 : 
; 2665 : #ifdef DEBUG_ENCODING
; 2666 :             xmlGenericError(xmlGenericErrorContext,
; 2667 :                     "handling output conversion error\n");
; 2668 :             xmlGenericError(xmlGenericErrorContext,
; 2669 :                     "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
; 2670 :                     in->content[0], in->content[1],
; 2671 :                     in->content[2], in->content[3]);
; 2672 : #endif
; 2673 :             /*
; 2674 :              * Removes the UTF8 sequence, and replace it by a charref
; 2675 :              * and continue the transcoding phase, hoping the error
; 2676 :              * did not mangle the encoder state.
; 2677 :              */
; 2678 :             charrefLen = snprintf((char *) &charref[0], sizeof(charref),

	mov	eax, DWORD PTR _cur$3[ebp]
	push	eax
	push	OFFSET ??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL@
	push	20					; 00000014H
	mov	ecx, 1
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _charref$6[ebp+edx]
	push	eax
	call	_snprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _charrefLen$2[ebp], eax

; 2679 :                              "&#%d;", cur);
; 2680 :             xmlBufferShrink(in, len);

	mov	ecx, DWORD PTR _len$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_xmlBufferShrink
	add	esp, 8

; 2681 :             xmlBufferGrow(out, charrefLen * 4);

	mov	eax, DWORD PTR _charrefLen$2[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_xmlBufferGrow
	add	esp, 8

; 2682 : 	    written = out->size - out->use - 1;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	DWORD PTR _written$[ebp], ecx

; 2683 :             toconv = charrefLen;

	mov	edx, DWORD PTR _charrefLen$2[ebp]
	mov	DWORD PTR _toconv$[ebp], edx

; 2684 :             ret = xmlEncOutputChunk(handler, &out->content[out->use], &written,

	lea	eax, DWORD PTR _toconv$[ebp]
	push	eax
	lea	ecx, DWORD PTR _charref$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _written$[ebp]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR [edx+4]
	push	ecx
	mov	eax, DWORD PTR _handler$[ebp]
	push	eax
	call	_xmlEncOutputChunk
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$[ebp], eax

; 2685 :                                     charref, &toconv);
; 2686 : 
; 2687 : 	    if ((ret < 0) || (toconv != charrefLen)) {

	cmp	DWORD PTR _ret$[ebp], 0
	jl	SHORT $LN20@xmlCharEnc
	mov	ecx, DWORD PTR _toconv$[ebp]
	cmp	ecx, DWORD PTR _charrefLen$2[ebp]
	je	$LN19@xmlCharEnc
$LN20@xmlCharEnc:

; 2688 : 		char buf[50];
; 2689 : 
; 2690 : 		snprintf(&buf[0], 49, "0x%02X 0x%02X 0x%02X 0x%02X",

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+eax]
	push	eax
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+ecx]
	push	ecx
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+edx]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+ecx]
	push	ecx
	push	OFFSET ??_C@_0BM@MJIHCMEN@0x?$CF02X?50x?$CF02X?50x?$CF02X?50x?$CF02X@
	push	49					; 00000031H
	mov	edx, 1
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _buf$1[ebp+eax]
	push	ecx
	call	_snprintf
	add	esp, 28					; 0000001cH

; 2691 : 			 in->content[0], in->content[1],
; 2692 : 			 in->content[2], in->content[3]);
; 2693 : 		buf[49] = 0;

	mov	edx, 1
	imul	eax, edx, 49
	mov	BYTE PTR _buf$1[ebp+eax], 0

; 2694 : 		xmlEncodingErr(XML_I18N_CONV_FAILED,

	lea	ecx, DWORD PTR _buf$1[ebp]
	push	ecx
	push	OFFSET ??_C@_0DG@MDDGIHO@output?5conversion?5failed?5due?5to@
	push	6003					; 00001773H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH

; 2695 : 		    "output conversion failed due to conv error, bytes %s\n",
; 2696 : 			       buf);
; 2697 : 		if (in->alloc != XML_BUFFER_ALLOC_IMMUTABLE)

	mov	edx, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [edx+12], 2
	je	SHORT $LN21@xmlCharEnc

; 2698 : 		    in->content[0] = ' ';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [ecx+eax], 32			; 00000020H
$LN21@xmlCharEnc:

; 2699 : 	        break;

	jmp	SHORT $LN2@xmlCharEnc
$LN19@xmlCharEnc:

; 2700 : 	    }
; 2701 : 
; 2702 :             out->use += written;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _written$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+4], edx

; 2703 :             writtentot += written;

	mov	ecx, DWORD PTR _writtentot$[ebp]
	add	ecx, DWORD PTR _written$[ebp]
	mov	DWORD PTR _writtentot$[ebp], ecx

; 2704 :             out->content[out->use] = 0;

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+eax], 0

; 2705 :             goto retry;

	jmp	$retry$31
$LN2@xmlCharEnc:

; 2706 : 	}
; 2707 :     }
; 2708 :     return(ret);

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@xmlCharEnc:

; 2709 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@xmlCharEnc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 152				; 00000098H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN30@xmlCharEnc:
	DD	5
	DD	$LN29@xmlCharEnc
$LN29@xmlCharEnc:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN24@xmlCharEnc
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN25@xmlCharEnc
	DD	-60					; ffffffc4H
	DD	20					; 00000014H
	DD	$LN26@xmlCharEnc
	DD	-72					; ffffffb8H
	DD	4
	DD	$LN27@xmlCharEnc
	DD	-144					; ffffff70H
	DD	50					; 00000032H
	DD	$LN28@xmlCharEnc
$LN28@xmlCharEnc:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN27@xmlCharEnc:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN26@xmlCharEnc:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	0
$LN25@xmlCharEnc:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	118					; 00000076H
	DB	0
$LN24@xmlCharEnc:
	DB	119					; 00000077H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_xmlCharEncOutFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlDetectCharEncoding
_TEXT	SEGMENT
_in$ = 8						; size = 4
_len$ = 12						; size = 4
_xmlDetectCharEncoding PROC				; COMDAT

; 933  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 934  :     if (in == NULL)

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN2@xmlDetectC

; 935  :         return(XML_CHAR_ENCODING_NONE);

	xor	eax, eax
	jmp	$LN1@xmlDetectC
$LN2@xmlDetectC:

; 936  :     if (len >= 4) {

	cmp	DWORD PTR _len$[ebp], 4
	jl	$LN3@xmlDetectC

; 937  : 	if ((in[0] == 0x00) && (in[1] == 0x00) &&
; 938  : 	    (in[2] == 0x00) && (in[3] == 0x3C))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN4@xmlDetectC
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN4@xmlDetectC
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN4@xmlDetectC
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN4@xmlDetectC

; 939  : 	    return(XML_CHAR_ENCODING_UCS4BE);

	mov	eax, 5
	jmp	$LN1@xmlDetectC
$LN4@xmlDetectC:

; 940  : 	if ((in[0] == 0x3C) && (in[1] == 0x00) &&
; 941  : 	    (in[2] == 0x00) && (in[3] == 0x00))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 60					; 0000003cH
	jne	SHORT $LN5@xmlDetectC
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN5@xmlDetectC
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN5@xmlDetectC
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN5@xmlDetectC

; 942  : 	    return(XML_CHAR_ENCODING_UCS4LE);

	mov	eax, 4
	jmp	$LN1@xmlDetectC
$LN5@xmlDetectC:

; 943  : 	if ((in[0] == 0x00) && (in[1] == 0x00) &&
; 944  : 	    (in[2] == 0x3C) && (in[3] == 0x00))

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN6@xmlDetectC
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN6@xmlDetectC
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN6@xmlDetectC
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN6@xmlDetectC

; 945  : 	    return(XML_CHAR_ENCODING_UCS4_2143);

	mov	eax, 7
	jmp	$LN1@xmlDetectC
$LN6@xmlDetectC:

; 946  : 	if ((in[0] == 0x00) && (in[1] == 0x3C) &&
; 947  : 	    (in[2] == 0x00) && (in[3] == 0x00))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN7@xmlDetectC
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN7@xmlDetectC
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN7@xmlDetectC
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN7@xmlDetectC

; 948  : 	    return(XML_CHAR_ENCODING_UCS4_3412);

	mov	eax, 8
	jmp	$LN1@xmlDetectC
$LN7@xmlDetectC:

; 949  : 	if ((in[0] == 0x4C) && (in[1] == 0x6F) &&
; 950  : 	    (in[2] == 0xA7) && (in[3] == 0x94))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 76					; 0000004cH
	jne	SHORT $LN8@xmlDetectC
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 111				; 0000006fH
	jne	SHORT $LN8@xmlDetectC
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 167				; 000000a7H
	jne	SHORT $LN8@xmlDetectC
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 148				; 00000094H
	jne	SHORT $LN8@xmlDetectC

; 951  : 	    return(XML_CHAR_ENCODING_EBCDIC);

	mov	eax, 6
	jmp	$LN1@xmlDetectC
$LN8@xmlDetectC:

; 952  : 	if ((in[0] == 0x3C) && (in[1] == 0x3F) &&
; 953  : 	    (in[2] == 0x78) && (in[3] == 0x6D))

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN9@xmlDetectC
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 63					; 0000003fH
	jne	SHORT $LN9@xmlDetectC
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 120				; 00000078H
	jne	SHORT $LN9@xmlDetectC
	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 109				; 0000006dH
	jne	SHORT $LN9@xmlDetectC

; 954  : 	    return(XML_CHAR_ENCODING_UTF8);

	mov	eax, 1
	jmp	$LN1@xmlDetectC
$LN9@xmlDetectC:

; 955  : 	/*
; 956  : 	 * Although not part of the recommendation, we also
; 957  : 	 * attempt an "auto-recognition" of UTF-16LE and
; 958  : 	 * UTF-16BE encodings.
; 959  : 	 */
; 960  : 	if ((in[0] == 0x3C) && (in[1] == 0x00) &&
; 961  : 	    (in[2] == 0x3F) && (in[3] == 0x00))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 60					; 0000003cH
	jne	SHORT $LN10@xmlDetectC
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN10@xmlDetectC
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN10@xmlDetectC
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN10@xmlDetectC

; 962  : 	    return(XML_CHAR_ENCODING_UTF16LE);

	mov	eax, 2
	jmp	$LN1@xmlDetectC
$LN10@xmlDetectC:

; 963  : 	if ((in[0] == 0x00) && (in[1] == 0x3C) &&
; 964  : 	    (in[2] == 0x00) && (in[3] == 0x3F))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN3@xmlDetectC
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 60					; 0000003cH
	jne	SHORT $LN3@xmlDetectC
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN3@xmlDetectC
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN3@xmlDetectC

; 965  : 	    return(XML_CHAR_ENCODING_UTF16BE);

	mov	eax, 3
	jmp	$LN1@xmlDetectC
$LN3@xmlDetectC:

; 966  :     }
; 967  :     if (len >= 3) {

	cmp	DWORD PTR _len$[ebp], 3
	jl	SHORT $LN12@xmlDetectC

; 968  : 	/*
; 969  : 	 * Errata on XML-1.0 June 20 2001
; 970  : 	 * We now allow an UTF8 encoded BOM
; 971  : 	 */
; 972  : 	if ((in[0] == 0xEF) && (in[1] == 0xBB) &&

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 239				; 000000efH
	jne	SHORT $LN12@xmlDetectC
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 187				; 000000bbH
	jne	SHORT $LN12@xmlDetectC
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 191				; 000000bfH
	jne	SHORT $LN12@xmlDetectC

; 973  : 	    (in[2] == 0xBF))
; 974  : 	    return(XML_CHAR_ENCODING_UTF8);

	mov	eax, 1
	jmp	SHORT $LN1@xmlDetectC
$LN12@xmlDetectC:

; 975  :     }
; 976  :     /* For UTF-16 we can recognize by the BOM */
; 977  :     if (len >= 2) {

	cmp	DWORD PTR _len$[ebp], 2
	jl	SHORT $LN14@xmlDetectC

; 978  : 	if ((in[0] == 0xFE) && (in[1] == 0xFF))

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 254				; 000000feH
	jne	SHORT $LN15@xmlDetectC
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN15@xmlDetectC

; 979  : 	    return(XML_CHAR_ENCODING_UTF16BE);

	mov	eax, 3
	jmp	SHORT $LN1@xmlDetectC
$LN15@xmlDetectC:

; 980  : 	if ((in[0] == 0xFF) && (in[1] == 0xFE))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN14@xmlDetectC
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 254				; 000000feH
	jne	SHORT $LN14@xmlDetectC

; 981  : 	    return(XML_CHAR_ENCODING_UTF16LE);

	mov	eax, 2
	jmp	SHORT $LN1@xmlDetectC
$LN14@xmlDetectC:

; 982  :     }
; 983  :     return(XML_CHAR_ENCODING_NONE);

	xor	eax, eax
$LN1@xmlDetectC:

; 984  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlDetectCharEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlGetCharEncodingName
_TEXT	SEGMENT
tv64 = -4						; size = 4
_enc$ = 8						; size = 4
_xmlGetCharEncodingName PROC				; COMDAT

; 1234 : xmlGetCharEncodingName(xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1235 :     switch (enc) {

	mov	eax, DWORD PTR _enc$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	add	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 23			; 00000017H
	ja	$LN2@xmlGetChar
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN29@xmlGetChar[edx*4]
$LN4@xmlGetChar:

; 1236 :         case XML_CHAR_ENCODING_ERROR:
; 1237 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlGetChar
$LN5@xmlGetChar:

; 1238 :         case XML_CHAR_ENCODING_NONE:
; 1239 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlGetChar
$LN6@xmlGetChar:

; 1240 :         case XML_CHAR_ENCODING_UTF8:
; 1241 : 	    return("UTF-8");

	mov	eax, OFFSET ??_C@_05EGJIMALK@UTF?98@
	jmp	$LN1@xmlGetChar
$LN7@xmlGetChar:

; 1242 :         case XML_CHAR_ENCODING_UTF16LE:
; 1243 : 	    return("UTF-16");

	mov	eax, OFFSET ??_C@_06KNDPGIKI@UTF?916@
	jmp	$LN1@xmlGetChar
$LN8@xmlGetChar:

; 1244 :         case XML_CHAR_ENCODING_UTF16BE:
; 1245 : 	    return("UTF-16");

	mov	eax, OFFSET ??_C@_06KNDPGIKI@UTF?916@
	jmp	$LN1@xmlGetChar
$LN9@xmlGetChar:

; 1246 :         case XML_CHAR_ENCODING_EBCDIC:
; 1247 :             return("EBCDIC");

	mov	eax, OFFSET ??_C@_06JJAKJGEC@EBCDIC@
	jmp	SHORT $LN1@xmlGetChar
$LN10@xmlGetChar:

; 1248 :         case XML_CHAR_ENCODING_UCS4LE:
; 1249 :             return("ISO-10646-UCS-4");

	mov	eax, OFFSET ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@
	jmp	SHORT $LN1@xmlGetChar
$LN11@xmlGetChar:

; 1250 :         case XML_CHAR_ENCODING_UCS4BE:
; 1251 :             return("ISO-10646-UCS-4");

	mov	eax, OFFSET ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@
	jmp	SHORT $LN1@xmlGetChar
$LN12@xmlGetChar:

; 1252 :         case XML_CHAR_ENCODING_UCS4_2143:
; 1253 :             return("ISO-10646-UCS-4");

	mov	eax, OFFSET ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@
	jmp	SHORT $LN1@xmlGetChar
$LN13@xmlGetChar:

; 1254 :         case XML_CHAR_ENCODING_UCS4_3412:
; 1255 :             return("ISO-10646-UCS-4");

	mov	eax, OFFSET ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@
	jmp	SHORT $LN1@xmlGetChar
$LN14@xmlGetChar:

; 1256 :         case XML_CHAR_ENCODING_UCS2:
; 1257 :             return("ISO-10646-UCS-2");

	mov	eax, OFFSET ??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@
	jmp	SHORT $LN1@xmlGetChar
$LN15@xmlGetChar:

; 1258 :         case XML_CHAR_ENCODING_8859_1:
; 1259 : 	    return("ISO-8859-1");

	mov	eax, OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@
	jmp	SHORT $LN1@xmlGetChar
$LN16@xmlGetChar:

; 1260 :         case XML_CHAR_ENCODING_8859_2:
; 1261 : 	    return("ISO-8859-2");

	mov	eax, OFFSET ??_C@_0L@ECKEIAIJ@ISO?98859?92@
	jmp	SHORT $LN1@xmlGetChar
$LN17@xmlGetChar:

; 1262 :         case XML_CHAR_ENCODING_8859_3:
; 1263 : 	    return("ISO-8859-3");

	mov	eax, OFFSET ??_C@_0L@FLLPLBMI@ISO?98859?93@
	jmp	SHORT $LN1@xmlGetChar
$LN18@xmlGetChar:

; 1264 :         case XML_CHAR_ENCODING_8859_4:
; 1265 : 	    return("ISO-8859-4");

	mov	eax, OFFSET ??_C@_0L@BEPOCHAP@ISO?98859?94@
	jmp	SHORT $LN1@xmlGetChar
$LN19@xmlGetChar:

; 1266 :         case XML_CHAR_ENCODING_8859_5:
; 1267 : 	    return("ISO-8859-5");

	mov	eax, OFFSET ??_C@_0L@NOFBGEO@ISO?98859?95@
	jmp	SHORT $LN1@xmlGetChar
$LN20@xmlGetChar:

; 1268 :         case XML_CHAR_ENCODING_8859_6:
; 1269 : 	    return("ISO-8859-6");

	mov	eax, OFFSET ??_C@_0L@CGMIEFIN@ISO?98859?96@
	jmp	SHORT $LN1@xmlGetChar
$LN21@xmlGetChar:

; 1270 :         case XML_CHAR_ENCODING_8859_7:
; 1271 : 	    return("ISO-8859-7");

	mov	eax, OFFSET ??_C@_0L@DPNDHEMM@ISO?98859?97@
	jmp	SHORT $LN1@xmlGetChar
$LN22@xmlGetChar:

; 1272 :         case XML_CHAR_ENCODING_8859_8:
; 1273 : 	    return("ISO-8859-8");

	mov	eax, OFFSET ??_C@_0L@LIELGIAD@ISO?98859?98@
	jmp	SHORT $LN1@xmlGetChar
$LN23@xmlGetChar:

; 1274 :         case XML_CHAR_ENCODING_8859_9:
; 1275 : 	    return("ISO-8859-9");

	mov	eax, OFFSET ??_C@_0L@KBFAFJEC@ISO?98859?99@
	jmp	SHORT $LN1@xmlGetChar
$LN24@xmlGetChar:

; 1276 :         case XML_CHAR_ENCODING_2022_JP:
; 1277 :             return("ISO-2022-JP");

	mov	eax, OFFSET ??_C@_0M@LMIFKILO@ISO?92022?9JP@
	jmp	SHORT $LN1@xmlGetChar
$LN25@xmlGetChar:

; 1278 :         case XML_CHAR_ENCODING_SHIFT_JIS:
; 1279 :             return("Shift-JIS");

	mov	eax, OFFSET ??_C@_09DNLJOPNC@Shift?9JIS@
	jmp	SHORT $LN1@xmlGetChar
$LN26@xmlGetChar:

; 1280 :         case XML_CHAR_ENCODING_EUC_JP:
; 1281 :             return("EUC-JP");

	mov	eax, OFFSET ??_C@_06KCFOODCD@EUC?9JP@
	jmp	SHORT $LN1@xmlGetChar
$LN27@xmlGetChar:

; 1282 : 	case XML_CHAR_ENCODING_ASCII:
; 1283 : 	    return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlGetChar
$LN2@xmlGetChar:

; 1284 :     }
; 1285 :     return(NULL);

	xor	eax, eax
$LN1@xmlGetChar:

; 1286 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN29@xmlGetChar:
	DD	$LN4@xmlGetChar
	DD	$LN5@xmlGetChar
	DD	$LN6@xmlGetChar
	DD	$LN7@xmlGetChar
	DD	$LN8@xmlGetChar
	DD	$LN10@xmlGetChar
	DD	$LN11@xmlGetChar
	DD	$LN9@xmlGetChar
	DD	$LN12@xmlGetChar
	DD	$LN13@xmlGetChar
	DD	$LN14@xmlGetChar
	DD	$LN15@xmlGetChar
	DD	$LN16@xmlGetChar
	DD	$LN17@xmlGetChar
	DD	$LN18@xmlGetChar
	DD	$LN19@xmlGetChar
	DD	$LN20@xmlGetChar
	DD	$LN21@xmlGetChar
	DD	$LN22@xmlGetChar
	DD	$LN23@xmlGetChar
	DD	$LN24@xmlGetChar
	DD	$LN25@xmlGetChar
	DD	$LN26@xmlGetChar
	DD	$LN27@xmlGetChar
_xmlGetCharEncodingName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlParseCharEncoding
_TEXT	SEGMENT
tv249 = -1056						; size = 4
tv854 = -1052						; size = 4
tv849 = -1046						; size = 1
tv842 = -1045						; size = 1
tv837 = -1044						; size = 4
tv839 = -1040						; size = 4
tv244 = -1036						; size = 4
tv832 = -1032						; size = 4
tv827 = -1026						; size = 1
tv820 = -1025						; size = 1
tv815 = -1024						; size = 4
tv817 = -1020						; size = 4
tv239 = -1016						; size = 4
tv810 = -1012						; size = 4
tv805 = -1006						; size = 1
tv798 = -1005						; size = 1
tv793 = -1004						; size = 4
tv795 = -1000						; size = 4
tv234 = -996						; size = 4
tv788 = -992						; size = 4
tv783 = -986						; size = 1
tv776 = -985						; size = 1
tv771 = -984						; size = 4
tv773 = -980						; size = 4
tv229 = -976						; size = 4
tv766 = -972						; size = 4
tv761 = -966						; size = 1
tv754 = -965						; size = 1
tv749 = -964						; size = 4
tv751 = -960						; size = 4
tv224 = -956						; size = 4
tv744 = -952						; size = 4
tv739 = -946						; size = 1
tv732 = -945						; size = 1
tv727 = -944						; size = 4
tv729 = -940						; size = 4
tv219 = -936						; size = 4
tv722 = -932						; size = 4
tv717 = -926						; size = 1
tv710 = -925						; size = 1
tv705 = -924						; size = 4
tv707 = -920						; size = 4
tv214 = -916						; size = 4
tv700 = -912						; size = 4
tv695 = -906						; size = 1
tv688 = -905						; size = 1
tv683 = -904						; size = 4
tv685 = -900						; size = 4
tv209 = -896						; size = 4
tv678 = -892						; size = 4
tv673 = -886						; size = 1
tv666 = -885						; size = 1
tv661 = -884						; size = 4
tv663 = -880						; size = 4
tv204 = -876						; size = 4
tv656 = -872						; size = 4
tv651 = -866						; size = 1
tv644 = -865						; size = 1
tv639 = -864						; size = 4
tv641 = -860						; size = 4
tv199 = -856						; size = 4
tv634 = -852						; size = 4
tv629 = -846						; size = 1
tv622 = -845						; size = 1
tv617 = -844						; size = 4
tv619 = -840						; size = 4
tv194 = -836						; size = 4
tv612 = -832						; size = 4
tv607 = -826						; size = 1
tv600 = -825						; size = 1
tv595 = -824						; size = 4
tv597 = -820						; size = 4
tv189 = -816						; size = 4
tv590 = -812						; size = 4
tv585 = -806						; size = 1
tv578 = -805						; size = 1
tv573 = -804						; size = 4
tv575 = -800						; size = 4
tv184 = -796						; size = 4
tv568 = -792						; size = 4
tv563 = -786						; size = 1
tv556 = -785						; size = 1
tv551 = -784						; size = 4
tv553 = -780						; size = 4
tv179 = -776						; size = 4
tv546 = -772						; size = 4
tv541 = -766						; size = 1
tv534 = -765						; size = 1
tv529 = -764						; size = 4
tv531 = -760						; size = 4
tv174 = -756						; size = 4
tv524 = -752						; size = 4
tv519 = -746						; size = 1
tv512 = -745						; size = 1
tv507 = -744						; size = 4
tv509 = -740						; size = 4
tv169 = -736						; size = 4
tv502 = -732						; size = 4
tv497 = -726						; size = 1
tv490 = -725						; size = 1
tv485 = -724						; size = 4
tv487 = -720						; size = 4
tv164 = -716						; size = 4
tv480 = -712						; size = 4
tv475 = -706						; size = 1
tv468 = -705						; size = 1
tv463 = -704						; size = 4
tv465 = -700						; size = 4
tv159 = -696						; size = 4
tv458 = -692						; size = 4
tv453 = -686						; size = 1
tv446 = -685						; size = 1
tv441 = -684						; size = 4
tv443 = -680						; size = 4
tv154 = -676						; size = 4
tv436 = -672						; size = 4
tv431 = -666						; size = 1
tv424 = -665						; size = 1
tv419 = -664						; size = 4
tv421 = -660						; size = 4
tv149 = -656						; size = 4
tv414 = -652						; size = 4
tv409 = -646						; size = 1
tv402 = -645						; size = 1
tv397 = -644						; size = 4
tv399 = -640						; size = 4
tv144 = -636						; size = 4
tv392 = -632						; size = 4
tv387 = -626						; size = 1
tv380 = -625						; size = 1
tv375 = -624						; size = 4
tv377 = -620						; size = 4
tv139 = -616						; size = 4
tv370 = -612						; size = 4
tv365 = -606						; size = 1
tv358 = -605						; size = 1
tv353 = -604						; size = 4
tv355 = -600						; size = 4
tv134 = -596						; size = 4
tv348 = -592						; size = 4
tv343 = -586						; size = 1
tv336 = -585						; size = 1
tv331 = -584						; size = 4
tv333 = -580						; size = 4
tv129 = -576						; size = 4
tv326 = -572						; size = 4
tv321 = -566						; size = 1
tv314 = -565						; size = 1
tv309 = -564						; size = 4
tv311 = -560						; size = 4
tv92 = -556						; size = 4
tv304 = -552						; size = 4
tv299 = -546						; size = 1
tv292 = -545						; size = 1
tv287 = -544						; size = 4
tv289 = -540						; size = 4
tv87 = -536						; size = 4
tv282 = -532						; size = 4
tv277 = -526						; size = 1
tv270 = -525						; size = 1
tv265 = -524						; size = 4
tv267 = -520						; size = 4
_i$ = -516						; size = 4
_upper$ = -508						; size = 500
_alias$ = -4						; size = 4
_name$ = 8						; size = 4
_xmlParseCharEncoding PROC				; COMDAT

; 1151 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1056				; 00000420H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1056]
	mov	ecx, 264				; 00000108H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1152 :     const char *alias;
; 1153 :     char upper[500];
; 1154 :     int i;
; 1155 : 
; 1156 :     if (name == NULL)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN5@xmlParseCh

; 1157 : 	return(XML_CHAR_ENCODING_NONE);

	xor	eax, eax
	jmp	$LN1@xmlParseCh
$LN5@xmlParseCh:

; 1158 : 
; 1159 :     /*
; 1160 :      * Do the alias resolution
; 1161 :      */
; 1162 :     alias = xmlGetEncodingAlias(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlGetEncodingAlias
	add	esp, 4
	mov	DWORD PTR _alias$[ebp], eax

; 1163 :     if (alias != NULL)

	cmp	DWORD PTR _alias$[ebp], 0
	je	SHORT $LN6@xmlParseCh

; 1164 : 	name = alias;

	mov	ecx, DWORD PTR _alias$[ebp]
	mov	DWORD PTR _name$[ebp], ecx
$LN6@xmlParseCh:

; 1165 : 
; 1166 :     for (i = 0;i < 499;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlParseCh
$LN2@xmlParseCh:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@xmlParseCh:
	cmp	DWORD PTR _i$[ebp], 499			; 000001f3H
	jge	SHORT $LN3@xmlParseCh

; 1167 :         upper[i] = toupper(name[i]);

	mov	eax, DWORD PTR _name$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _upper$[ebp+edx], al

; 1168 : 	if (upper[i] == 0) break;

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _upper$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN7@xmlParseCh
	jmp	SHORT $LN3@xmlParseCh
$LN7@xmlParseCh:

; 1169 :     }

	jmp	SHORT $LN2@xmlParseCh
$LN3@xmlParseCh:

; 1170 :     upper[i] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _upper$[ebp+edx], 0

; 1171 : 
; 1172 :     if (!strcmp(upper, "")) return(XML_CHAR_ENCODING_NONE);

	mov	DWORD PTR tv267[ebp], OFFSET ??_C@_00CNPNBAHC@@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv265[ebp], eax
$LL36@xmlParseCh:
	mov	ecx, DWORD PTR tv265[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv270[ebp], dl
	mov	eax, DWORD PTR tv267[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN37@xmlParseCh
	cmp	BYTE PTR tv270[ebp], 0
	je	SHORT $LN38@xmlParseCh
	mov	ecx, DWORD PTR tv265[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv277[ebp], dl
	mov	eax, DWORD PTR tv267[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN37@xmlParseCh
	add	DWORD PTR tv265[ebp], 2
	add	DWORD PTR tv267[ebp], 2
	cmp	BYTE PTR tv277[ebp], 0
	jne	SHORT $LL36@xmlParseCh
$LN38@xmlParseCh:
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN39@xmlParseCh
$LN37@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv282[ebp], ecx
$LN39@xmlParseCh:
	mov	edx, DWORD PTR tv282[ebp]
	mov	DWORD PTR tv87[ebp], edx
	cmp	DWORD PTR tv87[ebp], 0
	jne	SHORT $LN8@xmlParseCh
	xor	eax, eax
	jmp	$LN1@xmlParseCh
$LN8@xmlParseCh:

; 1173 :     if (!strcmp(upper, "UTF-8")) return(XML_CHAR_ENCODING_UTF8);

	mov	DWORD PTR tv289[ebp], OFFSET ??_C@_05EGJIMALK@UTF?98@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv287[ebp], eax
$LL40@xmlParseCh:
	mov	ecx, DWORD PTR tv287[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv292[ebp], dl
	mov	eax, DWORD PTR tv289[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN41@xmlParseCh
	cmp	BYTE PTR tv292[ebp], 0
	je	SHORT $LN42@xmlParseCh
	mov	ecx, DWORD PTR tv287[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv299[ebp], dl
	mov	eax, DWORD PTR tv289[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN41@xmlParseCh
	add	DWORD PTR tv287[ebp], 2
	add	DWORD PTR tv289[ebp], 2
	cmp	BYTE PTR tv299[ebp], 0
	jne	SHORT $LL40@xmlParseCh
$LN42@xmlParseCh:
	mov	DWORD PTR tv304[ebp], 0
	jmp	SHORT $LN43@xmlParseCh
$LN41@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv304[ebp], ecx
$LN43@xmlParseCh:
	mov	edx, DWORD PTR tv304[ebp]
	mov	DWORD PTR tv92[ebp], edx
	cmp	DWORD PTR tv92[ebp], 0
	jne	SHORT $LN9@xmlParseCh
	mov	eax, 1
	jmp	$LN1@xmlParseCh
$LN9@xmlParseCh:

; 1174 :     if (!strcmp(upper, "UTF8")) return(XML_CHAR_ENCODING_UTF8);

	mov	DWORD PTR tv311[ebp], OFFSET ??_C@_04OOMJJNCF@UTF8@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv309[ebp], eax
$LL44@xmlParseCh:
	mov	ecx, DWORD PTR tv309[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv314[ebp], dl
	mov	eax, DWORD PTR tv311[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN45@xmlParseCh
	cmp	BYTE PTR tv314[ebp], 0
	je	SHORT $LN46@xmlParseCh
	mov	ecx, DWORD PTR tv309[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv321[ebp], dl
	mov	eax, DWORD PTR tv311[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN45@xmlParseCh
	add	DWORD PTR tv309[ebp], 2
	add	DWORD PTR tv311[ebp], 2
	cmp	BYTE PTR tv321[ebp], 0
	jne	SHORT $LL44@xmlParseCh
$LN46@xmlParseCh:
	mov	DWORD PTR tv326[ebp], 0
	jmp	SHORT $LN47@xmlParseCh
$LN45@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv326[ebp], ecx
$LN47@xmlParseCh:
	mov	edx, DWORD PTR tv326[ebp]
	mov	DWORD PTR tv129[ebp], edx
	cmp	DWORD PTR tv129[ebp], 0
	jne	SHORT $LN10@xmlParseCh
	mov	eax, 1
	jmp	$LN1@xmlParseCh
$LN10@xmlParseCh:

; 1175 : 
; 1176 :     /*
; 1177 :      * NOTE: if we were able to parse this, the endianness of UTF16 is
; 1178 :      *       already found and in use
; 1179 :      */
; 1180 :     if (!strcmp(upper, "UTF-16")) return(XML_CHAR_ENCODING_UTF16LE);

	mov	DWORD PTR tv333[ebp], OFFSET ??_C@_06KNDPGIKI@UTF?916@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv331[ebp], eax
$LL48@xmlParseCh:
	mov	ecx, DWORD PTR tv331[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv336[ebp], dl
	mov	eax, DWORD PTR tv333[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN49@xmlParseCh
	cmp	BYTE PTR tv336[ebp], 0
	je	SHORT $LN50@xmlParseCh
	mov	ecx, DWORD PTR tv331[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv343[ebp], dl
	mov	eax, DWORD PTR tv333[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN49@xmlParseCh
	add	DWORD PTR tv331[ebp], 2
	add	DWORD PTR tv333[ebp], 2
	cmp	BYTE PTR tv343[ebp], 0
	jne	SHORT $LL48@xmlParseCh
$LN50@xmlParseCh:
	mov	DWORD PTR tv348[ebp], 0
	jmp	SHORT $LN51@xmlParseCh
$LN49@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv348[ebp], ecx
$LN51@xmlParseCh:
	mov	edx, DWORD PTR tv348[ebp]
	mov	DWORD PTR tv134[ebp], edx
	cmp	DWORD PTR tv134[ebp], 0
	jne	SHORT $LN11@xmlParseCh
	mov	eax, 2
	jmp	$LN1@xmlParseCh
$LN11@xmlParseCh:

; 1181 :     if (!strcmp(upper, "UTF16")) return(XML_CHAR_ENCODING_UTF16LE);

	mov	DWORD PTR tv355[ebp], OFFSET ??_C@_05MNCHLHCA@UTF16@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv353[ebp], eax
$LL52@xmlParseCh:
	mov	ecx, DWORD PTR tv353[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv358[ebp], dl
	mov	eax, DWORD PTR tv355[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN53@xmlParseCh
	cmp	BYTE PTR tv358[ebp], 0
	je	SHORT $LN54@xmlParseCh
	mov	ecx, DWORD PTR tv353[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv365[ebp], dl
	mov	eax, DWORD PTR tv355[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN53@xmlParseCh
	add	DWORD PTR tv353[ebp], 2
	add	DWORD PTR tv355[ebp], 2
	cmp	BYTE PTR tv365[ebp], 0
	jne	SHORT $LL52@xmlParseCh
$LN54@xmlParseCh:
	mov	DWORD PTR tv370[ebp], 0
	jmp	SHORT $LN55@xmlParseCh
$LN53@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv370[ebp], ecx
$LN55@xmlParseCh:
	mov	edx, DWORD PTR tv370[ebp]
	mov	DWORD PTR tv139[ebp], edx
	cmp	DWORD PTR tv139[ebp], 0
	jne	SHORT $LN12@xmlParseCh
	mov	eax, 2
	jmp	$LN1@xmlParseCh
$LN12@xmlParseCh:

; 1182 : 
; 1183 :     if (!strcmp(upper, "ISO-10646-UCS-2")) return(XML_CHAR_ENCODING_UCS2);

	mov	DWORD PTR tv377[ebp], OFFSET ??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv375[ebp], eax
$LL56@xmlParseCh:
	mov	ecx, DWORD PTR tv375[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv380[ebp], dl
	mov	eax, DWORD PTR tv377[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN57@xmlParseCh
	cmp	BYTE PTR tv380[ebp], 0
	je	SHORT $LN58@xmlParseCh
	mov	ecx, DWORD PTR tv375[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv387[ebp], dl
	mov	eax, DWORD PTR tv377[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN57@xmlParseCh
	add	DWORD PTR tv375[ebp], 2
	add	DWORD PTR tv377[ebp], 2
	cmp	BYTE PTR tv387[ebp], 0
	jne	SHORT $LL56@xmlParseCh
$LN58@xmlParseCh:
	mov	DWORD PTR tv392[ebp], 0
	jmp	SHORT $LN59@xmlParseCh
$LN57@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv392[ebp], ecx
$LN59@xmlParseCh:
	mov	edx, DWORD PTR tv392[ebp]
	mov	DWORD PTR tv144[ebp], edx
	cmp	DWORD PTR tv144[ebp], 0
	jne	SHORT $LN13@xmlParseCh
	mov	eax, 9
	jmp	$LN1@xmlParseCh
$LN13@xmlParseCh:

; 1184 :     if (!strcmp(upper, "UCS-2")) return(XML_CHAR_ENCODING_UCS2);

	mov	DWORD PTR tv399[ebp], OFFSET ??_C@_05JHAMEAP@UCS?92@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv397[ebp], eax
$LL60@xmlParseCh:
	mov	ecx, DWORD PTR tv397[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv402[ebp], dl
	mov	eax, DWORD PTR tv399[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN61@xmlParseCh
	cmp	BYTE PTR tv402[ebp], 0
	je	SHORT $LN62@xmlParseCh
	mov	ecx, DWORD PTR tv397[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv409[ebp], dl
	mov	eax, DWORD PTR tv399[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN61@xmlParseCh
	add	DWORD PTR tv397[ebp], 2
	add	DWORD PTR tv399[ebp], 2
	cmp	BYTE PTR tv409[ebp], 0
	jne	SHORT $LL60@xmlParseCh
$LN62@xmlParseCh:
	mov	DWORD PTR tv414[ebp], 0
	jmp	SHORT $LN63@xmlParseCh
$LN61@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv414[ebp], ecx
$LN63@xmlParseCh:
	mov	edx, DWORD PTR tv414[ebp]
	mov	DWORD PTR tv149[ebp], edx
	cmp	DWORD PTR tv149[ebp], 0
	jne	SHORT $LN14@xmlParseCh
	mov	eax, 9
	jmp	$LN1@xmlParseCh
$LN14@xmlParseCh:

; 1185 :     if (!strcmp(upper, "UCS2")) return(XML_CHAR_ENCODING_UCS2);

	mov	DWORD PTR tv421[ebp], OFFSET ??_C@_04MDAFHLBC@UCS2@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv419[ebp], eax
$LL64@xmlParseCh:
	mov	ecx, DWORD PTR tv419[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv424[ebp], dl
	mov	eax, DWORD PTR tv421[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN65@xmlParseCh
	cmp	BYTE PTR tv424[ebp], 0
	je	SHORT $LN66@xmlParseCh
	mov	ecx, DWORD PTR tv419[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv431[ebp], dl
	mov	eax, DWORD PTR tv421[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN65@xmlParseCh
	add	DWORD PTR tv419[ebp], 2
	add	DWORD PTR tv421[ebp], 2
	cmp	BYTE PTR tv431[ebp], 0
	jne	SHORT $LL64@xmlParseCh
$LN66@xmlParseCh:
	mov	DWORD PTR tv436[ebp], 0
	jmp	SHORT $LN67@xmlParseCh
$LN65@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv436[ebp], ecx
$LN67@xmlParseCh:
	mov	edx, DWORD PTR tv436[ebp]
	mov	DWORD PTR tv154[ebp], edx
	cmp	DWORD PTR tv154[ebp], 0
	jne	SHORT $LN15@xmlParseCh
	mov	eax, 9
	jmp	$LN1@xmlParseCh
$LN15@xmlParseCh:

; 1186 : 
; 1187 :     /*
; 1188 :      * NOTE: if we were able to parse this, the endianness of UCS4 is
; 1189 :      *       already found and in use
; 1190 :      */
; 1191 :     if (!strcmp(upper, "ISO-10646-UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);

	mov	DWORD PTR tv443[ebp], OFFSET ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv441[ebp], eax
$LL68@xmlParseCh:
	mov	ecx, DWORD PTR tv441[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv446[ebp], dl
	mov	eax, DWORD PTR tv443[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN69@xmlParseCh
	cmp	BYTE PTR tv446[ebp], 0
	je	SHORT $LN70@xmlParseCh
	mov	ecx, DWORD PTR tv441[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv453[ebp], dl
	mov	eax, DWORD PTR tv443[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN69@xmlParseCh
	add	DWORD PTR tv441[ebp], 2
	add	DWORD PTR tv443[ebp], 2
	cmp	BYTE PTR tv453[ebp], 0
	jne	SHORT $LL68@xmlParseCh
$LN70@xmlParseCh:
	mov	DWORD PTR tv458[ebp], 0
	jmp	SHORT $LN71@xmlParseCh
$LN69@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv458[ebp], ecx
$LN71@xmlParseCh:
	mov	edx, DWORD PTR tv458[ebp]
	mov	DWORD PTR tv159[ebp], edx
	cmp	DWORD PTR tv159[ebp], 0
	jne	SHORT $LN16@xmlParseCh
	mov	eax, 4
	jmp	$LN1@xmlParseCh
$LN16@xmlParseCh:

; 1192 :     if (!strcmp(upper, "UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);

	mov	DWORD PTR tv465[ebp], OFFSET ??_C@_05FPCKGDIJ@UCS?94@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv463[ebp], eax
$LL72@xmlParseCh:
	mov	ecx, DWORD PTR tv463[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv468[ebp], dl
	mov	eax, DWORD PTR tv465[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN73@xmlParseCh
	cmp	BYTE PTR tv468[ebp], 0
	je	SHORT $LN74@xmlParseCh
	mov	ecx, DWORD PTR tv463[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv475[ebp], dl
	mov	eax, DWORD PTR tv465[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN73@xmlParseCh
	add	DWORD PTR tv463[ebp], 2
	add	DWORD PTR tv465[ebp], 2
	cmp	BYTE PTR tv475[ebp], 0
	jne	SHORT $LL72@xmlParseCh
$LN74@xmlParseCh:
	mov	DWORD PTR tv480[ebp], 0
	jmp	SHORT $LN75@xmlParseCh
$LN73@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv480[ebp], ecx
$LN75@xmlParseCh:
	mov	edx, DWORD PTR tv480[ebp]
	mov	DWORD PTR tv164[ebp], edx
	cmp	DWORD PTR tv164[ebp], 0
	jne	SHORT $LN17@xmlParseCh
	mov	eax, 4
	jmp	$LN1@xmlParseCh
$LN17@xmlParseCh:

; 1193 :     if (!strcmp(upper, "UCS4")) return(XML_CHAR_ENCODING_UCS4LE);

	mov	DWORD PTR tv487[ebp], OFFSET ??_C@_04JFFPNMJE@UCS4@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv485[ebp], eax
$LL76@xmlParseCh:
	mov	ecx, DWORD PTR tv485[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv490[ebp], dl
	mov	eax, DWORD PTR tv487[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN77@xmlParseCh
	cmp	BYTE PTR tv490[ebp], 0
	je	SHORT $LN78@xmlParseCh
	mov	ecx, DWORD PTR tv485[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv497[ebp], dl
	mov	eax, DWORD PTR tv487[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN77@xmlParseCh
	add	DWORD PTR tv485[ebp], 2
	add	DWORD PTR tv487[ebp], 2
	cmp	BYTE PTR tv497[ebp], 0
	jne	SHORT $LL76@xmlParseCh
$LN78@xmlParseCh:
	mov	DWORD PTR tv502[ebp], 0
	jmp	SHORT $LN79@xmlParseCh
$LN77@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv502[ebp], ecx
$LN79@xmlParseCh:
	mov	edx, DWORD PTR tv502[ebp]
	mov	DWORD PTR tv169[ebp], edx
	cmp	DWORD PTR tv169[ebp], 0
	jne	SHORT $LN18@xmlParseCh
	mov	eax, 4
	jmp	$LN1@xmlParseCh
$LN18@xmlParseCh:

; 1194 : 
; 1195 : 
; 1196 :     if (!strcmp(upper,  "ISO-8859-1")) return(XML_CHAR_ENCODING_8859_1);

	mov	DWORD PTR tv509[ebp], OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv507[ebp], eax
$LL80@xmlParseCh:
	mov	ecx, DWORD PTR tv507[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv512[ebp], dl
	mov	eax, DWORD PTR tv509[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN81@xmlParseCh
	cmp	BYTE PTR tv512[ebp], 0
	je	SHORT $LN82@xmlParseCh
	mov	ecx, DWORD PTR tv507[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv519[ebp], dl
	mov	eax, DWORD PTR tv509[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN81@xmlParseCh
	add	DWORD PTR tv507[ebp], 2
	add	DWORD PTR tv509[ebp], 2
	cmp	BYTE PTR tv519[ebp], 0
	jne	SHORT $LL80@xmlParseCh
$LN82@xmlParseCh:
	mov	DWORD PTR tv524[ebp], 0
	jmp	SHORT $LN83@xmlParseCh
$LN81@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv524[ebp], ecx
$LN83@xmlParseCh:
	mov	edx, DWORD PTR tv524[ebp]
	mov	DWORD PTR tv174[ebp], edx
	cmp	DWORD PTR tv174[ebp], 0
	jne	SHORT $LN19@xmlParseCh
	mov	eax, 10					; 0000000aH
	jmp	$LN1@xmlParseCh
$LN19@xmlParseCh:

; 1197 :     if (!strcmp(upper,  "ISO-LATIN-1")) return(XML_CHAR_ENCODING_8859_1);

	mov	DWORD PTR tv531[ebp], OFFSET ??_C@_0M@HACBCLE@ISO?9LATIN?91@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv529[ebp], eax
$LL84@xmlParseCh:
	mov	ecx, DWORD PTR tv529[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv534[ebp], dl
	mov	eax, DWORD PTR tv531[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN85@xmlParseCh
	cmp	BYTE PTR tv534[ebp], 0
	je	SHORT $LN86@xmlParseCh
	mov	ecx, DWORD PTR tv529[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv541[ebp], dl
	mov	eax, DWORD PTR tv531[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN85@xmlParseCh
	add	DWORD PTR tv529[ebp], 2
	add	DWORD PTR tv531[ebp], 2
	cmp	BYTE PTR tv541[ebp], 0
	jne	SHORT $LL84@xmlParseCh
$LN86@xmlParseCh:
	mov	DWORD PTR tv546[ebp], 0
	jmp	SHORT $LN87@xmlParseCh
$LN85@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv546[ebp], ecx
$LN87@xmlParseCh:
	mov	edx, DWORD PTR tv546[ebp]
	mov	DWORD PTR tv179[ebp], edx
	cmp	DWORD PTR tv179[ebp], 0
	jne	SHORT $LN20@xmlParseCh
	mov	eax, 10					; 0000000aH
	jmp	$LN1@xmlParseCh
$LN20@xmlParseCh:

; 1198 :     if (!strcmp(upper,  "ISO LATIN 1")) return(XML_CHAR_ENCODING_8859_1);

	mov	DWORD PTR tv553[ebp], OFFSET ??_C@_0M@POJFGGLA@ISO?5LATIN?51@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv551[ebp], eax
$LL88@xmlParseCh:
	mov	ecx, DWORD PTR tv551[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv556[ebp], dl
	mov	eax, DWORD PTR tv553[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN89@xmlParseCh
	cmp	BYTE PTR tv556[ebp], 0
	je	SHORT $LN90@xmlParseCh
	mov	ecx, DWORD PTR tv551[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv563[ebp], dl
	mov	eax, DWORD PTR tv553[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN89@xmlParseCh
	add	DWORD PTR tv551[ebp], 2
	add	DWORD PTR tv553[ebp], 2
	cmp	BYTE PTR tv563[ebp], 0
	jne	SHORT $LL88@xmlParseCh
$LN90@xmlParseCh:
	mov	DWORD PTR tv568[ebp], 0
	jmp	SHORT $LN91@xmlParseCh
$LN89@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv568[ebp], ecx
$LN91@xmlParseCh:
	mov	edx, DWORD PTR tv568[ebp]
	mov	DWORD PTR tv184[ebp], edx
	cmp	DWORD PTR tv184[ebp], 0
	jne	SHORT $LN21@xmlParseCh
	mov	eax, 10					; 0000000aH
	jmp	$LN1@xmlParseCh
$LN21@xmlParseCh:

; 1199 : 
; 1200 :     if (!strcmp(upper,  "ISO-8859-2")) return(XML_CHAR_ENCODING_8859_2);

	mov	DWORD PTR tv575[ebp], OFFSET ??_C@_0L@ECKEIAIJ@ISO?98859?92@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv573[ebp], eax
$LL92@xmlParseCh:
	mov	ecx, DWORD PTR tv573[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv578[ebp], dl
	mov	eax, DWORD PTR tv575[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN93@xmlParseCh
	cmp	BYTE PTR tv578[ebp], 0
	je	SHORT $LN94@xmlParseCh
	mov	ecx, DWORD PTR tv573[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv585[ebp], dl
	mov	eax, DWORD PTR tv575[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN93@xmlParseCh
	add	DWORD PTR tv573[ebp], 2
	add	DWORD PTR tv575[ebp], 2
	cmp	BYTE PTR tv585[ebp], 0
	jne	SHORT $LL92@xmlParseCh
$LN94@xmlParseCh:
	mov	DWORD PTR tv590[ebp], 0
	jmp	SHORT $LN95@xmlParseCh
$LN93@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv590[ebp], ecx
$LN95@xmlParseCh:
	mov	edx, DWORD PTR tv590[ebp]
	mov	DWORD PTR tv189[ebp], edx
	cmp	DWORD PTR tv189[ebp], 0
	jne	SHORT $LN22@xmlParseCh
	mov	eax, 11					; 0000000bH
	jmp	$LN1@xmlParseCh
$LN22@xmlParseCh:

; 1201 :     if (!strcmp(upper,  "ISO-LATIN-2")) return(XML_CHAR_ENCODING_8859_2);

	mov	DWORD PTR tv597[ebp], OFFSET ??_C@_0M@CMCPEBHH@ISO?9LATIN?92@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv595[ebp], eax
$LL96@xmlParseCh:
	mov	ecx, DWORD PTR tv595[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv600[ebp], dl
	mov	eax, DWORD PTR tv597[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN97@xmlParseCh
	cmp	BYTE PTR tv600[ebp], 0
	je	SHORT $LN98@xmlParseCh
	mov	ecx, DWORD PTR tv595[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv607[ebp], dl
	mov	eax, DWORD PTR tv597[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN97@xmlParseCh
	add	DWORD PTR tv595[ebp], 2
	add	DWORD PTR tv597[ebp], 2
	cmp	BYTE PTR tv607[ebp], 0
	jne	SHORT $LL96@xmlParseCh
$LN98@xmlParseCh:
	mov	DWORD PTR tv612[ebp], 0
	jmp	SHORT $LN99@xmlParseCh
$LN97@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv612[ebp], ecx
$LN99@xmlParseCh:
	mov	edx, DWORD PTR tv612[ebp]
	mov	DWORD PTR tv194[ebp], edx
	cmp	DWORD PTR tv194[ebp], 0
	jne	SHORT $LN23@xmlParseCh
	mov	eax, 11					; 0000000bH
	jmp	$LN1@xmlParseCh
$LN23@xmlParseCh:

; 1202 :     if (!strcmp(upper,  "ISO LATIN 2")) return(XML_CHAR_ENCODING_8859_2);

	mov	DWORD PTR tv619[ebp], OFFSET ??_C@_0M@NFLIDFHD@ISO?5LATIN?52@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv617[ebp], eax
$LL100@xmlParseCh:
	mov	ecx, DWORD PTR tv617[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv622[ebp], dl
	mov	eax, DWORD PTR tv619[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN101@xmlParseCh
	cmp	BYTE PTR tv622[ebp], 0
	je	SHORT $LN102@xmlParseCh
	mov	ecx, DWORD PTR tv617[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv629[ebp], dl
	mov	eax, DWORD PTR tv619[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN101@xmlParseCh
	add	DWORD PTR tv617[ebp], 2
	add	DWORD PTR tv619[ebp], 2
	cmp	BYTE PTR tv629[ebp], 0
	jne	SHORT $LL100@xmlParseCh
$LN102@xmlParseCh:
	mov	DWORD PTR tv634[ebp], 0
	jmp	SHORT $LN103@xmlParseCh
$LN101@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv634[ebp], ecx
$LN103@xmlParseCh:
	mov	edx, DWORD PTR tv634[ebp]
	mov	DWORD PTR tv199[ebp], edx
	cmp	DWORD PTR tv199[ebp], 0
	jne	SHORT $LN24@xmlParseCh
	mov	eax, 11					; 0000000bH
	jmp	$LN1@xmlParseCh
$LN24@xmlParseCh:

; 1203 : 
; 1204 :     if (!strcmp(upper,  "ISO-8859-3")) return(XML_CHAR_ENCODING_8859_3);

	mov	DWORD PTR tv641[ebp], OFFSET ??_C@_0L@FLLPLBMI@ISO?98859?93@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv639[ebp], eax
$LL104@xmlParseCh:
	mov	ecx, DWORD PTR tv639[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv644[ebp], dl
	mov	eax, DWORD PTR tv641[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN105@xmlParseCh
	cmp	BYTE PTR tv644[ebp], 0
	je	SHORT $LN106@xmlParseCh
	mov	ecx, DWORD PTR tv639[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv651[ebp], dl
	mov	eax, DWORD PTR tv641[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN105@xmlParseCh
	add	DWORD PTR tv639[ebp], 2
	add	DWORD PTR tv641[ebp], 2
	cmp	BYTE PTR tv651[ebp], 0
	jne	SHORT $LL104@xmlParseCh
$LN106@xmlParseCh:
	mov	DWORD PTR tv656[ebp], 0
	jmp	SHORT $LN107@xmlParseCh
$LN105@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv656[ebp], ecx
$LN107@xmlParseCh:
	mov	edx, DWORD PTR tv656[ebp]
	mov	DWORD PTR tv204[ebp], edx
	cmp	DWORD PTR tv204[ebp], 0
	jne	SHORT $LN25@xmlParseCh
	mov	eax, 12					; 0000000cH
	jmp	$LN1@xmlParseCh
$LN25@xmlParseCh:

; 1205 :     if (!strcmp(upper,  "ISO-8859-4")) return(XML_CHAR_ENCODING_8859_4);

	mov	DWORD PTR tv663[ebp], OFFSET ??_C@_0L@BEPOCHAP@ISO?98859?94@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv661[ebp], eax
$LL108@xmlParseCh:
	mov	ecx, DWORD PTR tv661[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv666[ebp], dl
	mov	eax, DWORD PTR tv663[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN109@xmlParseCh
	cmp	BYTE PTR tv666[ebp], 0
	je	SHORT $LN110@xmlParseCh
	mov	ecx, DWORD PTR tv661[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv673[ebp], dl
	mov	eax, DWORD PTR tv663[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN109@xmlParseCh
	add	DWORD PTR tv661[ebp], 2
	add	DWORD PTR tv663[ebp], 2
	cmp	BYTE PTR tv673[ebp], 0
	jne	SHORT $LL108@xmlParseCh
$LN110@xmlParseCh:
	mov	DWORD PTR tv678[ebp], 0
	jmp	SHORT $LN111@xmlParseCh
$LN109@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv678[ebp], ecx
$LN111@xmlParseCh:
	mov	edx, DWORD PTR tv678[ebp]
	mov	DWORD PTR tv209[ebp], edx
	cmp	DWORD PTR tv209[ebp], 0
	jne	SHORT $LN26@xmlParseCh
	mov	eax, 13					; 0000000dH
	jmp	$LN1@xmlParseCh
$LN26@xmlParseCh:

; 1206 :     if (!strcmp(upper,  "ISO-8859-5")) return(XML_CHAR_ENCODING_8859_5);

	mov	DWORD PTR tv685[ebp], OFFSET ??_C@_0L@NOFBGEO@ISO?98859?95@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv683[ebp], eax
$LL112@xmlParseCh:
	mov	ecx, DWORD PTR tv683[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv688[ebp], dl
	mov	eax, DWORD PTR tv685[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN113@xmlParseCh
	cmp	BYTE PTR tv688[ebp], 0
	je	SHORT $LN114@xmlParseCh
	mov	ecx, DWORD PTR tv683[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv695[ebp], dl
	mov	eax, DWORD PTR tv685[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN113@xmlParseCh
	add	DWORD PTR tv683[ebp], 2
	add	DWORD PTR tv685[ebp], 2
	cmp	BYTE PTR tv695[ebp], 0
	jne	SHORT $LL112@xmlParseCh
$LN114@xmlParseCh:
	mov	DWORD PTR tv700[ebp], 0
	jmp	SHORT $LN115@xmlParseCh
$LN113@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv700[ebp], ecx
$LN115@xmlParseCh:
	mov	edx, DWORD PTR tv700[ebp]
	mov	DWORD PTR tv214[ebp], edx
	cmp	DWORD PTR tv214[ebp], 0
	jne	SHORT $LN27@xmlParseCh
	mov	eax, 14					; 0000000eH
	jmp	$LN1@xmlParseCh
$LN27@xmlParseCh:

; 1207 :     if (!strcmp(upper,  "ISO-8859-6")) return(XML_CHAR_ENCODING_8859_6);

	mov	DWORD PTR tv707[ebp], OFFSET ??_C@_0L@CGMIEFIN@ISO?98859?96@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv705[ebp], eax
$LL116@xmlParseCh:
	mov	ecx, DWORD PTR tv705[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv710[ebp], dl
	mov	eax, DWORD PTR tv707[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN117@xmlParseCh
	cmp	BYTE PTR tv710[ebp], 0
	je	SHORT $LN118@xmlParseCh
	mov	ecx, DWORD PTR tv705[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv717[ebp], dl
	mov	eax, DWORD PTR tv707[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN117@xmlParseCh
	add	DWORD PTR tv705[ebp], 2
	add	DWORD PTR tv707[ebp], 2
	cmp	BYTE PTR tv717[ebp], 0
	jne	SHORT $LL116@xmlParseCh
$LN118@xmlParseCh:
	mov	DWORD PTR tv722[ebp], 0
	jmp	SHORT $LN119@xmlParseCh
$LN117@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv722[ebp], ecx
$LN119@xmlParseCh:
	mov	edx, DWORD PTR tv722[ebp]
	mov	DWORD PTR tv219[ebp], edx
	cmp	DWORD PTR tv219[ebp], 0
	jne	SHORT $LN28@xmlParseCh
	mov	eax, 15					; 0000000fH
	jmp	$LN1@xmlParseCh
$LN28@xmlParseCh:

; 1208 :     if (!strcmp(upper,  "ISO-8859-7")) return(XML_CHAR_ENCODING_8859_7);

	mov	DWORD PTR tv729[ebp], OFFSET ??_C@_0L@DPNDHEMM@ISO?98859?97@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv727[ebp], eax
$LL120@xmlParseCh:
	mov	ecx, DWORD PTR tv727[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv732[ebp], dl
	mov	eax, DWORD PTR tv729[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN121@xmlParseCh
	cmp	BYTE PTR tv732[ebp], 0
	je	SHORT $LN122@xmlParseCh
	mov	ecx, DWORD PTR tv727[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv739[ebp], dl
	mov	eax, DWORD PTR tv729[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN121@xmlParseCh
	add	DWORD PTR tv727[ebp], 2
	add	DWORD PTR tv729[ebp], 2
	cmp	BYTE PTR tv739[ebp], 0
	jne	SHORT $LL120@xmlParseCh
$LN122@xmlParseCh:
	mov	DWORD PTR tv744[ebp], 0
	jmp	SHORT $LN123@xmlParseCh
$LN121@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv744[ebp], ecx
$LN123@xmlParseCh:
	mov	edx, DWORD PTR tv744[ebp]
	mov	DWORD PTR tv224[ebp], edx
	cmp	DWORD PTR tv224[ebp], 0
	jne	SHORT $LN29@xmlParseCh
	mov	eax, 16					; 00000010H
	jmp	$LN1@xmlParseCh
$LN29@xmlParseCh:

; 1209 :     if (!strcmp(upper,  "ISO-8859-8")) return(XML_CHAR_ENCODING_8859_8);

	mov	DWORD PTR tv751[ebp], OFFSET ??_C@_0L@LIELGIAD@ISO?98859?98@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv749[ebp], eax
$LL124@xmlParseCh:
	mov	ecx, DWORD PTR tv749[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv754[ebp], dl
	mov	eax, DWORD PTR tv751[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN125@xmlParseCh
	cmp	BYTE PTR tv754[ebp], 0
	je	SHORT $LN126@xmlParseCh
	mov	ecx, DWORD PTR tv749[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv761[ebp], dl
	mov	eax, DWORD PTR tv751[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN125@xmlParseCh
	add	DWORD PTR tv749[ebp], 2
	add	DWORD PTR tv751[ebp], 2
	cmp	BYTE PTR tv761[ebp], 0
	jne	SHORT $LL124@xmlParseCh
$LN126@xmlParseCh:
	mov	DWORD PTR tv766[ebp], 0
	jmp	SHORT $LN127@xmlParseCh
$LN125@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv766[ebp], ecx
$LN127@xmlParseCh:
	mov	edx, DWORD PTR tv766[ebp]
	mov	DWORD PTR tv229[ebp], edx
	cmp	DWORD PTR tv229[ebp], 0
	jne	SHORT $LN30@xmlParseCh
	mov	eax, 17					; 00000011H
	jmp	$LN1@xmlParseCh
$LN30@xmlParseCh:

; 1210 :     if (!strcmp(upper,  "ISO-8859-9")) return(XML_CHAR_ENCODING_8859_9);

	mov	DWORD PTR tv773[ebp], OFFSET ??_C@_0L@KBFAFJEC@ISO?98859?99@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv771[ebp], eax
$LL128@xmlParseCh:
	mov	ecx, DWORD PTR tv771[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv776[ebp], dl
	mov	eax, DWORD PTR tv773[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN129@xmlParseCh
	cmp	BYTE PTR tv776[ebp], 0
	je	SHORT $LN130@xmlParseCh
	mov	ecx, DWORD PTR tv771[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv783[ebp], dl
	mov	eax, DWORD PTR tv773[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN129@xmlParseCh
	add	DWORD PTR tv771[ebp], 2
	add	DWORD PTR tv773[ebp], 2
	cmp	BYTE PTR tv783[ebp], 0
	jne	SHORT $LL128@xmlParseCh
$LN130@xmlParseCh:
	mov	DWORD PTR tv788[ebp], 0
	jmp	SHORT $LN131@xmlParseCh
$LN129@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv788[ebp], ecx
$LN131@xmlParseCh:
	mov	edx, DWORD PTR tv788[ebp]
	mov	DWORD PTR tv234[ebp], edx
	cmp	DWORD PTR tv234[ebp], 0
	jne	SHORT $LN31@xmlParseCh
	mov	eax, 18					; 00000012H
	jmp	$LN1@xmlParseCh
$LN31@xmlParseCh:

; 1211 : 
; 1212 :     if (!strcmp(upper, "ISO-2022-JP")) return(XML_CHAR_ENCODING_2022_JP);

	mov	DWORD PTR tv795[ebp], OFFSET ??_C@_0M@LMIFKILO@ISO?92022?9JP@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv793[ebp], eax
$LL132@xmlParseCh:
	mov	ecx, DWORD PTR tv793[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv798[ebp], dl
	mov	eax, DWORD PTR tv795[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN133@xmlParseCh
	cmp	BYTE PTR tv798[ebp], 0
	je	SHORT $LN134@xmlParseCh
	mov	ecx, DWORD PTR tv793[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv805[ebp], dl
	mov	eax, DWORD PTR tv795[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN133@xmlParseCh
	add	DWORD PTR tv793[ebp], 2
	add	DWORD PTR tv795[ebp], 2
	cmp	BYTE PTR tv805[ebp], 0
	jne	SHORT $LL132@xmlParseCh
$LN134@xmlParseCh:
	mov	DWORD PTR tv810[ebp], 0
	jmp	SHORT $LN135@xmlParseCh
$LN133@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv810[ebp], ecx
$LN135@xmlParseCh:
	mov	edx, DWORD PTR tv810[ebp]
	mov	DWORD PTR tv239[ebp], edx
	cmp	DWORD PTR tv239[ebp], 0
	jne	SHORT $LN32@xmlParseCh
	mov	eax, 19					; 00000013H
	jmp	$LN1@xmlParseCh
$LN32@xmlParseCh:

; 1213 :     if (!strcmp(upper, "SHIFT_JIS")) return(XML_CHAR_ENCODING_SHIFT_JIS);

	mov	DWORD PTR tv817[ebp], OFFSET ??_C@_09NDNIACC@SHIFT_JIS@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv815[ebp], eax
$LL136@xmlParseCh:
	mov	ecx, DWORD PTR tv815[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv820[ebp], dl
	mov	eax, DWORD PTR tv817[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN137@xmlParseCh
	cmp	BYTE PTR tv820[ebp], 0
	je	SHORT $LN138@xmlParseCh
	mov	ecx, DWORD PTR tv815[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv827[ebp], dl
	mov	eax, DWORD PTR tv817[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN137@xmlParseCh
	add	DWORD PTR tv815[ebp], 2
	add	DWORD PTR tv817[ebp], 2
	cmp	BYTE PTR tv827[ebp], 0
	jne	SHORT $LL136@xmlParseCh
$LN138@xmlParseCh:
	mov	DWORD PTR tv832[ebp], 0
	jmp	SHORT $LN139@xmlParseCh
$LN137@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv832[ebp], ecx
$LN139@xmlParseCh:
	mov	edx, DWORD PTR tv832[ebp]
	mov	DWORD PTR tv244[ebp], edx
	cmp	DWORD PTR tv244[ebp], 0
	jne	SHORT $LN33@xmlParseCh
	mov	eax, 20					; 00000014H
	jmp	$LN1@xmlParseCh
$LN33@xmlParseCh:

; 1214 :     if (!strcmp(upper, "EUC-JP")) return(XML_CHAR_ENCODING_EUC_JP);

	mov	DWORD PTR tv839[ebp], OFFSET ??_C@_06KCFOODCD@EUC?9JP@
	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv837[ebp], eax
$LL140@xmlParseCh:
	mov	ecx, DWORD PTR tv837[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv842[ebp], dl
	mov	eax, DWORD PTR tv839[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN141@xmlParseCh
	cmp	BYTE PTR tv842[ebp], 0
	je	SHORT $LN142@xmlParseCh
	mov	ecx, DWORD PTR tv837[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv849[ebp], dl
	mov	eax, DWORD PTR tv839[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN141@xmlParseCh
	add	DWORD PTR tv837[ebp], 2
	add	DWORD PTR tv839[ebp], 2
	cmp	BYTE PTR tv849[ebp], 0
	jne	SHORT $LL140@xmlParseCh
$LN142@xmlParseCh:
	mov	DWORD PTR tv854[ebp], 0
	jmp	SHORT $LN143@xmlParseCh
$LN141@xmlParseCh:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv854[ebp], ecx
$LN143@xmlParseCh:
	mov	edx, DWORD PTR tv854[ebp]
	mov	DWORD PTR tv249[ebp], edx
	cmp	DWORD PTR tv249[ebp], 0
	jne	SHORT $LN34@xmlParseCh
	mov	eax, 21					; 00000015H
	jmp	SHORT $LN1@xmlParseCh
$LN34@xmlParseCh:

; 1215 : 
; 1216 : #ifdef DEBUG_ENCODING
; 1217 :     xmlGenericError(xmlGenericErrorContext, "Unknown encoding %s\n", name);
; 1218 : #endif
; 1219 :     return(XML_CHAR_ENCODING_ERROR);

	or	eax, -1
$LN1@xmlParseCh:

; 1220 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN146@xmlParseCh
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 1056				; 00000420H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN146@xmlParseCh:
	DD	1
	DD	$LN145@xmlParseCh
$LN145@xmlParseCh:
	DD	-508					; fffffe04H
	DD	500					; 000001f4H
	DD	$LN144@xmlParseCh
$LN144@xmlParseCh:
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_xmlParseCharEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCleanupEncodingAliases
_TEXT	SEGMENT
_i$ = -4						; size = 4
_xmlCleanupEncodingAliases PROC				; COMDAT

; 992  : xmlCleanupEncodingAliases(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 993  :     int i;
; 994  : 
; 995  :     if (xmlCharEncodingAliases == NULL)

	cmp	DWORD PTR _xmlCharEncodingAliases, 0
	jne	SHORT $LN5@xmlCleanup

; 996  : 	return;

	jmp	$LN1@xmlCleanup
$LN5@xmlCleanup:

; 997  : 
; 998  :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlCleanup
$LN2@xmlCleanup:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlCleanup:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _xmlCharEncodingAliasesNb
	jge	SHORT $LN3@xmlCleanup

; 999  : 	if (xmlCharEncodingAliases[i].name != NULL)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _xmlCharEncodingAliases
	cmp	DWORD PTR [eax+edx*8], 0
	je	SHORT $LN6@xmlCleanup

; 1000 : 	    xmlFree((char *) xmlCharEncodingAliases[i].name);

	mov	esi, esp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xmlCharEncodingAliases
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlCleanup:

; 1001 : 	if (xmlCharEncodingAliases[i].alias != NULL)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xmlCharEncodingAliases
	cmp	DWORD PTR [edx+ecx*8+4], 0
	je	SHORT $LN7@xmlCleanup

; 1002 : 	    xmlFree((char *) xmlCharEncodingAliases[i].alias);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xmlCharEncodingAliases
	mov	edx, DWORD PTR [ecx+eax*8+4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlCleanup:

; 1003 :     }

	jmp	SHORT $LN2@xmlCleanup
$LN3@xmlCleanup:

; 1004 :     xmlCharEncodingAliasesNb = 0;

	mov	DWORD PTR _xmlCharEncodingAliasesNb, 0

; 1005 :     xmlCharEncodingAliasesMax = 0;

	mov	DWORD PTR _xmlCharEncodingAliasesMax, 0

; 1006 :     xmlFree(xmlCharEncodingAliases);

	mov	esi, esp
	mov	eax, DWORD PTR _xmlCharEncodingAliases
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1007 :     xmlCharEncodingAliases = NULL;

	mov	DWORD PTR _xmlCharEncodingAliases, 0
$LN1@xmlCleanup:

; 1008 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlCleanupEncodingAliases ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlGetEncodingAlias
_TEXT	SEGMENT
tv90 = -132						; size = 4
tv161 = -128						; size = 4
tv156 = -122						; size = 1
tv149 = -121						; size = 1
tv143 = -120						; size = 4
tv145 = -116						; size = 4
_upper$ = -108						; size = 100
_i$ = -4						; size = 4
_alias$ = 8						; size = 4
_xmlGetEncodingAlias PROC				; COMDAT

; 1019 : xmlGetEncodingAlias(const char *alias) {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-132]
	mov	ecx, 33					; 00000021H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1020 :     int i;
; 1021 :     char upper[100];
; 1022 : 
; 1023 :     if (alias == NULL)

	cmp	DWORD PTR _alias$[ebp], 0
	jne	SHORT $LN8@xmlGetEnco

; 1024 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlGetEnco
$LN8@xmlGetEnco:

; 1025 : 
; 1026 :     if (xmlCharEncodingAliases == NULL)

	cmp	DWORD PTR _xmlCharEncodingAliases, 0
	jne	SHORT $LN9@xmlGetEnco

; 1027 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlGetEnco
$LN9@xmlGetEnco:

; 1028 : 
; 1029 :     for (i = 0;i < 99;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlGetEnco
$LN2@xmlGetEnco:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlGetEnco:
	cmp	DWORD PTR _i$[ebp], 99			; 00000063H
	jge	SHORT $LN3@xmlGetEnco

; 1030 :         upper[i] = toupper(alias[i]);

	mov	ecx, DWORD PTR _alias$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _upper$[ebp+ecx], al

; 1031 : 	if (upper[i] == 0) break;

	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _upper$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN10@xmlGetEnco
	jmp	SHORT $LN3@xmlGetEnco
$LN10@xmlGetEnco:

; 1032 :     }

	jmp	SHORT $LN2@xmlGetEnco
$LN3@xmlGetEnco:

; 1033 :     upper[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _upper$[ebp+ecx], 0

; 1034 : 
; 1035 :     /*
; 1036 :      * Walk down the list looking for a definition of the alias
; 1037 :      */
; 1038 :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@xmlGetEnco
$LN5@xmlGetEnco:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@xmlGetEnco:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _xmlCharEncodingAliasesNb
	jge	SHORT $LN6@xmlGetEnco

; 1039 : 	if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {

	lea	ecx, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv145[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _xmlCharEncodingAliases
	mov	ecx, DWORD PTR [eax+edx*8+4]
	mov	DWORD PTR tv143[ebp], ecx
$LL13@xmlGetEnco:
	mov	edx, DWORD PTR tv143[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv149[ebp], al
	mov	ecx, DWORD PTR tv145[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN14@xmlGetEnco
	cmp	BYTE PTR tv149[ebp], 0
	je	SHORT $LN15@xmlGetEnco
	mov	edx, DWORD PTR tv143[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv156[ebp], al
	mov	ecx, DWORD PTR tv145[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN14@xmlGetEnco
	add	DWORD PTR tv143[ebp], 2
	add	DWORD PTR tv145[ebp], 2
	cmp	BYTE PTR tv156[ebp], 0
	jne	SHORT $LL13@xmlGetEnco
$LN15@xmlGetEnco:
	mov	DWORD PTR tv161[ebp], 0
	jmp	SHORT $LN16@xmlGetEnco
$LN14@xmlGetEnco:
	sbb	edx, edx
	or	edx, 1
	mov	DWORD PTR tv161[ebp], edx
$LN16@xmlGetEnco:
	mov	eax, DWORD PTR tv161[ebp]
	mov	DWORD PTR tv90[ebp], eax
	cmp	DWORD PTR tv90[ebp], 0
	jne	SHORT $LN11@xmlGetEnco

; 1040 : 	    return(xmlCharEncodingAliases[i].name);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xmlCharEncodingAliases
	mov	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1@xmlGetEnco
$LN11@xmlGetEnco:

; 1041 : 	}
; 1042 :     }

	jmp	$LN5@xmlGetEnco
$LN6@xmlGetEnco:

; 1043 :     return(NULL);

	xor	eax, eax
$LN1@xmlGetEnco:

; 1044 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@xmlGetEnco
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 132				; 00000084H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN19@xmlGetEnco:
	DD	1
	DD	$LN18@xmlGetEnco
$LN18@xmlGetEnco:
	DD	-108					; ffffff94H
	DD	100					; 00000064H
	DD	$LN17@xmlGetEnco
$LN17@xmlGetEnco:
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_xmlGetEncodingAlias ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlDelEncodingAlias
_TEXT	SEGMENT
tv74 = -24						; size = 4
tv152 = -20						; size = 4
tv147 = -14						; size = 1
tv140 = -13						; size = 1
tv134 = -12						; size = 4
tv136 = -8						; size = 4
_i$ = -4						; size = 4
_alias$ = 8						; size = 4
_xmlDelEncodingAlias PROC				; COMDAT

; 1114 : xmlDelEncodingAlias(const char *alias) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1115 :     int i;
; 1116 : 
; 1117 :     if (alias == NULL)

	cmp	DWORD PTR _alias$[ebp], 0
	jne	SHORT $LN5@xmlDelEnco

; 1118 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlDelEnco
$LN5@xmlDelEnco:

; 1119 : 
; 1120 :     if (xmlCharEncodingAliases == NULL)

	cmp	DWORD PTR _xmlCharEncodingAliases, 0
	jne	SHORT $LN6@xmlDelEnco

; 1121 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlDelEnco
$LN6@xmlDelEnco:

; 1122 :     /*
; 1123 :      * Walk down the list looking for a definition of the alias
; 1124 :      */
; 1125 :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlDelEnco
$LN2@xmlDelEnco:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlDelEnco:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _xmlCharEncodingAliasesNb
	jge	$LN3@xmlDelEnco

; 1126 : 	if (!strcmp(xmlCharEncodingAliases[i].alias, alias)) {

	mov	edx, DWORD PTR _alias$[ebp]
	mov	DWORD PTR tv136[ebp], edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xmlCharEncodingAliases
	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR tv134[ebp], edx
$LL9@xmlDelEnco:
	mov	eax, DWORD PTR tv134[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv140[ebp], cl
	mov	edx, DWORD PTR tv136[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN10@xmlDelEnco
	cmp	BYTE PTR tv140[ebp], 0
	je	SHORT $LN11@xmlDelEnco
	mov	eax, DWORD PTR tv134[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv147[ebp], cl
	mov	edx, DWORD PTR tv136[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN10@xmlDelEnco
	add	DWORD PTR tv134[ebp], 2
	add	DWORD PTR tv136[ebp], 2
	cmp	BYTE PTR tv147[ebp], 0
	jne	SHORT $LL9@xmlDelEnco
$LN11@xmlDelEnco:
	mov	DWORD PTR tv152[ebp], 0
	jmp	SHORT $LN12@xmlDelEnco
$LN10@xmlDelEnco:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv152[ebp], eax
$LN12@xmlDelEnco:
	mov	ecx, DWORD PTR tv152[ebp]
	mov	DWORD PTR tv74[ebp], ecx
	cmp	DWORD PTR tv74[ebp], 0
	jne	SHORT $LN7@xmlDelEnco

; 1127 : 	    xmlFree((char *) xmlCharEncodingAliases[i].name);

	mov	esi, esp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _xmlCharEncodingAliases
	mov	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1128 : 	    xmlFree((char *) xmlCharEncodingAliases[i].alias);

	mov	esi, esp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _xmlCharEncodingAliases
	mov	ecx, DWORD PTR [eax+edx*8+4]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1129 : 	    xmlCharEncodingAliasesNb--;

	mov	edx, DWORD PTR _xmlCharEncodingAliasesNb
	sub	edx, 1
	mov	DWORD PTR _xmlCharEncodingAliasesNb, edx

; 1130 : 	    memmove(&xmlCharEncodingAliases[i], &xmlCharEncodingAliases[i + 1],

	mov	eax, DWORD PTR _xmlCharEncodingAliasesNb
	sub	eax, DWORD PTR _i$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xmlCharEncodingAliases
	lea	eax, DWORD PTR [edx+ecx*8+8]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xmlCharEncodingAliases
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 1131 : 		    sizeof(xmlCharEncodingAlias) * (xmlCharEncodingAliasesNb - i));
; 1132 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlDelEnco
$LN7@xmlDelEnco:

; 1133 : 	}
; 1134 :     }

	jmp	$LN2@xmlDelEnco
$LN3@xmlDelEnco:

; 1135 :     return(-1);

	or	eax, -1
$LN1@xmlDelEnco:

; 1136 : }

	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xmlDelEncodingAlias ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlAddEncodingAlias
_TEXT	SEGMENT
tv133 = -132						; size = 4
tv200 = -128						; size = 4
tv195 = -122						; size = 1
tv188 = -121						; size = 1
tv182 = -120						; size = 4
tv184 = -116						; size = 4
_upper$ = -108						; size = 100
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_alias$ = 12						; size = 4
_xmlAddEncodingAlias PROC				; COMDAT

; 1057 : xmlAddEncodingAlias(const char *name, const char *alias) {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-132]
	mov	ecx, 33					; 00000021H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1058 :     int i;
; 1059 :     char upper[100];
; 1060 : 
; 1061 :     if ((name == NULL) || (alias == NULL))

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN9@xmlAddEnco
	cmp	DWORD PTR _alias$[ebp], 0
	jne	SHORT $LN8@xmlAddEnco
$LN9@xmlAddEnco:

; 1062 : 	return(-1);

	or	eax, -1
	jmp	$LN1@xmlAddEnco
$LN8@xmlAddEnco:

; 1063 : 
; 1064 :     for (i = 0;i < 99;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlAddEnco
$LN2@xmlAddEnco:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@xmlAddEnco:
	cmp	DWORD PTR _i$[ebp], 99			; 00000063H
	jge	SHORT $LN3@xmlAddEnco

; 1065 :         upper[i] = toupper(alias[i]);

	mov	ecx, DWORD PTR _alias$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _upper$[ebp+ecx], al

; 1066 : 	if (upper[i] == 0) break;

	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _upper$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN10@xmlAddEnco
	jmp	SHORT $LN3@xmlAddEnco
$LN10@xmlAddEnco:

; 1067 :     }

	jmp	SHORT $LN2@xmlAddEnco
$LN3@xmlAddEnco:

; 1068 :     upper[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _upper$[ebp+ecx], 0

; 1069 : 
; 1070 :     if (xmlCharEncodingAliases == NULL) {

	cmp	DWORD PTR _xmlCharEncodingAliases, 0
	jne	SHORT $LN11@xmlAddEnco

; 1071 : 	xmlCharEncodingAliasesNb = 0;

	mov	DWORD PTR _xmlCharEncodingAliasesNb, 0

; 1072 : 	xmlCharEncodingAliasesMax = 20;

	mov	DWORD PTR _xmlCharEncodingAliasesMax, 20 ; 00000014H

; 1073 : 	xmlCharEncodingAliases = (xmlCharEncodingAliasPtr)

	mov	edx, DWORD PTR _xmlCharEncodingAliasesMax
	shl	edx, 3
	mov	esi, esp
	push	edx
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _xmlCharEncodingAliases, eax

; 1074 : 	      xmlMalloc(xmlCharEncodingAliasesMax * sizeof(xmlCharEncodingAlias));
; 1075 : 	if (xmlCharEncodingAliases == NULL)

	cmp	DWORD PTR _xmlCharEncodingAliases, 0
	jne	SHORT $LN13@xmlAddEnco

; 1076 : 	    return(-1);

	or	eax, -1
	jmp	$LN1@xmlAddEnco
$LN13@xmlAddEnco:

; 1077 :     } else if (xmlCharEncodingAliasesNb >= xmlCharEncodingAliasesMax) {

	jmp	SHORT $LN12@xmlAddEnco
$LN11@xmlAddEnco:
	mov	eax, DWORD PTR _xmlCharEncodingAliasesNb
	cmp	eax, DWORD PTR _xmlCharEncodingAliasesMax
	jl	SHORT $LN12@xmlAddEnco

; 1078 : 	xmlCharEncodingAliasesMax *= 2;

	mov	ecx, DWORD PTR _xmlCharEncodingAliasesMax
	shl	ecx, 1
	mov	DWORD PTR _xmlCharEncodingAliasesMax, ecx

; 1079 : 	xmlCharEncodingAliases = (xmlCharEncodingAliasPtr)

	mov	edx, DWORD PTR _xmlCharEncodingAliasesMax
	shl	edx, 3
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _xmlCharEncodingAliases
	push	eax
	call	DWORD PTR _xmlRealloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _xmlCharEncodingAliases, eax
$LN12@xmlAddEnco:

; 1080 : 	      xmlRealloc(xmlCharEncodingAliases,
; 1081 : 		         xmlCharEncodingAliasesMax * sizeof(xmlCharEncodingAlias));
; 1082 :     }
; 1083 :     /*
; 1084 :      * Walk down the list looking for a definition of the alias
; 1085 :      */
; 1086 :     for (i = 0;i < xmlCharEncodingAliasesNb;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@xmlAddEnco
$LN5@xmlAddEnco:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@xmlAddEnco:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _xmlCharEncodingAliasesNb
	jge	$LN6@xmlAddEnco

; 1087 : 	if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {

	lea	eax, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv184[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xmlCharEncodingAliases
	mov	eax, DWORD PTR [edx+ecx*8+4]
	mov	DWORD PTR tv182[ebp], eax
$LL17@xmlAddEnco:
	mov	ecx, DWORD PTR tv182[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv188[ebp], dl
	mov	eax, DWORD PTR tv184[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN18@xmlAddEnco
	cmp	BYTE PTR tv188[ebp], 0
	je	SHORT $LN19@xmlAddEnco
	mov	ecx, DWORD PTR tv182[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv195[ebp], dl
	mov	eax, DWORD PTR tv184[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN18@xmlAddEnco
	add	DWORD PTR tv182[ebp], 2
	add	DWORD PTR tv184[ebp], 2
	cmp	BYTE PTR tv195[ebp], 0
	jne	SHORT $LL17@xmlAddEnco
$LN19@xmlAddEnco:
	mov	DWORD PTR tv200[ebp], 0
	jmp	SHORT $LN20@xmlAddEnco
$LN18@xmlAddEnco:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv200[ebp], ecx
$LN20@xmlAddEnco:
	mov	edx, DWORD PTR tv200[ebp]
	mov	DWORD PTR tv133[ebp], edx
	cmp	DWORD PTR tv133[ebp], 0
	jne	SHORT $LN15@xmlAddEnco

; 1088 : 	    /*
; 1089 : 	     * Replace the definition.
; 1090 : 	     */
; 1091 : 	    xmlFree((char *) xmlCharEncodingAliases[i].name);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _xmlCharEncodingAliases
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1092 : 	    xmlCharEncodingAliases[i].name = xmlMemStrdup(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _xmlCharEncodingAliases
	mov	DWORD PTR [edx+ecx*8], eax

; 1093 : 	    return(0);

	xor	eax, eax
	jmp	SHORT $LN1@xmlAddEnco
$LN15@xmlAddEnco:

; 1094 : 	}
; 1095 :     }

	jmp	$LN5@xmlAddEnco
$LN6@xmlAddEnco:

; 1096 :     /*
; 1097 :      * Add the definition
; 1098 :      */
; 1099 :     xmlCharEncodingAliases[xmlCharEncodingAliasesNb].name = xmlMemStrdup(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _xmlCharEncodingAliasesNb
	mov	edx, DWORD PTR _xmlCharEncodingAliases
	mov	DWORD PTR [edx+ecx*8], eax

; 1100 :     xmlCharEncodingAliases[xmlCharEncodingAliasesNb].alias = xmlMemStrdup(upper);

	mov	esi, esp
	lea	eax, DWORD PTR _upper$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _xmlCharEncodingAliasesNb
	mov	edx, DWORD PTR _xmlCharEncodingAliases
	mov	DWORD PTR [edx+ecx*8+4], eax

; 1101 :     xmlCharEncodingAliasesNb++;

	mov	eax, DWORD PTR _xmlCharEncodingAliasesNb
	add	eax, 1
	mov	DWORD PTR _xmlCharEncodingAliasesNb, eax

; 1102 :     return(0);

	xor	eax, eax
$LN1@xmlAddEnco:

; 1103 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@xmlAddEnco
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 132				; 00000084H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN23@xmlAddEnco:
	DD	1
	DD	$LN22@xmlAddEnco
$LN22@xmlAddEnco:
	DD	-108					; ffffff94H
	DD	100					; 00000064H
	DD	$LN21@xmlAddEnco
$LN21@xmlAddEnco:
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_xmlAddEncodingAlias ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlNewCharEncodingHandler
_TEXT	SEGMENT
_up$ = -524						; size = 4
_i$ = -520						; size = 4
_upper$ = -512						; size = 500
_alias$ = -8						; size = 4
_handler$ = -4						; size = 4
_name$ = 8						; size = 4
_input$ = 12						; size = 4
_output$ = 16						; size = 4
_xmlNewCharEncodingHandler PROC				; COMDAT

; 1320 :                           xmlCharEncodingOutputFunc output) {

	push	ebp
	mov	ebp, esp
	sub	esp, 524				; 0000020cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-524]
	mov	ecx, 131				; 00000083H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1321 :     xmlCharEncodingHandlerPtr handler;
; 1322 :     const char *alias;
; 1323 :     char upper[500];
; 1324 :     int i;
; 1325 :     char *up = NULL;

	mov	DWORD PTR _up$[ebp], 0

; 1326 : 
; 1327 :     /*
; 1328 :      * Do the alias resolution
; 1329 :      */
; 1330 :     alias = xmlGetEncodingAlias(name);

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_xmlGetEncodingAlias
	add	esp, 4
	mov	DWORD PTR _alias$[ebp], eax

; 1331 :     if (alias != NULL)

	cmp	DWORD PTR _alias$[ebp], 0
	je	SHORT $LN5@xmlNewChar

; 1332 : 	name = alias;

	mov	ecx, DWORD PTR _alias$[ebp]
	mov	DWORD PTR _name$[ebp], ecx
$LN5@xmlNewChar:

; 1333 : 
; 1334 :     /*
; 1335 :      * Keep only the uppercase version of the encoding.
; 1336 :      */
; 1337 :     if (name == NULL) {

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN6@xmlNewChar

; 1338 :         xmlEncodingErr(XML_I18N_NO_NAME,

	push	0
	push	OFFSET ??_C@_0CH@LKFDNFFB@xmlNewCharEncodingHandler?5?3?5no?5@
	push	6000					; 00001770H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH

; 1339 : 		       "xmlNewCharEncodingHandler : no name !\n", NULL);
; 1340 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewChar
$LN6@xmlNewChar:

; 1341 :     }
; 1342 :     for (i = 0;i < 499;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlNewChar
$LN2@xmlNewChar:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@xmlNewChar:
	cmp	DWORD PTR _i$[ebp], 499			; 000001f3H
	jge	SHORT $LN3@xmlNewChar

; 1343 :         upper[i] = toupper(name[i]);

	mov	eax, DWORD PTR _name$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _upper$[ebp+edx], al

; 1344 : 	if (upper[i] == 0) break;

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR _upper$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN7@xmlNewChar
	jmp	SHORT $LN3@xmlNewChar
$LN7@xmlNewChar:

; 1345 :     }

	jmp	SHORT $LN2@xmlNewChar
$LN3@xmlNewChar:

; 1346 :     upper[i] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _upper$[ebp+edx], 0

; 1347 :     up = xmlMemStrdup(upper);

	mov	esi, esp
	lea	eax, DWORD PTR _upper$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _up$[ebp], eax

; 1348 :     if (up == NULL) {

	cmp	DWORD PTR _up$[ebp], 0
	jne	SHORT $LN8@xmlNewChar

; 1349 :         xmlEncodingErrMemory("xmlNewCharEncodingHandler : out of memory !\n");

	push	OFFSET ??_C@_0CN@DOLIIPJB@xmlNewCharEncodingHandler?5?3?5out@
	call	_xmlEncodingErrMemory
	add	esp, 4

; 1350 : 	return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlNewChar
$LN8@xmlNewChar:

; 1351 :     }
; 1352 : 
; 1353 :     /*
; 1354 :      * allocate and fill-up an handler block.
; 1355 :      */
; 1356 :     handler = (xmlCharEncodingHandlerPtr)

	mov	esi, esp
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _handler$[ebp], eax

; 1357 :               xmlMalloc(sizeof(xmlCharEncodingHandler));
; 1358 :     if (handler == NULL) {

	cmp	DWORD PTR _handler$[ebp], 0
	jne	SHORT $LN9@xmlNewChar

; 1359 :         xmlFree(up);

	mov	esi, esp
	mov	ecx, DWORD PTR _up$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1360 :         xmlEncodingErrMemory("xmlNewCharEncodingHandler : out of memory !\n");

	push	OFFSET ??_C@_0CN@DOLIIPJB@xmlNewCharEncodingHandler?5?3?5out@
	call	_xmlEncodingErrMemory
	add	esp, 4

; 1361 : 	return(NULL);

	xor	eax, eax
	jmp	SHORT $LN1@xmlNewChar
$LN9@xmlNewChar:

; 1362 :     }
; 1363 :     memset(handler, 0, sizeof(xmlCharEncodingHandler));

	xor	edx, edx
	mov	eax, DWORD PTR _handler$[ebp]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], edx

; 1364 :     handler->input = input;

	mov	ecx, DWORD PTR _handler$[ebp]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 1365 :     handler->output = output;

	mov	eax, DWORD PTR _handler$[ebp]
	mov	ecx, DWORD PTR _output$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1366 :     handler->name = up;

	mov	edx, DWORD PTR _handler$[ebp]
	mov	eax, DWORD PTR _up$[ebp]
	mov	DWORD PTR [edx], eax

; 1367 : 
; 1368 : #ifdef LIBXML_ICONV_ENABLED
; 1369 :     handler->iconv_in = NULL;

	mov	ecx, DWORD PTR _handler$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1370 :     handler->iconv_out = NULL;

	mov	edx, DWORD PTR _handler$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1371 : #endif
; 1372 : #ifdef LIBXML_ICU_ENABLED
; 1373 :     handler->uconv_in = NULL;
; 1374 :     handler->uconv_out = NULL;
; 1375 : #endif
; 1376 : 
; 1377 :     /*
; 1378 :      * registers and returns the handler.
; 1379 :      */
; 1380 :     xmlRegisterCharEncodingHandler(handler);

	mov	eax, DWORD PTR _handler$[ebp]
	push	eax
	call	_xmlRegisterCharEncodingHandler
	add	esp, 4

; 1381 : #ifdef DEBUG_ENCODING
; 1382 :     xmlGenericError(xmlGenericErrorContext,
; 1383 : 	    "Registered encoding handler for %s\n", name);
; 1384 : #endif
; 1385 :     return(handler);

	mov	eax, DWORD PTR _handler$[ebp]
$LN1@xmlNewChar:

; 1386 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@xmlNewChar
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 524				; 0000020cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@xmlNewChar:
	DD	1
	DD	$LN12@xmlNewChar
$LN12@xmlNewChar:
	DD	-512					; fffffe00H
	DD	500					; 000001f4H
	DD	$LN11@xmlNewChar
$LN11@xmlNewChar:
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_xmlNewCharEncodingHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlFindCharEncodingHandler
_TEXT	SEGMENT
tv179 = -180						; size = 4
tv301 = -176						; size = 4
tv296 = -170						; size = 1
tv289 = -169						; size = 1
tv283 = -168						; size = 4
tv285 = -164						; size = 4
tv130 = -160						; size = 4
tv224 = -156						; size = 4
tv219 = -150						; size = 1
tv212 = -149						; size = 1
tv206 = -148						; size = 4
tv208 = -144						; size = 4
_canon$1 = -140						; size = 4
_i$ = -136						; size = 4
_upper$ = -128						; size = 100
_icv_out$ = -24						; size = 4
_icv_in$ = -20						; size = 4
_enc$ = -16						; size = 4
_alias$ = -12						; size = 4
_norig$ = -8						; size = 4
_nalias$ = -4						; size = 4
_name$ = 8						; size = 4
_xmlFindCharEncodingHandler PROC			; COMDAT

; 1641 : xmlFindCharEncodingHandler(const char *name) {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-180]
	mov	ecx, 45					; 0000002dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1642 :     const char *nalias;
; 1643 :     const char *norig;
; 1644 :     xmlCharEncoding alias;
; 1645 : #ifdef LIBXML_ICONV_ENABLED
; 1646 :     xmlCharEncodingHandlerPtr enc;
; 1647 :     iconv_t icv_in, icv_out;
; 1648 : #endif /* LIBXML_ICONV_ENABLED */
; 1649 : #ifdef LIBXML_ICU_ENABLED
; 1650 :     xmlCharEncodingHandlerPtr encu;
; 1651 :     uconv_t *ucv_in, *ucv_out;
; 1652 : #endif /* LIBXML_ICU_ENABLED */
; 1653 :     char upper[100];
; 1654 :     int i;
; 1655 : 
; 1656 :     if (handlers == NULL) xmlInitCharEncodingHandlers();

	cmp	DWORD PTR _handlers, 0
	jne	SHORT $LN8@xmlFindCha
	call	_xmlInitCharEncodingHandlers
$LN8@xmlFindCha:

; 1657 :     if (name == NULL) return(xmlDefaultCharEncodingHandler);

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN9@xmlFindCha
	mov	eax, DWORD PTR _xmlDefaultCharEncodingHandler
	jmp	$LN1@xmlFindCha
$LN9@xmlFindCha:

; 1658 :     if (name[0] == 0) return(xmlDefaultCharEncodingHandler);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _name$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN10@xmlFindCha
	mov	eax, DWORD PTR _xmlDefaultCharEncodingHandler
	jmp	$LN1@xmlFindCha
$LN10@xmlFindCha:

; 1659 : 
; 1660 :     /*
; 1661 :      * Do the alias resolution
; 1662 :      */
; 1663 :     norig = name;

	mov	ecx, DWORD PTR _name$[ebp]
	mov	DWORD PTR _norig$[ebp], ecx

; 1664 :     nalias = xmlGetEncodingAlias(name);

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_xmlGetEncodingAlias
	add	esp, 4
	mov	DWORD PTR _nalias$[ebp], eax

; 1665 :     if (nalias != NULL)

	cmp	DWORD PTR _nalias$[ebp], 0
	je	SHORT $LN11@xmlFindCha

; 1666 : 	name = nalias;

	mov	eax, DWORD PTR _nalias$[ebp]
	mov	DWORD PTR _name$[ebp], eax
$LN11@xmlFindCha:

; 1667 : 
; 1668 :     /*
; 1669 :      * Check first for directly registered encoding names
; 1670 :      */
; 1671 :     for (i = 0;i < 99;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@xmlFindCha
$LN2@xmlFindCha:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@xmlFindCha:
	cmp	DWORD PTR _i$[ebp], 99			; 00000063H
	jge	SHORT $LN3@xmlFindCha

; 1672 :         upper[i] = toupper(name[i]);

	mov	edx, DWORD PTR _name$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _upper$[ebp+ecx], al

; 1673 : 	if (upper[i] == 0) break;

	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, BYTE PTR _upper$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN12@xmlFindCha
	jmp	SHORT $LN3@xmlFindCha
$LN12@xmlFindCha:

; 1674 :     }

	jmp	SHORT $LN2@xmlFindCha
$LN3@xmlFindCha:

; 1675 :     upper[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _upper$[ebp+ecx], 0

; 1676 : 
; 1677 :     if (handlers != NULL) {

	cmp	DWORD PTR _handlers, 0
	je	$LN13@xmlFindCha

; 1678 :         for (i = 0;i < nbCharEncodingHandler; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@xmlFindCha
$LN5@xmlFindCha:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@xmlFindCha:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _nbCharEncodingHandler
	jge	$LN13@xmlFindCha

; 1679 :             if (!strcmp(upper, handlers[i]->name)) {

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _handlers
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv208[ebp], ecx
	lea	edx, DWORD PTR _upper$[ebp]
	mov	DWORD PTR tv206[ebp], edx
$LL25@xmlFindCha:
	mov	eax, DWORD PTR tv206[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv212[ebp], cl
	mov	edx, DWORD PTR tv208[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN26@xmlFindCha
	cmp	BYTE PTR tv212[ebp], 0
	je	SHORT $LN27@xmlFindCha
	mov	eax, DWORD PTR tv206[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv219[ebp], cl
	mov	edx, DWORD PTR tv208[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN26@xmlFindCha
	add	DWORD PTR tv206[ebp], 2
	add	DWORD PTR tv208[ebp], 2
	cmp	BYTE PTR tv219[ebp], 0
	jne	SHORT $LL25@xmlFindCha
$LN27@xmlFindCha:
	mov	DWORD PTR tv224[ebp], 0
	jmp	SHORT $LN28@xmlFindCha
$LN26@xmlFindCha:
	sbb	eax, eax
	or	eax, 1
	mov	DWORD PTR tv224[ebp], eax
$LN28@xmlFindCha:
	mov	ecx, DWORD PTR tv224[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	cmp	DWORD PTR tv130[ebp], 0
	jne	SHORT $LN14@xmlFindCha

; 1680 : #ifdef DEBUG_ENCODING
; 1681 :                 xmlGenericError(xmlGenericErrorContext,
; 1682 :                         "Found registered handler for encoding %s\n", name);
; 1683 : #endif
; 1684 :                 return(handlers[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _handlers
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	$LN1@xmlFindCha
$LN14@xmlFindCha:

; 1685 :             }
; 1686 :         }

	jmp	$LN5@xmlFindCha
$LN13@xmlFindCha:

; 1687 :     }
; 1688 : 
; 1689 : #ifdef LIBXML_ICONV_ENABLED
; 1690 :     /* check whether iconv can handle this */
; 1691 :     icv_in = iconv_open("UTF-8", name);

	mov	esi, esp
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	call	DWORD PTR __imp__libiconv_open
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _icv_in$[ebp], eax

; 1692 :     icv_out = iconv_open(name, "UTF-8");

	mov	esi, esp
	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	DWORD PTR __imp__libiconv_open
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _icv_out$[ebp], eax

; 1693 :     if (icv_in == (iconv_t) -1) {

	cmp	DWORD PTR _icv_in$[ebp], -1
	jne	SHORT $LN15@xmlFindCha

; 1694 :         icv_in = iconv_open("UTF-8", upper);

	mov	esi, esp
	lea	eax, DWORD PTR _upper$[ebp]
	push	eax
	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	call	DWORD PTR __imp__libiconv_open
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _icv_in$[ebp], eax
$LN15@xmlFindCha:

; 1695 :     }
; 1696 :     if (icv_out == (iconv_t) -1) {

	cmp	DWORD PTR _icv_out$[ebp], -1
	jne	SHORT $LN16@xmlFindCha

; 1697 : 	icv_out = iconv_open(upper, "UTF-8");

	mov	esi, esp
	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	lea	ecx, DWORD PTR _upper$[ebp]
	push	ecx
	call	DWORD PTR __imp__libiconv_open
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _icv_out$[ebp], eax
$LN16@xmlFindCha:

; 1698 :     }
; 1699 :     if ((icv_in != (iconv_t) -1) && (icv_out != (iconv_t) -1)) {

	cmp	DWORD PTR _icv_in$[ebp], -1
	je	$LN17@xmlFindCha
	cmp	DWORD PTR _icv_out$[ebp], -1
	je	$LN17@xmlFindCha

; 1700 : 	    enc = (xmlCharEncodingHandlerPtr)

	mov	esi, esp
	push	20					; 00000014H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _enc$[ebp], eax

; 1701 : 	          xmlMalloc(sizeof(xmlCharEncodingHandler));
; 1702 : 	    if (enc == NULL) {

	cmp	DWORD PTR _enc$[ebp], 0
	jne	SHORT $LN19@xmlFindCha

; 1703 : 	        iconv_close(icv_in);

	mov	esi, esp
	mov	edx, DWORD PTR _icv_in$[ebp]
	push	edx
	call	DWORD PTR __imp__libiconv_close
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1704 : 	        iconv_close(icv_out);

	mov	esi, esp
	mov	eax, DWORD PTR _icv_out$[ebp]
	push	eax
	call	DWORD PTR __imp__libiconv_close
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1705 : 		return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlFindCha
$LN19@xmlFindCha:

; 1706 : 	    }
; 1707 :             memset(enc, 0, sizeof(xmlCharEncodingHandler));

	xor	ecx, ecx
	mov	edx, DWORD PTR _enc$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [edx+8], ecx
	mov	DWORD PTR [edx+12], ecx
	mov	DWORD PTR [edx+16], ecx

; 1708 : 	    enc->name = xmlMemStrdup(name);

	mov	esi, esp
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _xmlMemStrdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _enc$[ebp]
	mov	DWORD PTR [ecx], eax

; 1709 : 	    enc->input = NULL;

	mov	edx, DWORD PTR _enc$[ebp]
	mov	DWORD PTR [edx+4], 0

; 1710 : 	    enc->output = NULL;

	mov	eax, DWORD PTR _enc$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1711 : 	    enc->iconv_in = icv_in;

	mov	ecx, DWORD PTR _enc$[ebp]
	mov	edx, DWORD PTR _icv_in$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1712 : 	    enc->iconv_out = icv_out;

	mov	eax, DWORD PTR _enc$[ebp]
	mov	ecx, DWORD PTR _icv_out$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1713 : #ifdef DEBUG_ENCODING
; 1714 :             xmlGenericError(xmlGenericErrorContext,
; 1715 : 		    "Found iconv handler for encoding %s\n", name);
; 1716 : #endif
; 1717 : 	    return enc;

	mov	eax, DWORD PTR _enc$[ebp]
	jmp	$LN1@xmlFindCha
	jmp	SHORT $LN18@xmlFindCha
$LN17@xmlFindCha:

; 1718 :     } else if ((icv_in != (iconv_t) -1) || icv_out != (iconv_t) -1) {

	cmp	DWORD PTR _icv_in$[ebp], -1
	jne	SHORT $LN21@xmlFindCha
	cmp	DWORD PTR _icv_out$[ebp], -1
	je	SHORT $LN18@xmlFindCha
$LN21@xmlFindCha:

; 1719 : 	    xmlEncodingErr(XML_ERR_INTERNAL_ERROR,

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0CI@CIBAEANE@iconv?5?3?5problems?5with?5filters?5f@
	push	1
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH
$LN18@xmlFindCha:

; 1720 : 		    "iconv : problems with filters for '%s'\n", name);
; 1721 :     }
; 1722 : #endif /* LIBXML_ICONV_ENABLED */
; 1723 : #ifdef LIBXML_ICU_ENABLED
; 1724 :     /* check whether icu can handle this */
; 1725 :     ucv_in = openIcuConverter(name, 1);
; 1726 :     ucv_out = openIcuConverter(name, 0);
; 1727 :     if (ucv_in != NULL && ucv_out != NULL) {
; 1728 : 	    encu = (xmlCharEncodingHandlerPtr)
; 1729 : 	           xmlMalloc(sizeof(xmlCharEncodingHandler));
; 1730 : 	    if (encu == NULL) {
; 1731 :                 closeIcuConverter(ucv_in);
; 1732 :                 closeIcuConverter(ucv_out);
; 1733 : 		return(NULL);
; 1734 : 	    }
; 1735 :             memset(encu, 0, sizeof(xmlCharEncodingHandler));
; 1736 : 	    encu->name = xmlMemStrdup(name);
; 1737 : 	    encu->input = NULL;
; 1738 : 	    encu->output = NULL;
; 1739 : 	    encu->uconv_in = ucv_in;
; 1740 : 	    encu->uconv_out = ucv_out;
; 1741 : #ifdef DEBUG_ENCODING
; 1742 :             xmlGenericError(xmlGenericErrorContext,
; 1743 : 		    "Found ICU converter handler for encoding %s\n", name);
; 1744 : #endif
; 1745 : 	    return encu;
; 1746 :     } else if (ucv_in != NULL || ucv_out != NULL) {
; 1747 :             closeIcuConverter(ucv_in);
; 1748 :             closeIcuConverter(ucv_out);
; 1749 : 	    xmlEncodingErr(XML_ERR_INTERNAL_ERROR,
; 1750 : 		    "ICU converter : problems with filters for '%s'\n", name);
; 1751 :     }
; 1752 : #endif /* LIBXML_ICU_ENABLED */
; 1753 : 
; 1754 : #ifdef DEBUG_ENCODING
; 1755 :     xmlGenericError(xmlGenericErrorContext,
; 1756 : 	    "No handler found for encoding %s\n", name);
; 1757 : #endif
; 1758 : 
; 1759 :     /*
; 1760 :      * Fallback using the canonical names
; 1761 :      */
; 1762 :     alias = xmlParseCharEncoding(norig);

	mov	eax, DWORD PTR _norig$[ebp]
	push	eax
	call	_xmlParseCharEncoding
	add	esp, 4
	mov	DWORD PTR _alias$[ebp], eax

; 1763 :     if (alias != XML_CHAR_ENCODING_ERROR) {

	cmp	DWORD PTR _alias$[ebp], -1
	je	$LN22@xmlFindCha

; 1764 :         const char* canon;
; 1765 :         canon = xmlGetCharEncodingName(alias);

	mov	ecx, DWORD PTR _alias$[ebp]
	push	ecx
	call	_xmlGetCharEncodingName
	add	esp, 4
	mov	DWORD PTR _canon$1[ebp], eax

; 1766 :         if ((canon != NULL) && (strcmp(name, canon))) {

	cmp	DWORD PTR _canon$1[ebp], 0
	je	$LN22@xmlFindCha
	mov	edx, DWORD PTR _canon$1[ebp]
	mov	DWORD PTR tv285[ebp], edx
	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR tv283[ebp], eax
$LL29@xmlFindCha:
	mov	ecx, DWORD PTR tv283[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv289[ebp], dl
	mov	eax, DWORD PTR tv285[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN30@xmlFindCha
	cmp	BYTE PTR tv289[ebp], 0
	je	SHORT $LN31@xmlFindCha
	mov	ecx, DWORD PTR tv283[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv296[ebp], dl
	mov	eax, DWORD PTR tv285[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN30@xmlFindCha
	add	DWORD PTR tv283[ebp], 2
	add	DWORD PTR tv285[ebp], 2
	cmp	BYTE PTR tv296[ebp], 0
	jne	SHORT $LL29@xmlFindCha
$LN31@xmlFindCha:
	mov	DWORD PTR tv301[ebp], 0
	jmp	SHORT $LN32@xmlFindCha
$LN30@xmlFindCha:
	sbb	ecx, ecx
	or	ecx, 1
	mov	DWORD PTR tv301[ebp], ecx
$LN32@xmlFindCha:
	mov	edx, DWORD PTR tv301[ebp]
	mov	DWORD PTR tv179[ebp], edx
	cmp	DWORD PTR tv179[ebp], 0
	je	SHORT $LN22@xmlFindCha

; 1767 : 	    return(xmlFindCharEncodingHandler(canon));

	mov	eax, DWORD PTR _canon$1[ebp]
	push	eax
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	jmp	SHORT $LN1@xmlFindCha
$LN22@xmlFindCha:

; 1768 :         }
; 1769 :     }
; 1770 : 
; 1771 :     /* If "none of the above", give up */
; 1772 :     return(NULL);

	xor	eax, eax
$LN1@xmlFindCha:

; 1773 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN35@xmlFindCha
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 180				; 000000b4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN35@xmlFindCha:
	DD	1
	DD	$LN34@xmlFindCha
$LN34@xmlFindCha:
	DD	-128					; ffffff80H
	DD	100					; 00000064H
	DD	$LN33@xmlFindCha
$LN33@xmlFindCha:
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_xmlFindCharEncodingHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlGetCharEncodingHandler
_TEXT	SEGMENT
tv65 = -8						; size = 4
_handler$ = -4						; size = 4
_enc$ = 8						; size = 4
_xmlGetCharEncodingHandler PROC				; COMDAT

; 1507 : xmlGetCharEncodingHandler(xmlCharEncoding enc) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1508 :     xmlCharEncodingHandlerPtr handler;
; 1509 : 
; 1510 :     if (handlers == NULL) xmlInitCharEncodingHandlers();

	cmp	DWORD PTR _handlers, 0
	jne	SHORT $LN4@xmlGetChar
	call	_xmlInitCharEncodingHandlers
$LN4@xmlGetChar:

; 1511 :     switch (enc) {

	mov	eax, DWORD PTR _enc$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	add	ecx, 1
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 22			; 00000016H
	ja	$LN2@xmlGetChar
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN57@xmlGetChar[edx*4]
$LN5@xmlGetChar:

; 1512 :         case XML_CHAR_ENCODING_ERROR:
; 1513 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlGetChar
$LN6@xmlGetChar:

; 1514 :         case XML_CHAR_ENCODING_NONE:
; 1515 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlGetChar
$LN7@xmlGetChar:

; 1516 :         case XML_CHAR_ENCODING_UTF8:
; 1517 : 	    return(NULL);

	xor	eax, eax
	jmp	$LN1@xmlGetChar
$LN8@xmlGetChar:

; 1518 :         case XML_CHAR_ENCODING_UTF16LE:
; 1519 : 	    return(xmlUTF16LEHandler);

	mov	eax, DWORD PTR _xmlUTF16LEHandler
	jmp	$LN1@xmlGetChar
$LN9@xmlGetChar:

; 1520 :         case XML_CHAR_ENCODING_UTF16BE:
; 1521 : 	    return(xmlUTF16BEHandler);

	mov	eax, DWORD PTR _xmlUTF16BEHandler
	jmp	$LN1@xmlGetChar
$LN10@xmlGetChar:

; 1522 :         case XML_CHAR_ENCODING_EBCDIC:
; 1523 :             handler = xmlFindCharEncodingHandler("EBCDIC");

	push	OFFSET ??_C@_06JJAKJGEC@EBCDIC@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1524 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN11@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN11@xmlGetChar:

; 1525 :             handler = xmlFindCharEncodingHandler("ebcdic");

	push	OFFSET ??_C@_06JNCBEIJA@ebcdic@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1526 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN12@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN12@xmlGetChar:

; 1527 :             handler = xmlFindCharEncodingHandler("EBCDIC-US");

	push	OFFSET ??_C@_09BNGJAIJK@EBCDIC?9US@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1528 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN13@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN13@xmlGetChar:

; 1529 :             handler = xmlFindCharEncodingHandler("IBM-037");

	push	OFFSET ??_C@_07LDANGMFL@IBM?9037@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1530 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN14@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN14@xmlGetChar:

; 1531 : 	    break;

	jmp	$LN2@xmlGetChar
$LN15@xmlGetChar:

; 1532 :         case XML_CHAR_ENCODING_UCS4BE:
; 1533 :             handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");

	push	OFFSET ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1534 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN16@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN16@xmlGetChar:

; 1535 :             handler = xmlFindCharEncodingHandler("UCS-4");

	push	OFFSET ??_C@_05FPCKGDIJ@UCS?94@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1536 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN17@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN17@xmlGetChar:

; 1537 :             handler = xmlFindCharEncodingHandler("UCS4");

	push	OFFSET ??_C@_04JFFPNMJE@UCS4@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1538 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN18@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN18@xmlGetChar:

; 1539 : 	    break;

	jmp	$LN2@xmlGetChar
$LN19@xmlGetChar:

; 1540 :         case XML_CHAR_ENCODING_UCS4LE:
; 1541 :             handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");

	push	OFFSET ??_C@_0BA@NBNDMHOM@ISO?910646?9UCS?94@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1542 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN20@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN20@xmlGetChar:

; 1543 :             handler = xmlFindCharEncodingHandler("UCS-4");

	push	OFFSET ??_C@_05FPCKGDIJ@UCS?94@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1544 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN21@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN21@xmlGetChar:

; 1545 :             handler = xmlFindCharEncodingHandler("UCS4");

	push	OFFSET ??_C@_04JFFPNMJE@UCS4@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1546 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN22@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN22@xmlGetChar:

; 1547 : 	    break;

	jmp	$LN2@xmlGetChar

; 1548 :         case XML_CHAR_ENCODING_UCS4_2143:
; 1549 : 	    break;

	jmp	$LN2@xmlGetChar

; 1550 :         case XML_CHAR_ENCODING_UCS4_3412:
; 1551 : 	    break;

	jmp	$LN2@xmlGetChar
$LN25@xmlGetChar:

; 1552 :         case XML_CHAR_ENCODING_UCS2:
; 1553 :             handler = xmlFindCharEncodingHandler("ISO-10646-UCS-2");

	push	OFFSET ??_C@_0BA@IHIJGAGK@ISO?910646?9UCS?92@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1554 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN26@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN26@xmlGetChar:

; 1555 :             handler = xmlFindCharEncodingHandler("UCS-2");

	push	OFFSET ??_C@_05JHAMEAP@UCS?92@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1556 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN27@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN27@xmlGetChar:

; 1557 :             handler = xmlFindCharEncodingHandler("UCS2");

	push	OFFSET ??_C@_04MDAFHLBC@UCS2@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1558 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN28@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN28@xmlGetChar:

; 1559 : 	    break;

	jmp	$LN2@xmlGetChar
$LN29@xmlGetChar:

; 1560 : 
; 1561 : 	    /*
; 1562 : 	     * We used to keep ISO Latin encodings native in the
; 1563 : 	     * generated data. This led to so many problems that
; 1564 : 	     * this has been removed. One can still change this
; 1565 : 	     * back by registering no-ops encoders for those
; 1566 : 	     */
; 1567 :         case XML_CHAR_ENCODING_8859_1:
; 1568 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-1");

	push	OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1569 : 	    if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN30@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN30@xmlGetChar:

; 1570 : 	    break;

	jmp	$LN2@xmlGetChar
$LN31@xmlGetChar:

; 1571 :         case XML_CHAR_ENCODING_8859_2:
; 1572 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-2");

	push	OFFSET ??_C@_0L@ECKEIAIJ@ISO?98859?92@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1573 : 	    if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN32@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN32@xmlGetChar:

; 1574 : 	    break;

	jmp	$LN2@xmlGetChar
$LN33@xmlGetChar:

; 1575 :         case XML_CHAR_ENCODING_8859_3:
; 1576 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-3");

	push	OFFSET ??_C@_0L@FLLPLBMI@ISO?98859?93@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1577 : 	    if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN34@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN34@xmlGetChar:

; 1578 : 	    break;

	jmp	$LN2@xmlGetChar
$LN35@xmlGetChar:

; 1579 :         case XML_CHAR_ENCODING_8859_4:
; 1580 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-4");

	push	OFFSET ??_C@_0L@BEPOCHAP@ISO?98859?94@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1581 : 	    if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN36@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN36@xmlGetChar:

; 1582 : 	    break;

	jmp	$LN2@xmlGetChar
$LN37@xmlGetChar:

; 1583 :         case XML_CHAR_ENCODING_8859_5:
; 1584 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-5");

	push	OFFSET ??_C@_0L@NOFBGEO@ISO?98859?95@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1585 : 	    if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN38@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN38@xmlGetChar:

; 1586 : 	    break;

	jmp	$LN2@xmlGetChar
$LN39@xmlGetChar:

; 1587 :         case XML_CHAR_ENCODING_8859_6:
; 1588 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-6");

	push	OFFSET ??_C@_0L@CGMIEFIN@ISO?98859?96@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1589 : 	    if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN40@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN40@xmlGetChar:

; 1590 : 	    break;

	jmp	$LN2@xmlGetChar
$LN41@xmlGetChar:

; 1591 :         case XML_CHAR_ENCODING_8859_7:
; 1592 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-7");

	push	OFFSET ??_C@_0L@DPNDHEMM@ISO?98859?97@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1593 : 	    if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN42@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN42@xmlGetChar:

; 1594 : 	    break;

	jmp	$LN2@xmlGetChar
$LN43@xmlGetChar:

; 1595 :         case XML_CHAR_ENCODING_8859_8:
; 1596 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-8");

	push	OFFSET ??_C@_0L@LIELGIAD@ISO?98859?98@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1597 : 	    if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN44@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN44@xmlGetChar:

; 1598 : 	    break;

	jmp	$LN2@xmlGetChar
$LN45@xmlGetChar:

; 1599 :         case XML_CHAR_ENCODING_8859_9:
; 1600 : 	    handler = xmlFindCharEncodingHandler("ISO-8859-9");

	push	OFFSET ??_C@_0L@KBFAFJEC@ISO?98859?99@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1601 : 	    if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN46@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	$LN1@xmlGetChar
$LN46@xmlGetChar:

; 1602 : 	    break;

	jmp	$LN2@xmlGetChar
$LN47@xmlGetChar:

; 1603 : 
; 1604 : 
; 1605 :         case XML_CHAR_ENCODING_2022_JP:
; 1606 :             handler = xmlFindCharEncodingHandler("ISO-2022-JP");

	push	OFFSET ??_C@_0M@LMIFKILO@ISO?92022?9JP@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1607 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN48@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	SHORT $LN1@xmlGetChar
$LN48@xmlGetChar:

; 1608 : 	    break;

	jmp	SHORT $LN2@xmlGetChar
$LN49@xmlGetChar:

; 1609 :         case XML_CHAR_ENCODING_SHIFT_JIS:
; 1610 :             handler = xmlFindCharEncodingHandler("SHIFT-JIS");

	push	OFFSET ??_C@_09IOCPDDIN@SHIFT?9JIS@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1611 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN50@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	SHORT $LN1@xmlGetChar
$LN50@xmlGetChar:

; 1612 :             handler = xmlFindCharEncodingHandler("SHIFT_JIS");

	push	OFFSET ??_C@_09NDNIACC@SHIFT_JIS@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1613 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN51@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	SHORT $LN1@xmlGetChar
$LN51@xmlGetChar:

; 1614 :             handler = xmlFindCharEncodingHandler("Shift_JIS");

	push	OFFSET ??_C@_09LOKLFMHN@Shift_JIS@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1615 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN52@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	SHORT $LN1@xmlGetChar
$LN52@xmlGetChar:

; 1616 : 	    break;

	jmp	SHORT $LN2@xmlGetChar
$LN53@xmlGetChar:

; 1617 :         case XML_CHAR_ENCODING_EUC_JP:
; 1618 :             handler = xmlFindCharEncodingHandler("EUC-JP");

	push	OFFSET ??_C@_06KCFOODCD@EUC?9JP@
	call	_xmlFindCharEncodingHandler
	add	esp, 4
	mov	DWORD PTR _handler$[ebp], eax

; 1619 :             if (handler != NULL) return(handler);

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN2@xmlGetChar
	mov	eax, DWORD PTR _handler$[ebp]
	jmp	SHORT $LN1@xmlGetChar
$LN2@xmlGetChar:

; 1620 : 	    break;
; 1621 : 	default:
; 1622 : 	    break;
; 1623 :     }
; 1624 : 
; 1625 : #ifdef DEBUG_ENCODING
; 1626 :     xmlGenericError(xmlGenericErrorContext,
; 1627 : 	    "No handler found for encoding %d\n", enc);
; 1628 : #endif
; 1629 :     return(NULL);

	xor	eax, eax
$LN1@xmlGetChar:

; 1630 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN57@xmlGetChar:
	DD	$LN5@xmlGetChar
	DD	$LN6@xmlGetChar
	DD	$LN7@xmlGetChar
	DD	$LN8@xmlGetChar
	DD	$LN9@xmlGetChar
	DD	$LN19@xmlGetChar
	DD	$LN15@xmlGetChar
	DD	$LN10@xmlGetChar
	DD	$LN2@xmlGetChar
	DD	$LN2@xmlGetChar
	DD	$LN25@xmlGetChar
	DD	$LN29@xmlGetChar
	DD	$LN31@xmlGetChar
	DD	$LN33@xmlGetChar
	DD	$LN35@xmlGetChar
	DD	$LN37@xmlGetChar
	DD	$LN39@xmlGetChar
	DD	$LN41@xmlGetChar
	DD	$LN43@xmlGetChar
	DD	$LN45@xmlGetChar
	DD	$LN47@xmlGetChar
	DD	$LN49@xmlGetChar
	DD	$LN53@xmlGetChar
_xmlGetCharEncodingHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlRegisterCharEncodingHandler
_TEXT	SEGMENT
_handler$ = 8						; size = 4
_xmlRegisterCharEncodingHandler PROC			; COMDAT

; 1481 : xmlRegisterCharEncodingHandler(xmlCharEncodingHandlerPtr handler) {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1482 :     if (handlers == NULL) xmlInitCharEncodingHandlers();

	cmp	DWORD PTR _handlers, 0
	jne	SHORT $LN2@xmlRegiste
	call	_xmlInitCharEncodingHandlers
$LN2@xmlRegiste:

; 1483 :     if ((handler == NULL) || (handlers == NULL)) {

	cmp	DWORD PTR _handler$[ebp], 0
	je	SHORT $LN4@xmlRegiste
	cmp	DWORD PTR _handlers, 0
	jne	SHORT $LN3@xmlRegiste
$LN4@xmlRegiste:

; 1484 :         xmlEncodingErr(XML_I18N_NO_HANDLER,

	push	0
	push	OFFSET ??_C@_0DA@NDFKGHEJ@xmlRegisterCharEncodingHandler?3@
	push	6001					; 00001771H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH

; 1485 : 		"xmlRegisterCharEncodingHandler: NULL handler !\n", NULL);
; 1486 : 	return;

	jmp	SHORT $LN1@xmlRegiste
$LN3@xmlRegiste:

; 1487 :     }
; 1488 : 
; 1489 :     if (nbCharEncodingHandler >= MAX_ENCODING_HANDLERS) {

	cmp	DWORD PTR _nbCharEncodingHandler, 50	; 00000032H
	jl	SHORT $LN5@xmlRegiste

; 1490 :         xmlEncodingErr(XML_I18N_EXCESS_HANDLER,

	push	OFFSET ??_C@_0BG@EJFNACMF@MAX_ENCODING_HANDLERS@
	push	OFFSET ??_C@_0EF@MMDODKKK@xmlRegisterCharEncodingHandler?3@
	push	6002					; 00001772H
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH

; 1491 : 	"xmlRegisterCharEncodingHandler: Too many handler registered, see %s\n",
; 1492 : 	               "MAX_ENCODING_HANDLERS");
; 1493 : 	return;

	jmp	SHORT $LN1@xmlRegiste
$LN5@xmlRegiste:

; 1494 :     }
; 1495 :     handlers[nbCharEncodingHandler++] = handler;

	mov	eax, DWORD PTR _nbCharEncodingHandler
	mov	ecx, DWORD PTR _handlers
	mov	edx, DWORD PTR _handler$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _nbCharEncodingHandler
	add	eax, 1
	mov	DWORD PTR _nbCharEncodingHandler, eax
$LN1@xmlRegiste:

; 1496 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlRegisterCharEncodingHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlCleanupCharEncodingHandlers
_TEXT	SEGMENT
_xmlCleanupCharEncodingHandlers PROC			; COMDAT

; 1455 : xmlCleanupCharEncodingHandlers(void) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1456 :     xmlCleanupEncodingAliases();

	call	_xmlCleanupEncodingAliases

; 1457 : 
; 1458 :     if (handlers == NULL) return;

	cmp	DWORD PTR _handlers, 0
	jne	SHORT $LN4@xmlCleanup
	jmp	$LN1@xmlCleanup
$LN4@xmlCleanup:

; 1459 : 
; 1460 :     for (;nbCharEncodingHandler > 0;) {

	cmp	DWORD PTR _nbCharEncodingHandler, 0
	jle	SHORT $LN3@xmlCleanup

; 1461 :         nbCharEncodingHandler--;

	mov	eax, DWORD PTR _nbCharEncodingHandler
	sub	eax, 1
	mov	DWORD PTR _nbCharEncodingHandler, eax

; 1462 : 	if (handlers[nbCharEncodingHandler] != NULL) {

	mov	ecx, DWORD PTR _nbCharEncodingHandler
	mov	edx, DWORD PTR _handlers
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $LN6@xmlCleanup

; 1463 : 	    if (handlers[nbCharEncodingHandler]->name != NULL)

	mov	eax, DWORD PTR _nbCharEncodingHandler
	mov	ecx, DWORD PTR _handlers
	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN7@xmlCleanup

; 1464 : 		xmlFree(handlers[nbCharEncodingHandler]->name);

	mov	eax, DWORD PTR _nbCharEncodingHandler
	mov	ecx, DWORD PTR _handlers
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	esi, esp
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@xmlCleanup:

; 1465 : 	    xmlFree(handlers[nbCharEncodingHandler]);

	mov	esi, esp
	mov	ecx, DWORD PTR _nbCharEncodingHandler
	mov	edx, DWORD PTR _handlers
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@xmlCleanup:

; 1466 : 	}
; 1467 :     }

	jmp	$LN4@xmlCleanup
$LN3@xmlCleanup:

; 1468 :     xmlFree(handlers);

	mov	esi, esp
	mov	ecx, DWORD PTR _handlers
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1469 :     handlers = NULL;

	mov	DWORD PTR _handlers, 0

; 1470 :     nbCharEncodingHandler = 0;

	mov	DWORD PTR _nbCharEncodingHandler, 0

; 1471 :     xmlDefaultCharEncodingHandler = NULL;

	mov	DWORD PTR _xmlDefaultCharEncodingHandler, 0
$LN1@xmlCleanup:

; 1472 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_xmlCleanupCharEncodingHandlers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlInitCharEncodingHandlers
_TEXT	SEGMENT
_ptr$ = -16						; size = 4
_tst$ = -8						; size = 2
_xmlInitCharEncodingHandlers PROC			; COMDAT

; 1397 : xmlInitCharEncodingHandlers(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 1398 :     unsigned short int tst = 0x1234;

	mov	eax, 4660				; 00001234H
	mov	WORD PTR _tst$[ebp], ax

; 1399 :     unsigned char *ptr = (unsigned char *) &tst;

	lea	ecx, DWORD PTR _tst$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 1400 : 
; 1401 :     if (handlers != NULL) return;

	cmp	DWORD PTR _handlers, 0
	je	SHORT $LN2@xmlInitCha
	jmp	$LN1@xmlInitCha
$LN2@xmlInitCha:

; 1402 : 
; 1403 :     handlers = (xmlCharEncodingHandlerPtr *)

	mov	esi, esp
	push	200					; 000000c8H
	call	DWORD PTR _xmlMalloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _handlers, eax

; 1404 :         xmlMalloc(MAX_ENCODING_HANDLERS * sizeof(xmlCharEncodingHandlerPtr));
; 1405 : 
; 1406 :     if (*ptr == 0x12) xmlLittleEndian = 0;

	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 18					; 00000012H
	jne	SHORT $LN3@xmlInitCha
	mov	DWORD PTR _xmlLittleEndian, 0
	jmp	SHORT $LN4@xmlInitCha
$LN3@xmlInitCha:

; 1407 :     else if (*ptr == 0x34) xmlLittleEndian = 1;

	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 52					; 00000034H
	jne	SHORT $LN5@xmlInitCha
	mov	DWORD PTR _xmlLittleEndian, 1
	jmp	SHORT $LN4@xmlInitCha
$LN5@xmlInitCha:

; 1408 :     else {
; 1409 :         xmlEncodingErr(XML_ERR_INTERNAL_ERROR,

	push	0
	push	OFFSET ??_C@_0CF@BMACILLF@Odd?5problem?5at?5endianness?5detec@
	push	1
	call	_xmlEncodingErr
	add	esp, 12					; 0000000cH
$LN4@xmlInitCha:

; 1410 : 	               "Odd problem at endianness detection\n", NULL);
; 1411 :     }
; 1412 : 
; 1413 :     if (handlers == NULL) {

	cmp	DWORD PTR _handlers, 0
	jne	SHORT $LN7@xmlInitCha

; 1414 :         xmlEncodingErrMemory("xmlInitCharEncodingHandlers : out of memory !\n");

	push	OFFSET ??_C@_0CP@BACAHNKC@xmlInitCharEncodingHandlers?5?3?5o@
	call	_xmlEncodingErrMemory
	add	esp, 4

; 1415 : 	return;

	jmp	$LN1@xmlInitCha
$LN7@xmlInitCha:

; 1416 :     }
; 1417 :     xmlNewCharEncodingHandler("UTF-8", UTF8ToUTF8, UTF8ToUTF8);

	push	OFFSET _UTF8ToUTF8
	push	OFFSET _UTF8ToUTF8
	push	OFFSET ??_C@_05EGJIMALK@UTF?98@
	call	_xmlNewCharEncodingHandler
	add	esp, 12					; 0000000cH

; 1418 : #ifdef LIBXML_OUTPUT_ENABLED
; 1419 :     xmlUTF16LEHandler =

	push	OFFSET _UTF8ToUTF16LE
	push	OFFSET _UTF16LEToUTF8
	push	OFFSET ??_C@_08NBDJLNFA@UTF?916LE@
	call	_xmlNewCharEncodingHandler
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlUTF16LEHandler, eax

; 1420 :           xmlNewCharEncodingHandler("UTF-16LE", UTF16LEToUTF8, UTF8ToUTF16LE);
; 1421 :     xmlUTF16BEHandler =

	push	OFFSET _UTF8ToUTF16BE
	push	OFFSET _UTF16BEToUTF8
	push	OFFSET ??_C@_08NLKHJAFK@UTF?916BE@
	call	_xmlNewCharEncodingHandler
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xmlUTF16BEHandler, eax

; 1422 :           xmlNewCharEncodingHandler("UTF-16BE", UTF16BEToUTF8, UTF8ToUTF16BE);
; 1423 :     xmlNewCharEncodingHandler("UTF-16", UTF16LEToUTF8, UTF8ToUTF16);

	push	OFFSET _UTF8ToUTF16
	push	OFFSET _UTF16LEToUTF8
	push	OFFSET ??_C@_06KNDPGIKI@UTF?916@
	call	_xmlNewCharEncodingHandler
	add	esp, 12					; 0000000cH

; 1424 :     xmlNewCharEncodingHandler("ISO-8859-1", isolat1ToUTF8, UTF8Toisolat1);

	push	OFFSET _UTF8Toisolat1
	push	OFFSET _isolat1ToUTF8
	push	OFFSET ??_C@_0L@GJIJNDEK@ISO?98859?91@
	call	_xmlNewCharEncodingHandler
	add	esp, 12					; 0000000cH

; 1425 :     xmlNewCharEncodingHandler("ASCII", asciiToUTF8, UTF8Toascii);

	push	OFFSET _UTF8Toascii
	push	OFFSET _asciiToUTF8
	push	OFFSET ??_C@_05CCNLIHFO@ASCII@
	call	_xmlNewCharEncodingHandler
	add	esp, 12					; 0000000cH

; 1426 :     xmlNewCharEncodingHandler("US-ASCII", asciiToUTF8, UTF8Toascii);

	push	OFFSET _UTF8Toascii
	push	OFFSET _asciiToUTF8
	push	OFFSET ??_C@_08DIBGJKBD@US?9ASCII@
	call	_xmlNewCharEncodingHandler
	add	esp, 12					; 0000000cH

; 1427 : #ifdef LIBXML_HTML_ENABLED
; 1428 :     xmlNewCharEncodingHandler("HTML", NULL, UTF8ToHtml);

	push	OFFSET _UTF8ToHtml
	push	0
	push	OFFSET ??_C@_04DBLPJNAF@HTML@
	call	_xmlNewCharEncodingHandler
	add	esp, 12					; 0000000cH
$LN1@xmlInitCha:

; 1429 : #endif
; 1430 : #else
; 1431 :     xmlUTF16LEHandler =
; 1432 :           xmlNewCharEncodingHandler("UTF-16LE", UTF16LEToUTF8, NULL);
; 1433 :     xmlUTF16BEHandler =
; 1434 :           xmlNewCharEncodingHandler("UTF-16BE", UTF16BEToUTF8, NULL);
; 1435 :     xmlNewCharEncodingHandler("UTF-16", UTF16LEToUTF8, NULL);
; 1436 :     xmlNewCharEncodingHandler("ISO-8859-1", isolat1ToUTF8, NULL);
; 1437 :     xmlNewCharEncodingHandler("ASCII", asciiToUTF8, NULL);
; 1438 :     xmlNewCharEncodingHandler("US-ASCII", asciiToUTF8, NULL);
; 1439 : #endif /* LIBXML_OUTPUT_ENABLED */
; 1440 : #if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED)
; 1441 : #ifdef LIBXML_ISO8859X_ENABLED
; 1442 :     xmlRegisterCharEncodingHandlersISO8859x ();
; 1443 : #endif
; 1444 : #endif
; 1445 : 
; 1446 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@xmlInitCha
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@xmlInitCha:
	DD	1
	DD	$LN10@xmlInitCha
$LN10@xmlInitCha:
	DD	-8					; fffffff8H
	DD	2
	DD	$LN9@xmlInitCha
$LN9@xmlInitCha:
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_xmlInitCharEncodingHandlers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\users\dag\documents\_clients\codeproject authors group\windows on arm\libxml2\libxml2-2.9.9\encoding.c
;	COMDAT _xmlByteConsumed
_TEXT	SEGMENT
_ret$1 = -32052						; size = 4
_written$2 = -32044					; size = 4
_toconv$3 = -32032					; size = 4
_cur$4 = -32024						; size = 4
_convbuf$5 = -32016					; size = 32000
_handler$6 = -12					; size = 4
_unused$7 = -8						; size = 4
_in$ = -4						; size = 4
_ctxt$ = 8						; size = 4
_xmlByteConsumed PROC					; COMDAT

; 2803 : xmlByteConsumed(xmlParserCtxtPtr ctxt) {

	push	ebp
	mov	ebp, esp
	mov	eax, 32052				; 00007d34H
	call	__chkstk
	push	edi
	lea	edi, DWORD PTR [ebp-32052]
	mov	ecx, 8013				; 00001f4dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C8D9C3F6_encoding@c
	call	@__CheckForDebuggerJustMyCode@4

; 2804 :     xmlParserInputPtr in;
; 2805 : 
; 2806 :     if (ctxt == NULL) return(-1);

	cmp	DWORD PTR _ctxt$[ebp], 0
	jne	SHORT $LN5@xmlByteCon
	or	eax, -1
	jmp	$LN1@xmlByteCon
$LN5@xmlByteCon:

; 2807 :     in = ctxt->input;

	mov	eax, DWORD PTR _ctxt$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _in$[ebp], ecx

; 2808 :     if (in == NULL)  return(-1);

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN6@xmlByteCon
	or	eax, -1
	jmp	$LN1@xmlByteCon
$LN6@xmlByteCon:

; 2809 :     if ((in->buf != NULL) && (in->buf->encoder != NULL)) {

	mov	edx, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN7@xmlByteCon
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+12], 0
	je	$LN7@xmlByteCon

; 2810 :         unsigned int unused = 0;

	mov	DWORD PTR _unused$7[ebp], 0

; 2811 : 	xmlCharEncodingHandler * handler = in->buf->encoder;

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _handler$6[ebp], ecx

; 2812 :         /*
; 2813 : 	 * Encoding conversion, compute the number of unused original
; 2814 : 	 * bytes from the input not consumed and substract that from
; 2815 : 	 * the raw consumed value, this is not a cheap operation
; 2816 : 	 */
; 2817 :         if (in->end - in->cur > 0) {

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+16]
	test	ecx, ecx
	jle	$LN8@xmlByteCon

; 2818 : 	    unsigned char convbuf[32000];
; 2819 : 	    const unsigned char *cur = (const unsigned char *)in->cur;

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _cur$4[ebp], eax

; 2820 : 	    int toconv = in->end - in->cur, written = 32000;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _toconv$3[ebp], eax
	mov	DWORD PTR _written$2[ebp], 32000	; 00007d00H
$LN4@xmlByteCon:

; 2821 : 
; 2822 : 	    int ret;
; 2823 : 
; 2824 :             do {
; 2825 :                 toconv = in->end - cur;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR _cur$4[ebp]
	mov	DWORD PTR _toconv$3[ebp], edx

; 2826 :                 written = 32000;

	mov	DWORD PTR _written$2[ebp], 32000	; 00007d00H

; 2827 :                 ret = xmlEncOutputChunk(handler, &convbuf[0], &written,

	lea	eax, DWORD PTR _toconv$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _written$2[ebp]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _convbuf$5[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _handler$6[ebp]
	push	eax
	call	_xmlEncOutputChunk
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret$1[ebp], eax

; 2828 :                                         cur, &toconv);
; 2829 :                 if (ret < 0) {

	cmp	DWORD PTR _ret$1[ebp], 0
	jge	SHORT $LN9@xmlByteCon

; 2830 :                     if (written > 0)

	cmp	DWORD PTR _written$2[ebp], 0
	jle	SHORT $LN10@xmlByteCon

; 2831 :                         ret = -2;

	mov	DWORD PTR _ret$1[ebp], -2		; fffffffeH
	jmp	SHORT $LN9@xmlByteCon
$LN10@xmlByteCon:

; 2832 :                     else
; 2833 :                         return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlByteCon
$LN9@xmlByteCon:

; 2834 :                 }
; 2835 :                 unused += written;

	mov	ecx, DWORD PTR _unused$7[ebp]
	add	ecx, DWORD PTR _written$2[ebp]
	mov	DWORD PTR _unused$7[ebp], ecx

; 2836 :                 cur += toconv;

	mov	edx, DWORD PTR _cur$4[ebp]
	add	edx, DWORD PTR _toconv$3[ebp]
	mov	DWORD PTR _cur$4[ebp], edx

; 2837 :             } while (ret == -2);

	cmp	DWORD PTR _ret$1[ebp], -2		; fffffffeH
	je	$LN4@xmlByteCon
$LN8@xmlByteCon:

; 2838 : 	}
; 2839 : 	if (in->buf->rawconsumed < unused)

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	cmp	edx, DWORD PTR _unused$7[ebp]
	jae	SHORT $LN12@xmlByteCon

; 2840 : 	    return(-1);

	or	eax, -1
	jmp	SHORT $LN1@xmlByteCon
$LN12@xmlByteCon:

; 2841 : 	return(in->buf->rawconsumed - unused);

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+32]
	sub	eax, DWORD PTR _unused$7[ebp]
	jmp	SHORT $LN1@xmlByteCon
$LN7@xmlByteCon:

; 2842 :     }
; 2843 :     return(in->consumed + (in->cur - in->base));

	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _in$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	eax, ecx
$LN1@xmlByteCon:

; 2844 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@xmlByteCon
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 32052				; 00007d34H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN18@xmlByteCon:
	DD	3
	DD	$LN17@xmlByteCon
$LN17@xmlByteCon:
	DD	-32016					; ffff82f0H
	DD	32000					; 00007d00H
	DD	$LN14@xmlByteCon
	DD	-32032					; ffff82e0H
	DD	4
	DD	$LN15@xmlByteCon
	DD	-32044					; ffff82d4H
	DD	4
	DD	$LN16@xmlByteCon
$LN16@xmlByteCon:
	DB	119					; 00000077H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN15@xmlByteCon:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	118					; 00000076H
	DB	0
$LN14@xmlByteCon:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	118					; 00000076H
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_xmlByteConsumed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __A452D4A0_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR __Format$[ebp]
	mov	DWORD PTR __Format$[ebp], ecx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	edx, DWORD PTR __ArgList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Format$[ebp]
	push	eax
	mov	ecx, DWORD PTR __BufferCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$1[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$1[ebp], 0
	jge	SHORT $LN5@snprintf
	mov	DWORD PTR tv81[ebp], -1
	jmp	SHORT $LN3@snprintf
$LN5@snprintf:
	mov	eax, DWORD PTR __Result$1[ebp]
	mov	DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __2CC6E67D_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
